c 2d parallel PIC library for solving field equationsc written by viktor k. decyk, uclac copyright 1995, regents of the university of californiac update: november 16, 2002c-----------------------------------------------------------------------      subroutine PCGUARD2X(fxy,nyp,nx,nxe,nypmx,nblok)c replicate extended periodic fieldc quadratic interpolation, for distributed data      implicit none      real fxy      integer nyp, nx, nxe, nypmx, nblok      dimension fxy(2,nxe,nypmx,nblok), nyp(nblok)      integer i, k, l, nyp3      do 30 l = 1, nblok      nyp3 = nyp(l) + 3      do 20 k = 1, nyp3      do 10 i = 1, 2      fxy(i,1,k,l) = fxy(i,nx+1,k,l)      fxy(i,nx+2,k,l) = fxy(i,2,k,l)      fxy(i,nx+3,k,l) = fxy(i,3,k,l)   10 continue   20 continue   30 continue      return      endc-----------------------------------------------------------------------      subroutine PDGUARD2X(q,nyp,nx,nxe,nypmx,nblok)c replicate extended periodic scalar fieldc quadratic interpolation, for distributed data      implicit none      real q      integer nyp, nx, nxe, nypmx, nblok      dimension q(nxe,nypmx,nblok), nyp(nblok)      integer k, l, nyp3      do 20 l = 1, nblok      nyp3 = nyp(l) + 3      do 10 k = 1, nyp3      q(1,k,l) = q(nx+1,k,l)      q(nx+2,k,l) = q(2,k,l)      q(nx+3,k,l) = q(3,k,l)   10 continue   20 continue      return      endc-----------------------------------------------------------------------      subroutine PBGUARD2X(bxy,nyp,nx,nxe,nypmx,nblok)c replicate extended periodic vector fieldc quadratic interpolation, for distributed data      implicit none      real bxy      integer nyp, nx, nxe, nypmx, nblok      dimension bxy(3,nxe,nypmx,nblok), nyp(nblok)      integer i, k, l, nyp3      do 30 l = 1, nblok      nyp3 = nyp(l) + 3      do 20 k = 1, nyp3      do 10 i = 1, 3      bxy(i,1,k,l) = bxy(i,nx+1,k,l)      bxy(i,nx+2,k,l) = bxy(i,2,k,l)      bxy(i,nx+3,k,l) = bxy(i,3,k,l)   10 continue   20 continue   30 continue      return      endc-----------------------------------------------------------------------      subroutine PSCGUARD2(cu,nyp,xj0,yj0,zj0,nx,nxe,nypmx,nblok)c initialize extended periodic fieldc quadratic interpolation, for distributed data      implicit none      real cu, xj0, yj0, zj0      integer nyp, nx, nxe, nypmx, nblok      dimension cu(3,nxe,nypmx,nblok), nyp(nblok)      integer i, j, k, l, nyp3, nx3c initialize extended field, with zero in the edges      nx3 = nx + 3      do 60 l = 1, nblok      nyp3 = nyp(l) + 3      do 30 k = 1, nyp(l)      do 10 j = 1, nx      cu(1,j+1,k+1,l) = xj0      cu(2,j+1,k+1,l) = yj0      cu(3,j+1,k+1,l) = zj0   10 continue      do 20 i = 1, 3      cu(i,1,k+1,l) = 0.      cu(i,nx+2,k+1,l) = 0.      cu(i,nx+3,k+1,l) = 0.   20 continue   30 continue      do 50 j = 1, nx3      do 40 i = 1, 3      cu(i,j,1,l) = 0.      cu(i,j,nyp3-1,l) = 0.      cu(i,j,nyp3,l) = 0.   40 continue   50 continue   60 continue      return      endc-----------------------------------------------------------------------      subroutine PSGUARD2(q,nyp,qi0,nx,nxe,nypmx,nblok)c initialize extended periodic scalar fieldc quadratic interpolation, for distributed data      implicit none      real q, qi0      integer nyp, nx, nxe, nypmx, nblok      dimension q(nxe,nypmx,nblok), nyp(nblok)      integer j, k, l, nyp3, nx3c initialize extended field, with zero in the edges      nx3 = nx + 3      do 40 l = 1, nblok      nyp3 = nyp(l) + 3      do 20 k = 1, nyp(l)      do 10 j = 1, nx      q(j+1,k+1,l) = qi0   10 continue      q(1,k+1,l) = 0.      q(nx+2,k+1,l) = 0.      q(nx+3,k+1,l) = 0.   20 continue      do 30 j = 1, nx3      q(j,1,l) = 0.      q(j,nyp3-1,l) = 0.      q(j,nyp3,l) = 0.   30 continue   40 continue      return      endc-----------------------------------------------------------------------      subroutine PACGUARD2X(cu,nyp,nx,nxe,nypmx,nblok)c accumulate extended periodic fieldc quadratic interpolation, for distributed data      implicit none      real cu      integer nyp, nx, nxe, nypmx, nblok      dimension cu(3,nxe,nypmx,nblok), nyp(nblok)      integer i, k, l, nyp3c accumulate edges of extended field      do 30 l = 1, nblok      nyp3 = nyp(l) + 3      do 20 k = 1, nyp3      do 10 i = 1, 3      cu(i,2,k,l) = cu(i,2,k,l) + cu(i,nx+2,k,l)      cu(i,3,k,l) = cu(i,3,k,l) + cu(i,nx+3,k,l)      cu(i,nx+1,k,l) = cu(i,nx+1,k,l) + cu(i,1,k,l)   10 continue   20 continue   30 continue      return      endc-----------------------------------------------------------------------      subroutine PAGUARD2X(q,nyp,nx,nxe,nypmx,nblok)c accumulate extended periodic scalar fieldc quadratic interpolation, for distributed data      implicit none      real q      integer nyp, nx, nxe, nypmx, nblok      dimension q(nxe,nypmx,nblok), nyp(nblok)      integer k, l, nyp3c accumulate edges of extended field      do 20 l = 1, nblok      nyp3 = nyp(l) + 3      do 10 k = 1, nyp3      q(2,k,l) = q(2,k,l) + q(nx+2,k,l)      q(3,k,l) = q(3,k,l) + q(nx+3,k,l)      q(nx+1,k,l) = q(nx+1,k,l) + q(1,k,l)   10 continue   20 continue      return      endc-----------------------------------------------------------------------      subroutine PCGUARD2XL(fxy,nyp,nx,nxe,nypmx,nblok)c replicate extended periodic fieldc linear interpolation, for distributed data      implicit none      real fxy      integer nyp, nx, nxe, nypmx, nblok      dimension fxy(2,nxe,nypmx,nblok), nyp(nblok)      integer k, l, nyp1      do 20 l = 1, nblok      nyp1 = nyp(l) + 1      do 10 k = 1, nyp1      fxy(1,nx+1,k,l) = fxy(1,1,k,l)      fxy(2,nx+1,k,l) = fxy(2,1,k,l)   10 continue   20 continue      return      endc-----------------------------------------------------------------------      subroutine PDGUARD2XL(q,nyp,nx,nxe,nypmx,nblok)c replicate extended periodic scalar fieldc linear interpolation, for distributed data      implicit none      real q      integer nyp, nx, nxe, nypmx, nblok      dimension q(nxe,nypmx,nblok), nyp(nblok)      integer k, l, nyp1      do 20 l = 1, nblok      nyp1 = nyp(l) + 1      do 10 k = 1, nyp1      q(nx+1,k,l) = q(1,k,l)   10 continue   20 continue      return      endc-----------------------------------------------------------------------      subroutine PBGUARD2XL(bxy,nyp,nx,nxe,nypmx,nblok)c replicate extended periodic vector fieldc linear interpolation, for distributed data      implicit none      real bxy      integer nyp, nx, nxe, nypmx, nblok      dimension bxy(3,nxe,nypmx,nblok), nyp(nblok)      integer k, l, nyp1      do 20 l = 1, nblok      nyp1 = nyp(l) + 1      do 10 k = 1, nyp1      bxy(1,nx+1,k,l) = bxy(1,1,k,l)      bxy(2,nx+1,k,l) = bxy(2,1,k,l)      bxy(3,nx+1,k,l) = bxy(3,1,k,l)   10 continue   20 continue      return      endc-----------------------------------------------------------------------      subroutine PSCGUARD2L(cu,nyp,xj0,yj0,zj0,nx,nxe,nypmx,nblok)c initialize extended periodic fieldc linear interpolation, for distributed data      implicit none      real cu, xj0, yj0, zj0      integer nyp, nx, nxe, nypmx, nblok      dimension cu(3,nxe,nypmx,nblok), nyp(nblok)      integer i, j, k, l, nyp1, nx1c initialize extended field, with zero in the edges      nx1 = nx + 1      do 60 l = 1, nblok      nyp1 = nyp(l) + 1      do 30 k = 1, nyp(l)      do 10 j = 1, nx      cu(1,j,k,l) = xj0      cu(2,j,k,l) = yj0      cu(3,j,k,l) = zj0   10 continue      do 20 i = 1, 3      cu(i,nx+1,k,l) = 0.   20 continue   30 continue      do 50 j = 1, nx1      do 40 i = 1, 3      cu(i,j,nyp1,l) = 0.   40 continue   50 continue   60 continue      return      endc-----------------------------------------------------------------------      subroutine PSGUARD2L(q,nyp,qi0,nx,nxe,nypmx,nblok)c initialize extended periodic scalar fieldc linear interpolation, for distributed data      implicit none      real q, qi0      integer nyp, nx, nxe, nypmx, nblok      dimension q(nxe,nypmx,nblok), nyp(nblok)      integer j, k, l, nyp1, nx1c initialize extended field, with zero in the edges      nx1 = nx + 1      do 40 l = 1, nblok      nyp1 = nyp(l) + 1      do 20 k = 1, nyp(l)      do 10 j = 1, nx      q(j,k,l) = qi0   10 continue      q(nx+1,k,l) = 0.   20 continue      do 30 j = 1, nx1      q(j,nyp1,l) = 0.   30 continue   40 continue      return      endc-----------------------------------------------------------------------      subroutine PACGUARD2XL(cu,nyp,nx,nxe,nypmx,nblok)c accumulate extended periodic fieldc linear interpolation, for distributed data      implicit none      real cu      integer nyp, nx, nxe, nypmx, nblok      dimension cu(3,nxe,nypmx,nblok), nyp(nblok)      integer i, k, l, nyp1c accumulate edges of extended field      do 30 l = 1, nblok      nyp1 = nyp(l) + 1      do 20 k = 1, nyp1      do 10 i = 1, 3      cu(i,1,k,l) = cu(i,1,k,l) + cu(i,nx+1,k,l)   10 continue   20 continue   30 continue      return      endc-----------------------------------------------------------------------      subroutine PAGUARD2XL(q,nyp,nx,nxe,nypmx,nblok)c accumulate extended periodic scalar fieldc linear interpolation, for distributed data      implicit none      real q      integer nyp, nx, nxe, nypmx, nblok      dimension q(nxe,nypmx,nblok), nyp(nblok)      integer k, l, nyp1c accumulate edges of extended field      do 20 l = 1, nblok      nyp1 = nyp(l) + 1      do 10 k = 1, nyp1      q(1,k,l) = q(1,k,l) + q(nx+1,k,l)   10 continue   20 continue      return      endc-----------------------------------------------------------------------      subroutine PPOISP2(q,fx,fy,isign,ffc,ax,ay,affp,we,nx,ny,kstrt,nyv     1,kxp,jblok,nyhd)c this subroutine solves 2d poisson's equation in fourier space forc force/charge (or convolution of electric field over particle shape)c or for potential, or provides a smoothing function,c with periodic boundary conditions for distributed data.c for isign = 0, input: isign,ax,ay,affp,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: ffcc for isign = -1, input: q,ffc,isign,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: fx,fy,wec approximate flop count is: 33*nxc*nyc + 15*(nxc + nyc)c for isign = 1, input: q,ffc,isign,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: fx,wec approximate flop count is: 21*nxc*nyc + 11*(nxc + nyc)c for isign = 2, input: q,ffc,isign,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: fyc approximate flop count is: 4*nxc*nyc + 2*(nxc + nyc)c where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc if isign < 0, force/charge is calculated using the equations:c fx(kx,ky) = -sqrt(-1)*kx*g(kx,ky)*q(kx,ky)*s(kx,ky),c fy(kx,ky) = -sqrt(-1)*ky*g(kx,ky)*q(kx,ky)*s(kx,ky),c where kx = 2pi*j/nx, ky = 2pi*k/ny, and j,k = fourier mode numbers,c g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky),c s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2), except forc fx(kx=pi) = fy(kx=pi) = fx(ky=pi) = fy(ky=pi) = 0, andc fx(kx=0,ky=0) = fy(kx=0,ky=0) = 0.c if isign = 1, potential is calculated using the equation:c fx(kx,ky) = g(kx,ky)*q(kx,ky)c if isign = 2, smoothing is calculated using the equation:c fy(kx,ky) = q(kx,ky)*s(kx,ky)c q(k,j,l) = complex charge density for fourier mode (jj-1,k-1)c fx(k,j,l) = x component of complex force/charge,c fy(k,j,l) = y component of complex force/charge,c for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c jblok = number of data blocksc kxp = number of data values per blockc kstrt = starting data block numberc if isign = 0, form factor array is preparedc aimag(ffc(k,j,l)) = finite-size particle shape factor sc real(ffc(k,j,l)) = potential green's function gc for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c ax/ay = half-width of particle in x/y directionc affp = normalization constant = nx*ny/np, where np=number of particlesc electric field energy is also calculated, usingc we = nx*ny*sum((affp/(kx**2+ky**2))*|q(kx,ky)*s(kx,ky)|**2)c nx/ny = system length in x/y directionc nyv = first dimension of field arrays, must be >= nyc nyhd = first dimension of form factor array, must be >= nyh      double precision wp      complex q, fx, fy, ffc, zero      dimension q(nyv,kxp,jblok)      dimension fx(nyv,kxp,jblok), fy(nyv,kxp,jblok)      dimension ffc(nyhd,kxp,jblok)      nxh = nx/2      nyh = ny/2      ny2 = ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx)      dny = 6.28318530717959/float(ny)      zero = cmplx(0.,0.)      if (isign.ne.0) go to 40      if (kstrt.gt.nxh) returnc prepare form factor array      do 30 l = 1, jblok      joff = kxp*(l + ks) - 1      do 20 j = 1, kxp      dkx = dnx*float(j + joff)      at1 = dkx*dkx      at2 = (dkx*ax)**2      do 10 k = 1, nyh      dky = dny*float(k - 1)      at3 = dky*dky + at1      at4 = exp(-.5*((dky*ay)**2 + at2))      if (at3.eq.0.) then         ffc(k,j,l) = cmplx(affp,1.)      else         ffc(k,j,l) = cmplx(affp*at4/at3,at4)      endif   10 continue   20 continue   30 continue      return   40 if (isign.gt.0) go to 100c calculate force/charge and sum field energy      wp = 0.0d0      if (kstrt.gt.nxh) go to 90      do 80 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 60 j = 1, kxp      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 50 k = 2, nyh         k1 = ny2 - k         at1 = real(ffc(k,j,l))*aimag(ffc(k,j,l))         at2 = dkx*at1         at3 = dny*float(k - 1)*at1         fx(k,j,l) = at2*cmplx(aimag(q(k,j,l)),-real(q(k,j,l)))         fx(k1,j,l) = at2*cmplx(aimag(q(k1,j,l)),-real(q(k1,j,l)))         fy(k,j,l) = at3*cmplx(aimag(q(k,j,l)),-real(q(k,j,l)))         fy(k1,j,l) = at3*cmplx(-aimag(q(k1,j,l)),real(q(k1,j,l)))         wp = wp + at1*(q(k,j,l)*conjg(q(k,j,l)) + q(k1,j,l)*conjg(q(k1,     1j,l)))   50    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         at1 = real(ffc(1,j,l))*aimag(ffc(1,j,l))         fx(1,j,l) = dkx*at1*cmplx(aimag(q(1,j,l)),-real(q(1,j,l)))         fx(k1,j,l) = zero         fy(1,j,l) = zero         fy(k1,j,l) = zero         wp = wp + at1*(q(1,j,l)*conjg(q(1,j,l)))      endif   60 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 70 k = 2, nyh         k1 = ny2 - k         at1 = real(ffc(k,1,l))*aimag(ffc(k,1,l))         fx(k,1,l) = zero         fx(k1,1,l) = zero         fy(k,1,l) = dny*float(k - 1)*at1*cmplx(aimag(q(k,1,l)),-real(q(     1k,1,l)))         fy(k1,1,l) = zero         wp = wp + at1*(q(k,1,l)*conjg(q(k,1,l)))   70    continue         k1 = nyh + 1         fx(1,1,l) = zero         fx(k1,1,l) = zero         fy(1,1,l) = zero         fy(k1,1,l) = zero      endif   80 continue   90 continue      we = float(nx*ny)*wp      returnc calculate potential and sum field energy  100 if (isign.gt.1) go to 160      wp = 0.0d0      if (kstrt.gt.nxh) go to 150      do 140 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 120 j = 1, kxp      if ((j+joff).gt.0) then         do 110 k = 2, nyh         k1 = ny2 - k         at2 = real(ffc(k,j,l))         at1 = at2*aimag(ffc(k,j,l))         fx(k,j,l) = at2*q(k,j,l)         fx(k1,j,l) = at2*q(k1,j,l)         wp = wp + at1*(q(k,j,l)*conjg(q(k,j,l)) + q(k1,j,l)*conjg(q(k1,     1j,l)))  110    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         at2 = real(ffc(1,j,l))         at1 = at2*aimag(ffc(1,j,l))         fx(1,j,l) = at2*q(1,j,l)         fx(k1,j,l) = zero         wp = wp + at1*(q(1,j,l)*conjg(q(1,j,l)))      endif  120 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 130 k = 2, nyh         k1 = ny2 - k         at2 = real(ffc(k,1,l))         at1 = at2*aimag(ffc(k,1,l))         fx(k,1,l) = at2*q(k,1,l)         fx(k1,1,l) = zero         wp = wp + at1*(q(k,1,l)*conjg(q(k,1,l)))  130    continue         k1 = nyh + 1         fx(1,1,l) = zero         fx(k1,1,l) = zero      endif  140 continue  150 continue      we = float(nx*ny)*wp      returnc calculate smoothing  160 if (kstrt.gt.nxh) go to 210      do 200 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 180 j = 1, kxp      if ((j+joff).gt.0) then         do 170 k = 2, nyh         k1 = ny2 - k         at1 = aimag(ffc(k,j,l))         fy(k,j,l) = at1*q(k,j,l)         fy(k1,j,l) = at1*q(k1,j,l)  170    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         at1 = aimag(ffc(1,j,l))         fy(1,j,l) = at1*q(1,j,l)         fy(k1,j,l) = zero      endif  180 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 190 k = 2, nyh         k1 = ny2 - k         at1 = aimag(ffc(k,1,l))         fy(k,1,l) = at1*q(k,1,l)         fy(k1,1,l) = zero  190    continue         k1 = nyh + 1         fy(1,1,l) = cmplx(aimag(ffc(1,1,l))*real(q(1,1,l)),0.)         fy(k1,1,l) = zero      endif  200 continue  210 continue      return      endc-----------------------------------------------------------------------      subroutine PPOIS22(q,fxy,isign,ffc,ax,ay,affp,we,nx,ny,kstrt,nyv,k     1xp,jblok,nyhd)c this subroutine solves 2d poisson's equation in fourier space forc force/charge (or convolution of electric field over particle shape)c with periodic boundary conditions, for distributed data.c for isign = 0, input: isign,ax,ay,affp,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: ffcc for isign /= 0, input: q,ffc,isign,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: fxy,wec approximate flop count is: 33*nxc*nyc + 15*(nxc + nyc)c where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc the equation used is:c fx(kx,ky) = -sqrt(-1)*kx*g(kx,ky)*s(kx,ky)*q(kx,ky),c fy(kx,ky) = -sqrt(-1)*ky*g(kx,ky)*s(kx,ky)*q(kx,ky),c where kx = 2pi*j/nx, ky = 2pi*k/ny, and j,k = fourier mode numbers,c g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky),c s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2), except forc fx(kx=pi) = fy(kx=pi) = fx(ky=pi) = fy(ky=pi) = 0, andc fx(kx=0,ky=0) = fy(kx=0,ky=0) = 0.c q(k,j,l) = complex charge density for fourier mode (jj-1,k-1)c fxy(1,k,j,l) = x component of complex force/charge,c fxy(2,k,j,l) = y component of complex force/charge,c for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c jblok = number of data blocksc kxp = number of data values per blockc kstrt = starting data block numberc if isign = 0, form factor array is preparedc if isign is not equal to 0, force/charge is calculated.c aimag(ffc(k,j,l)) = finite-size particle shape factor sc real(ffc(k,j,l)) = potential green's function gc for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c ax/ay = half-width of particle in x/y directionc affp = normalization constant = nx*ny/np, where np=number of particlesc electric field energy is also calculated, usingc we = nx*ny*sum((affp/(kx**2+ky**2))*|q(kx,ky)*s(kx,ky)|**2)c nx/ny = system length in x/y directionc nyv = first dimension of field arrays, must be >= nyc nyhd = first dimension of form factor array, must be >= nyh      double precision wp      complex q, fxy, ffc, zero, zt1, zt2      dimension q(nyv,kxp,jblok), fxy(2,nyv,kxp,jblok)      dimension ffc(nyhd,kxp,jblok)      nxh = nx/2      nyh = ny/2      ny2 = ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx)      dny = 6.28318530717959/float(ny)      zero = cmplx(0.,0.)      if (isign.ne.0) go to 40      if (kstrt.gt.nxh) returnc prepare form factor array      do 30 l = 1, jblok      joff = kxp*(l + ks) - 1      do 20 j = 1, kxp      dkx = dnx*float(j + joff)      at1 = dkx*dkx      at2 = (dkx*ax)**2      do 10 k = 1, nyh      dky = dny*float(k - 1)      at3 = dky*dky + at1      at4 = exp(-.5*((dky*ay)**2 + at2))      if (at3.eq.0.) then         ffc(k,j,l) = cmplx(affp,1.)      else         ffc(k,j,l) = cmplx(affp*at4/at3,at4)      endif   10 continue   20 continue   30 continue      returnc calculate force/charge and sum field energy   40 wp = 0.0d0      if (kstrt.gt.nxh) go to 90      do 80 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 60 j = 1, kxp      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 50 k = 2, nyh         k1 = ny2 - k         at1 = real(ffc(k,j,l))*aimag(ffc(k,j,l))         at2 = dkx*at1         at3 = dny*float(k - 1)*at1         zt1 = cmplx(aimag(q(k,j,l)),-real(q(k,j,l)))         zt2 = cmplx(aimag(q(k1,j,l)),-real(q(k1,j,l)))         fxy(1,k,j,l) = at2*zt1         fxy(2,k,j,l) = at3*zt1         fxy(1,k1,j,l) = at2*zt2         fxy(2,k1,j,l) = -at3*zt2         wp = wp + at1*(q(k,j,l)*conjg(q(k,j,l)) + q(k1,j,l)*conjg(q(k1,     1j,l)))   50    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         at1 = real(ffc(1,j,l))*aimag(ffc(1,j,l))         at3 = dkx*at1         zt1 = cmplx(aimag(q(1,j,l)),-real(q(1,j,l)))         fxy(1,1,j,l) = at3*zt1         fxy(2,1,j,l) = zero         fxy(1,k1,j,l) = zero         fxy(2,k1,j,l) = zero         wp = wp + at1*(q(1,j,l)*conjg(q(1,j,l)))      endif   60 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 70 k = 2, nyh         k1 = ny2 - k         at1 = real(ffc(k,1,l))*aimag(ffc(k,1,l))         at2 = dny*float(k - 1)*at1         zt1 = cmplx(aimag(q(k,1,l)),-real(q(k,1,l)))         fxy(1,k,1,l) = zero         fxy(2,k,1,l) = at2*zt1         fxy(1,k1,1,l) = zero         fxy(2,k1,1,l) = zero         wp = wp + at1*(q(k,1,l)*conjg(q(k,1,l)))   70    continue         k1 = nyh + 1         fxy(1,1,1,l) = zero         fxy(2,1,1,l) = zero         fxy(1,k1,1,l) = zero         fxy(2,k1,1,l) = zero      endif   80 continue   90 continue      we = float(nx*ny)*wp      return      endc-----------------------------------------------------------------------      subroutine PPOIS23(q,fxy,isign,ffc,ax,ay,affp,we,nx,ny,kstrt,nyv,k     1xp,jblok,nyhd)c this subroutine solves 2d poisson's equation in fourier space forc force/charge (or convolution of electric field over particle shape)c with periodic boundary conditions.  Zeros out z component.c for distributed data.c for isign = 0, input: isign,ax,ay,affp,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: ffcc for isign /= 0, input: q,ffc,isign,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: fxy,wec approximate flop count is: 33*nxc*nyc + 15*(nxc + nyc)c where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc the equation used is:c fx(kx,ky) = -sqrt(-1)*kx*g(kx,ky)*s(kx,ky)*q(kx,ky),c fy(kx,ky) = -sqrt(-1)*ky*g(kx,ky)*s(kx,ky)*q(kx,ky),c fz(kx,ky) = zero,c where kx = 2pi*j/nx, ky = 2pi*k/ny, and j,k = fourier mode numbers,c g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky),c s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2), except forc fx(kx=pi) = fy(kx=pi) = fx(ky=pi) = fy(ky=pi) = 0, andc fx(kx=0,ky=0) = fy(kx=0,ky=0) = 0.c q(k,j,l) = complex charge density for fourier mode (jj-1,k-1)c fxy(1,k,j,l) = x component of complex force/charge,c fxy(2,k,j,l) = y component of complex force/charge,c fxy(3,k,j,l) = zero,c for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c jblok = number of data blocksc kxp = number of data values per blockc kstrt = starting data block numberc if isign = 0, form factor array is preparedc if isign is not equal to 0, force/charge is calculated.c aimag(ffc(k,j,l)) = finite-size particle shape factor sc real(ffc(k,j,l)) = potential green's function gc for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c ax/ay = half-width of particle in x/y directionc affp = normalization constant = nx*ny/np, where np=number of particlesc electric field energy is also calculated, usingc we = nx*ny*sum((affp/(kx**2+ky**2))*|q(kx,ky)*s(kx,ky)|**2)c nx/ny = system length in x/y directionc nyv = first dimension of field arrays, must be >= nyc nyhd = first dimension of form factor array, must be >= nyh      double precision wp      complex q, fxy, ffc, zero, zt1, zt2      dimension q(nyv,kxp,jblok), fxy(3,nyv,kxp,jblok)      dimension ffc(nyhd,kxp,jblok)      nxh = nx/2      nyh = ny/2      ny2 = ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx)      dny = 6.28318530717959/float(ny)      zero = cmplx(0.,0.)      if (isign.ne.0) go to 40      if (kstrt.gt.nxh) returnc prepare form factor array      do 30 l = 1, jblok      joff = kxp*(l + ks) - 1      do 20 j = 1, kxp      dkx = dnx*float(j + joff)      at1 = dkx*dkx      at2 = (dkx*ax)**2      do 10 k = 1, nyh      dky = dny*float(k - 1)      at3 = dky*dky + at1      at4 = exp(-.5*((dky*ay)**2 + at2))      if (at3.eq.0.) then         ffc(k,j,l) = cmplx(affp,1.)      else         ffc(k,j,l) = cmplx(affp*at4/at3,at4)      endif   10 continue   20 continue   30 continue      returnc calculate force/charge and sum field energy   40 wp = 0.0d0      if (kstrt.gt.nxh) go to 90      do 80 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 60 j = 1, kxp      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 50 k = 2, nyh         k1 = ny2 - k         at1 = real(ffc(k,j,l))*aimag(ffc(k,j,l))         at2 = dkx*at1         at3 = dny*float(k - 1)*at1         zt1 = cmplx(aimag(q(k,j,l)),-real(q(k,j,l)))         zt2 = cmplx(aimag(q(k1,j,l)),-real(q(k1,j,l)))         fxy(1,k,j,l) = at2*zt1         fxy(2,k,j,l) = at3*zt1         fxy(3,k,j,l) = zero         fxy(1,k1,j,l) = at2*zt2         fxy(2,k1,j,l) = -at3*zt2         fxy(3,k1,j,l) = zero         wp = wp + at1*(q(k,j,l)*conjg(q(k,j,l)) + q(k1,j,l)*conjg(q(k1,     1j,l)))   50    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         at1 = real(ffc(1,j,l))*aimag(ffc(1,j,l))         at3 = dkx*at1         zt1 = cmplx(aimag(q(1,j,l)),-real(q(1,j,l)))         fxy(1,1,j,l) = at3*zt1         fxy(2,1,j,l) = zero         fxy(3,1,j,l) = zero         fxy(1,k1,j,l) = zero         fxy(2,k1,j,l) = zero         fxy(3,k1,j,l) = zero         wp = wp + at1*(q(1,j,l)*conjg(q(1,j,l)))      endif   60 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 70 k = 2, nyh         k1 = ny2 - k         at1 = real(ffc(k,1,l))*aimag(ffc(k,1,l))         at2 = dny*float(k - 1)*at1         zt1 = cmplx(aimag(q(k,1,l)),-real(q(k,1,l)))         fxy(1,k,1,l) = zero         fxy(2,k,1,l) = at2*zt1         fxy(3,k,1,l) = zero         fxy(1,k1,1,l) = zero         fxy(2,k1,1,l) = zero         fxy(3,k1,1,l) = zero         wp = wp + at1*(q(k,1,l)*conjg(q(k,1,l)))   70    continue         k1 = nyh + 1         fxy(1,1,1,l) = zero         fxy(2,1,1,l) = zero         fxy(3,1,1,l) = zero         fxy(1,k1,1,l) = zero         fxy(2,k1,1,l) = zero         fxy(3,k1,1,l) = zero      endif   80 continue   90 continue      we = float(nx*ny)*wp      return      endc-----------------------------------------------------------------------      subroutine PDIVF2(f,df,nx,ny,kstrt,ndim,nyv,kxp,jblok)c this subroutine calculates the divergence in fourier spacec input: all except df, output: dfc approximate flop count is: 16*nxc*nyc + 5*(nxc + nyc)c where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc the divergence is calculated using the equation:c df(kx,ky) = sqrt(-1)*(kx*fx(kx,ky)+ky*fy(kx,ky))c where kx = 2pi*j/nx, ky = 2pi*k/ny, and j,k = fourier mode numbers,c except for df(kx=pi) = df(ky=pi) = df(kx=0,ky=0) = 0.c nx/ny = system length in x/y directionc ndim = number of field arrays, must be >= 2c kstrt = starting data block numberc nyv = first dimension of field arrays, must be >= nyc kxp = number of data values per blockc jblok = number of data blocks      complex f, df, zero, zt1      dimension f(ndim,nyv,kxp,jblok), df(nyv,kxp,jblok)      if (ndim.lt.2) return      nxh = nx/2      nyh = ny/2      ny2 = ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx)      dny = 6.28318530717959/float(ny)      zero = cmplx(0.,0.)c calculate the divergence      if (kstrt.gt.nxh) return      do 40 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 20 j = 1, kxp      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 10 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         zt1 = dkx*f(1,k,j,l) + dky*f(2,k,j,l)         df(k,j,l) = cmplx(-aimag(zt1),real(zt1))         zt1 = dkx*f(1,k1,j,l) - dky*f(2,k1,j,l)         df(k1,j,l) = cmplx(-aimag(zt1),real(zt1))   10    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         df(1,j,l) = dkx*cmplx(-aimag(f(1,1,j,l)),real(f(1,1,j,l)))         df(k1,j,l) = zero      endif   20 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 30 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         df(k,1,l) = dky*cmplx(-aimag(f(2,k,1,l)),real(f(2,k,1,l)))         df(k1,1,l) = zero   30    continue         k1 = nyh + 1         df(1,1,l) = zero         df(k1,1,l) = zero      endif   40 continue      return      endc-----------------------------------------------------------------------      subroutine PGRADF2(df,f,nx,ny,kstrt,ndim,nyv,kxp,jblok)c this subroutine calculates the gradient in fourier spacec input: all except f, output: fc approximate flop count is: 12*nxc*nyc + 4*(nxc + nyc)c where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc the gradient is calculated using the equations:c fx(kx,ky) = sqrt(-1)*kx*df(kx,ky)c fy(kx,ky) = sqrt(-1)*ky*df(kx,ky)c where kx = 2pi*j/nx, ky = 2pi*k/ny, and j,k = fourier mode numbers,c except for fx(kx=pi) = fy(kx=pi) = 0, fx(ky=pi) = fy(ky=pi) = 0,c and fx(kx=0,ky=0) = fy(kx=0,ky=0) = 0.c nx/ny = system length in x/y directionc ndim = number of field arrays, must be >= 2c kstrt = starting data block numberc nyv = first dimension of field arrays, must be >= nyc kxp = number of data values per blockc jblok = number of data blocks      complex df, f, zero, zt1      dimension df(nyv,kxp,jblok), f(ndim,nyv,kxp,jblok)      nxh = nx/2      nyh = ny/2      ny2 = ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx)      dny = 6.28318530717959/float(ny)      zero = cmplx(0.,0.)c calculate the gradient      if (kstrt.gt.nxh) return      do 40 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 20 j = 1, kxp      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 10 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         zt1 = cmplx(-aimag(df(k,j,l)),real(df(k,j,l)))         f(1,k,j,l) = dkx*zt1         f(2,k,j,l) = dky*zt1         zt1 = cmplx(-aimag(df(k1,j,l)),real(df(k1,j,l)))         f(1,k1,j,l) = dkx*zt1         f(2,k1,j,l) = -dky*zt1   10    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         f(1,1,j,l) = dkx*cmplx(-aimag(df(1,j,l)),real(df(1,j,l)))         f(2,1,j,l) = zero         f(1,k1,j,l) = zero         f(2,k1,j,l) = zero      endif   20 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 30 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         f(1,k,1,l) = zero         f(2,k,1,l) = dky*cmplx(-aimag(df(k,1,l)),real(df(k,1,l)))         f(1,k1,1,l) = zero         f(2,k1,1,l) = zero   30    continue         k1 = nyh + 1         f(1,1,1,l) = zero         f(2,1,1,l) = zero         f(1,k1,1,l) = zero         f(2,k1,1,l) = zero      endif   40 continue      return      endc-----------------------------------------------------------------------      subroutine PCURLF2(f,g,nx,ny,kstrt,nyv,kxp,jblok)c this subroutine calculates the curl in fourier spacec input: all except g, output: gc approximate flop count is: 32*nxc*nyc + 10*(nxc + nyc)c where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc the curl is calculated using the equations:c gx(kx,ky) = sqrt(-1)*ky*fz(kx,ky)c gy(kx,ky) = -sqrt(-1)*kx*fz(kx,ky)c gz(kx,ky) = sqrt(-1)*(kx*fy(kx,ky)-ky*fx(kx,ky))c where kx = 2pi*j/nx, ky = 2pi*k/ny, and j,k = fourier mode numbers,c except for gx(kx=pi) = gy(kx=pi) = 0, gx(ky=pi) = gy(ky=pi) = 0,c and gx(kx=0,ky=0) = gy(kx=0,ky=0) = 0.c nx/ny = system length in x/y directionc kstrt = starting data block numberc nyv = first dimension of field arrays, must be >= nyc kxp = number of data values per blockc jblok = number of data blocks      complex f, g, zero, zt1, zt2, zt3      dimension f(3,nyv,kxp,jblok), g(3,nyv,kxp,jblok)      nxh = nx/2      nyh = ny/2      ny2 = ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx)      dny = 6.28318530717959/float(ny)      zero = cmplx(0.,0.)c calculate the curl      if (kstrt.gt.nxh) return      do 40 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 20 j = 1, kxp      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 10 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         zt1 = cmplx(-aimag(f(3,k,j,l)),real(f(3,k,j,l)))         zt2 = cmplx(-aimag(f(2,k,j,l)),real(f(2,k,j,l)))         zt3 = cmplx(-aimag(f(1,k,j,l)),real(f(1,k,j,l)))         g(1,k,j,l) = dky*zt1         g(2,k,j,l) = -dkx*zt1         g(3,k,j,l) = dkx*zt2 - dky*zt3         zt1 = cmplx(-aimag(f(3,k1,j,l)),real(f(3,k1,j,l)))         zt2 = cmplx(-aimag(f(2,k1,j,l)),real(f(2,k1,j,l)))         zt3 = cmplx(-aimag(f(1,k1,j,l)),real(f(1,k1,j,l)))         g(1,k1,j,l) = -dky*zt1         g(2,k1,j,l) = -dkx*zt1         g(3,k1,j,l) = dkx*zt2 + dky*zt3   10    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         zt1 = cmplx(-aimag(f(3,1,j,l)),real(f(3,1,j,l)))         zt2 = cmplx(-aimag(f(2,1,j,l)),real(f(2,1,j,l)))         g(1,1,j,l) = zero         g(2,1,j,l) = -dkx*zt1         g(3,1,j,l) = dkx*zt2         g(1,k1,j,l) = zero         g(2,k1,j,l) = zero         g(3,k1,j,l) = zero      endif   20 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 30 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         zt1 = cmplx(-aimag(f(3,k,1,l)),real(f(3,k,1,l)))         zt2 = cmplx(-aimag(f(1,k,1,l)),real(f(1,k,1,l)))         g(1,k,1,l) = dky*zt1         g(2,k,1,l) = zero         g(3,k,1,l) = -dky*zt2         g(1,k1,1,l) = zero         g(2,k1,1,l) = zero         g(3,k1,1,l) = zero   30    continue         k1 = nyh + 1         g(1,1,1,l) = zero         g(2,1,1,l) = zero         g(3,1,1,l) = zero         g(1,k1,1,l) = zero         g(2,k1,1,l) = zero         g(2,k1,1,l) = zero      endif   40 continue      return      endc-----------------------------------------------------------------------      subroutine PCUPERP2(cu,nx,ny,kstrt,nyv,kxp,jblok)c this subroutine calculates the transverse current in fourier spacec input: all, output: cuc approximate flop count is: 36*nxc*nycc and nxc*nyc dividesc where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc the transverse current is calculated using the equation:c cux(kx,ky) = cux(kx,ky)-kx*(kx*cux(kx,ky)+ky*cuy(kx,ky))/(kx*kx+ky*ky)c cuy(kx,ky) = cuy(kx,ky)-ky*(kx*cux(kx,ky)+ky*cuy(kx,ky))/(kx*kx+ky*ky)c where kx = 2pi*j/nx, ky = 2pi*k/ny, and j,k = fourier mode numbers,c except for cux(kx=pi) = cuy(kx=pi) = 0, cux(ky=pi) = cuy(ky=pi) = 0,c and cux(kx=0,ky=0) = cuy(kx=0,ky=0) = 0.c cu(i,k,j,l) = i-th component of complex current density andc for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c nx/ny = system length in x/y directionc kstrt = starting data block numberc nyv = first dimension of field arrays, must be >= nyc kxp = number of data values per blockc jblok = number of data blocks      complex cu, zero, zt1      dimension cu(3,nyv,kxp,jblok)      nxh = nx/2      nyh = ny/2      ny2 = ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx)      dny = 6.28318530717959/float(ny)      zero = cmplx(0.,0.)c calculate transverse part of current      if (kstrt.gt.nxh) return      do 40 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 20 j = 1, kxp      dkx = dnx*float(j + joff)      dkx2 = dkx*dkx      if ((j+joff).gt.0) then         do 10 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         at1 = 1./(dky*dky + dkx2)         zt1 = at1*(dkx*cu(1,k,j,l) + dky*cu(2,k,j,l))         cu(1,k,j,l) = cu(1,k,j,l) - dkx*zt1         cu(2,k,j,l) = cu(2,k,j,l) - dky*zt1         zt1 = at1*(dkx*cu(1,k1,j,l) - dky*cu(2,k1,j,l))         cu(1,k1,j,l) = cu(1,k1,j,l) - dkx*zt1         cu(2,k1,j,l) = cu(2,k1,j,l) + dky*zt1   10    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         cu(1,1,j,l) = zero         cu(1,k1,j,l) = zero         cu(2,k1,j,l) = zero      endif   20 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 30 k = 2, nyh         k1 = ny2 - k         cu(2,k,1,l) = zero         cu(1,k1,1,l) = zero         cu(2,k1,1,l) = zero   30    continue         k1 = nyh + 1         cu(1,1,1,l) = zero         cu(2,1,1,l) = zero         cu(1,k1,1,l) = zero         cu(2,k1,1,l) = zero      endif   40 continue      return      endc-----------------------------------------------------------------------      subroutine PBPOISP23(cu,bxy,isign,ffc,ax,ay,affp,ci,wm,nx,ny,kstrt     1,nyv,kxp,jblok,nyhd)c this subroutine solves 2d poisson's equation in fourier space forc magnetic field (or convolution of magnetic field over particle shape)c or for vector potential, or provides a smoothing function,c with periodic boundary conditions for distributed data.c for isign = 0, input: isign,ax,ay,affp,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: ffcc for isign = -1, input: cu,ffc,isign,ci,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: bxy,wmc approximate flop count is: 85*nxc*nyc + 36*(nxc + nyc)c for isign = 1, input: cu,ffc,isign,ci,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: bxy,wmc approximate flop count is: 63*nxc*nyc + 33*(nxc + nyc)c for isign = 2, input: cu,ffc,isign,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: bxyc approximate flop count is: 12*nxc*nyc + 6*(nxc + nyc)c where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc if isign = 0, form factor array is preparedc if isign < 0, magnetic field is calculated using the equations:c bx(kx,ky) = ci*ci*sqrt(-1)*g(kx,ky)*ky*cuz(kx,ky)*s(kx,ky),c by(kx,ky) = -ci*ci*sqrt(-1)*g(kx,ky)*kx*cuz(kx,ky)*s(kx,ky),c bz(kx,ky) = ci*ci*sqrt(-1)*g(kx,ky)*(kx*cuy(kx,ky)-ky*cux(kx,ky))*c             s(kx,ky),c where kx = 2pi*j/nx, ky = 2pi*k/ny, and j,k = fourier mode numbers,c g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky),c s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2), except forc bx(kx=pi) = by(kx=pi) = bz(kx=pi) = 0,c bx(ky=pi) = by(ky=pi) = bz(ky=pi) = 0,c bx(kx=0,ky=0) = by(kx=0,ky=0) = bz(kx=0,ky=0) = 0.c if isign = 1, vector potential is calculated using the equation:c bx(kx,ky) = ci*ci*g(kx,ky)*cux(kx,ky)c by(kx,ky) = ci*ci*g(kx,ky)*cuy(kx,ky)c bz(kx,ky) = ci*ci*g(kx,ky)*cuz(kx,ky)c if isign = 2, smoothing is calculated using the equation:c bx(kx,ky) = cux(kx,ky)*s(kx,ky)c by(kx,ky) = cuy(kx,ky)*s(kx,ky)c bz(kx,ky) = cuz(kx,ky)*s(kx,ky)c cu(i,k,j,l) = i-th component of complex current density andc bxy(i,k,j,l) = i-th component of complex magnetic field,c for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c jblok = number of data blocksc kxp = number of data values per blockc kstrt = starting data block numberc aimag(ffc(k,j,l)) = finite-size particle shape factor sc real(ffc(k,j,l)) = potential green's function gc for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c ax/ay = half-width of particle in x/y directionc affp = normalization constant = nx*ny/np, where np=number of particlesc ci = reciprical of velocity of lightc magnetic field energy is also calculated, usingc wm = nx*ny*nz*sum((affp/(kx**2+ky**2+kz**2))*ci*cic    |cu(kx,ky,kz)*s(kx,ky,kz)|**2)c this expression is valid only if the current is divergence-freec nx/ny = system length in x/y directionc nyv = first dimension of field arrays, must be >= nyc nyhd = first dimension of form factor array, must be >= nyh      double precision wp      complex cu, bxy, ffc, zero, zt1, zt2, zt3      dimension cu(3,nyv,kxp,jblok)      dimension bxy(3,nyv,kxp,jblok)      dimension ffc(nyhd,kxp,jblok)      nxh = nx/2      nyh = ny/2      ny2 = ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx)      dny = 6.28318530717959/float(ny)      zero = cmplx(0.,0.)      ci2 = ci*ci      if (isign.ne.0) go to 40      if (kstrt.gt.nxh) returnc prepare form factor array      do 30 l = 1, jblok      joff = kxp*(l + ks) - 1      do 20 j = 1, kxp      dkx = dnx*float(j + joff)      at1 = dkx*dkx      at2 = (dkx*ax)**2      do 10 k = 1, nyh      dky = dny*float(k - 1)      at3 = dky*dky + at1      at4 = exp(-.5*((dky*ay)**2 + at2))      if (at3.eq.0.) then         ffc(k,j,l) = cmplx(affp,1.)      else         ffc(k,j,l) = cmplx(affp*at4/at3,at4)      endif   10 continue   20 continue   30 continue      return   40 if (isign.gt.0) go to 100c calculate magnetic field and sum field energy      wp = 0.0d0      if (kstrt.gt.nxh) go to 90      do 80 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 60 j = 1, kxp      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 50 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         at1 = ci2*real(ffc(k,j,l))*aimag(ffc(k,j,l))         at2 = dky*at1         at3 = dkx*at1         zt1 = cmplx(-aimag(cu(3,k,j,l)),real(cu(3,k,j,l)))         zt2 = cmplx(-aimag(cu(2,k,j,l)),real(cu(2,k,j,l)))         zt3 = cmplx(-aimag(cu(1,k,j,l)),real(cu(1,k,j,l)))         bxy(1,k,j,l) = at2*zt1         bxy(2,k,j,l) = -at3*zt1         bxy(3,k,j,l) = at3*zt2 - at2*zt3         zt1 = cmplx(-aimag(cu(3,k1,j,l)),real(cu(3,k1,j,l)))         zt2 = cmplx(-aimag(cu(2,k1,j,l)),real(cu(2,k1,j,l)))         zt3 = cmplx(-aimag(cu(1,k1,j,l)),real(cu(1,k1,j,l)))         bxy(1,k1,j,l) = -at2*zt1         bxy(2,k1,j,l) = -at3*zt1         bxy(3,k1,j,l) = at3*zt2 + at2*zt3         wp = wp + at1*(cu(1,k,j,l)*conjg(cu(1,k,j,l)) + cu(2,k,j,l)*con     1jg(cu(2,k,j,l)) + cu(3,k,j,l)*conjg(cu(3,k,j,l)) + cu(1,k1,j,l)*co     2njg(cu(1,k1,j,l)) + cu(2,k1,j,l)*conjg(cu(2,k1,j,l)) + cu(3,k1,j,l     3)*conjg(cu(3,k1,j,l)))   50    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         at1 = ci2*real(ffc(1,j,l))*aimag(ffc(1,j,l))         at2 = dkx*at1         zt1 = cmplx(-aimag(cu(3,1,j,l)),real(cu(3,1,j,l)))         zt2 = cmplx(-aimag(cu(2,1,j,l)),real(cu(2,1,j,l)))         bxy(1,1,j,l) = zero         bxy(2,1,j,l) = -at2*zt1         bxy(3,1,j,l) = at2*zt2         bxy(1,k1,j,l) = zero         bxy(2,k1,j,l) = zero         bxy(3,k1,j,l) = zero         wp = wp + at1*(cu(1,1,j,l)*conjg(cu(1,1,j,l)) + cu(2,1,j,l)*con     1jg(cu(2,1,j,l)) + cu(3,1,j,l)*conjg(cu(3,1,j,l)))      endif   60 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 70 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         at1 = ci2*real(ffc(k,1,l))*aimag(ffc(k,1,l))         at2 = dky*at1         zt1 = cmplx(-aimag(cu(3,k,1,l)),real(cu(3,k,1,l)))         zt2 = cmplx(-aimag(cu(1,k,1,l)),real(cu(1,k,1,l)))         bxy(1,k,1,l) = at2*zt1         bxy(2,k,1,l) = zero         bxy(3,k,1,l) = -at2*zt2         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero         bxy(3,k1,1,l) = zero         wp = wp + at1*(cu(1,k,1,l)*conjg(cu(1,k,1,l)) + cu(2,k,1,l)*con     1jg(cu(2,k,1,l)) + cu(3,k,1,l)*conjg(cu(3,k,1,l)))   70    continue         k1 = nyh + 1         bxy(1,1,1,l) = zero         bxy(2,1,1,l) = zero         bxy(3,1,1,l) = zero         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero         bxy(3,k1,1,l) = zero      endif   80 continue   90 continue      wm = float(nx*ny)*wp      returnc calculate vector potential and sum field energy  100 if (isign.gt.1) go to 160      wp = 0.0d0      if (kstrt.gt.nxh) go to 150      do 140 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 120 j = 1, kxp      if ((j+joff).gt.0) then         do 110 k = 2, nyh         k1 = ny2 - k         at2 = ci2*real(ffc(k,j,l))         at1 = at2*aimag(ffc(k,j,l))         bxy(1,k,j,l) = at2*cu(1,k,j,l)         bxy(2,k,j,l) = at2*cu(2,k,j,l)         bxy(3,k,j,l) = at2*cu(3,k,j,l)         bxy(1,k1,j,l) = at2*cu(1,k1,j,l)         bxy(2,k1,j,l) = at2*cu(2,k1,j,l)         bxy(3,k1,j,l) = at2*cu(3,k1,j,l)         wp = wp + at1*(cu(1,k,j,l)*conjg(cu(1,k,j,l)) + cu(2,k,j,l)*con     1jg(cu(2,k,j,l)) + cu(3,k,j,l)*conjg(cu(3,k,j,l)) + cu(1,k1,j,l)*co     2njg(cu(1,k1,j,l)) + cu(2,k1,j,l)*conjg(cu(2,k1,j,l)) + cu(3,k1,j,l     3)*conjg(cu(3,k1,j,l)))  110    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         at2 = ci2*real(ffc(1,j,l))         at1 = at2*aimag(ffc(1,j,l))         bxy(1,1,j,l) = at2*cu(1,1,j,l)         bxy(2,1,j,l) = at2*cu(2,1,j,l)         bxy(3,1,j,l) = at2*cu(3,1,j,l)         bxy(1,k1,j,l) = zero         bxy(2,k1,j,l) = zero         bxy(3,k1,j,l) = zero         wp = wp + at1*(cu(1,1,j,l)*conjg(cu(1,1,j,l)) + cu(2,1,j,l)*con     1jg(cu(2,1,j,l)) + cu(3,1,j,l)*conjg(cu(3,1,j,l)))      endif  120 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 130 k = 2, nyh         k1 = ny2 - k         at2 = ci2*real(ffc(k,1,l))         at1 = at2*aimag(ffc(k,1,l))         bxy(1,k,1,l) = at2*cu(1,k,1,l)         bxy(2,k,1,l) = at2*cu(2,k,1,l)         bxy(3,k,1,l) = at2*cu(3,k,1,l)         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero         bxy(3,k1,1,l) = zero         wp = wp + at1*(cu(1,k,1,l)*conjg(cu(1,k,1,l)) + cu(2,k,1,l)*con     1jg(cu(2,k,1,l)) + cu(3,k,1,l)*conjg(cu(3,k,1,l)))  130    continue         k1 = nyh + 1         bxy(1,1,1,l) = zero         bxy(2,1,1,l) = zero         bxy(3,1,1,l) = zero         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero         bxy(3,k1,1,l) = zero      endif  140 continue  150 continue      wm = float(nx*ny)*wp      returnc calculate smoothing  160 if (kstrt.gt.nxh) go to 210      do 200 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 180 j = 1, kxp      if ((j+joff).gt.0) then         do 170 k = 2, nyh         k1 = ny2 - k         at1 = aimag(ffc(k,j,l))         bxy(1,k,j,l) = at1*cu(1,k,j,l)         bxy(2,k,j,l) = at1*cu(2,k,j,l)         bxy(3,k,j,l) = at1*cu(3,k,j,l)         bxy(1,k1,j,l) = at1*cu(1,k1,j,l)         bxy(2,k1,j,l) = at1*cu(2,k1,j,l)         bxy(3,k1,j,l) = at1*cu(3,k1,j,l)  170    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         at1 = aimag(ffc(1,j,l))         bxy(1,1,j,l) = at1*cu(1,1,j,l)         bxy(2,1,j,l) = at1*cu(2,1,j,l)         bxy(3,1,j,l) = at1*cu(3,1,j,l)         bxy(1,k1,j,l) = zero         bxy(2,k1,j,l) = zero         bxy(3,k1,j,l) = zero      endif  180 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 190 k = 2, nyh         k1 = ny2 - k         at1 = aimag(ffc(k,1,l))         bxy(1,k,1,l) = at1*cu(1,k,1,l)         bxy(2,k,1,l) = at1*cu(2,k,1,l)         bxy(3,k,1,l) = at1*cu(3,k,1,l)         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero         bxy(3,k1,1,l) = zero  190    continue         k1 = nyh + 1         at1 = aimag(ffc(1,1,l))         bxy(1,1,1,l) = cmplx(at1*real(cu(1,1,1,l)),0.)         bxy(2,1,1,l) = cmplx(at1*real(cu(2,1,1,l)),0.)         bxy(3,1,1,l) = cmplx(at1*real(cu(3,1,1,l)),0.)         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero         bxy(3,k1,1,l) = zero      endif  200 continue  210 continue      return      endc-----------------------------------------------------------------------      subroutine PMAXWEL2(exy,bxy,cu,ffc,affp,ci,dt,wf,wm,nx,ny,kstrt,ny     1v,kxp,jblok,nyhd)c this subroutine solves 2d maxwell's equation in fourier space forc transverse electric and magnetic fields with periodic boundaryc conditions.c input: all, output: wf, wm, exy, bxyc approximate flop count is: 286*nxc*nyc + 84*(nxc + nyc)c plus nxc*nyc dividesc where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc the magnetic field is first updated half a step using the equations:c bx(kx,ky) = bx(kx,ky) - .5*dt*sqrt(-1)*ky*ez(kx,ky)c by(kx,ky) = by(kx,ky) + .5*dt*sqrt(-1)*kx*ez(kx,ky)c bz(kx,ky) = bz(kx,ky) - .5*dt*sqrt(-1)*(kx*ey(kx,ky)-ky*ex(kx,ky))c the electric field is then updated a whole step using the equations:c ex(kx,ky) = ex(kx,ky) + c2*dt*sqrt(-1)*ky*bz(kx,ky)c                       - affp*dt*cux(kx,ky)*s(kx,ky)c ey(kx,ky) = ey(kx,ky) - c2*dt*sqrt(-1)*kx*bz(kx,ky)c                       - affp*dt*cuy(kx,ky)*s(kx,ky)c ez(kx,ky) = ez(kx,ky) + c2*dt*sqrt(-1)*(kx*by(kx,ky)-ky*bx(kx,ky))c                       - affp*dt*cuz(kx,ky)*s(kx,ky)c the magnetic field is finally updated the remaining half step withc the new electric field and the previous magnetic field equations.c where kx = 2pi*j/nx, ky = 2pi*k/ny, c2 = 1./(ci*ci)c and s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)c j,k = fourier mode numbers, except forc ex(kx=pi) = ey(kx=pi) = ez(kx=pi) = 0,c ex(ky=pi) = ey(ky=pi) = ez(ky=pi) = 0,c ex(kx=0,ky=0) = ey(kx=0,ky=0) = ez(kx=0,ky=0) = 0.c and similarly for bx, by, bz.c cu(i,k,j,l) = i-th component of complex current density andc exy(i,k,j,l) = i-th component of complex electric field,c bxy(i,k,j,l) = i-th component of complex magnetic field,c for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c aimag(ffc(k,j,l)) = finite-size particle shape factor sc s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)c for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c affp = normalization constant = nx*ny/np, where np=number of particlesc ci = reciprical of velocity of lightc dt = time interval between successive calculationsc transverse electric field energy is also calculated, usingc wf = nx*ny*nz**sum((1/affp)*|exyz(kx,ky,kz)|**2)c magnetic field energy is also calculated, usingc wm = nx*ny*nz**sum((c2/affp)*|bxyz(kx,ky,kz)|**2)c nx/ny = system length in x/y directionc jblok = number of data blocksc kxp = number of data values per blockc kstrt = starting data block numberc nyv = first dimension of field arrays, must be >= nyc nyhd = first dimension of form factor array, must be >= nyh      double precision wp, ws      complex exy, bxy, cu, ffc      complex zero, zt1, zt2, zt3, zt4, zt5, zt6, zt7, zt8, zt9      dimension exy(3,nyv,kxp,jblok), bxy(3,nyv,kxp,jblok)      dimension cu(3,nyv,kxp,jblok)      dimension ffc(nyhd,kxp,jblok)      if (ci.le.0.) return      nxh = nx/2      nyh = ny/2      ny2 = ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx)      dny = 6.28318530717959/float(ny)      dth = .5*dt      c2 = 1./(ci*ci)      cdt = c2*dt      adt = affp*dt      zero = cmplx(0.,0.)      anorm = 1.0/affpc update electromagnetic field and sum field energies      ws = 0.0d0      wp = 0.0d0      if (kstrt.gt.nxh) go to 50c calculate the electromagnetic fields      do 40 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 20 j = 1, kxp      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 10 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         at1 = aimag(ffc(k,j,l))**2         afdt = adt*at1         at1 = anorm/at1c update magnetic field half time step, ky > 0         zt1 = cmplx(-aimag(exy(3,k,j,l)),real(exy(3,k,j,l)))         zt2 = cmplx(-aimag(exy(2,k,j,l)),real(exy(2,k,j,l)))         zt3 = cmplx(-aimag(exy(1,k,j,l)),real(exy(1,k,j,l)))         zt4 = bxy(1,k,j,l) - dth*(dky*zt1)         zt5 = bxy(2,k,j,l) + dth*(dkx*zt1)         zt6 = bxy(3,k,j,l) - dth*(dkx*zt2 - dky*zt3)c update electric field whole time step         zt1 = cmplx(-aimag(zt6),real(zt6))         zt2 = cmplx(-aimag(zt5),real(zt5))         zt3 = cmplx(-aimag(zt4),real(zt4))         zt7 = exy(1,k,j,l) + cdt*(dky*zt1) - afdt*cu(1,k,j,l)         zt8 = exy(2,k,j,l) - cdt*(dkx*zt1) - afdt*cu(2,k,j,l)         zt9 = exy(3,k,j,l) + cdt*(dkx*zt2 - dky*zt3) - afdt*cu(3,k,j,l)c update magnetic field half time step and store electric field         zt1 = cmplx(-aimag(zt9),real(zt9))         zt2 = cmplx(-aimag(zt8),real(zt8))         zt3 = cmplx(-aimag(zt7),real(zt7))         exy(1,k,j,l) = zt7         exy(2,k,j,l) = zt8         exy(3,k,j,l) = zt9         ws = ws + at1*(zt7*conjg(zt7) + zt8*conjg(zt8) + zt9*conjg(zt9)     1)         zt4 = zt4 - dth*(dky*zt1)         zt5 = zt5 + dth*(dkx*zt1)         zt6 = zt6 - dth*(dkx*zt2 - dky*zt3)         bxy(1,k,j,l) = zt4         bxy(2,k,j,l) = zt5         bxy(3,k,j,l) = zt6         wp = wp + at1*(zt4*conjg(zt4) + zt5*conjg(zt5) + zt6*conjg(zt6)     1)c update magnetic field half time step, ky < 0         zt1 = cmplx(-aimag(exy(3,k1,j,l)),real(exy(3,k1,j,l)))         zt2 = cmplx(-aimag(exy(2,k1,j,l)),real(exy(2,k1,j,l)))         zt3 = cmplx(-aimag(exy(1,k1,j,l)),real(exy(1,k1,j,l)))         zt4 = bxy(1,k1,j,l) + dth*(dky*zt1)         zt5 = bxy(2,k1,j,l) + dth*(dkx*zt1)         zt6 = bxy(3,k1,j,l) - dth*(dkx*zt2 + dky*zt3)c update electric field whole time step         zt1 = cmplx(-aimag(zt6),real(zt6))         zt2 = cmplx(-aimag(zt5),real(zt5))         zt3 = cmplx(-aimag(zt4),real(zt4))         zt7 = exy(1,k1,j,l) - cdt*(dky*zt1) - afdt*cu(1,k1,j,l)         zt8 = exy(2,k1,j,l) - cdt*(dkx*zt1) - afdt*cu(2,k1,j,l)         zt9 = exy(3,k1,j,l) + cdt*(dkx*zt2 + dky*zt3) - afdt*cu(3,k1,j,     1l)c update magnetic field half time step and store electric field         zt1 = cmplx(-aimag(zt9),real(zt9))         zt2 = cmplx(-aimag(zt8),real(zt8))         zt3 = cmplx(-aimag(zt7),real(zt7))         exy(1,k1,j,l) = zt7         exy(2,k1,j,l) = zt8         exy(3,k1,j,l) = zt9         ws = ws + at1*(zt7*conjg(zt7) + zt8*conjg(zt8) + zt9*conjg(zt9)     1)         zt4 = zt4 + dth*(dky*zt1)         zt5 = zt5 + dth*(dkx*zt1)         zt6 = zt6 - dth*(dkx*zt2 + dky*zt3)         bxy(1,k1,j,l) = zt4         bxy(2,k1,j,l) = zt5         bxy(3,k1,j,l) = zt6         wp = wp + at1*(zt4*conjg(zt4) + zt5*conjg(zt5) + zt6*conjg(zt6)     1)   10    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         at1 = aimag(ffc(1,j,l))**2         afdt = adt*at1         at1 = anorm/at1c update magnetic field half time step         zt1 = cmplx(-aimag(exy(3,1,j,l)),real(exy(3,1,j,l)))         zt2 = cmplx(-aimag(exy(2,1,j,l)),real(exy(2,1,j,l)))         zt5 = bxy(2,1,j,l) + dth*(dkx*zt1)         zt6 = bxy(3,1,j,l) - dth*(dkx*zt2)c update electric field whole time step         zt1 = cmplx(-aimag(zt6),real(zt6))         zt2 = cmplx(-aimag(zt5),real(zt5))         zt8 = exy(2,1,j,l) - cdt*(dkx*zt1) - afdt*cu(2,1,j,l)         zt9 = exy(3,1,j,l) + cdt*(dkx*zt2) - afdt*cu(3,1,j,l)c update magnetic field half time step and store electric field         zt1 = cmplx(-aimag(zt9),real(zt9))         zt2 = cmplx(-aimag(zt8),real(zt8))         exy(1,1,j,l) = zero         exy(2,1,j,l) = zt8         exy(3,1,j,l) = zt9         ws = ws + at1*(zt8*conjg(zt8) + zt9*conjg(zt9))         zt5 = zt5 + dth*(dkx*zt1)         zt6 = zt6 - dth*(dkx*zt2)         bxy(1,1,j,l) = zero         bxy(2,1,j,l) = zt5         bxy(3,1,j,l) = zt6         wp = wp + at1*(zt5*conjg(zt5) + zt6*conjg(zt6))         bxy(1,k1,j,l) = zero         bxy(2,k1,j,l) = zero         bxy(3,k1,j,l) = zero         exy(1,k1,j,l) = zero         exy(2,k1,j,l) = zero         exy(3,k1,j,l) = zero      endif   20 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 30 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         at1 = aimag(ffc(k,1,l))**2         afdt = adt*at1         at1 = anorm/at1c update magnetic field half time step         zt1 = cmplx(-aimag(exy(3,k,1,l)),real(exy(3,k,1,l)))         zt3 = cmplx(-aimag(exy(1,k,1,l)),real(exy(1,k,1,l)))         zt4 = bxy(1,k,1,l) - dth*(dky*zt1)         zt6 = bxy(3,k,1,l) + dth*(dky*zt3)c update electric field whole time step         zt1 = cmplx(-aimag(zt6),real(zt6))         zt3 = cmplx(-aimag(zt4),real(zt4))         zt7 = exy(1,k,1,l) + cdt*(dky*zt1) - afdt*cu(1,k,1,l)         zt9 = exy(3,k,1,l) - cdt*(dky*zt3) - afdt*cu(3,k,1,l)c update magnetic field half time step and store electric field         zt1 = cmplx(-aimag(zt9),real(zt9))         zt3 = cmplx(-aimag(zt7),real(zt7))         exy(1,k,1,l) = zt7         exy(2,k,1,l) = zero         exy(3,k,1,l) = zt9         ws = ws + at1*(zt7*conjg(zt7) + zt9*conjg(zt9))         zt4 = zt4 - dth*(dky*zt1)         zt6 = zt6 + dth*(dky*zt3)         bxy(1,k,1,l) = zt4         bxy(2,k,1,l) = zero         bxy(3,k,1,l) = zt6         wp = wp + at1*(zt4*conjg(zt4) + zt6*conjg(zt6))         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero         bxy(3,k1,1,l) = zero         exy(1,k1,1,l) = zero         exy(2,k1,1,l) = zero         exy(3,k1,1,l) = zero   30    continue         k1 = nyh + 1         bxy(1,1,1,l) = zero         bxy(2,1,1,l) = zero         bxy(3,1,1,l) = zero         exy(1,1,1,l) = zero         exy(2,1,1,l) = zero         exy(3,1,1,l) = zero         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero         bxy(3,k1,1,l) = zero         exy(1,k1,1,l) = zero         exy(2,k1,1,l) = zero         exy(3,k1,1,l) = zero      endif   40 continue   50 continue      wf = float(nx*ny)*ws      wm = float(nx*ny)*c2*wp      return      endc-----------------------------------------------------------------------      subroutine PEMFIELD2(fxy,exy,isign,nx,ny,kstrt,nyv,kxp,jblok)c this subroutine either adds complex vector fields if isign > 0c or copies complex vector fields if isign < 0      implicit none      integer isign, nx, ny, kstrt, nyv, kxp, jblok      complex fxy, exy      dimension fxy(3,nyv,kxp,jblok), exy(3,nyv,kxp,jblok)      integer i, j, k, l, nxh      nxh = nx/2      if (kstrt.gt.nxh) returnc add the fields      if (isign.gt.0) then         do 40 l = 1, jblok         do 30 j = 1, kxp         do 20 k = 1, ny         do 10 i = 1, 3         fxy(i,k,j,l) = fxy(i,k,j,l) + exy(i,k,j,l)   10    continue   20    continue   30    continue   40    continuec copy the fields      else if (isign.lt.0) then         do 80 l = 1, jblok         do 70 j = 1, kxp         do 60 k = 1, ny         do 50 i = 1, 3         fxy(i,k,j,l) = exy(i,k,j,l)   50    continue   60    continue   70    continue   80    continue      endif      return      endc-----------------------------------------------------------------------      subroutine PLCGUARD2X(fxy,nyp,nx,nxe,nypmx,nblok)c this subroutine replicates field so as to disablec quadratic interpolation within a half a cell of the edges,c and reduce it to linear interpolation in the x directionc for distributed data      implicit none      real fxy      integer nyp, nx, nxe, nypmx, nblok      dimension fxy(2,nxe,nypmx,nblok), nyp(nblok)c local data      integer k, l, nyp3      do 20 l = 1, nblok      nyp3 = nyp(l) + 3      do 10 k = 1, nyp3      fxy(1,1,k,l) = 2.*fxy(1,2,k,l) - fxy(1,3,k,l)      fxy(2,1,k,l) = 2.*fxy(2,2,k,l) - fxy(2,3,k,l)      fxy(1,nx+3,k,l) = 2.*fxy(1,nx+2,k,l) - fxy(1,nx+1,k,l)      fxy(2,nx+3,k,l) = 2.*fxy(2,nx+2,k,l) - fxy(2,nx+1,k,l)   10 continue   20 continue      return      endc-----------------------------------------------------------------------      subroutine PLDGUARD2X(q,nyp,nx,nxe,nypmx,nblok)c this subroutine replicates scalar field so as to disablec quadratic interpolation within a half a cell of the edges,c and reduce it to linear interpolation in the x directionc for distributed data      implicit none      real q      integer nyp, nx, nxe, nypmx, nblok      dimension q(nxe,nypmx,nblok), nyp(nblok)c local data      integer k, l, nyp3      do 20 l = 1, nblok      nyp3 = nyp(l) + 3      do 10 k = 1, nyp3      q(1,k,l) = 2.*q(2,k,l) - q(3,k,l)      q(nx+3,k,l) = 2.*q(nx+2,k,l) - q(nx+1,k,l)   10 continue   20 continue      return      endc-----------------------------------------------------------------------      subroutine PLBGUARD2X(bxy,nyp,nx,nxe,nypmx,nblok)c this subroutine replicates field so as to disablec quadratic interpolation within a half a cell of the edges,c and reduce it to linear interpolation in the x directionc for distributed data      implicit none      real bxy      integer nyp, nx, nxe, nypmx, nblok      dimension bxy(3,nxe,nypmx,nblok), nyp(nblok)c local data      integer k, l, nyp3      do 20 l = 1, nblok      nyp3 = nyp(l) + 3      do 10 k = 1, nyp3      bxy(1,1,k,l) = 2.*bxy(1,2,k,l) - bxy(1,3,k,l)      bxy(2,1,k,l) = 2.*bxy(2,2,k,l) - bxy(2,3,k,l)      bxy(3,1,k,l) = 2.*bxy(3,2,k,l) - bxy(3,3,k,l)      bxy(1,nx+3,k,l) = 2.*bxy(1,nx+2,k,l) - bxy(1,nx+1,k,l)      bxy(2,nx+3,k,l) = 2.*bxy(2,nx+2,k,l) - bxy(2,nx+1,k,l)      bxy(3,nx+3,k,l) = 2.*bxy(3,nx+2,k,l) - bxy(3,nx+1,k,l)   10 continue   20 continue      return      endc-----------------------------------------------------------------------      subroutine PLSCGUARD2(cu,kstrt,nvp,nyp,xj0,yj0,zj0,nx,ngx,ngy,nxe,     1nypmx,nblok)c initialize extended non-periodic fieldc ngx/ngy = (0,1) number of grid cells away from edgec quadratic interpolation, for distributed data      implicit none      real cu, xj0, yj0, zj0      integer kstrt, nvp, nyp, nx, ngx, ngy, nxe, nypmx, nblok      dimension cu(3,nxe,nypmx,nblok), nyp(nblok)      integer i, j, k, l, ks, nyp3, nxg, nx3      real chx, chy, chz      if ((ngx.lt.0).or.(ngx.gt.1).or.(ngy.lt.0).or.(ngy.gt.1)) returnc initialize extended field, with zero in the edges      nxg = nx - 2*ngx      nx3 = nx + 3      ks = kstrt - 2      chx = .5*xj0      chy = .5*yj0      chz = .5*zj0      do 120 l = 1, nblok      nyp3 = nyp(l) + 3      do 30 k = 1, nyp(l)      do 10 j = 2, nxg      cu(1,j+ngx+1,k+1,l) = xj0      cu(2,j+ngx+1,k+1,l) = yj0      cu(3,j+ngx+1,k+1,l) = zj0   10 continue      do 20 i = 1, 3      cu(i,1,k+1,l) = 0.      cu(i,2,k+1,l) = 0.      cu(i,nx+2,k+1,l) = 0.      cu(i,nx+3,k+1,l) = 0.   20 continue      cu(1,ngx+2,k+1,l) = chx      cu(2,ngx+2,k+1,l) = chy      cu(3,ngx+2,k+1,l) = chz      cu(1,nx-ngx+2,k+1,l) = chx      cu(2,nx-ngx+2,k+1,l) = chy      cu(3,nx-ngx+2,k+1,l) = chz   30 continue      do 50 j = 1, nx3      do 40 i = 1, 3      cu(i,j,1,l) = 0.      cu(i,j,nyp3-1,l) = 0.      cu(i,j,nyp3,l) = 0.   40 continue   50 continue      if ((l+ks).eq.0) thenc fix previous deposit when grid is only one wide.         if ((ngy+4).gt.nyp3) then            chx = -chx            chy = -chy            chz = -chz         endifc handle first grid point in y         do 70 j = 1, nx3         do 60 i = 1, 3         cu(i,j,2,l) = 0.   60    continue   70    continue         do 80 j = 2, nxg         cu(1,j+ngx+1,ngy+2,l) = chx         cu(2,j+ngx+1,ngy+2,l) = chy         cu(3,j+ngx+1,ngy+2,l) = chz   80    continue         do 90 i = 1, 3         cu(i,1,ngy+2,l) = 0.         cu(i,2,ngy+2,l) = 0.         cu(i,nx+2,ngy+2,l) = 0.         cu(i,nx+3,ngy+2,l) = 0.   90    continue         cu(1,ngx+2,ngy+2,l) = .5*chx         cu(2,ngx+2,ngy+2,l) = .5*chy         cu(3,ngx+2,ngy+2,l) = .5*chz         cu(1,nx-ngx+2,ngy+2,l) = .5*chx         cu(2,nx-ngx+2,ngy+2,l) = .5*chy         cu(3,nx-ngx+2,ngy+2,l) = .5*chz         chx = .5*xj0         chy = .5*yj0         chz = .5*zj0      endif      if ((l+ks).eq.(nvp-1)) thenc handle last grid point in y         do 100 j = 2, nxg         cu(1,j+ngx+1,nyp3-ngy-1,l) = chx         cu(2,j+ngx+1,nyp3-ngy-1,l) = chy         cu(3,j+ngx+1,nyp3-ngy-1,l) = chz  100    continue         do 110 i = 1, 3         cu(i,1,nyp3-ngy-1,l) = 0.         cu(i,2,nyp3-ngy-1,l) = 0.         cu(i,nx+2,nyp3-ngy-1,l) = 0.         cu(i,nx+3,nyp3-ngy-1,l) = 0.  110    continue         cu(1,ngx+2,nyp3-ngy-1,l) = .5*chx         cu(2,ngx+2,nyp3-ngy-1,l) = .5*chy         cu(3,ngx+2,nyp3-ngy-1,l) = .5*chz         cu(1,nx-ngx+2,nyp3-ngy-1,l) = .5*chx         cu(2,nx-ngx+2,nyp3-ngy-1,l) = .5*chy         cu(3,nx-ngx+2,nyp3-ngy-1,l) = .5*chz      endif  120 continue      return      endc-----------------------------------------------------------------------      subroutine PLSGUARD2(q,kstrt,nvp,nyp,qi0,nx,ngx,ngy,nxe,nypmx,nblo     1k)c initialize extended non-periodic scalar fieldc ngx/ngy = (0,1) number of grid cells away from edgec quadratic interpolation, for distributed data      implicit none      real q, qi0      integer kstrt, nvp, nyp, nx, ngx, ngy, nxe, nypmx, nblok      dimension q(nxe,nypmx,nblok), nyp(nblok)      integer j, k, l, ks, nyp3, nxg, nx3      real qh      if ((ngx.lt.0).or.(ngx.gt.1).or.(ngy.lt.0).or.(ngy.gt.1)) returnc initialize extended field, with zero in the edges      nxg = nx - 2*ngx      nx3 = nx + 3      ks = kstrt - 2      qh = .5*qi0      do 70 l = 1, nblok      nyp3 = nyp(l) + 3      do 20 k = 1, nyp(l)      do 10 j = 2, nxg      q(j+ngx+1,k+1,l) = qi0   10 continue      q(1,k+1,l) = 0.      q(2,k+1,l) = 0.      q(nx+2,k+1,l) = 0.      q(nx+3,k+1,l) = 0.      q(ngx+2,k+1,l) = qh      q(nx-ngx+2,k+1,l) = qh   20 continue      do 30 j = 1, nx3      q(j,1,l) = 0.      q(j,nyp3-1,l) = 0.      q(j,nyp3,l) = 0.   30 continue      if ((l+ks).eq.0) thenc fix previous deposit when grid is only one wide.         if ((ngy+4).gt.nyp3) qh = -qhc handle first grid point in y         do 40 j = 1, nx3         q(j,2,l) = 0.   40    continue         do 50 j = 2, nxg         q(j+ngx+1,ngy+2,l) = qh   50    continue         q(1,ngy+2,l) = 0.         q(2,ngy+2,l) = 0.         q(nx+2,ngy+2,l) = 0.         q(nx+3,ngy+2,l) = 0.         q(ngx+2,ngy+2,l) = .5*qh         q(nx-ngx+2,ngy+2,l) = .5*qh         qh = .5*qi0      endif      if ((l+ks).eq.(nvp-1)) thenc handle last grid point in y         do 60 j = 2, nxg         q(j+ngx+1,nyp3-ngy-1,l) = qh   60    continue         q(1,nyp3-ngy-1,l) = 0.         q(2,nyp3-ngy-1,l) = 0.         q(nx+2,nyp3-ngy-1,l) = 0.         q(nx+3,nyp3-ngy-1,l) = 0.         q(ngx+2,nyp3-ngy-1,l) = .5*qh         q(nx-ngx+2,nyp3-ngy-1,l) = .5*qh      endif   70 continue      return      endc-----------------------------------------------------------------------      subroutine PLACGUARD2X(cu,nyp,nx,nxe,nypmx,nblok)c this subroutine adds adds up guard cells so as to disablec quadratic interpolation within a half a cell of the edges,c and reduce it to linear interpolation in the x directionc for distributed data      implicit none      real cu      integer nyp, nx, nxe, nypmx, nblok      dimension cu(3,nxe,nypmx,nblok), nyp(nblok)c local data      integer i, k, l, nyp3c add up guard cells      do 30 l = 1, nblok      nyp3 = nyp(l) + 3      do 20 k = 1, nyp3      do 10 i = 1, 3      cu(i,2,k,l) = cu(i,2,k,l) + 2.*cu(i,1,k,l)      cu(i,3,k,l) = cu(i,3,k,l) - cu(i,1,k,l)      cu(i,nx+1,k,l) = cu(i,nx+1,k,l) - cu(i,nx+3,k,l)      cu(i,nx+2,k,l) = cu(i,nx+2,k,l) + 2.*cu(i,nx+3,k,l)      cu(i,1,k,l) = 0.      cu(i,nx+3,k,l) = 0.   10 continue   20 continue   30 continue      return      endc-----------------------------------------------------------------------      subroutine PLAGUARD2X(q,nyp,nx,nxe,nypmx,nblok)c this subroutine adds adds up guard cells so as to disablec quadratic interpolation within a half a cell of the edges,c and reduce it to linear interpolation in the x directionc for distributed scalar data      implicit none      real q      integer nyp, nx, nxe, nypmx, nblok      dimension q(nxe,nypmx,nblok), nyp(nblok)c local data      integer k, l, nyp3c add up guard cells      do 20 l = 1, nblok      nyp3 = nyp(l) + 3      do 10 k = 1, nyp3      q(2,k,l) = q(2,k,l) + 2.*q(1,k,l)      q(3,k,l) = q(3,k,l) - q(1,k,l)      q(nx+1,k,l) = q(nx+1,k,l) - q(nx+3,k,l)      q(nx+2,k,l) = q(nx+2,k,l) + 2.*q(nx+3,k,l)      q(1,k,l) = 0.      q(nx+3,k,l) = 0.   10 continue   20 continue      return      endc-----------------------------------------------------------------------      subroutine PLSCGUARD2L(cu,kstrt,nvp,nyp,xj0,yj0,zj0,nx,ngx,ngy,nxe     1,nypmx,nblok)c initialize extended non-periodic fieldc ngx/ngy = (0,1) = number of grid cells away from edgec linear interpolation, for distributed data      implicit none      real cu, xj0,yj0,zj0      integer kstrt, nvp, nyp, nx, ngx, ngy, nxe, nypmx, nblok      dimension cu(3,nxe,nypmx,nblok), nyp(nblok)      integer i, j, k, l, ks, nyp1, nxg, nx1      real chx, chy, chz      if ((ngx.lt.0).or.(ngx.gt.1).or.(ngy.lt.0).or.(ngy.gt.1)) returnc initialize extended field, with zero in the edges      nxg = nx - 2*ngx      nx1 = nx + 1      ks = kstrt - 2      chx = .5*xj0      chy = .5*yj0      chz = .5*zj0      do 120 l = 1, nblok      nyp1 = nyp(l) + 1      do 30 k = 1, nyp(l)      do 10 j = 2, nxg      cu(1,j+ngx,k,l) = xj0      cu(2,j+ngx,k,l) = yj0      cu(3,j+ngx,k,l) = zj0   10 continue      do 20 i = 1, 3      cu(i,1,k,l) = 0.      cu(i,nx+1,k,l) = 0.   20 continue      cu(1,ngx+1,k,l) = chx      cu(2,ngx+1,k,l) = chy      cu(3,ngx+1,k,l) = chz      cu(1,nx-ngx+1,k,l) = chx      cu(2,nx-ngx+1,k,l) = chy      cu(3,nx-ngx+1,k,l) = chz   30 continue      do 50 j = 1, nx1      do 40 i = 1, 3      cu(i,j,nyp1,l) = 0.   40 continue   50 continue      if ((l+ks).eq.0) thenc fix previous deposit when grid is only one wide.         if ((ngy+2).gt.nyp1) then            chx = -chx            chy = -chy            chz = -chz         endifc handle first grid point in y         do 70 j = 1, nx1         do 60 i = 1, 3         cu(i,j,1,l) = 0.   60    continue   70    continue         do 80 j = 2, nxg         cu(1,j+ngx,ngy+1,l) = chx         cu(2,j+ngx,ngy+1,l) = chy         cu(3,j+ngx,ngy+1,l) = chz   80    continue         do 90 i = 1, 3         cu(i,1,ngy+1,l) = 0.         cu(i,nx+1,ngy+1,l) = 0.   90    continue         cu(1,ngx+1,ngy+1,l) = .5*chx         cu(2,ngx+1,ngy+1,l) = .5*chy         cu(3,ngx+1,ngy+1,l) = .5*chz         cu(1,nx-ngx+1,ngy+1,l) = .5*chx         cu(2,nx-ngx+1,ngy+1,l) = .5*chy         cu(3,nx-ngx+1,ngy+1,l) = .5*chz         chx = .5*xj0         chy = .5*yj0         chz = .5*zj0      endif      if ((l+ks).eq.(nvp-1)) thenc handle last grid point in y         do 100 j = 2, nxg         cu(1,j+ngx,nyp1-ngy,l) = chx         cu(2,j+ngx,nyp1-ngy,l) = chy         cu(3,j+ngx,nyp1-ngy,l) = chz  100    continue         do 110 i = 1, 3         cu(i,1,nyp1-ngy,l) = 0.         cu(i,nx+1,nyp1-ngy,l) = 0.  110    continue         cu(1,ngx+1,nyp1-ngy,l) = .5*chx         cu(2,ngx+1,nyp1-ngy,l) = .5*chy         cu(3,ngx+1,nyp1-ngy,l) = .5*chz         cu(1,nx-ngx+1,nyp1-ngy,l) = .5*chx         cu(2,nx-ngx+1,nyp1-ngy,l) = .5*chy         cu(3,nx-ngx+1,nyp1-ngy,l) = .5*chz      endif  120 continue      return      endc-----------------------------------------------------------------------      subroutine PLSGUARD2L(q,kstrt,nvp,nyp,qi0,nx,ngx,ngy,nxe,nypmx,nbl     1ok)c initialize extended non-periodic scalar fieldc ngx/ngy = (0,1) = number of grid cells away from edgec linear interpolation, for distributed data      implicit none      real q, qi0      integer kstrt, nvp, nyp, nx, ngx, ngy, nxe, nypmx, nblok      dimension q(nxe,nypmx,nblok), nyp(nblok)      integer j, k, l, ks, nyp1, nxg, nx1      real qh      if ((ngx.lt.0).or.(ngx.gt.1).or.(ngy.lt.0).or.(ngy.gt.1)) returnc initialize extended field, with zero in the edges      nxg = nx - 2*ngx      nx1 = nx + 1      ks = kstrt - 2      qh = .5*qi0      do 70 l = 1, nblok      nyp1 = nyp(l) + 1      do 20 k = 1, nyp(l)      do 10 j = 2, nxg      q(j+ngx,k,l) = qi0   10 continue      q(1,k,l) = 0.      q(nx+1,k,l) = 0.      q(ngx+1,k,l) = qh      q(nx-ngx+1,k,l) = qh   20 continue      do 30 j = 1, nx1      q(j,nyp1,l) = 0.   30 continue      if ((l+ks).eq.0) thenc fix previous deposit when grid is only one wide.         if ((ngy+2).gt.nyp1) qh = -qhc handle first grid point in y         do 40 j = 1, nx1         q(j,1,l) = 0.   40    continue         do 50 j = 2, nxg         q(j+ngx,ngy+1,l) = qh   50    continue         q(1,ngy+1,l) = 0.         q(nx+1,ngy+1,l) = 0.         q(ngx+1,ngy+1,l) = .5*qh         q(nx-ngx+1,ngy+1,l) = .5*qh         qh = .5*qi0      endif      if ((l+ks).eq.(nvp-1)) thenc handle last grid point in y         do 60 j = 2, nxg         q(j+ngx,nyp1-ngy,l) = qh   60    continue         q(1,nyp1-ngy,l) = 0.         q(nx+1,nyp1-ngy,l) = 0.         q(ngx+1,nyp1-ngy,l) = .5*qh         q(nx-ngx+1,nyp1-ngy,l) = .5*qh      endif   70 continue      return      endc-----------------------------------------------------------------------      subroutine PPOISD2(q,fx,fy,isign,ffd,ax,ay,affp,we,nx,ny,kstrt,ny2     1d,kxp2,j2blok,nyd)c this subroutine solves 2d poisson's equation in fourier space forc force/charge (or convolution of electric field over particle shape)c or for potential, or provides a smoothing function, with diricheletc boundary conditions (zero potential), for distributed data.c fourier coefficients are constructed so that a real to complex fftc will perform the appropriate sin-sin, sin-cos, or cos-sin transformc for isign = 0,input: isign,ax,ay,affp,nx,ny,kstrt,ny2d,kxp2,j2blok,nydc               output: ffdc for isign = -1, input: q,ffd,isign,nx,ny,kstrt,ny2d,kxp2,j2blok,nydc                output: fx,fy,wec approximate flop count is: 11*nx*nyc for isign = 1, input: q,ffd,isign,nx,ny,kstrt,ny2d,kxp2,j2blok,nydc                output: fx,wec approximate flop count is: 6*nc*nyc for isign = 2, input: q,ffd,isign,nx,ny,kstrt,ny2d,kxp2,j2blok,nydc                output: fyc approximate flop count is: 2*nx*nyc if isign < 0, force/charge is calculated using the equations:c fx(kx,ky) = -sqrt(-1)*kx*g(kx,ky)*s(kx,ky)*q(kx,ky),c fy(kx,ky) = -sqrt(-1)*ky*g(kx,ky)*s(kx,ky)*q(kx,ky),c where kx = pi*j/nx, ky = pi*k/ny, and j,k = fourier mode numbers,c g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky),c s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2), except forc if isign = 1, potential is calculated using the equation:c fx(kx,ky) = g(kx,ky)*q(kx,ky)*s(kx,ky)c if isign = 2, smoothing is calculated using the equation:c fy(kx,ky) = q(kx,ky)*s(kx,ky)c q(k,j,l) = complex charge density for fourier mode (jj-1,k-1)c fx(k,j,l) = x component of complex force/charge,c fy(k,j,l) = y component of complex force/charge,c all for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c if isign = 0, form factor array is preparedc ffd(k,2*j,l) = finite-size particle shape factor sc ffd(k,2*j-1,l) = potential green's function gc all for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c j2blok = number of data blocksc kxp2 = number of data values per blockc kstrt = starting data block numberc ax/ay = half-width of particle in x/y directionc affp = normalization constant = nx*ny/np, where np=number of particlesc electric field energy is also calculated, usingc we = 2*nx*ny*sum((affp/(kx**2+ky**2))*|q(kx,ky)*s(kx,ky)|**2)c nx/ny = system length in x/y directionc ny2d = first dimension of field arrays, must be >= 2*nyc nyd = first dimension of form factor array, must be >= ny      double precision wp      complex q, fx, fy, ffd, zero      dimension q(ny2d,kxp2,j2blok)      dimension fx(ny2d,kxp2,j2blok), fy(ny2d,kxp2,j2blok)      dimension ffd(nyd,kxp2,j2blok)      ny2 = 2*ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx + nx)      dny = 6.28318530717959/float(ny + ny)      zero = cmplx(0.,0.)      if (isign.ne.0) go to 40      if (kstrt.gt.nx) returnc prepare form factor array      do 30 l = 1, j2blok      joff = kxp2*(l + ks) - 1      do 20 j = 1, kxp2      dkx = dnx*float(j + joff)      at1 = dkx*dkx      at2 = (dkx*ax)**2      do 10 k = 1, ny      dky = dny*float(k - 1)      at3 = dky*dky + at1      at4 = exp(-.5*((dky*ay)**2 + at2))      if (at3.eq.0.) then         ffd(k,j,l) = cmplx(affp,1.)      else         ffd(k,j,l) = cmplx(affp*at4/at3,at4)      endif   10 continue   20 continue   30 continue      return   40 if (isign.gt.0) go to 100c calculate force/charge and sum field energy      wp = 0.0d0      if (kstrt.gt.nx) go to 90      do 80 l = 1, j2blokc mode numbers kx > 0 and 0 < ky < ny      joff = kxp2*(l + ks) - 1      do 60 j = 1, kxp2      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 50 k = 2, ny         k1 = ny2 - k         at1 = real(ffd(k,j,l))*aimag(ffd(k,j,l))         at3 = -at1*real(q(k,j,l))         at2 = dkx*at3         at3 = dny*float(k - 1)*at3         fx(k,j,l) = cmplx(0.,at2)         fx(k1,j,l) = cmplx(0.,-at2)         fy(k,j,l) = cmplx(0.,at3)         fy(k1,j,l) = cmplx(0.,at3)         wp = wp + at1*real(q(k,j,l))**2   50    continue      endifc mode numbers ky = 0, ny      at1 = real(ffd(1,j,l))*aimag(ffd(1,j,l))      fx(1,j,l) = zero      fx(ny+1,j,l) = zero      fy(1,j,l) = zero      fy(ny+1,j,l) = zero      wp = wp + at1*real(q(1,j,l))**2   60 continuec mode number kx = 0      if ((l+ks).eq.0) then         do 70 k = 2, ny         k1 = ny2 - k         at1 = real(ffd(k,1,l))*aimag(ffd(k,1,l))         fx(k,1,l) = zero         fx(k1,1,l) = zero         fy(k,1,l) = zero         fy(k1,1,l) = zero         wp = wp + at1*real(q(k,1,l))**2   70    continue      endif   80 continue   90 continue      we = 2.0*float(nx*ny)*wp      returnc calculate potential and sum field energy  100 if (isign.gt.1) go to 160      wp = 0.0d0      if (kstrt.gt.nx) go to 150      do 140 l = 1, j2blokc mode numbers kx > 0 and 0 < ky < ny      joff = kxp2*(l + ks) - 1      do 120 j = 1, kxp2      if ((j+joff).gt.0) then         do 110 k = 2, ny         k1 = ny2 - k         at2 = real(ffd(k,j,l))         at1 = at2*aimag(ffd(k,j,l))         at3 = at2*real(q(k,j,l))         fx(k,j,l) = cmplx(at3,0.)         fx(k1,j,l) = cmplx(-at3,0.)         wp = wp + at1*real(q(k,j,l))**2  110    continue      endifc mode numbers ky = 0, ny      at1 = real(ffd(1,j,l))*aimag(ffd(1,j,l))      fx(1,j,l) = zero      fx(ny+1,j,l) = zero      wp = wp + at1*real(q(1,j,l))**2  120 continuec mode number kx = 0      if ((l+ks).eq.0) then         do 130 k = 2, ny         k1 = ny2 - k         at1 = real(ffd(k,1,l))*aimag(ffd(k,1,l))         fx(k,1,l) = zero         fx(k1,1,l) = zero         wp = wp + at1*real(q(k,1,l))**2  130    continue      endif  140 continue  150 continue      we = 2.0*float(nx*ny)*wp      returnc calculate smoothing  160 if (kstrt.gt.nx) go to 210      do 200 l = 1, j2blokc mode numbers kx > 0 and 0 < ky < ny      joff = kxp2*(l + ks) - 1      do 180 j = 1, kxp2      if ((j+joff).gt.0) then         do 170 k = 2, ny         k1 = ny2 - k         at1 = aimag(ffd(k,j,l))         at2 = at1*real(q(k,j,l))         fy(k,j,l) = cmplx(at2,0.)         fy(k1,j,l) = cmplx(-at2,0.)  170    continue      endifc mode numbers ky = 0, ny      fy(1,j,l) = zero      fy(ny+1,j,l) = zero  180 continuec mode number kx = 0      if ((l+ks).eq.0) then         do 190 k = 2, ny         k1 = ny2 - k         fy(k,1,l) = zero         fy(k1,1,l) = zero  190    continue      endif  200 continue  210 continue      return      endc-----------------------------------------------------------------------      subroutine PPOISD22(q,fxy,isign,ffd,ax,ay,affp,we,nx,ny,kstrt,ny2d     1,kxp2,j2blok,nyd)c this subroutine solves 2d poisson's equation in fourier space forc force/charge (or convolution of electric field over particle shape)c with dirichelet boundary conditions (zero potential),c for distributed data.c fourier coefficients are constructed so that a real to complex fftc will perform the appropriate sin-cos, or cos-sin transformc for isign = 0,input: isign,ax,ay,affp,nx,ny,kstrt,ny2d,kxp2,j2blok,nydc               output: ffdc for isign /= 0, input: q,ffd,isign,nx,ny,kstrt,ny2d,kxp2,j2blok,nydc                output: fxy,wec approximate flop count is: 11*nx*nyc eqwuation used is:c fx(kx,ky) = -sqrt(-1)*kx*g(kx,ky)*s(kx,ky)*q(kx,ky),c fy(kx,ky) = -sqrt(-1)*ky*g(kx,ky)*s(kx,ky)*q(kx,ky),c where kx = pi*j/nx, ky = pi*k/ny, and j,k = fourier mode numbers,c g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky),c s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2), except forc q(k,j,l) = complex charge density for fourier mode (jj-1,k-1)c fxy(1,k,j,l) = x component of complex force/charge,c fxy(2,k,j,l) = y component of complex force/charge,c all for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c if isign = 0, form factor array is preparedc ffd(k,2*j,l) = finite-size particle shape factor sc ffd(k,2*j-1,l) = potential green's function gc all for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c j2blok = number of data blocksc kxp2 = number of data values per blockc kstrt = starting data block numberc ax/ay = half-width of particle in x/y directionc affp = normalization constant = nx*ny/np, where np=number of particlesc electric field energy is also calculated, usingc we = 2*nx*ny*sum((affp/(kx**2+ky**2))*|q(kx,ky)*s(kx,ky)|**2)c nx/ny = system length in x/y directionc ny2d = first dimension of field arrays, must be >= 2*nyc nyd = first dimension of form factor array, must be >= ny      double precision wp      complex q, fxy, ffd, zero      dimension q(ny2d,kxp2,j2blok), fxy(2,ny2d,kxp2,j2blok)      dimension ffd(nyd,kxp2,j2blok)      ny2 = 2*ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx + nx)      dny = 6.28318530717959/float(ny + ny)      zero = cmplx(0.,0.)      if (isign.ne.0) go to 40      if (kstrt.gt.nx) returnc prepare form factor array      do 30 l = 1, j2blok      joff = kxp2*(l + ks) - 1      do 20 j = 1, kxp2      dkx = dnx*float(j + joff)      at1 = dkx*dkx      at2 = (dkx*ax)**2      do 10 k = 1, ny      dky = dny*float(k - 1)      at3 = dky*dky + at1      at4 = exp(-.5*((dky*ay)**2 + at2))      if (at3.eq.0.) then         ffd(k,j,l) = cmplx(affp,1.)      else         ffd(k,j,l) = cmplx(affp*at4/at3,at4)      endif   10 continue   20 continue   30 continue      returnc calculate force/charge and sum field energy   40 wp = 0.0d0      if (kstrt.gt.nx) go to 90      do 80 l = 1, j2blokc mode numbers kx > 0 and 0 < ky < ny      joff = kxp2*(l + ks) - 1      do 60 j = 1, kxp2      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 50 k = 2, ny         k1 = ny2 - k         at1 = real(ffd(k,j,l))*aimag(ffd(k,j,l))         at3 = -at1*real(q(k,j,l))         at2 = dkx*at3         at3 = dny*float(k - 1)*at3         fxy(1,k,j,l) = cmplx(0.,at2)         fxy(2,k,j,l) = cmplx(0.,at3)         fxy(1,k1,j,l) = cmplx(0.,-at2)         fxy(2,k1,j,l) = cmplx(0.,at3)         wp = wp + at1*real(q(k,j,l))**2   50    continue      endifc mode numbers ky = 0, ny      at1 = real(ffd(1,j,l))*aimag(ffd(1,j,l))      fxy(1,1,j,l) = zero      fxy(2,1,j,l) = zero      fxy(1,ny+1,j,l) = zero      fxy(2,ny+1,j,l) = zero      wp = wp + at1*real(q(1,j,l))**2   60 continuec mode number kx = 0      if ((l+ks).eq.0) then         do 70 k = 2, ny         k1 = ny2 - k         at1 = real(ffd(k,1,l))*aimag(ffd(k,1,l))         fxy(1,k,1,l) = zero         fxy(2,k,1,l) = zero         fxy(1,k1,1,l) = zero         fxy(2,k1,1,l) = zero         wp = wp + at1*real(q(k,1,l))**2   70    continue      endif   80 continue   90 continue      we = 2.0*float(nx*ny)*wp      return      endc-----------------------------------------------------------------------      subroutine PBNDRYV2(q,ffc,bv,nx,ny,kstrt,nyv,kxp,jblok,nyhd)c this subroutine calculates the boundary values of electric field ofc the periodic solution of poisson's equation in Fourier space from thec charge density.  The results are used in calculating the solution of ac laplacian in order to satisfy non-periodic boundary conditions.c algorithm used in described in V. K. Decyk and J. M. Dawson,c Journal of Computational Physics 30, 407 (1979).c input: q, ffp, nx, ny, nxvh, nxhd, nyhd, output: bvc approximate flop count = 16*nxc*nyc + 7*nyc + 7*nxcc where nxc = nx/2 - 1, nyc = ny/2 - 1c q(j,k) = input complex charge density,c real(ffc(j,k)) = finite-size particle shape factor s,c aimag(ffc(j,k)) = potential green's function g,c all for for fourier mode (j-1,k-1)c bv = boundary fields, bv(k,3) = KmPm and bv(k,4) = PIm, exceptc imag(PI0) = net charge density rhoc nx/ny = system length in x/y directionc nxvh = first dimension of field arrays, must be >= nx/2c nxhd = must be >= nx/2c nyhd = must be >= ny/2      implicit none      complex q, ffc, bv      integer nx, ny, kstrt, nyv, kxp, jblok, nyhd      dimension q(nyv,kxp,jblok), ffc(nyhd,kxp,jblok), bv(nyhd,4)c local data      integer nxh, nyh, ny2, j, k, k1, l, ks, joff      real dnx, dny, dky, sum1, sum2, sum3, sum4, at1, at2      nxh = nx/2      nyh = ny/2      ny2 = ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx)      dny = 6.28318530717959/float(ny)      if (kstrt.gt.nxh) return      do 40 l = 1, jblok      joff = kxp*(l + ks) - 1      do 20 k = 2, nyh      k1 = ny2 - k      dky = dny*float(k - 1)c calculate KmPm and PIm      sum1 = 0.      sum2 = 0.      sum3 = 0.      sum4 = 0.      do 10 j = 1, kxp      if ((j+joff).gt.0) then         at2 = real(ffc(k,j,l))         at1 = dky*at2         at2 = dnx*float(j + joff)*at2         sum1 = sum1 + at1*real(q(k,j,l) + q(k1,j,l))         sum2 = sum2 + at1*aimag(q(k,j,l) - q(k1,j,l))         sum3 = sum3 + at2*aimag(q(k,j,l) + q(k1,j,l))         sum4 = sum4 + at2*real(q(k1,j,l) - q(k,j,l))      endif   10 continue      bv(k,3) = cmplx(sum1,sum2)      bv(k,4) = cmplx(sum3,sum4)      if ((l+ks).eq.0) bv(k,3) = bv(k,3) + (dky*real(ffc(k,1,l)))*q(k,1,     1l)   20 continuec calculate P0 and PI0      sum1 = 0.      sum2 = 0.      do 30 j = 1, kxp      if ((j+joff).gt.0) then         at1 = real(ffc(1,j,l))         sum1 = sum1 + at1*real(q(1,j,l))         sum2 = sum2 + (dnx*float(j + joff)*at1)*aimag(q(1,j,l))      endif   30 continue      bv(1,3) = cmplx(sum1 + sum1,0.)c imaginary part of bv(1,4) contains net charge rho00      bv(1,4) = cmplx(sum2 + sum2,0.)      if ((l+ks).eq.0) bv(1,4) = bv(1,4) + cmplx(0.,real(ffc(1,1,l))*rea     1l(q(1,1,l)))   40 continue      return      endc-----------------------------------------------------------------------      subroutine PPOISB2(fx,fy,isign,ffb,bv,bcd,mixup,sct,t,we,affp,indx     1,ny,kstrt,nyv,kxp,jblok,nxhd,nyhd)c this subroutine finds corrections to 2d poisson's equation for c force/charge or potential with vacuum boundary conditions and c external surface charge, for distributed data.c average potential across system is zero.  a periodic solution isc assumed to have been found first with ppoisp2, and boundary valuesc with bndryv2c algorithm used in described in V. K. Decyk and J. M. Dawson,c Journal of Computational Physics 30, 407 (1979).c for isign = 0, input: isign,indx,nxh,ny,nyh,nxvhc                output: ffb,bcdc                scratch: mixup,sct,tc for isign = -1, input:  isign,fx,fy,ffb,bv,bcd,affp,indx,nyc                         nxvh,nxhd,nyhdc                 output: fx, fy, bv, wec approximate flop count is: 54*nxc*nyc + + 115*nyc + 3*nxcc for isign = 1, input:  isign,fx,ffb,bv,bcd,affp,indx,ny,nxvh,nxhd,nyhdc                output: fx, bv, wec approximate flop count is: 27*nxc*nyc + + 74*nyc + 6*nxcc where nxc = nx/2 - 1, nyc = ny/2 - 1c if isign < 0, the force/charge correction is calculated:c exc(km,x) = -Am*exp(-km*(Lx-x)) + Bm*exp(-km*x)c eyc(km,x) = -sqrt(-1)*(Am*exp(-km*(Lx-x)) + Bm*exp(-km*x))c exc(k0,x) = -4*pi*rho00*(Lx/2-x) - A0c eyc(k0,x) = 0.c where Am = .5*(4*pi*sigma(x=Lx,k) + PIm - km*Pm),c       Bm = .5*(4*pi*sigma(x=0,k) - PIm - km*Pm),c and   A0 = 2*pi*sigma(x=Lx) - 2*pi*sigma(x=0) + PI0c where PIm and Pm are the periodic ex and phi at the boundariesc the calculations are done in fourier space and are added to thec periodic forces already in fx, fyc on output, bv = value of electric fields on right boundary:c bv(k,5) = ex(x=Lx), bv(k,6) = ey(x=Lx)c if isign = 1, potential correction is calculated:c potc(km,x) = (Am*exp(-km*(Lx-x)) + Bm*exp(-km*x)/kmc potc(k0,x) = 2*pi*rho00*x*(Lx-x) - A0*(Lx/2-x) - P0c the calculation is done in fourier space and is added to thec periodic potential already in fx.c on output, bv = value of potential on right boundary:c bv(k,6) = phi(x=Lx)c if isign = 0, form factor arrays ffb and bcd are preparedc on input, fx and/or fy contain periodic part of solutionc on output, fx and/or fy contain total solutionc ffb(j,k) = (1/nx)*inverse fft(exp(-dky*float(nx + 1 - j))))c real(ffb(j,1)) = (1/nx)*inverse fft((j - 1)*(nx + 1 - j))))c aimag(ffb(j,1)) = (1/nx)*inverse fft((nx/2 + 1 - j)))c on input, bv = input surface charge and boundary valuesc for fourier mode k-1:c bv(k,1) = 4*pi*sigma(x=0), bv(k,2) = 4*pi*sigma(x=Lx)c bv(k,3) = KmPm, bv(k,4) = PImc both are normalized in the same way as the electric field.c bcd(k) = exp(-ky*Lx)c mixup = array of bit reversed addresses for fftc sct = sine/cosine table for fftc t = complex scratch array, used during initialiation of fft tablesc we = bounded corrections to periodic electric field energyc affp = normalization constant for poisson's equationc indx = exponent which determines length in x direction, where nx=2**indxc ny = system length in y directionc nxvh = first dimension of field arrays, must be >= nx/2c nxhd = must be >= nx/2c nyhd = must be >= ny/2      implicit none      complex fx, fy, ffb, bv, sct, t      integer isign, mixup, indx, ny, kstrt, nyv, kxp, jblok, nxhd, nyhd      real bcd, we, affp      dimension fx(nyv,kxp,jblok), fy(nyv,kxp,jblok)      dimension ffb(nyhd,kxp,jblok), bv(nyhd,6), bcd(nyhd)      dimension mixup(nxhd), sct(nxhd), t(nxhd)c local data      double precision wp, wb      complex zc, zd, zt1, zt2, zt3, zt4      integer nx, nxh, nx1, nyh, ny2      integer is, j, j1, j2, j3, k, k1, ks, l, joff      real dny, anx, anxi, dky, at1, at2, at3, at4, rho, rholx, dkyi      real sum1, sum2, sum3, sum4      nx = 2**indx      nxh = nx/2      nx1 = nx + 1      nyh = ny/2      ny2 = ny + 2      ks = kstrt - 2      dny = 6.28318530717959/float(ny)      anx = float(nx)c initialization      if (isign.ne.0) go to 50      if (kstrt.gt.nxh) returnc prepare fft tables      is = 0c     call FFT1RX(ffb,t,is,mixup,sct,indx,nx,nxh)      is = -1c prepare form factor array      do 10 j = 1, nxh      j1 = j - 1      j2 = j1 + j1      j3 = j2 + 1c     ffb(j,1) = cmplx(float(j2*(nx - j2)),float(j3*(nx - j3)))c     ffb(j,2) = cmplx(float(nxh - j2),float(nxh - j3))   10 continuec     call FFT1RX(ffb(1,1),t,is,mixup,sct,indx,nx,nxh)c     call FFT1RX(ffb(1,2),t,is,mixup,sct,indx,nx,nxh)      do 20 j = 1, nxhc     ffb(j,1) = cmplx(real(ffb(j,1)),aimag(ffb(j,2)))   20 continue      do 40 k = 2, nyh      dky = dny*float(k - 1)      do 30 j = 1, nxh      j2 = j + j      j1 = j2 - 1c     ffb(j,k) = cmplx(exp(-amin1(50.,dky*float(nx1 - j1))),exp(-amin1(5c    10.,dky*float(nx1 - j2))))   30 continue      bcd(k) = exp(-amin1(50.,dky*anx))c     call FFT1RX(ffb(1,k),t,is,mixup,sct,indx,nx,nxh)   40 continue      return   50 if (isign.gt.0) go to 100c calculate force/charge and sum field energy      anxi = 1./anx      wp = 0.0d0      wb = 0.0d0      do 90 l = 1, jblok      joff = kxp*(l + ks) - 1      do 70 k = 2, nyh      k1 = ny2 - k      dky = dny*float(k - 1)c find constants for solution of homogeneous equation      zc = .5*(bv(k,1) - bv(k,3) - bv(k,4))      zd = .5*(bv(k,2) - bv(k,3) + bv(k,4))      zt1 = zc - zd      zt2 = cmplx(0.,1.)*conjg(zc + zd)c boundary fields      zt3 = zc + zd*bcd(k)      zt4 = zc*bcd(k) + zdc calculate internal and boundary energy corrections      at2 = anxi/dky      wp = wp + (aimag(zt2*bv(k,3)) - real(conjg(zt1)*bv(k,4)))*at2*(1.      1- bcd(k))      wb = wb + (conjg(bv(k,1))*(bv(k,3) + zt3) + conjg(bv(k,2))*(bv(k,3     1) + zt4))*at2c homogenous electric field in x direction at x = Lx      bv(k,5) = zc*bcd(k) - zdc homogenous electric field in y direction at x = Lx      bv(k,6) = -cmplx(0.,1.)*zt4c homogenous electric field in x direction at x = 0c     bv(k,7) = zc - zd*bcd(k)c homogenous electric field in y direction at x = 0c     bv(k,8) = -cmplx(0.,1.)*zt3c calculate extra term in homogeneous solution      zc = zc*(1. - bcd(k))*anxi      zd = -cmplx(0.,1.)*zcc find boundary values of periodic solution      sum1 = 0.      sum2 = 0.      sum3 = 0.      sum4 = 0.c add solutions of homogeneous equation to periodic solution      do 60 j = 2, nxh      sum1 = sum1 + real(fx(k,j,l) + fx(k1,j,l))      sum2 = sum2 + aimag(fx(k,j,l) - fx(k1,j,l))      sum3 = sum3 + real(fy(k,j,l) + fy(k1,j,l))      sum4 = sum4 + aimag(fy(k,j,l) - fy(k1,j,l))      fx(k,j,l) = fx(k,j,l) + zt1*real(ffb(k,j,l)) + conjg(zt2)*aimag(ff     1b(k,j,l)) + zc      fx(k1,j,l) = fx(k1,j,l) + conjg(zt1)*real(ffb(k,j,l)) - zt2*aimag(     1ffb(k,j,l)) + conjg(zc)      fy(k,j,l) = fy(k,j,l) + conjg(zt2)*real(ffb(k,j,l)) - zt1*aimag(ff     1b(k,j,l)) + zd      fy(k1,j,l) = fy(k1,j,l) + zt2*real(ffb(k,j,l)) + conjg(zt1)*aimag(     1ffb(k,j,l)) + conjg(zd)   60 continuec modes with n = 0, nx/2 are special      sum1 = sum1 + real(fx(k,1,l))      sum2 = sum2 + aimag(fx(k,1,l))      sum3 = sum3 + real(fy(k,1,l))      sum4 = sum4 + aimag(fy(k,1,l))      fx(k,1,l) = zt1*real(ffb(k,1,l)) + zc      fx(k1,1,l) = conjg(zt1)*aimag(ffb(k,1,l)) + conjg(zc)      fy(k,1,l) = fy(k,1,l) + conjg(zt2)*real(ffb(k,1,l)) + zd      fy(k1,1,l) = zt2*aimag(ffb(k,1,l)) + conjg(zd)c electric field in x direction at x = Lx      bv(k,5) = bv(k,5) + cmplx(sum1,sum2)c electric field in y direction at x = Lx      bv(k,6) = bv(k,6) + cmplx(sum3,sum4)c electric field in x direction at x = 0c     bv(k,7) = bv(k,7) + cmplx(sum1,sum2)c electric field in y direction at x = 0c     bv(k,8) = bv(k,8) + cmplx(sum3,sum4)   70 continuec find constants for solution of homogeneous equation      rho = aimag(bv(1,4))      rholx = .5*rho*anxc find constants for solution of homogeneous equation      at1 = rho*aimag(ffb(1,1,l))      at2 = -(.5*(bv(1,2) - bv(1,1)) + bv(1,4))      at3 = .5*at2*anxc calculate energies      wp = wp - .5*(at2*bv(1,4) - rho*(rholx*anx/6. - 2.*real(bv(1,3))))      wb = wb - .5*(bv(1,2) - bv(1,1))*at2      we = anx*float(ny)*(wp + wb)/affpc find boundary values of periodic solution      sum1 = 0.      sum2 = 0.c add solution of homogeneous equation to periodic solution      do 80 j = 2, nxh      sum1 = sum1 + real(fx(1,j,l))      sum2 = sum2 + real(fy(1,j,l))      if (rho.ne.0.) fx(1,j,l) = fx(1,j,l) - cmplx(at1,rho*aimag(ffb(1,j     1,l)))   80 continue      sum1 = sum1 + sum1      sum2 = sum2 + sum2      fx(1,1,l) = cmplx(at2 - at1,-at1)c electric field in x direction at x = Lx      bv(1,5) = cmplx(at2+rholx,0.) + cmplx(sum1,0.)c electric field in y direction at x = Lx      bv(1,6) = cmplx(sum2,0.)c electric field in x direction at x = 0c     bv(1,7) = cmplx(at2-rholx,0.) + cmplx(sum1,0.)c electric field in y direction at x = 0c     bv(1,8) = cmplx(sum2,0.)   90 continue      returnc calculate potential and sum field energy  100 anxi = 1./anx      wp = 0.0d0      wb = 0.0d0      do 140 l = 1, jblok      joff = kxp*(l + ks) - 1      do 120 k = 2, nyh      k1 = ny2 - k      dky = dny*float(k - 1)      dkyi = .5/dkyc find constants for solution of homogeneous equation      zc = dkyi*(bv(k,1) - bv(k,3) - bv(k,4))      zd = dkyi*(bv(k,2) - bv(k,3) + bv(k,4))      zt1 = zc + zd      zt2 = cmplx(0.,1.)*conjg(zc - zd)c boundary potentials      zt3 = zc + zd*bcd(k)      zt4 = zc*bcd(k) + zdc calculate internal and boundary energy corrections      at2 = anxi/dky      wp = wp + (real(conjg(zt1)*bv(k,3)) - aimag(zt2*bv(k,4)))*anxi*(1.     1- bcd(k))      wb = wb + (conjg(bv(k,1))*(bv(k,3) + zt3*dky) + conjg(bv(k,2))*(bv     1(k,3) + zt4*dky))*at2c calculate extra term in homogeneous solution      zc = zc*(1. - bcd(k))*anxic find boundary values of periodic solution      sum1 = 0.      sum2 = 0.c add solutions of homogeneous equation to periodic solution      do 110 j = 2, nxh      sum1 = sum1 + real(fx(k,j,l) + fx(k1,j,l))      sum2 = sum2 + aimag(fx(k,j,l) - fx(k1,j,l))      fx(k,j,l) = fx(k,j,l) + zt1*real(ffb(k,j,l)) + conjg(zt2)*aimag(ff     1b(k,j,l)) + zc      fx(k1,j,l) = fx(k1,j,l) + conjg(zt1)*real(ffb(k,j,l)) - zt2*aimag(     1ffb(k,j,l)) + conjg(zc)  110 continuec modes with n = 0, nx/2 are special      sum1 = sum1 + real(fx(k,1,l))      sum2 = sum2 + aimag(fx(k,1,l))      fx(k,1,l) = fx(k,1,l) + zt1*real(ffb(k,1,l)) + zc      fx(k1,1,l) = conjg(zt1)*aimag(ffb(k,1,l)) + conjg(zc)c potential at x = Lx      bv(k,6) = zt4 + cmplx(sum1,sum2)c potential at x = 0c     bv(k,5) = zt3 + cmplx(sum1,sum2)  120 continuec find constants for solution of homogeneous equation      rho = aimag(bv(1,4))      rholx = .5*rho*anxc find constants for solution of homogeneous equation      at2 = -(.5*(bv(1,2) - bv(1,1)) + bv(1,4))      at3 = .5*at2*anx      at1 = at2*aimag(ffb(1,1,l))      at4 = -bv(1,3)c calculate energies      wp = wp - .5*(at2*bv(1,4) - rho*(rholx*anx/6. + 2.*at4))      wb = wb - .5*(bv(1,2) - bv(1,1))*at2      we = anx*float(ny)*(wp + wb)/affpc homogenous potential at x = Lx      bv(1,6) = cmplx(-at3,0.)c homogenous potential at x = 0c     bv(1,5) = cmplx(at3,0.)      at3 = .5*rhoc find boundary values of periodic solution      sum1 = 0.c add solution of homogeneous equation to periodic solution      do 130 j = 2, nxh      sum1 = sum1 + real(fx(1,j,l))      fx(1,j,l) = fx(1,j,l) + cmplx(at1 + at3*real(ffb(1,j,l)),at2*aimag     1(ffb(1,j,l)))  130 continue      sum1 = sum1 + sum1      fx(1,1,l) = at3*conjg(ffb(1,1,l)) + cmplx(at1 + at4,at1)c potential at x = Lx      bv(1,6) = bv(1,6) + cmplx(sum1+at4,0.)c potential at x = 0c     bv(1,5) = bv(1,5) + cmplx(sum1+at4,0.)  140 continue      return      endc-----------------------------------------------------------------------      subroutine PFFT2R(f,g,bs,br,isign,ntpose,mixup,sct,indx,indy,kstrt     1,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)c this subroutine performs a two dimensional real to complex fastc fourier transform and its inverse, using complex arithmetic,c for data which is distributed in blocksc for isign = 0, input: isign, indx, indy, kstrt, nxhyd, nxyhdc output: mixup, sctc for isign = (-1,1), input: all, output: f, g, bs, brc for isign = -1, approximate flop count: N*(5*log2(N) + 10)/nvpc for isign = 1,  approximate flop count: N*(5*log2(N) + 8)/nvpc where N = (nx/2)*ny, and nvp = number of procsc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc ntpose = (0,1) = (no,yes) input, output data are transposedc if isign = 0, the fft tables are preparedc if isign = -1, an inverse fourier transform is performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(n,m,l) = (1/nx*ny)*sum(f(j,k,i)*c       exp(-sqrt(-1)*2pi*n*j/nx)*exp(-sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, f is the input and g is the outputc g(m,n,l) = (1/nx*ny)*sum(f(j,k,i)*c       exp(-sqrt(-1)*2pi*nn*j/nx)*exp(-sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c if isign = 1, a forward fourier transform is performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(j,k,i) = sum(f(n,m,l)*exp(sqrt(-1)*2pi*n*j/nx)*c       exp(sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, g is the input and f is the outputc f(j,k,i) = sum(g(m,n,l)*exp(sqrt(-1)*2pi*nn*j/nx)*c       exp(sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c bs, br = scratch arraysc kstrt = starting data block numberc nxvh/nyv = first dimension of f/gc kypd = second dimension of fc kxp/kyp = number of data values per block in x/yc jblok/kblok = number of data blocks in x/yc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxhyd = maximum of (nx/2,ny)c nxyhd = one half of maximum of (nx,ny)c the real data is stored in a complex array of length nx/2, nyc with the odd/even x points stored in the real/imaginary parts.c in complex notation, fourier coefficients are stored as follows:c if ntpose = 0,c f(j,k,i) = mode j-1,kk-1, where kk = k + kyp*(i - 1)c 1 <= j <= nx/2 and 1 <= kk <= ny, except forc f(1,k,i) = mode nx/2,kk-1, where ny/2+2 <= kk <= ny, andc imaginary part of f(1,1,1) = real part of mode nx/2,0 andc imaginary part of f(1,1,(ny/2)/kyp+1) = real part of mode nx/2,ny/2c if ntpose = 1,c g(k,j,i) = mode jj-1,k-1, where jj = j + kxp*(i - 1)c 1 <= jj <= nx/2 and 1 <= k <= ny, except forc g(k,1,1) = mode nx/2,k-1, where ny/2+2 <= k <= ny, andc imaginary part of g(1,1,1) = real part of mode nx/2,0 andc imaginary part of g(ny/2+1,1,1) = real part of mode nx/2,ny/2c written by viktor k. decyk, uclac parallel version      implicit none      integer isign, ntpose, indx, indy, kstrt, nxvh, nyv, kxp, kyp      integer kypd, jblok, kblok, nxhyd, nxyhd, mixup      complex f, g, bs, br, sct      dimension f(nxvh,kypd,kblok), g(nyv,kxp,jblok)      dimension bs(kxp,kyp,kblok), br(kxp,kyp,jblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, nxh, nxhh, nxh2, ny, nyh, ny2, nxy      integer nxhy, ks, j, k, lb, ll, jb, it, nxyh, nrx, nry, l, i, m      integer ns, ns2, km, kmr, k1, k2, j1, j2      real dnxy, arg, ani      complex s, t, t1      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nxh2 = nxh + 2      ny = 2**indy      nyh = ny/2      ny2 = ny + 2      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      if (isign) 50, 10, 300c prepare fft tablesc bit-reverse index table: mixup(j) = 1 + reversed bits of (j - 1)   10 do 30 j = 1, nxhy      lb = j - 1      ll = 0      do 20 k = 1, indx1y      jb = lb/2      it = lb - 2*jb      lb = jb      ll = 2*ll + it   20 continue      mixup(j) = ll + 1   30 continuec sine/cosine table for the angles 2*n*pi/nxy      nxyh = nxy/2      dnxy = 6.28318530717959/float(nxy)      do 40 j = 1, nxyh      arg = dnxy*float(j - 1)      sct(j) = cmplx(cos(arg),-sin(arg))   40 continue      returnc inverse fourier transform   50 if (kstrt.gt.ny) go to 180      nrx = nxhy/nxh      do 80 l = 1, kblokc bit-reverse array elements in x      do 70 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 70      do 60 k = 1, kyp      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = t   60 continue   70 continue   80 continuec first transform in x      nrx = nxy/nxh      do 130 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 120 l = 1, kblok      do 110 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 100 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 90 i = 1, kyp      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t   90 continue  100 continue  110 continue  120 continue  130 continuec unscramble coefficients and normalize      kmr = nxy/nx      ani = 1./float(2*nx*ny)      do 170 l = 1, kblok      do 150 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),-real(sct(1+kmr*(j-1))))      do 140 k = 1, kyp      t = conjg(f(nxh2-j,k,l))      s = f(j,k,l) + t      t = (f(j,k,l) - t)*t1      f(j,k,l) = ani*(s + t)      f(nxh2-j,k,l) = ani*conjg(s - t)  140 continue  150 continue      do 160 k = 1, kyp      f(nxhh+1,k,l) = 2.*ani*conjg(f(nxhh+1,k,l))      f(1,k,l) = 2.*ani*cmplx(real(f(1,k,l)) + aimag(f(1,k,l)),real(f(1,     1k,l)) - aimag(f(1,k,l)))  160 continue  170 continuec transpose f array to g  180 call PTPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kypd,jblok     1,kblok)      if (kstrt.gt.nxh) go to 290      nry = nxhy/ny      do 210 l = 1, jblokc bit-reverse array elements in y      do 200 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 200      do 190 j = 1, kxp      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = t  190 continue  200 continue  210 continuec then transform in y      nry = nxy/ny      do 260 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 250 l = 1, jblok      do 240 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 230 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 220 i = 1, kxp      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t  220 continue  230 continue  240 continue  250 continue  260 continuec unscramble modes kx = 0, nx/2      do 280 l = 1, jblok      if ((l+ks).gt.0) go to 280      do 270 k = 2, nyh      s = g(ny2-k,1,l)      g(ny2-k,1,l) = .5*cmplx(aimag(g(k,1,l) + s),real(g(k,1,l) - s))      g(k,1,l) = .5*cmplx(real(g(k,1,l) + s),aimag(g(k,1,l) - s))  270 continue  280 continuec transpose g array to f  290 if (ntpose.eq.0) call PTPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,kyp,k     1xp,kypd,kxp,kblok,jblok)      returnc forward fourier transformc transpose f array to g  300 if (ntpose.eq.0) call PTPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,kxp,k     1yp,kxp,kypd,jblok,kblok)      if (kstrt.gt.nxh) go to 410      nry = nxhy/ny      do 350 l = 1, jblokc scramble modes kx = 0, nx/2      if ((l+ks).gt.0) go to 320      do 310 k = 2, nyh      s = cmplx(aimag(g(ny2-k,1,l)),real(g(ny2-k,1,l)))      g(ny2-k,1,l) = conjg(g(k,1,l) - s)      g(k,1,l) = g(k,1,l) + s  310 continuec bit-reverse array elements in y  320 do 340 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 340      do 330 j = 1, kxp      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = t  330 continue  340 continue  350 continuec first transform in y      nry = nxy/ny      do 400 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 390 l = 1, jblok      do 380 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 370 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 360 i = 1, kxp      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t  360 continue  370 continue  380 continue  390 continue  400 continuec transpose g array to f  410 call PTPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kxp,kblok     1,jblok)      if (kstrt.gt.ny) return      nrx = nxhy/nxh      kmr = nxy/nx      do 470 l = 1, kblokc scramble coefficients      do 430 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),real(sct(1+kmr*(j-1))))      do 420 k = 1, kyp      t = conjg(f(nxh2-j,k,l))      s = f(j,k,l) + t      t = (f(j,k,l) - t)*t1      f(j,k,l) = s + t      f(nxh2-j,k,l) = conjg(s - t)  420 continue  430 continue      do 440 k = 1, kyp      f(nxhh+1,k,l) = 2.*conjg(f(nxhh+1,k,l))      f(1,k,l) = cmplx(real(f(1,k,l)) + aimag(f(1,k,l)),real(f(1,k,l)) -     1 aimag(f(1,k,l)))  440 continuec bit-reverse array elements in x      do 460 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 460      do 450 k = 1, kyp      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = t  450 continue  460 continue  470 continuec then transform in x      nrx = nxy/nxh      do 520 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 510 l = 1, kblok      do 500 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 490 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 480 i = 1, kyp      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t  480 continue  490 continue  500 continue  510 continue  520 continue      return      endc-----------------------------------------------------------------------      subroutine PFFT2R2(f,g,bs,br,isign,ntpose,mixup,sct,indx,indy,kstr     1t,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)c this subroutine performs 2 two dimensional complex to real fastc fourier transforms, using complex arithmetic,c for data which is distributed in blocksc for isign = 0, input: isign, indx, indy, kstrt, nxhyd, nxyhdc output: mixup, sctc for isign = (-1,1), input: all, output: f, g, bs, brc for isign = -1, approximate flop count: N*(5*log2(N) + 10)/nvpc for isign = 1,  approximate flop count: N*(5*log2(N) + 8)/nvpc where N = (nx/2)*ny, and nvp = number of procsc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc ntpose = (0,1) = (no,yes) input, output data are transposedc if isign = 0, the fft tables are preparedc if isign = -1, two inverse fourier transforms are performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(1:2,n,m,l) = (1/nx*ny)*sum(f(1:2,j,k,i)*c       exp(-sqrt(-1)*2pi*n*j/nx)*exp(-sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, f is the input and g is the outputc g(1:2,m,n,l) = (1/nx*ny)*sum(f(1:2,j,k,i)*c       exp(-sqrt(-1)*2pi*nn*j/nx)*exp(-sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c if isign = 1, two forward fourier transforms are performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(1:2,j,k,i) = sum(f(1:2,n,m,l)*exp(sqrt(-1)*2pi*n*j/nx)*c       exp(sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, g is the input and f is the outputc f(1:2,j,k,i) = sum(g(1:2,m,n,l)*exp(sqrt(-1)*2pi*nn*j/nx)*c       exp(sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c bs, br = scratch arraysc kstrt = starting data block numberc nxvh/nyv = second dimension of f/gc kypd = third dimension of fc kxp/kyp = number of data values per block in x/yc jblok/kblok = number of data blocks in x/yc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxhyd = maximum of (nx/2,ny)c nxyhd = one half of maximum of (nx,ny)c the real data is stored in a complex array of length nx/2, nyc with the odd/even x points stored in the real/imaginary parts.c in complex notation, fourier coefficients are stored as follows:c if ntpose = 0,c f(j,k,i) = mode j-1,kk-1, where kk = k + kyp*(i - 1)c 1 <= j <= nx/2 and 1 <= kk <= ny, except forc f(1,k,i) = mode nx/2,kk-1, where ny/2+2 <= kk <= ny, andc imaginary part of f(1,1,1) = real part of mode nx/2,0 andc imaginary part of f(1,1,(ny/2)/kyp+1) = real part of mode nx/2,ny/2c if ntpose = 1,c g(k,j,i) = mode jj-1,k-1, where jj = j + kxp*(i - 1)c 1 <= jj <= nx/2 and 1 <= k <= ny, except forc g(k,1,1) = mode nx/2,k-1, where ny/2+2 <= k <= ny, andc imaginary part of g(1,1,1) = real part of mode nx/2,0 andc imaginary part of g(ny/2+1,1,1) = real part of mode nx/2,ny/2c written by viktor k. decyk, uclac parallel version      implicit none      integer isign, ntpose, indx, indy, kstrt, nxvh, nyv, kxp, kyp      integer kypd, jblok, kblok, nxhyd, nxyhd, mixup      complex f, g, bs, br, sct      dimension f(2,nxvh,kypd,kblok), g(2,nyv,kxp,jblok)      dimension bs(2,kxp,kyp,kblok), br(2,kxp,kyp,jblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, nxh, nxhh, nxh2, ny, nyh, ny2, nxy      integer nxhy, ks, j, k, lb, ll, jb, it, nxyh, nrx, nry, l, i, m      integer ns, ns2, km, kmr, k1, k2, j1, j2, jj      real dnxy, arg, ani, at1      complex s, t, t1, t2      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nxh2 = nxh + 2      ny = 2**indy      nyh = ny/2      ny2 = ny + 2      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      if (isign) 50, 10, 360c prepare fft tablesc bit-reverse index table: mixup(j) = 1 + reversed bits of (j - 1)   10 do 30 j = 1, nxhy      lb = j - 1      ll = 0      do 20 k = 1, indx1y      jb = lb/2      it = lb - 2*jb      lb = jb      ll = 2*ll + it   20 continue      mixup(j) = ll + 1   30 continuec sine/cosine table for the angles 2*n*pi/nxy      nxyh = nxy/2      dnxy = 6.28318530717959/float(nxy)      do 40 j = 1, nxyh      arg = dnxy*float(j - 1)      sct(j) = cmplx(cos(arg),-sin(arg))   40 continue      returnc inverse fourier transform   50 if (kstrt.gt.ny) go to 230c swap complex components      do 80 l = 1, kblok      do 70 k = 1, kyp      do 60 j = 1, nxh      at1 = aimag(f(1,j,k,l))      f(1,j,k,l) = cmplx(real(f(1,j,k,l)),real(f(2,j,k,l)))      f(2,j,k,l) = cmplx(at1,aimag(f(2,j,k,l)))   60 continue   70 continue   80 continue      nrx = nxhy/nxh      do 110 l = 1, kblokc bit-reverse array elements in x      do 100 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 100      do 90 k = 1, kyp      t1 = f(1,j1,k,l)      t2 = f(2,j1,k,l)      f(1,j1,k,l) = f(1,j,k,l)      f(2,j1,k,l) = f(2,j,k,l)      f(1,j,k,l) = t1      f(2,j,k,l) = t2   90 continue  100 continue  110 continuec first transform in x      nrx = nxy/nxh      do 160 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 150 l = 1, kblok      do 140 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 130 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 120 i = 1, kyp      t1 = s*f(1,j2,i,l)      t2 = s*f(2,j2,i,l)      f(1,j2,i,l) = f(1,j1,i,l) - t1      f(2,j2,i,l) = f(2,j1,i,l) - t2      f(1,j1,i,l) = f(1,j1,i,l) + t1      f(2,j1,i,l) = f(2,j1,i,l) + t2  120 continue  130 continue  140 continue  150 continue  160 continuec unscramble coefficients and normalize      kmr = nxy/nx      ani = 1./float(2*nx*ny)      do 220 l = 1, kblok      do 190 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),-real(sct(1+kmr*(j-1))))      do 180 k = 1, kyp      do 170 jj = 1, 2      t = conjg(f(jj,nxh2-j,k,l))      s = f(jj,j,k,l) + t      t = (f(jj,j,k,l) - t)*t1      f(jj,j,k,l) = ani*(s + t)      f(jj,nxh2-j,k,l) = ani*conjg(s - t)  170 continue  180 continue  190 continue      do 210 k = 1, kyp      do 200 jj = 1, 2      f(jj,nxhh+1,k,l) = 2.*ani*conjg(f(jj,nxhh+1,k,l))      f(jj,1,k,l) = 2.*ani*cmplx(real(f(jj,1,k,l)) + aimag(f(jj,1,k,l)),     1real(f(jj,1,k,l)) - aimag(f(jj,1,k,l)))  200 continue  210 continue  220 continuec transpose f array to g  230 call P2TPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kypd,jblo     1k,kblok)      if (kstrt.gt.nxh) go to 350      nry = nxhy/ny      do 260 l = 1, jblokc bit-reverse array elements in y      do 250 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 250      do 240 j = 1, kxp      t1 = g(1,k1,j,l)      t2 = g(2,k1,j,l)      g(1,k1,j,l) = g(1,k,j,l)      g(2,k1,j,l) = g(2,k,j,l)      g(1,k,j,l) = t1      g(2,k,j,l) = t2  240 continue  250 continue  260 continuec then transform in y      nry = nxy/ny      do 310 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 300 l = 1, jblok      do 290 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 280 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 270 i = 1, kxp      t1 = s*g(1,j2,i,l)      t2 = s*g(2,j2,i,l)      g(1,j2,i,l) = g(1,j1,i,l) - t1      g(2,j2,i,l) = g(2,j1,i,l) - t2      g(1,j1,i,l) = g(1,j1,i,l) + t1      g(2,j1,i,l) = g(2,j1,i,l) + t2  270 continue  280 continue  290 continue  300 continue  310 continuec unscramble modes kx = 0, nx/2      do 340 l = 1, jblok      if ((l+ks).gt.0) go to 340      do 330 k = 2, nyh      do 320 jj = 1, 2      s = g(jj,ny2-k,1,l)      g(jj,ny2-k,1,l) = .5*cmplx(aimag(g(jj,k,1,l) + s),real(g(jj,k,1,l)     1- s))      g(jj,k,1,l) = .5*cmplx(real(g(jj,k,1,l) + s),aimag(g(jj,k,1,l) - s     1))  320 continue  330 continue  340 continuec transpose g array to f  350 if (ntpose.eq.0) call P2TPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,kyp,     1kxp,kypd,kxp,kblok,jblok)      returnc forward fourier transformc transpose f array to g  360 if (ntpose.eq.0) call P2TPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,kxp,     1kyp,kxp,kypd,jblok,kblok)      if (kstrt.gt.nxh) go to 480      nry = nxhy/ny      do 420 l = 1, jblokc scramble modes kx = 0, nx/2      if ((l+ks).gt.0) go to 390      do 380 k = 2, nyh      do 370 jj = 1, 2      s = cmplx(aimag(g(jj,ny2-k,1,l)),real(g(jj,ny2-k,1,l)))      g(jj,ny2-k,1,l) = conjg(g(jj,k,1,l) - s)      g(jj,k,1,l) = g(jj,k,1,l) + s  370 continue  380 continuec bit-reverse array elements in y  390 do 410 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 410      do 400 j = 1, kxp      t1 = g(1,k1,j,l)      t2 = g(2,k1,j,l)      g(1,k1,j,l) = g(1,k,j,l)      g(2,k1,j,l) = g(2,k,j,l)      g(1,k,j,l) = t1      g(2,k,j,l) = t2  400 continue  410 continue  420 continuec first transform in y      nry = nxy/ny      do 470 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 460 l = 1, jblok      do 450 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 440 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 430 i = 1, kxp      t1 = s*g(1,j2,i,l)      t2 = s*g(2,j2,i,l)      g(1,j2,i,l) = g(1,j1,i,l) - t1      g(2,j2,i,l) = g(2,j1,i,l) - t2      g(1,j1,i,l) = g(1,j1,i,l) + t1      g(2,j1,i,l) = g(2,j1,i,l) + t2  430 continue  440 continue  450 continue  460 continue  470 continuec transpose g array to f  480 call P2TPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kxp,kblo     1k,jblok)      if (kstrt.gt.ny) return      nrx = nxhy/nxh      kmr = nxy/nx      do 560 l = 1, kblokc scramble coefficients      do 510 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),real(sct(1+kmr*(j-1))))      do 500 k = 1, kyp      do 490 jj = 1, 2      t = conjg(f(jj,nxh2-j,k,l))      s = f(jj,j,k,l) + t      t = (f(jj,j,k,l) - t)*t1      f(jj,j,k,l) = s + t      f(jj,nxh2-j,k,l) = conjg(s - t)  490 continue  500 continue  510 continue      do 530 k = 1, kyp      do 520 jj = 1, 2      f(jj,nxhh+1,k,l) = 2.*conjg(f(jj,nxhh+1,k,l))      f(jj,1,k,l) = cmplx(real(f(jj,1,k,l)) + aimag(f(jj,1,k,l)),real(f(     1jj,1,k,l)) - aimag(f(jj,1,k,l)))  520 continue  530 continuec bit-reverse array elements in x      do 550 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 550      do 540 k = 1, kyp      t1 = f(1,j1,k,l)      t2 = f(2,j1,k,l)      f(1,j1,k,l) = f(1,j,k,l)      f(2,j1,k,l) = f(2,j,k,l)      f(1,j,k,l) = t1      f(2,j,k,l) = t2  540 continue  550 continue  560 continuec then transform in x      nrx = nxy/nxh      do 610 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 600 l = 1, kblok      do 590 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 580 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 570 i = 1, kyp      t1 = s*f(1,j2,i,l)      t2 = s*f(2,j2,i,l)      f(1,j2,i,l) = f(1,j1,i,l) - t1      f(2,j2,i,l) = f(2,j1,i,l) - t2      f(1,j1,i,l) = f(1,j1,i,l) + t1      f(2,j1,i,l) = f(2,j1,i,l) + t2  570 continue  580 continue  590 continue  600 continue  610 continuec swap complex components      do 640 l = 1, kblok      do 630 k = 1, kyp      do 620 j = 1, nxh      at1 = aimag(f(1,j,k,l))      f(1,j,k,l) = cmplx(real(f(1,j,k,l)),real(f(2,j,k,l)))      f(2,j,k,l) = cmplx(at1,aimag(f(2,j,k,l)))  620 continue  630 continue  640 continue      return      endc-----------------------------------------------------------------------      subroutine PFFT2R3(f,g,bs,br,isign,ntpose,mixup,sct,indx,indy,kstr     1t,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)c this subroutine performs 3 two dimensional complex to real fastc fourier transforms, using complex arithmetic,c for data which is distributed in blocksc for isign = 0, input: isign, indx, indy, kstrt, nxhyd, nxyhdc output: mixup, sctc for isign = (-1,1), input: all, output: f, g, bs, brc for isign = -1, approximate flop count: N*(5*log2(N) + 10)/nvpc for isign = 1,  approximate flop count: N*(5*log2(N) + 8)/nvpc where N = (nx/2)*ny, and nvp = number of procsc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc ntpose = (0,1) = (no,yes) input, output data are transposedc if isign = 0, the fft tables are preparedc if isign = -1, three inverse fourier transforms are performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(1:3,n,m,l) = (1/nx*ny)*sum(f(1:3,j,k,i)*c       exp(-sqrt(-1)*2pi*n*j/nx)*exp(-sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, f is the input and g is the outputc g(1:3,m,n,l) = (1/nx*ny)*sum(f(1:3,j,k,i)*c       exp(-sqrt(-1)*2pi*nn*j/nx)*exp(-sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c if isign = 1, three forward fourier transforms are performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(1:3,j,k,i) = sum(f(1:3,n,m,l)*exp(sqrt(-1)*2pi*n*j/nx)*c       exp(sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, g is the input and f is the outputc f(1:3,j,k,i) = sum(g(1:3,m,n,l)*exp(sqrt(-1)*2pi*nn*j/nx)*c       exp(sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c bs, br = scratch arraysc kstrt = starting data block numberc nxvh/nyv = second dimension of f/gc kypd = third dimension of fc kxp/kyp = number of data values per block in x/yc jblok/kblok = number of data blocks in x/yc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxhyd = maximum of (nx/2,ny)c nxyhd = one half of maximum of (nx,ny)c the real data is stored in a complex array of length nx/2, nyc with the odd/even x points stored in the real/imaginary parts.c in complex notation, fourier coefficients are stored as follows:c if ntpose = 0,c f(j,k,i) = mode j-1,kk-1, where kk = k + kyp*(i - 1)c 1 <= j <= nx/2 and 1 <= kk <= ny, except forc f(1,k,i) = mode nx/2,kk-1, where ny/2+2 <= kk <= ny, andc imaginary part of f(1,1,1) = real part of mode nx/2,0 andc imaginary part of f(1,1,(ny/2)/kyp+1) = real part of mode nx/2,ny/2c if ntpose = 1,c g(k,j,i) = mode jj-1,k-1, where jj = j + kxp*(i - 1)c 1 <= jj <= nx/2 and 1 <= k <= ny, except forc g(k,1,1) = mode nx/2,k-1, where ny/2+2 <= k <= ny, andc imaginary part of g(1,1,1) = real part of mode nx/2,0 andc imaginary part of g(ny/2+1,1,1) = real part of mode nx/2,ny/2c written by viktor k. decyk, uclac parallel version      implicit none      integer isign, ntpose, indx, indy, kstrt, nxvh, nyv, kxp, kyp      integer kypd, jblok, kblok, nxhyd, nxyhd, mixup      complex f, g, bs, br, sct      dimension f(3,nxvh,kypd,kblok), g(3,nyv,kxp,jblok)      dimension bs(3,kxp,kyp,kblok), br(3,kxp,kyp,jblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, nxh, nxhh, nxh2, ny, nyh, ny2, nxy      integer nxhy, ks, j, k, lb, ll, jb, it, nxyh, nrx, nry, l, i, m      integer ns, ns2, km, kmr, k1, k2, j1, j2, jj      real dnxy, arg, ani, at1, at2      complex s, t, t1, t2, t3      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nxh2 = nxh + 2      ny = 2**indy      nyh = ny/2      ny2 = ny + 2      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      if (isign) 50, 10, 360c prepare fft tablesc bit-reverse index table: mixup(j) = 1 + reversed bits of (j - 1)   10 do 30 j = 1, nxhy      lb = j - 1      ll = 0      do 20 k = 1, indx1y      jb = lb/2      it = lb - 2*jb      lb = jb      ll = 2*ll + it   20 continue      mixup(j) = ll + 1   30 continuec sine/cosine table for the angles 2*n*pi/nxy      nxyh = nxy/2      dnxy = 6.28318530717959/float(nxy)      do 40 j = 1, nxyh      arg = dnxy*float(j - 1)      sct(j) = cmplx(cos(arg),-sin(arg))   40 continue      returnc inverse fourier transform   50 if (kstrt.gt.ny) go to 230c swap complex components      do 80 l = 1, kblok      do 70 i = 1, kyp      do 60 j = 1, nxh      at1 = real(f(3,j,i,l))      f(3,j,i,l) = cmplx(real(f(2,j,i,l)),aimag(f(3,j,i,l)))      at2 = aimag(f(2,j,i,l))      f(2,j,i,l) = cmplx(aimag(f(1,j,i,l)),at1)      f(1,j,i,l) = cmplx(real(f(1,j,i,l)),at2)   60 continue   70 continue   80 continue      nrx = nxhy/nxh      do 110 l = 1, kblokc bit-reverse array elements in x      do 100 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 100      do 90 k = 1, kyp      t1 = f(1,j1,k,l)      t2 = f(2,j1,k,l)      t3 = f(3,j1,k,l)      f(1,j1,k,l) = f(1,j,k,l)      f(2,j1,k,l) = f(2,j,k,l)      f(3,j1,k,l) = f(3,j,k,l)      f(1,j,k,l) = t1      f(2,j,k,l) = t2      f(3,j,k,l) = t3   90 continue  100 continue  110 continuec first transform in x      nrx = nxy/nxh      do 160 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 150 l = 1, kblok      do 140 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 130 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 120 i = 1, kyp      t1 = s*f(1,j2,i,l)      t2 = s*f(2,j2,i,l)      t3 = s*f(3,j2,i,l)      f(1,j2,i,l) = f(1,j1,i,l) - t1      f(2,j2,i,l) = f(2,j1,i,l) - t2      f(3,j2,i,l) = f(3,j1,i,l) - t3      f(1,j1,i,l) = f(1,j1,i,l) + t1      f(2,j1,i,l) = f(2,j1,i,l) + t2      f(3,j1,i,l) = f(3,j1,i,l) + t3  120 continue  130 continue  140 continue  150 continue  160 continuec unscramble coefficients and normalize      kmr = nxy/nx      ani = 1./float(2*nx*ny)      do 220 l = 1, kblok      do 190 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),-real(sct(1+kmr*(j-1))))      do 180 k = 1, kyp      do 170 jj = 1, 3      t = conjg(f(jj,nxh2-j,k,l))      s = f(jj,j,k,l) + t      t = (f(jj,j,k,l) - t)*t1      f(jj,j,k,l) = ani*(s + t)      f(jj,nxh2-j,k,l) = ani*conjg(s - t)  170 continue  180 continue  190 continue      do 210 k = 1, kyp      do 200 jj = 1, 3      f(jj,nxhh+1,k,l) = 2.*ani*conjg(f(jj,nxhh+1,k,l))      f(jj,1,k,l) = 2.*ani*cmplx(real(f(jj,1,k,l)) + aimag(f(jj,1,k,l)),     1real(f(jj,1,k,l)) - aimag(f(jj,1,k,l)))  200 continue  210 continue  220 continuec transpose f array to g  230 call P3TPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kypd,jblo     1k,kblok)      if (kstrt.gt.nxh) go to 350      nry = nxhy/ny      do 260 l = 1, jblokc bit-reverse array elements in y      do 250 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 250      do 240 j = 1, kxp      t1 = g(1,k1,j,l)      t2 = g(2,k1,j,l)      t3 = g(3,k1,j,l)      g(1,k1,j,l) = g(1,k,j,l)      g(2,k1,j,l) = g(2,k,j,l)      g(3,k1,j,l) = g(3,k,j,l)      g(1,k,j,l) = t1      g(2,k,j,l) = t2      g(3,k,j,l) = t3  240 continue  250 continue  260 continuec then transform in y      nry = nxy/ny      do 310 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 300 l = 1, jblok      do 290 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 280 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 270 i = 1, kxp      t1 = s*g(1,j2,i,l)      t2 = s*g(2,j2,i,l)      t3 = s*g(3,j2,i,l)      g(1,j2,i,l) = g(1,j1,i,l) - t1      g(2,j2,i,l) = g(2,j1,i,l) - t2      g(3,j2,i,l) = g(3,j1,i,l) - t3      g(1,j1,i,l) = g(1,j1,i,l) + t1      g(2,j1,i,l) = g(2,j1,i,l) + t2      g(3,j1,i,l) = g(3,j1,i,l) + t3  270 continue  280 continue  290 continue  300 continue  310 continuec unscramble modes kx = 0, nx/2      do 340 l = 1, jblok      if ((l+ks).gt.0) go to 340      do 330 k = 2, nyh      do 320 jj = 1, 3      s = g(jj,ny2-k,1,l)      g(jj,ny2-k,1,l) = .5*cmplx(aimag(g(jj,k,1,l) + s),real(g(jj,k,1,l)     1- s))      g(jj,k,1,l) = .5*cmplx(real(g(jj,k,1,l) + s),aimag(g(jj,k,1,l) - s     1))  320 continue  330 continue  340 continuec transpose g array to f  350 if (ntpose.eq.0) call P3TPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,kyp,     1kxp,kypd,kxp,kblok,jblok)      returnc forward fourier transformc transpose f array to g  360 if (ntpose.eq.0) call P3TPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,kxp,     1kyp,kxp,kypd,jblok,kblok)      if (kstrt.gt.nxh) go to 480      nry = nxhy/ny      do 420 l = 1, jblokc scramble modes kx = 0, nx/2      if ((l+ks).gt.0) go to 390      do 380 k = 2, nyh      do 370 jj = 1, 3      s = cmplx(aimag(g(jj,ny2-k,1,l)),real(g(jj,ny2-k,1,l)))      g(jj,ny2-k,1,l) = conjg(g(jj,k,1,l) - s)      g(jj,k,1,l) = g(jj,k,1,l) + s  370 continue  380 continuec bit-reverse array elements in y  390 do 410 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 410      do 400 j = 1, kxp      t1 = g(1,k1,j,l)      t2 = g(2,k1,j,l)      t3 = g(3,k1,j,l)      g(1,k1,j,l) = g(1,k,j,l)      g(2,k1,j,l) = g(2,k,j,l)      g(3,k1,j,l) = g(3,k,j,l)      g(1,k,j,l) = t1      g(2,k,j,l) = t2      g(3,k,j,l) = t3  400 continue  410 continue  420 continuec first transform in y      nry = nxy/ny      do 470 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 460 l = 1, jblok      do 450 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 440 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 430 i = 1, kxp      t1 = s*g(1,j2,i,l)      t2 = s*g(2,j2,i,l)      t3 = s*g(3,j2,i,l)      g(1,j2,i,l) = g(1,j1,i,l) - t1      g(2,j2,i,l) = g(2,j1,i,l) - t2      g(3,j2,i,l) = g(3,j1,i,l) - t3      g(1,j1,i,l) = g(1,j1,i,l) + t1      g(2,j1,i,l) = g(2,j1,i,l) + t2      g(3,j1,i,l) = g(3,j1,i,l) + t3  430 continue  440 continue  450 continue  460 continue  470 continuec transpose g array to f  480 call P3TPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kxp,kblo     1k,jblok)      if (kstrt.gt.ny) return      nrx = nxhy/nxh      kmr = nxy/nx      do 560 l = 1, kblokc scramble coefficients      do 510 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),real(sct(1+kmr*(j-1))))      do 500 k = 1, kyp      do 490 jj = 1, 3      t = conjg(f(jj,nxh2-j,k,l))      s = f(jj,j,k,l) + t      t = (f(jj,j,k,l) - t)*t1      f(jj,j,k,l) = s + t      f(jj,nxh2-j,k,l) = conjg(s - t)  490 continue  500 continue  510 continue      do 530 k = 1, kyp      do 520 jj = 1, 3      f(jj,nxhh+1,k,l) = 2.*conjg(f(jj,nxhh+1,k,l))      f(jj,1,k,l) = cmplx(real(f(jj,1,k,l)) + aimag(f(jj,1,k,l)),real(f(     1jj,1,k,l)) - aimag(f(jj,1,k,l)))  520 continue  530 continuec bit-reverse array elements in x      do 550 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 550      do 540 k = 1, kyp      t1 = f(1,j1,k,l)      t2 = f(2,j1,k,l)      t3 = f(3,j1,k,l)      f(1,j1,k,l) = f(1,j,k,l)      f(2,j1,k,l) = f(2,j,k,l)      f(3,j1,k,l) = f(3,j,k,l)      f(1,j,k,l) = t1      f(2,j,k,l) = t2      f(3,j,k,l) = t3  540 continue  550 continue  560 continuec then transform in x      nrx = nxy/nxh      do 610 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 600 l = 1, kblok      do 590 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 580 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 570 i = 1, kyp      t1 = s*f(1,j2,i,l)      t2 = s*f(2,j2,i,l)      t3 = s*f(3,j2,i,l)      f(1,j2,i,l) = f(1,j1,i,l) - t1      f(2,j2,i,l) = f(2,j1,i,l) - t2      f(3,j2,i,l) = f(3,j1,i,l) - t3      f(1,j1,i,l) = f(1,j1,i,l) + t1      f(2,j1,i,l) = f(2,j1,i,l) + t2      f(3,j1,i,l) = f(3,j1,i,l) + t3  570 continue  580 continue  590 continue  600 continue  610 continuec swap complex components      do 640 l = 1, kblok      do 630 i = 1, kyp      do 620 j = 1, nxh      at1 = real(f(3,j,i,l))      f(3,j,i,l) = cmplx(aimag(f(2,j,i,l)),aimag(f(3,j,i,l)))      at2 = real(f(2,j,i,l))      f(2,j,i,l) = cmplx(at1,aimag(f(1,j,i,l)))      f(1,j,i,l) = cmplx(real(f(1,j,i,l)),at2)  620 continue  630 continue  640 continue      return      endc-----------------------------------------------------------------------      subroutine PFFT2RX(f,g,isign,ntpose,mixup,sct,indx,indy,kstrt,nxvh     1,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)c this subroutine performs a two dimensional real to complex fastc fourier transform and its inverse, using complex arithmetic,c for data which is distributed in blocksc for isign = 0, input: isign, indx, indy, kstrt, nxhyd, nxyhdc output: mixup, sctc for isign = (-1,1), input: all, output: f, gc for isign = -1, approximate flop count: N*(5*log2(N) + 10)/nvpc for isign = 1,  approximate flop count: N*(5*log2(N) + 8)/nvpc where N = (nx/2)*ny, and nvp = number of procsc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc ntpose = (0,1) = (no,yes) input, output data are transposedc if isign = 0, the fft tables are preparedc if isign = -1, an inverse fourier transform is performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(n,m,l) = (1/nx*ny)*sum(f(j,k,i)*c       exp(-sqrt(-1)*2pi*n*j/nx)*exp(-sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, f is the input and g is the outputc g(m,n,l) = (1/nx*ny)*sum(f(j,k,i)*c       exp(-sqrt(-1)*2pi*nn*j/nx)*exp(-sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c if isign = 1, a forward fourier transform is performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(j,k,i) = sum(f(n,m,l)*exp(sqrt(-1)*2pi*n*j/nx)*c       exp(sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, g is the input and f is the outputc f(j,k,i) = sum(g(m,n,l)*exp(sqrt(-1)*2pi*nn*j/nx)*c       exp(sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c kstrt = starting data block numberc nxvh/nyv = first dimension of f/gc kypd = second dimension of fc kxp/kyp = number of data values per block in x/yc jblok/kblok = number of data blocks in x/yc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxhyd = maximum of (nx/2,ny)c nxyhd = one half of maximum of (nx,ny)c the real data is stored in a complex array of length nx/2, nyc with the odd/even x points stored in the real/imaginary parts.c in complex notation, fourier coefficients are stored as follows:c if ntpose = 0,c f(j,k,i) = mode j-1,kk-1, where kk = k + kyp*(i - 1)c 1 <= j <= nx/2 and 1 <= kk <= ny, except forc f(1,k,i) = mode nx/2,kk-1, where ny/2+2 <= kk <= ny, andc imaginary part of f(1,1,1) = real part of mode nx/2,0 andc imaginary part of f(1,1,(ny/2)/kyp+1) = real part of mode nx/2,ny/2c if ntpose = 1,c g(k,j,i) = mode jj-1,k-1, where jj = j + kxp*(i - 1)c 1 <= jj <= nx/2 and 1 <= k <= ny, except forc g(k,1,1) = mode nx/2,k-1, where ny/2+2 <= k <= ny, andc imaginary part of g(1,1,1) = real part of mode nx/2,0 andc imaginary part of g(ny/2+1,1,1) = real part of mode nx/2,ny/2c written by viktor k. decyk, uclac parallel, RISC optimized version      implicit none      integer isign, ntpose, mixup, indx, indy, kstrt, nxvh      integer nyv, kxp, kyp, kypd, jblok, kblok, nxhyd, nxyhd      complex f, g, sct      dimension f(nxvh,kypd,kblok), g(nyv,kxp,jblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, nxh, nxhh, nxh2, ny, nyh, ny2, nxy      integer nxhy, ks, j, k, lb, ll, jb, it, nxyh, nrx, nry, l, i, m      integer ns, ns2, km, kmr, k1, k2, j1, j2      real dnxy, arg, ani      complex s, t, t1      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nxh2 = nxh + 2      ny = 2**indy      nyh = ny/2      ny2 = ny + 2      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      if (isign) 50, 10, 300c prepare fft tablesc bit-reverse index table: mixup(j) = 1 + reversed bits of (j - 1)   10 do 30 j = 1, nxhy      lb = j - 1      ll = 0      do 20 k = 1, indx1y      jb = lb/2      it = lb - 2*jb      lb = jb      ll = 2*ll + it   20 continue      mixup(j) = ll + 1   30 continuec sine/cosine table for the angles 2*n*pi/nxy      nxyh = nxy/2      dnxy = 6.28318530717959/float(nxy)      do 40 j = 1, nxyh      arg = dnxy*float(j - 1)      sct(j) = cmplx(cos(arg),-sin(arg))   40 continue      returnc inverse fourier transform   50 if (kstrt.gt.ny) go to 180      nrx = nxhy/nxh      do 80 l = 1, kblokc bit-reverse array elements in x      do 70 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 70      do 60 k = 1, kyp      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = t   60 continue   70 continue   80 continuec first transform in x      nrx = nxy/nxh      do 130 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 120 l = 1, kblok      do 110 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 100 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 90 i = 1, kyp      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t   90 continue  100 continue  110 continue  120 continue  130 continuec unscramble coefficients and normalize      kmr = nxy/nx      ani = 1./float(2*nx*ny)      do 170 l = 1, kblok      do 150 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),-real(sct(1+kmr*(j-1))))      do 140 k = 1, kyp      t = conjg(f(nxh2-j,k,l))      s = f(j,k,l) + t      t = (f(j,k,l) - t)*t1      f(j,k,l) = ani*(s + t)      f(nxh2-j,k,l) = ani*conjg(s - t)  140 continue  150 continue      do 160 k = 1, kyp      f(nxhh+1,k,l) = 2.*ani*conjg(f(nxhh+1,k,l))      f(1,k,l) = 2.*ani*cmplx(real(f(1,k,l)) + aimag(f(1,k,l)),real(f(1,     1k,l)) - aimag(f(1,k,l)))  160 continue  170 continuec transpose f array to g  180 call PTPOSEX(f,g,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kypd,jblok,kblo     1k)      if (kstrt.gt.nxh) go to 290      nry = nxhy/ny      do 210 l = 1, jblokc bit-reverse array elements in y      do 200 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 200      do 190 j = 1, kxp      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = t  190 continue  200 continue  210 continuec then transform in y      nry = nxy/ny      do 260 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 250 l = 1, jblok      do 240 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 230 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 220 i = 1, kxp      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t  220 continue  230 continue  240 continue  250 continue  260 continuec unscramble modes kx = 0, nx/2      do 280 l = 1, jblok      if ((l+ks).gt.0) go to 280      do 270 k = 2, nyh      s = g(ny2-k,1,l)      g(ny2-k,1,l) = .5*cmplx(aimag(g(k,1,l) + s),real(g(k,1,l) - s))      g(k,1,l) = .5*cmplx(real(g(k,1,l) + s),aimag(g(k,1,l) - s))  270 continue  280 continuec transpose g array to f  290 if (ntpose.eq.0) call PTPOSEX(g,f,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,ky     1pd,kxp,kblok,jblok)      returnc forward fourier transformc transpose f array to g  300 if (ntpose.eq.0) call PTPOSEX(f,g,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kx     1p,kypd,jblok,kblok)      if (kstrt.gt.nxh) go to 410      nry = nxhy/ny      do 350 l = 1, jblokc scramble modes kx = 0, nx/2      if ((l+ks).gt.0) go to 320      do 310 k = 2, nyh      s = cmplx(aimag(g(ny2-k,1,l)),real(g(ny2-k,1,l)))      g(ny2-k,1,l) = conjg(g(k,1,l) - s)      g(k,1,l) = g(k,1,l) + s  310 continuec bit-reverse array elements in y  320 do 340 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 340      do 330 j = 1, kxp      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = t  330 continue  340 continue  350 continuec first transform in y      nry = nxy/ny      do 400 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 390 l = 1, jblok      do 380 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 370 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 360 i = 1, kxp      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t  360 continue  370 continue  380 continue  390 continue  400 continuec transpose g array to f  410 call PTPOSEX(g,f,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kxp,kblok,jblo     1k)      if (kstrt.gt.ny) return      nrx = nxhy/nxh      kmr = nxy/nx      do 470 l = 1, kblokc scramble coefficients      do 430 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),real(sct(1+kmr*(j-1))))      do 420 k = 1, kyp      t = conjg(f(nxh2-j,k,l))      s = f(j,k,l) + t      t = (f(j,k,l) - t)*t1      f(j,k,l) = s + t      f(nxh2-j,k,l) = conjg(s - t)  420 continue  430 continue      do 440 k = 1, kyp      f(nxhh+1,k,l) = 2.*conjg(f(nxhh+1,k,l))      f(1,k,l) = cmplx(real(f(1,k,l)) + aimag(f(1,k,l)),real(f(1,k,l)) -     1 aimag(f(1,k,l)))  440 continuec bit-reverse array elements in x      do 460 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 460      do 450 k = 1, kyp      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = t  450 continue  460 continue  470 continuec then transform in x      nrx = nxy/nxh      do 520 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 510 l = 1, kblok      do 500 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 490 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 480 i = 1, kyp      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t  480 continue  490 continue  500 continue  510 continue  520 continue      return      endc-----------------------------------------------------------------------      subroutine PFFT2RX2(f,g,isign,ntpose,mixup,sct,indx,indy,kstrt,nxv     1h,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)c this subroutine performs 2 two dimensional complex to real fastc fourier transforms, using complex arithmetic,c for data which is distributed in blocksc for isign = 0, input: isign, indx, indy, kstrt, nxhyd, nxyhdc output: mixup, sctc for isign = (-1,1), input: all, output: f, gc for isign = -1, approximate flop count: N*(5*log2(N) + 10)/nvpc for isign = 1,  approximate flop count: N*(5*log2(N) + 8)/nvpc where N = (nx/2)*ny, and nvp = number of procsc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc ntpose = (0,1) = (no,yes) input, output data are transposedc if isign = 0, the fft tables are preparedc if isign = -1, two inverse fourier transforms are performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(1:2,n,m,l) = (1/nx*ny)*sum(f(1:2,j,k,i)*c       exp(-sqrt(-1)*2pi*n*j/nx)*exp(-sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, f is the input and g is the outputc g(1:2,m,n,l) = (1/nx*ny)*sum(f(1:2,j,k,i)*c       exp(-sqrt(-1)*2pi*nn*j/nx)*exp(-sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c if isign = 1, two forward fourier transforms are performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(1:2,j,k,i) = sum(f(1:2,n,m,l)*exp(sqrt(-1)*2pi*n*j/nx)*c       exp(sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, g is the input and f is the outputc f(1:2,j,k,i) = sum(g(1:2,m,n,l)*exp(sqrt(-1)*2pi*nn*j/nx)*c       exp(sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c kstrt = starting data block numberc nxvh/nyv = second dimension of f/gc kypd = third dimension of fc kxp/kyp = number of data values per block in x/yc jblok/kblok = number of data blocks in x/yc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxhyd = maximum of (nx/2,ny)c nxyhd = one half of maximum of (nx,ny)c the real data is stored in a complex array of length nx/2, nyc with the odd/even x points stored in the real/imaginary parts.c in complex notation, fourier coefficients are stored as follows:c if ntpose = 0,c f(j,k,i) = mode j-1,kk-1, where kk = k + kyp*(i - 1)c 1 <= j <= nx/2 and 1 <= kk <= ny, except forc f(1,k,i) = mode nx/2,kk-1, where ny/2+2 <= kk <= ny, andc imaginary part of f(1,1,1) = real part of mode nx/2,0 andc imaginary part of f(1,1,(ny/2)/kyp+1) = real part of mode nx/2,ny/2c if ntpose = 1,c g(k,j,i) = mode jj-1,k-1, where jj = j + kxp*(i - 1)c 1 <= jj <= nx/2 and 1 <= k <= ny, except forc g(k,1,1) = mode nx/2,k-1, where ny/2+2 <= k <= ny, andc imaginary part of g(1,1,1) = real part of mode nx/2,0 andc imaginary part of g(ny/2+1,1,1) = real part of mode nx/2,ny/2c written by viktor k. decyk, uclac parallel, optimized version      implicit none      integer isign, ntpose, mixup, indx, indy, kstrt, nxvh      integer nyv, kxp, kyp, kypd, jblok, kblok, nxhyd, nxyhd      complex f, g, sct      dimension f(2,nxvh,kypd,kblok), g(2,nyv,kxp,jblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, nxh, nxhh, nxh2, ny, nyh, ny2, nxy      integer nxhy, ks, j, k, lb, ll, jb, it, nxyh, nrx, nry, l, i, m      integer ns, ns2, km, kmr, k1, k2, j1, j2, jj      real dnxy, arg, ani, at1      complex s, t, t1, t2      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nxh2 = nxh + 2      ny = 2**indy      nyh = ny/2      ny2 = ny + 2      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      if (isign) 50, 10, 360c prepare fft tablesc bit-reverse index table: mixup(j) = 1 + reversed bits of (j - 1)   10 do 30 j = 1, nxhy      lb = j - 1      ll = 0      do 20 k = 1, indx1y      jb = lb/2      it = lb - 2*jb      lb = jb      ll = 2*ll + it   20 continue      mixup(j) = ll + 1   30 continuec sine/cosine table for the angles 2*n*pi/nxy      nxyh = nxy/2      dnxy = 6.28318530717959/float(nxy)      do 40 j = 1, nxyh      arg = dnxy*float(j - 1)      sct(j) = cmplx(cos(arg),-sin(arg))   40 continue      returnc inverse fourier transform   50 if (kstrt.gt.ny) go to 230c swap complex components      do 80 l = 1, kblok      do 70 k = 1, kyp      do 60 j = 1, nxh      at1 = aimag(f(1,j,k,l))      f(1,j,k,l) = cmplx(real(f(1,j,k,l)),real(f(2,j,k,l)))      f(2,j,k,l) = cmplx(at1,aimag(f(2,j,k,l)))   60 continue   70 continue   80 continue      nrx = nxhy/nxh      do 110 l = 1, kblokc bit-reverse array elements in x      do 100 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 100      do 90 k = 1, kyp      t1 = f(1,j1,k,l)      t2 = f(2,j1,k,l)      f(1,j1,k,l) = f(1,j,k,l)      f(2,j1,k,l) = f(2,j,k,l)      f(1,j,k,l) = t1      f(2,j,k,l) = t2   90 continue  100 continue  110 continuec first transform in x      nrx = nxy/nxh      do 160 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 150 l = 1, kblok      do 140 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 130 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 120 i = 1, kyp      t1 = s*f(1,j2,i,l)      t2 = s*f(2,j2,i,l)      f(1,j2,i,l) = f(1,j1,i,l) - t1      f(2,j2,i,l) = f(2,j1,i,l) - t2      f(1,j1,i,l) = f(1,j1,i,l) + t1      f(2,j1,i,l) = f(2,j1,i,l) + t2  120 continue  130 continue  140 continue  150 continue  160 continuec unscramble coefficients and normalize      kmr = nxy/nx      ani = 1./float(2*nx*ny)      do 220 l = 1, kblok      do 190 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),-real(sct(1+kmr*(j-1))))      do 180 k = 1, kyp      do 170 jj = 1, 2      t = conjg(f(jj,nxh2-j,k,l))      s = f(jj,j,k,l) + t      t = (f(jj,j,k,l) - t)*t1      f(jj,j,k,l) = ani*(s + t)      f(jj,nxh2-j,k,l) = ani*conjg(s - t)  170 continue  180 continue  190 continue      do 210 k = 1, kyp      do 200 jj = 1, 2      f(jj,nxhh+1,k,l) = 2.*ani*conjg(f(jj,nxhh+1,k,l))      f(jj,1,k,l) = 2.*ani*cmplx(real(f(jj,1,k,l)) + aimag(f(jj,1,k,l)),     1real(f(jj,1,k,l)) - aimag(f(jj,1,k,l)))  200 continue  210 continue  220 continuec transpose f array to g  230 call P2TPOSEX(f,g,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kypd,jblok,kbl     1ok)      if (kstrt.gt.nxh) go to 350      nry = nxhy/ny      do 260 l = 1, jblokc bit-reverse array elements in y      do 250 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 250      do 240 j = 1, kxp      t1 = g(1,k1,j,l)      t2 = g(2,k1,j,l)      g(1,k1,j,l) = g(1,k,j,l)      g(2,k1,j,l) = g(2,k,j,l)      g(1,k,j,l) = t1      g(2,k,j,l) = t2  240 continue  250 continue  260 continuec then transform in y      nry = nxy/ny      do 310 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 300 l = 1, jblok      do 290 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 280 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 270 i = 1, kxp      t1 = s*g(1,j2,i,l)      t2 = s*g(2,j2,i,l)      g(1,j2,i,l) = g(1,j1,i,l) - t1      g(2,j2,i,l) = g(2,j1,i,l) - t2      g(1,j1,i,l) = g(1,j1,i,l) + t1      g(2,j1,i,l) = g(2,j1,i,l) + t2  270 continue  280 continue  290 continue  300 continue  310 continuec unscramble modes kx = 0, nx/2      do 340 l = 1, jblok      if ((l+ks).gt.0) go to 340      do 330 k = 2, nyh      do 320 jj = 1, 2      s = g(jj,ny2-k,1,l)      g(jj,ny2-k,1,l) = .5*cmplx(aimag(g(jj,k,1,l) + s),real(g(jj,k,1,l)     1- s))      g(jj,k,1,l) = .5*cmplx(real(g(jj,k,1,l) + s),aimag(g(jj,k,1,l) - s     1))  320 continue  330 continue  340 continuec transpose g array to f  350 if (ntpose.eq.0) call P2TPOSEX(g,f,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,k     1ypd,kxp,kblok,jblok)      returnc forward fourier transformc transpose f array to g  360 if (ntpose.eq.0) call P2TPOSEX(f,g,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,k     1xp,kypd,jblok,kblok)      if (kstrt.gt.nxh) go to 480      nry = nxhy/ny      do 420 l = 1, jblokc scramble modes kx = 0, nx/2      if ((l+ks).gt.0) go to 390      do 380 k = 2, nyh      do 370 jj = 1, 2      s = cmplx(aimag(g(jj,ny2-k,1,l)),real(g(jj,ny2-k,1,l)))      g(jj,ny2-k,1,l) = conjg(g(jj,k,1,l) - s)      g(jj,k,1,l) = g(jj,k,1,l) + s  370 continue  380 continuec bit-reverse array elements in y  390 do 410 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 410      do 400 j = 1, kxp      t1 = g(1,k1,j,l)      t2 = g(2,k1,j,l)      g(1,k1,j,l) = g(1,k,j,l)      g(2,k1,j,l) = g(2,k,j,l)      g(1,k,j,l) = t1      g(2,k,j,l) = t2  400 continue  410 continue  420 continuec first transform in y      nry = nxy/ny      do 470 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 460 l = 1, jblok      do 450 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 440 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 430 i = 1, kxp      t1 = s*g(1,j2,i,l)      t2 = s*g(2,j2,i,l)      g(1,j2,i,l) = g(1,j1,i,l) - t1      g(2,j2,i,l) = g(2,j1,i,l) - t2      g(1,j1,i,l) = g(1,j1,i,l) + t1      g(2,j1,i,l) = g(2,j1,i,l) + t2  430 continue  440 continue  450 continue  460 continue  470 continuec transpose g array to f  480 call P2TPOSEX(g,f,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kxp,kblok,jbl     1ok)      if (kstrt.gt.ny) return      nrx = nxhy/nxh      kmr = nxy/nx      do 560 l = 1, kblokc scramble coefficients      do 510 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),real(sct(1+kmr*(j-1))))      do 500 k = 1, kyp      do 490 jj = 1, 2      t = conjg(f(jj,nxh2-j,k,l))      s = f(jj,j,k,l) + t      t = (f(jj,j,k,l) - t)*t1      f(jj,j,k,l) = s + t      f(jj,nxh2-j,k,l) = conjg(s - t)  490 continue  500 continue  510 continue      do 530 k = 1, kyp      do 520 jj = 1, 2      f(jj,nxhh+1,k,l) = 2.*conjg(f(jj,nxhh+1,k,l))      f(jj,1,k,l) = cmplx(real(f(jj,1,k,l)) + aimag(f(jj,1,k,l)),real(f(     1jj,1,k,l)) - aimag(f(jj,1,k,l)))  520 continue  530 continuec bit-reverse array elements in x      do 550 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 550      do 540 k = 1, kyp      t1 = f(1,j1,k,l)      t2 = f(2,j1,k,l)      f(1,j1,k,l) = f(1,j,k,l)      f(2,j1,k,l) = f(2,j,k,l)      f(1,j,k,l) = t1      f(2,j,k,l) = t2  540 continue  550 continue  560 continuec then transform in x      nrx = nxy/nxh      do 610 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 600 l = 1, kblok      do 590 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 580 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 570 i = 1, kyp      t1 = s*f(1,j2,i,l)      t2 = s*f(2,j2,i,l)      f(1,j2,i,l) = f(1,j1,i,l) - t1      f(2,j2,i,l) = f(2,j1,i,l) - t2      f(1,j1,i,l) = f(1,j1,i,l) + t1      f(2,j1,i,l) = f(2,j1,i,l) + t2  570 continue  580 continue  590 continue  600 continue  610 continuec swap complex components      do 640 l = 1, kblok      do 630 k = 1, kyp      do 620 j = 1, nxh      at1 = aimag(f(1,j,k,l))      f(1,j,k,l) = cmplx(real(f(1,j,k,l)),real(f(2,j,k,l)))      f(2,j,k,l) = cmplx(at1,aimag(f(2,j,k,l)))  620 continue  630 continue  640 continue      return      endc-----------------------------------------------------------------------      subroutine PFFT2RX3(f,g,isign,ntpose,mixup,sct,indx,indy,kstrt,nxv     1h,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)c this subroutine performs 3 two dimensional complex to real fastc fourier transforms, using complex arithmetic,c for data which is distributed in blocksc for isign = 0, input: isign, indx, indy, kstrt, nxhyd, nxyhdc output: mixup, sctc for isign = (-1,1), input: all, output: f, gc for isign = -1, approximate flop count: N*(5*log2(N) + 10)/nvpc for isign = 1,  approximate flop count: N*(5*log2(N) + 8)/nvpc where N = (nx/2)*ny, and nvp = number of procsc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc ntpose = (0,1) = (no,yes) input, output data are transposedc if isign = 0, the fft tables are preparedc if isign = -1, three inverse fourier transforms are performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(1:3,n,m,l) = (1/nx*ny)*sum(f(1:3,j,k,i)*c       exp(-sqrt(-1)*2pi*n*j/nx)*exp(-sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, f is the input and g is the outputc g(1:3,m,n,l) = (1/nx*ny)*sum(f(1:3,j,k,i)*c       exp(-sqrt(-1)*2pi*nn*j/nx)*exp(-sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c if isign = 1, three forward fourier transforms are performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(1:3,j,k,i) = sum(f(1:3,n,m,l)*exp(sqrt(-1)*2pi*n*j/nx)*c       exp(sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, g is the input and f is the outputc f(1:3,j,k,i) = sum(g(1:3,m,n,l)*exp(sqrt(-1)*2pi*nn*j/nx)*c       exp(sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c kstrt = starting data block numberc nxvh/nyv = second dimension of f/gc kypd = third dimension of fc kxp/kyp = number of data values per block in x/yc jblok/kblok = number of data blocks in x/yc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxhyd = maximum of (nx/2,ny)c nxyhd = one half of maximum of (nx,ny)c the real data is stored in a complex array of length nx/2, nyc with the odd/even x points stored in the real/imaginary parts.c in complex notation, fourier coefficients are stored as follows:c if ntpose = 0,c f(j,k,i) = mode j-1,kk-1, where kk = k + kyp*(i - 1)c 1 <= j <= nx/2 and 1 <= kk <= ny, except forc f(1,k,i) = mode nx/2,kk-1, where ny/2+2 <= kk <= ny, andc imaginary part of f(1,1,1) = real part of mode nx/2,0 andc imaginary part of f(1,1,(ny/2)/kyp+1) = real part of mode nx/2,ny/2c if ntpose = 1,c g(k,j,i) = mode jj-1,k-1, where jj = j + kxp*(i - 1)c 1 <= jj <= nx/2 and 1 <= k <= ny, except forc g(k,1,1) = mode nx/2,k-1, where ny/2+2 <= k <= ny, andc imaginary part of g(1,1,1) = real part of mode nx/2,0 andc imaginary part of g(ny/2+1,1,1) = real part of mode nx/2,ny/2c written by viktor k. decyk, uclac parallel, optimized version      implicit none      integer isign, ntpose, indx, indy, kstrt, nxvh, nyv, kxp, kyp      integer kypd, jblok, kblok, nxhyd, nxyhd, mixup      complex f, g, sct      dimension f(3,nxvh,kypd,kblok), g(3,nyv,kxp,jblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, nxh, nxhh, nxh2, ny, nyh, ny2, nxy      integer nxhy, ks, j, k, lb, ll, jb, it, nxyh, nrx, nry, l, i, m      integer ns, ns2, km, kmr, k1, k2, j1, j2, jj      real dnxy, arg, ani, at1, at2      complex s, t, t1, t2, t3      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nxh2 = nxh + 2      ny = 2**indy      nyh = ny/2      ny2 = ny + 2      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      if (isign) 50, 10, 360c prepare fft tablesc bit-reverse index table: mixup(j) = 1 + reversed bits of (j - 1)   10 do 30 j = 1, nxhy      lb = j - 1      ll = 0      do 20 k = 1, indx1y      jb = lb/2      it = lb - 2*jb      lb = jb      ll = 2*ll + it   20 continue      mixup(j) = ll + 1   30 continuec sine/cosine table for the angles 2*n*pi/nxy      nxyh = nxy/2      dnxy = 6.28318530717959/float(nxy)      do 40 j = 1, nxyh      arg = dnxy*float(j - 1)      sct(j) = cmplx(cos(arg),-sin(arg))   40 continue      returnc inverse fourier transform   50 if (kstrt.gt.ny) go to 230c swap complex components      do 80 l = 1, kblok      do 70 i = 1, kyp      do 60 j = 1, nxh      at1 = real(f(3,j,i,l))      f(3,j,i,l) = cmplx(real(f(2,j,i,l)),aimag(f(3,j,i,l)))      at2 = aimag(f(2,j,i,l))      f(2,j,i,l) = cmplx(aimag(f(1,j,i,l)),at1)      f(1,j,i,l) = cmplx(real(f(1,j,i,l)),at2)   60 continue   70 continue   80 continue      nrx = nxhy/nxh      do 110 l = 1, kblokc bit-reverse array elements in x      do 100 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 100      do 90 k = 1, kyp      t1 = f(1,j1,k,l)      t2 = f(2,j1,k,l)      t3 = f(3,j1,k,l)      f(1,j1,k,l) = f(1,j,k,l)      f(2,j1,k,l) = f(2,j,k,l)      f(3,j1,k,l) = f(3,j,k,l)      f(1,j,k,l) = t1      f(2,j,k,l) = t2      f(3,j,k,l) = t3   90 continue  100 continue  110 continuec first transform in x      nrx = nxy/nxh      do 160 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 150 l = 1, kblok      do 140 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 130 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 120 i = 1, kyp      t1 = s*f(1,j2,i,l)      t2 = s*f(2,j2,i,l)      t3 = s*f(3,j2,i,l)      f(1,j2,i,l) = f(1,j1,i,l) - t1      f(2,j2,i,l) = f(2,j1,i,l) - t2      f(3,j2,i,l) = f(3,j1,i,l) - t3      f(1,j1,i,l) = f(1,j1,i,l) + t1      f(2,j1,i,l) = f(2,j1,i,l) + t2      f(3,j1,i,l) = f(3,j1,i,l) + t3  120 continue  130 continue  140 continue  150 continue  160 continuec unscramble coefficients and normalize      kmr = nxy/nx      ani = 1./float(2*nx*ny)      do 220 l = 1, kblok      do 190 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),-real(sct(1+kmr*(j-1))))      do 180 k = 1, kyp      do 170 jj = 1, 3      t = conjg(f(jj,nxh2-j,k,l))      s = f(jj,j,k,l) + t      t = (f(jj,j,k,l) - t)*t1      f(jj,j,k,l) = ani*(s + t)      f(jj,nxh2-j,k,l) = ani*conjg(s - t)  170 continue  180 continue  190 continue      do 210 k = 1, kyp      do 200 jj = 1, 3      f(jj,nxhh+1,k,l) = 2.*ani*conjg(f(jj,nxhh+1,k,l))      f(jj,1,k,l) = 2.*ani*cmplx(real(f(jj,1,k,l)) + aimag(f(jj,1,k,l)),     1real(f(jj,1,k,l)) - aimag(f(jj,1,k,l)))  200 continue  210 continue  220 continuec transpose f array to g  230 call P3TPOSEX(f,g,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kypd,jblok,kbl     1ok)      if (kstrt.gt.nxh) go to 350      nry = nxhy/ny      do 260 l = 1, jblokc bit-reverse array elements in y      do 250 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 250      do 240 j = 1, kxp      t1 = g(1,k1,j,l)      t2 = g(2,k1,j,l)      t3 = g(3,k1,j,l)      g(1,k1,j,l) = g(1,k,j,l)      g(2,k1,j,l) = g(2,k,j,l)      g(3,k1,j,l) = g(3,k,j,l)      g(1,k,j,l) = t1      g(2,k,j,l) = t2      g(3,k,j,l) = t3  240 continue  250 continue  260 continuec then transform in y      nry = nxy/ny      do 310 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 300 l = 1, jblok      do 290 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 280 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 270 i = 1, kxp      t1 = s*g(1,j2,i,l)      t2 = s*g(2,j2,i,l)      t3 = s*g(3,j2,i,l)      g(1,j2,i,l) = g(1,j1,i,l) - t1      g(2,j2,i,l) = g(2,j1,i,l) - t2      g(3,j2,i,l) = g(3,j1,i,l) - t3      g(1,j1,i,l) = g(1,j1,i,l) + t1      g(2,j1,i,l) = g(2,j1,i,l) + t2      g(3,j1,i,l) = g(3,j1,i,l) + t3  270 continue  280 continue  290 continue  300 continue  310 continuec unscramble modes kx = 0, nx/2      do 340 l = 1, jblok      if ((l+ks).gt.0) go to 340      do 330 k = 2, nyh      do 320 jj = 1, 3      s = g(jj,ny2-k,1,l)      g(jj,ny2-k,1,l) = .5*cmplx(aimag(g(jj,k,1,l) + s),real(g(jj,k,1,l)     1- s))      g(jj,k,1,l) = .5*cmplx(real(g(jj,k,1,l) + s),aimag(g(jj,k,1,l) - s     1))  320 continue  330 continue  340 continuec transpose g array to f  350 if (ntpose.eq.0) call P3TPOSEX(g,f,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,k     1ypd,kxp,kblok,jblok)      returnc forward fourier transformc transpose f array to g  360 if (ntpose.eq.0) call P3TPOSEX(f,g,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,k     1xp,kypd,jblok,kblok)      if (kstrt.gt.nxh) go to 480      nry = nxhy/ny      do 420 l = 1, jblokc scramble modes kx = 0, nx/2      if ((l+ks).gt.0) go to 390      do 380 k = 2, nyh      do 370 jj = 1, 3      s = cmplx(aimag(g(jj,ny2-k,1,l)),real(g(jj,ny2-k,1,l)))      g(jj,ny2-k,1,l) = conjg(g(jj,k,1,l) - s)      g(jj,k,1,l) = g(jj,k,1,l) + s  370 continue  380 continuec bit-reverse array elements in y  390 do 410 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 410      do 400 j = 1, kxp      t1 = g(1,k1,j,l)      t2 = g(2,k1,j,l)      t3 = g(3,k1,j,l)      g(1,k1,j,l) = g(1,k,j,l)      g(2,k1,j,l) = g(2,k,j,l)      g(3,k1,j,l) = g(3,k,j,l)      g(1,k,j,l) = t1      g(2,k,j,l) = t2      g(3,k,j,l) = t3  400 continue  410 continue  420 continuec first transform in y      nry = nxy/ny      do 470 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 460 l = 1, jblok      do 450 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 440 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 430 i = 1, kxp      t1 = s*g(1,j2,i,l)      t2 = s*g(2,j2,i,l)      t3 = s*g(3,j2,i,l)      g(1,j2,i,l) = g(1,j1,i,l) - t1      g(2,j2,i,l) = g(2,j1,i,l) - t2      g(3,j2,i,l) = g(3,j1,i,l) - t3      g(1,j1,i,l) = g(1,j1,i,l) + t1      g(2,j1,i,l) = g(2,j1,i,l) + t2      g(3,j1,i,l) = g(3,j1,i,l) + t3  430 continue  440 continue  450 continue  460 continue  470 continuec transpose g array to f  480 call P3TPOSEX(g,f,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kxp,kblok,jbl     1ok)      if (kstrt.gt.ny) return      nrx = nxhy/nxh      kmr = nxy/nx      do 560 l = 1, kblokc scramble coefficients      do 510 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),real(sct(1+kmr*(j-1))))      do 500 k = 1, kyp      do 490 jj = 1, 3      t = conjg(f(jj,nxh2-j,k,l))      s = f(jj,j,k,l) + t      t = (f(jj,j,k,l) - t)*t1      f(jj,j,k,l) = s + t      f(jj,nxh2-j,k,l) = conjg(s - t)  490 continue  500 continue  510 continue      do 530 k = 1, kyp      do 520 jj = 1, 3      f(jj,nxhh+1,k,l) = 2.*conjg(f(jj,nxhh+1,k,l))      f(jj,1,k,l) = cmplx(real(f(jj,1,k,l)) + aimag(f(jj,1,k,l)),real(f(     1jj,1,k,l)) - aimag(f(jj,1,k,l)))  520 continue  530 continuec bit-reverse array elements in x      do 550 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 550      do 540 k = 1, kyp      t1 = f(1,j1,k,l)      t2 = f(2,j1,k,l)      t3 = f(3,j1,k,l)      f(1,j1,k,l) = f(1,j,k,l)      f(2,j1,k,l) = f(2,j,k,l)      f(3,j1,k,l) = f(3,j,k,l)      f(1,j,k,l) = t1      f(2,j,k,l) = t2      f(3,j,k,l) = t3  540 continue  550 continue  560 continuec then transform in x      nrx = nxy/nxh      do 610 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 600 l = 1, kblok      do 590 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 580 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 570 i = 1, kyp      t1 = s*f(1,j2,i,l)      t2 = s*f(2,j2,i,l)      t3 = s*f(3,j2,i,l)      f(1,j2,i,l) = f(1,j1,i,l) - t1      f(2,j2,i,l) = f(2,j1,i,l) - t2      f(3,j2,i,l) = f(3,j1,i,l) - t3      f(1,j1,i,l) = f(1,j1,i,l) + t1      f(2,j1,i,l) = f(2,j1,i,l) + t2      f(3,j1,i,l) = f(3,j1,i,l) + t3  570 continue  580 continue  590 continue  600 continue  610 continuec swap complex components      do 640 l = 1, kblok      do 630 i = 1, kyp      do 620 j = 1, nxh      at1 = real(f(3,j,i,l))      f(3,j,i,l) = cmplx(aimag(f(2,j,i,l)),aimag(f(3,j,i,l)))      at2 = real(f(2,j,i,l))      f(2,j,i,l) = cmplx(at1,aimag(f(1,j,i,l)))      f(1,j,i,l) = cmplx(real(f(1,j,i,l)),at2)  620 continue  630 continue  640 continue      return      endc-----------------------------------------------------------------------      subroutine PFFT2C(f,g,bs,br,isign,ntpose,mixup,sct,indx,indy,kstrt     1,nxv,nyv,kxp,kyp,kypd,jblok,kblok,nxyd,nxyhd)c this subroutine performs a two dimensional complex to complex fastc fourier transform and its inverse, using complex arithmetic,c for data which is distributed in blocksc for isign = 0, input: isign, indx, indy, kstrt, nxyd, nxyhdc output: mixup, sctc for isign = (-1,1), input: all, output: f, g, bs, brc approximate flop count: 5*N*log2(N)/nvpc where N = nx*ny, and nvp = number of procsc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc ntpose = (0,1) = (no,yes) input, output data are transposedc if isign = 0, the fft tables are preparedc if isign = -1, an inverse fourier transform is performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(n,m,l) = (1/nx*ny)*sum(f(j,k,i)*c       exp(-sqrt(-1)*2pi*n*j/nx)*exp(-sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, f is the input and g is the outputc g(m,n,l) = (1/nx*ny)*sum(f(j,k,i)*c       exp(-sqrt(-1)*2pi*nn*j/nx)*exp(-sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c if isign = 1, a forward fourier transform is performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(j,k,i) = sum(f(n,m,l)*exp(sqrt(-1)*2pi*n*j/nx)*c       exp(sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, g is the input and f is the outputc f(j,k,i) = sum(g(m,n,l)*exp(sqrt(-1)*2pi*nn*j/nx)*c       exp(sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c bs, br = scratch arraysc kstrt = starting data block numberc nxv/nyv = first dimension of f/gc kypd = second dimension of f c kxp/kyp = number of data values per block in x/yc jblok/kblok = number of data blocks in x/yc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxy = maximum of (nx,ny)c nxyh = one half of maximum of (nx,ny)c written by viktor k. decyk, uclac parallel version      implicit none      integer isign, ntpose, indx, indy, kstrt, nxv, nyv, kxp, kyp      integer kypd, jblok, kblok, nxyd, nxyhd, mixup      complex f, g, bs, br, sct      dimension f(nxv,kypd,kblok), g(nyv,kxp,jblok)      dimension bs(kxp,kyp,kblok), br(kxp,kyp,jblok)      dimension mixup(nxyd), sct(nxyhd)c local data      integer indxy, nx, nxh, ny, nyh, nxy, j, k, lb, ll, jb, it, nxyh      integer nrx, nry, l, i, m, ns, ns2, km, kmr, k1, k2, j1, j2      real dnxy, arg, ani      complex s, t      indxy = max0(indx,indy)      nx = 2**indx      nxh = nx/2      ny = 2**indy      nyh = ny/2      nxy = 2**indxy      if (isign) 50, 10, 270c prepare fft tablesc bit-reverse index table: mixup(j) = 1 + reversed bits of (j - 1)   10 do 30 j = 1, nxy      lb = j - 1      ll = 0      do 20 k = 1, indxy      jb = lb/2      it = lb - 2*jb      lb = jb      ll = 2*ll + it   20 continue      mixup(j) = ll + 1   30 continuec sine/cosine table for the angles 2*n*pi/nxy      nxyh = nxy/2      dnxy = 6.28318530717959/float(nxy)      do 40 j = 1, nxyh      arg = dnxy*float(j - 1)      sct(j) = cmplx(cos(arg),-sin(arg))   40 continue      returnc inverse fourier transform   50 if (kstrt.gt.ny) go to 140      nrx = nxy/nx      do 80 l = 1, kblokc bit-reverse array elements in x      do 70 j = 1, nx      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 70      do 60 k = 1, kyp      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = t   60 continue   70 continue   80 continuec first transform in x      do 130 m = 1, indx      ns = 2**(m - 1)      ns2 = ns + ns      km = nxh/ns      kmr = km*nrx      do 120 l = 1, kblok      do 110 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 100 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 90 i = 1, kyp      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t   90 continue  100 continue  110 continue  120 continue  130 continuec transpose f array to g  140 call PTPOSE(f,g,bs,br,nx,ny,kstrt,nxv,nyv,kxp,kyp,kxp,kypd,jblok,k     1blok)      if (kstrt.gt.nx) go to 260      nry = nxy/ny      do 170 l = 1, jblokc bit-reverse array elements in y      do 160 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 160      do 150 j = 1, kxp      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = t  150 continue  160 continue  170 continuec then transform in y      do 220 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 210 l = 1, jblok      do 200 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 190 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 180 i = 1, kxp      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t  180 continue  190 continue  200 continue  210 continue  220 continuec normalize result      ani = 1./float(nx*ny)      do 250 l = 1, jblok      do 240 j = 1, kxp      do 230 k = 1, ny      g(k,j,l) = g(k,j,l)*ani  230 continue  240 continue  250 continuec transpose g array to f  260 if (ntpose.eq.0) call PTPOSE(g,f,br,bs,ny,nx,kstrt,nyv,nxv,kyp,kxp     1,kypd,kxp,kblok,jblok)      returnc forward fourier transformc transpose f array to g  270 if (ntpose.eq.0) call PTPOSE(f,g,bs,br,nx,ny,kstrt,nxv,nyv,kxp,kyp     1,kxp,kypd,jblok,kblok)      if (kstrt.gt.nx) go to 360      nry = nxy/ny      do 300 l = 1, jblokc bit-reverse array elements in y      do 290 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 290      do 280 j = 1, kxp      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = t  280 continue  290 continue  300 continuec first transform in y      do 350 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 340 l = 1, jblok      do 330 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 320 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 310 i = 1, kxp      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t  310 continue  320 continue  330 continue  340 continue  350 continuec transpose g array to f  360 call PTPOSE(g,f,br,bs,ny,nx,kstrt,nyv,nxv,kyp,kxp,kypd,kxp,kblok,j     1blok)      if (kstrt.gt.ny) return      nrx = nxy/nx      do 390 l = 1, kblokc bit-reverse array elements in x      do 380 j = 1, nx      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 380      do 370 k = 1, kyp      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = t  370 continue  380 continue  390 continuec then transform in x      do 440 m = 1, indx      ns = 2**(m - 1)      ns2 = ns + ns      km = nxh/ns      kmr = km*nrx      do 430 l = 1, kblok      do 420 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 410 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 400 i = 1, kyp      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t  400 continue  410 continue  420 continue  430 continue  440 continue      return      end