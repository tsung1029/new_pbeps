!-----------------------------------------------------------------------!      module p2d!! Fortran90 interface to 2d parallel PIC Fortran77 library p2lib.f! written by viktor k. decyk, ucla! copyright 2000, regents of the university of california! update: june 2, 2004!      use p0d      implicit none      private      public :: LINEAR, QUADRATIC, STANDARD, LOOKAHEAD, VECTOR      public :: PPINIT, PPID, PPEXIT, HARTBEAT, PHEAD2      public :: pwtimer, plsum, plmax, plbcast, writef, readf      public :: wrdata, rddata      public :: dcomp, pmove, pcguard, pcguardp, paguard, paguardp      public :: dblsin, hafdbl!! define interface to original Fortran77 procedures!      interface         subroutine DCOMP2(edges,nyp,noff,ny,kstrt,nvp,idps,nblok)         implicit none         integer :: ny, kstrt, nvp, idps, nblok         real, dimension(idps,nblok) :: edges         integer, dimension(nblok) :: nyp, noff         end subroutine      end interface      interface         subroutine DCOMP2L(edges,nyp,noff,ny,kstrt,nvp,idps,nblok)         implicit none         integer :: ny, kstrt, nvp, idps, nblok         real, dimension(idps,nblok) :: edges         integer, dimension(nblok) :: nyp, noff         end subroutine      end interface      interface         subroutine PCGUARD2(f,kstrt,nvp,nxv,nypmx,kyp,kblok)         implicit none         integer :: kstrt, nvp, nxv, nypmx, kyp, kblok         real, dimension(nxv,nypmx,kblok) :: f         end subroutine      end interface      interface         subroutine PCGUARD2L(f,kstrt,nvp,nxv,nypmx,kyp,kblok)         implicit none         integer :: kstrt, nvp, nxv, nypmx, kyp, kblok         real, dimension(nxv,nypmx,kblok) :: f         end subroutine      end interface      interface         subroutine PAGUARD2(f,scr,kstrt,nvp,nx,nxv,nypmx,kyp,kblok,ngds&     &)         implicit none         integer kstrt, nvp, nxv, nypmx, kyp, kblok, ngds         real, dimension(nxv,nypmx,kblok) :: f         real, dimension(nxv,ngds,kblok) :: scr         end subroutine      end interface      interface         subroutine PAGUARD2L(f,scr,kstrt,nvp,nx,nxv,nypmx,kyp,kblok)         implicit none         integer kstrt, nvp, nx, nxv, nypmx, kyp, kblok         real, dimension(nxv,nypmx,kblok) :: f         real, dimension(nxv,kblok) :: scr         end subroutine      end interface      interface         subroutine PDBLSIN2C(cu,cu2,nx,ny,kstrt,nxv,kyp,kypd,kyp2,kblok&     &,k2blok)         implicit none         integer :: nx, ny, kstrt, nxv, kyp, kypd, kyp2, kblok, k2blok         real :: cu         real, dimension(2,2*nxv,kyp2,k2blok) :: cu2         end subroutine      end interface      interface         subroutine PDBLSIN2D(q,q2,nx,ny,kstrt,nxv,kyp,kypd,kyp2,kblok,k&     &2blok)         implicit none         integer :: nx, ny, kstrt, nxv, kyp, kypd, kyp2, kblok, k2blok         real :: q         real, dimension(2*nxv,kyp2,k2blok) :: q2         end subroutine      end interface      interface         subroutine PDBLSIN2B(cu,cu2,nx,ny,kstrt,nxv,kyp,kypd,kyp2,kblok&     &,k2blok)         implicit none         integer :: nx, ny, kstrt, nxv, kyp, kypd, kyp2, kblok, k2blok         real :: cu         real, dimension(3,2*nxv,kyp2,k2blok) :: cu2         end subroutine      end interface      interface         subroutine PHAFDBL2C(fxy,fxy2,nx,ny,kstrt,nxv,kyp,kypd,kyp2,kbl&     &ok,k2blok)         implicit none         integer :: nx, ny, kstrt, nxv, kyp, kypd, kyp2, kblok, k2blok         real :: fxy         real, dimension(2,2*nxv,kyp2,k2blok) :: fxy2         end subroutine      end interface      interface         subroutine PHAFDBL2D(q,q2,nx,ny,kstrt,nxv,kyp,kypd,kyp2,kblok,k&     &2blok)         implicit none         integer :: nx, ny, kstrt, nxv, kyp, kypd, kyp2, kblok, k2blok         real :: q         real, dimension(2*nxv,kyp2,k2blok) :: q2         end subroutine      end interface      interface         subroutine PHAFDBL2B(fxy,fxy2,nx,ny,kstrt,nxv,kyp,kypd,kyp2,kbl&     &ok,k2blok)         implicit none         integer :: nx, ny, kstrt, nxv, kyp, kypd, kyp2, kblok, k2blok         real :: fxy         real, dimension(3,2*nxv,kyp2,k2blok) :: fxy2         end subroutine      end interface      interface         subroutine PLCGUARD2(f,kstrt,nvp,nx,nxv,nypmx,kyp,kblok)         implicit none         integer :: kstrt, nvp, nx, nxv, nypmx, kyp, kblok         real, dimension(2,nxv,nypmx,kblok) :: f         end subroutine      end interface      interface         subroutine PLDGUARD2(f,kstrt,nvp,nx,nxv,nypmx,kyp,kblok)         implicit none         integer :: kstrt, nvp, nx, nxv, nypmx, kyp, kblok         real, dimension(nxv,nypmx,kblok) :: f         end subroutine      end interface      interface         subroutine PLBGUARD2(f,kstrt,nvp,nx,nxv,nypmx,kyp,kblok)         implicit none         integer :: kstrt, nvp, nx, nxv, nypmx, kyp, kblok         real, dimension(3,nxv,nypmx,kblok) :: f         end subroutine      end interface      interface         subroutine PLACGUARD2(f,scr,kstrt,nvp,nx,nxv,nypmx,kyp,kblok,ng&     &ds)         implicit none         integer :: kstrt, nvp, nx, nxv, nypmx, kyp, kblok, ngds         real, dimension(3,nxv,nypmx,kblok) :: f         real, dimension(3,nxv,ngds,kblok) :: scr         end subroutine      end interface      interface         subroutine PLACGUARD22(f,scr,kstrt,nvp,nx,nxv,nypmx,kyp,kblok,n&     &gds)         implicit none         integer :: kstrt, nvp, nx, nxv, nypmx, kyp, kblok, ngds         real, dimension(2,nxv,nypmx,kblok) :: f         real, dimension(2,nxv,ngds,kblok) :: scr         end subroutine      end interface      interface         subroutine PLAGUARD2(f,scr,kstrt,nvp,nx,nxv,nypmx,kyp,kblok,ngd&     &s)         implicit none         integer :: kstrt, nvp, nx, nxv, nypmx, kyp, kblok, ngds         real, dimension(nxv,nypmx,kblok) :: f         real, dimension(nxv,ngds,kblok) :: scr         end subroutine      end interface      interface         subroutine PLACGUARDS2(f,kstrt,nvp,nx,nxv,nypmx,kyp,kblok)         implicit none         integer :: kstrt, nvp, nx, nxv, nypmx, kyp, kblok         real, dimension(3,nxv,nypmx,kblok) :: f         end subroutine      end interface      interface         subroutine PLACGUARDS22(f,kstrt,nvp,nx,nxv,nypmx,kyp,kblok)         implicit none         integer :: kstrt, nvp, nx, nxv, nypmx, kyp, kblok         real, dimension(2,nxv,nypmx,kblok) :: f         end subroutine      end interface      interface         subroutine PLAGUARDS2(f,kstrt,nvp,nx,nxv,nypmx,kyp,kblok)         implicit none         integer :: kstrt, nvp, nx, nxv, nypmx, kyp, kblok         real, dimension(nxv,nypmx,kblok) :: f         end subroutine      end interface      interface         subroutine PLACGUARD2L(f,scr,kstrt,nvp,nx,nxv,nypmx,kyp,kblok)         implicit none         integer :: kstrt, nvp, nx, nxv, nypmx, kyp, kblok         real, dimension(3,nxv,nypmx,kblok) :: f         real, dimension(3,nxv,kblok) :: scr         end subroutine      end interface      interface         subroutine PLACGUARD22L(f,scr,kstrt,nvp,nx,nxv,nypmx,kyp,kblok)         implicit none         integer :: kstrt, nvp, nx, nxv, nypmx, kyp, kblok         real, dimension(2,nxv,nypmx,kblok) :: f         real, dimension(2,nxv,kblok) :: scr         end subroutine      end interface      interface         subroutine PLAGUARD2L(f,scr,kstrt,nvp,nx,nxv,nypmx,kyp,kblok)         implicit none         integer :: kstrt, nvp, nx, nxv, nypmx, kyp, kblok         real, dimension(nxv,nypmx,kblok) :: f         real, dimension(nxv,kblok) :: scr         end subroutine      end interface      interface         subroutine PMOVE2(part,edges,npp,sbufr,sbufl,rbufr,rbufl,ihole,&     &jsr,jsl,jss,ny,kstrt,nvp,idimp,npmax,nblok,idps,nbmax,ntmax,ierr)         implicit none         integer :: ny, kstrt, nvp, idimp, npmax, nblok, idps         integer :: nbmax, ntmax, ierr         real, dimension(idimp,npmax,nblok) :: part         real, dimension(idps,nblok) :: edges         integer, dimension(nblok) :: npp         real, dimension(idimp,nbmax,nblok) :: sbufl, sbufr         real, dimension(idimp,nbmax,nblok) :: rbufl, rbufr         integer, dimension(idps,nblok) :: jsl, jsr, jss         integer, dimension(ntmax,nblok) :: ihole         end subroutine      end interface      interface         subroutine PXMOV2(part,edges,npp,sbufr,sbufl,rbufr,rbufl,ihole,&     &jsr,jsl,jss,ny,kstrt,nvp,idimp,npmax,nblok,idps,nbmax,ntmax,maskp,&     &ierr)         implicit none         integer :: ny, kstrt, nvp, idimp, npmax, nblok, idps         integer :: nbmax, ntmax, ierr         real, dimension(idimp,npmax,nblok) :: part         integer, dimension(npmax,nblok) :: maskp         real, dimension(idps,nblok) :: edges         integer, dimension(nblok) :: npp         real, dimension(idimp,nbmax,nblok) :: sbufl, sbufr         real, dimension(idimp,nbmax,nblok) :: rbufl, rbufr         integer, dimension(idps,nblok) :: jsl, jsr, jss         integer, dimension(ntmax,nblok) :: ihole         end subroutine      end interface      interface         subroutine PTPOSE(f,g,s,t,nx,ny,kstrt,nxv,nyv,kxp,kyp,kxpd,kypd&     &,jblok,kblok)         implicit none         integer :: nx, ny, kstrt, nxv, nyv, kxp, kyp, kxpd, kypd         integer :: jblok, kblok         complex, dimension(nxv,kypd,kblok) :: f         complex, dimension(nyv,kxpd,jblok) :: g         complex, dimension(kxp,kyp,kblok) :: s         complex, dimension(kxp,kyp,jblok) :: t         end subroutine      end interface      interface         subroutine P2TPOSE(f,g,s,t,nx,ny,kstrt,nxv,nyv,kxp,kyp,kxpd,kyp&     &d,jblok,kblok)         implicit none         integer :: nx, ny, kstrt, nxv, nyv, kxp, kyp, kxpd, kypd         integer :: jblok, kblok         complex, dimension(2,nxv,kypd,kblok) :: f         complex, dimension(2,nyv,kxpd,jblok) :: g         complex, dimension(2,kxp,kyp,kblok) :: s         complex, dimension(2,kxp,kyp,jblok) :: t         end subroutine      end interface      interface         subroutine P3TPOSE(f,g,s,t,nx,ny,kstrt,nxv,nyv,kxp,kyp,kxpd,kyp&     &d,jblok,kblok)         implicit none         integer :: nx, ny, kstrt, nxv, nyv, kxp, kyp, kxpd, kypd         integer :: jblok, kblok         complex, dimension(3,nxv,kypd,kblok) :: f         complex, dimension(3,nyv,kxpd,jblok) :: g         complex, dimension(3,kxp,kyp,kblok) :: s         complex, dimension(3,kxp,kyp,jblok) :: t         end subroutine      end interface      interface         subroutine PTPOSEX(f,g,nx,ny,kstrt,nxv,nyv,kxp,kyp,kxpd,kypd,jb&     &lok,kblok)         implicit none         integer  :: nx, ny, kstrt, nxv, nyv, kxp, kyp         integer :: kxpd, kypd, jblok, kblok         complex, dimension(nxv*kypd*kblok) :: f         complex, dimension(nyv*kxpd*jblok) :: g         end subroutine      end interface      interface         subroutine P2TPOSEX(f,g,nx,ny,kstrt,nxv,nyv,kxp,kyp,kxpd,kypd,j&     &blok,kblok)         implicit none         integer :: nx, ny, kstrt, nxv, nyv, kxp, kyp         integer :: kxpd, kypd, jblok, kblok         complex, dimension(2*nxv*kypd*kblok) :: f         complex, dimension(2*nyv*kxpd*jblok) :: g         end subroutine      end interface      interface         subroutine P3TPOSEX(f,g,nx,ny,kstrt,nxv,nyv,kxp,kyp,kxpd,kypd,j&     &blok,kblok)         implicit none         integer :: nx, ny, kstrt, nxv, nyv, kxp, kyp         integer :: kxpd, kypd, jblok, kblok         complex, dimension(3*nxv*kypd*kblok) :: f         complex, dimension(3*nyv*kxpd*jblok) :: g         end subroutine      end interface      interface         subroutine PWRITE2(f,nx,kyp,nxv,iunit,nrec,name)         implicit none         integer :: nx, kyp, nxv, iunit, nrec         character(len=*) :: name!        real, dimension(*) :: f         real :: f         end subroutine      end interface      interface         subroutine PHEAD2(iunit,nx,ny,nvp,fname)         implicit none         integer :: iunit, nx, ny, nvp         character(len=*) :: fname         end subroutine      end interface!! define generic interface to Fortran90 library!      interface dcomp         module procedure idcomp2      end interface!      interface pmove         module procedure ipmove2      end interface!      interface pcguard         module procedure ipcguard2         module procedure ipdguard2      end interface!      interface pcguardp         module procedure ipcguard2p         module procedure ipdguard2p      end interface!      interface paguard         module procedure ipaguard2         module procedure ipacguard2      end interface!      interface paguardp         module procedure ipaguard2p         module procedure ipacguard2p      end interface!      interface dblsin         module procedure ipdblsin2c         module procedure ipdblsin2d      end interface!      interface hafdbl         module procedure iphafdbl2c         module procedure iphafdbl2d      end interface!      interface plsum         module procedure ipsum2      end interface!      interface plbcast         module procedure ipbcast2      end interface!      interface writef         module procedure ipwrite2      end interface!      interface wrdata         module procedure ipwrdata2         module procedure ipwrrdata2         module procedure ipwrcdata2      end interface!      interface rddata         module procedure iprddata2         module procedure iprdrdata2         module procedure iprdcdata2      end interface!! define Fortran90 interface functions to Fortran77 library!      contains  !         subroutine idcomp2(edges,nyp,noff,ny,kstrt,nvp,inorder)         implicit none         integer :: ny, kstrt, nvp         integer, optional :: inorder         real, dimension(:,:) :: edges         integer, dimension(:) :: nyp, noff         integer :: idps, nblok, order         idps = size(edges,1); nblok = size(edges,2)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call DCOMP2L(edges,nyp,noff,ny,kstrt,nvp,idps,nblok)         else            call DCOMP2(edges,nyp,noff,ny,kstrt,nvp,idps,nblok)         endif         end subroutine idcomp2!         subroutine ipcguard2(f,kstrt,nvp,kyp,inorder)         implicit none         integer :: kstrt, nvp, kyp         integer, optional :: inorder         real, dimension(:,:,:,:) :: f         integer :: nxv, nypmx, kblok, order         nxv = size(f,1)*size(f,2); nypmx = size(f,3); kblok = size(f,4)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PCGUARD2L(f,kstrt,nvp,nxv,nypmx,kyp,kblok)         else            call PCGUARD2(f,kstrt,nvp,nxv,nypmx,kyp,kblok)         endif         end subroutine ipcguard2!         subroutine ipdguard2(f,kstrt,nvp,kyp,inorder)         implicit none         integer :: kstrt, nvp, kyp         integer, optional :: inorder         real, dimension(:,:,:) :: f         integer :: nxv, nypmx, kblok, order         nxv = size(f,1); nypmx = size(f,2); kblok = size(f,3)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PCGUARD2L(f,kstrt,nvp,nxv,nypmx,kyp,kblok)         else            call PCGUARD2(f,kstrt,nvp,nxv,nypmx,kyp,kblok)         endif         end subroutine ipdguard2!         subroutine ipcguard2p(f,kstrt,nvp,nx,kyp,ipbc,inorder)         implicit none         integer :: kstrt, nvp, nx, kyp, ipbc         integer, optional :: inorder         real, dimension(:,:,:,:) :: f         integer :: nxv, nypmx, kblok, order         nxv = size(f,1)*size(f,2); nypmx = size(f,3); kblok = size(f,4)         order = QUADRATIC         if (present(inorder)) order = inorder         if (ipbc==1) then            if (order==LINEAR) then               call PCGUARD2L(f,kstrt,nvp,nxv,nypmx,kyp,kblok)            else               call PCGUARD2(f,kstrt,nvp,nxv,nypmx,kyp,kblok)            endif         else if (ipbc==2) then            nxv = size(f,2)            if (order==QUADRATIC) then               if (size(f,1)==2) then                  call PLCGUARD2(f,kstrt,nvp,nx,nxv,nypmx,kyp,kblok)               else if (size(f,1)==3) then                  call PLBGUARD2(f,kstrt,nvp,nx,nxv,nypmx,kyp,kblok)               endif            endif         else if (ipbc==3) then            if (order==LINEAR) then               call PCGUARD2L(f,kstrt,nvp,nxv,nypmx,kyp,kblok)            else               call PCGUARD2(f,kstrt,nvp,nxv,nypmx,kyp,kblok)            endif         endif         end subroutine ipcguard2p!         subroutine ipdguard2p(f,kstrt,nvp,nx,kyp,ipbc,inorder)         implicit none         integer :: kstrt, nvp, nx, kyp, ipbc         integer, optional :: inorder         real, dimension(:,:,:) :: f         integer :: nxv, nypmx, kblok, order         nxv = size(f,1); nypmx = size(f,2); kblok = size(f,3)         order = QUADRATIC         if (present(inorder)) order = inorder         if (ipbc==1) then            if (order==LINEAR) then               call PCGUARD2L(f,kstrt,nvp,nxv,nypmx,kyp,kblok)            else               call PCGUARD2(f,kstrt,nvp,nxv,nypmx,kyp,kblok)            endif         else if (ipbc==2) then            if (order==QUADRATIC) then               call PLDGUARD2(f,kstrt,nvp,nx,nxv,nypmx,kyp,kblok)            endif         else if (ipbc==3) then            if (order==LINEAR) then               call PCGUARD2L(f,kstrt,nvp,nxv,nypmx,kyp,kblok)            else               call PCGUARD2(f,kstrt,nvp,nxv,nypmx,kyp,kblok)            endif         endif         end subroutine ipdguard2p!         subroutine ipacguard2(f,kstrt,nvp,kyp,ngds)         implicit none         integer :: kstrt, nvp, kyp, ngds         real, dimension(:,:,:,:) :: f         integer :: nxv, nypmx, kblok         real, dimension(size(f,1)*size(f,2),ngds,size(f,4)) :: scr         nxv = size(f,1)*size(f,2); nypmx = size(f,3); kblok = size(f,4)         if (ngds.eq.1) then            call PAGUARD2L(f,scr,kstrt,nvp,nxv,nypmx,kyp,kblok)         else            call PAGUARD2(f,scr,kstrt,nvp,nxv,nypmx,kyp,kblok,ngds)         endif         end subroutine ipacguard2!         subroutine ipaguard2(f,kstrt,nvp,kyp,ngds)         implicit none         integer :: kstrt, nvp, kyp, ngds         real, dimension(:,:,:) :: f         integer :: nxv, nypmx, kblok         real, dimension(size(f,1),ngds,size(f,3)) :: scr         nxv = size(f,1); nypmx = size(f,2); kblok = size(f,3)         if (ngds.eq.1) then            call PAGUARD2L(f,scr,kstrt,nvp,nxv,nypmx,kyp,kblok)         else            call PAGUARD2(f,scr,kstrt,nvp,nxv,nypmx,kyp,kblok,ngds)         endif         end subroutine ipaguard2!         subroutine ipacguard2p(f,kstrt,nvp,nx,kyp,ngds,ipbc)         implicit none         integer :: kstrt, nvp, nx, kyp, ngds, ipbc         real, dimension(:,:,:,:) :: f         integer :: nxv, nypmx, kblok         real, dimension(size(f,1),size(f,2),ngds,size(f,4)) :: scr         nypmx = size(f,3); kblok = size(f,4)         if (ipbc==1) then            nxv = size(f,1)*size(f,2)            if (ngds.eq.1) then               call PAGUARD2L(f,scr,kstrt,nvp,nxv,nypmx,kyp,kblok)            else               call PAGUARD2(f,scr,kstrt,nvp,nxv,nypmx,kyp,kblok,ngds)            endif         else if (ipbc==2) then            nxv = size(f,2)            if (ngds.eq.1) then               call PLACGUARD2L(f,scr,kstrt,nvp,nx,nxv,nypmx,kyp,kblok)            else               call PLACGUARD2(f,scr,kstrt,nvp,nx,nxv,nypmx,kyp,kblok,ng&     &ds)               call PLACGUARDS2(f,kstrt,nvp,nx,nxv,nypmx,kyp,kblok)            endif         else if (ipbc==3) then            nxv = size(f,1)*size(f,2)            if (ngds.eq.1) then               call PAGUARD2L(f,scr,kstrt,nvp,nxv,nypmx,kyp,kblok)            else               call PAGUARD2(f,scr,kstrt,nvp,nxv,nypmx,kyp,kblok,ngds)            endif         endif         end subroutine ipacguard2p!         subroutine ipaguard2p(f,kstrt,nvp,nx,kyp,ngds,ipbc)         implicit none         integer :: kstrt, nvp, nx, kyp, ngds, ipbc         real, dimension(:,:,:) :: f         integer :: nxv, nypmx, kblok         real, dimension(size(f,1),ngds,size(f,3)) :: scr         nxv = size(f,1); nypmx = size(f,2); kblok = size(f,3)         if (ipbc==1) then            if (ngds.eq.1) then               call PAGUARD2L(f,scr,kstrt,nvp,nxv,nypmx,kyp,kblok)            else               call PAGUARD2(f,scr,kstrt,nvp,nxv,nypmx,kyp,kblok,ngds)            endif         else if (ipbc==2) then            if (ngds.eq.1) then               call PLAGUARD2L(f,scr,kstrt,nvp,nx,nxv,nypmx,kyp,kblok)            else               call PLAGUARD2(f,scr,kstrt,nvp,nx,nxv,nypmx,kyp,kblok,ngd&     &s)               call PLAGUARDS2(f,kstrt,nvp,nx,nxv,nypmx,kyp,kblok)            endif         else if (ipbc==3) then            if (ngds.eq.1) then               call PAGUARD2L(f,scr,kstrt,nvp,nxv,nypmx,kyp,kblok)            else               call PAGUARD2(f,scr,kstrt,nvp,nxv,nypmx,kyp,kblok,ngds)            endif         endif         end subroutine ipaguard2p!         subroutine ipdblsin2c(cu,cu2,nx,ny,kstrt,kyp,kyp2,inorder)         implicit none         integer :: nx, ny, kstrt, kyp, kyp2         integer, optional :: inorder         real, dimension(:,:,:,:) :: cu         real, dimension(:,:,:,:) :: cu2         integer :: nxv, kypd, kblok, k2blok, order         nxv = size(cu,2);  kypd = size(cu,3); kblok = size(cu,4)         k2blok = size(cu2,4)         order = QUADRATIC         if (present(inorder)) order = inorder         if (size(cu,1)==3) then            if (order==LINEAR) then               call PDBLSIN2B(cu(1,1,1,1),cu2,nx,ny,kstrt,nxv,kyp,kypd,k&     &yp2,kblok,k2blok)            else               call PDBLSIN2B(cu(1,2,2,1),cu2,nx,ny,kstrt,nxv,kyp,kypd,k&     &yp2,kblok,k2blok)            endif         else if (size(cu,1)==2) then            if (order==LINEAR) then               call PDBLSIN2C(cu(1,1,1,1),cu2,nx,ny,kstrt,nxv,kyp,kypd,k&     &yp2,kblok,k2blok)            else               call PDBLSIN2C(cu(1,2,2,1),cu2,nx,ny,kstrt,nxv,kyp,kypd,k&     &yp2,kblok,k2blok)            endif         endif         end subroutine ipdblsin2c!         subroutine ipdblsin2d(q,q2,nx,ny,kstrt,kyp,kyp2,inorder)         implicit none         integer :: nx, ny, kstrt, kyp, kyp2         integer, optional :: inorder         real, dimension(:,:,:) :: q         real, dimension(:,:,:) :: q2         integer :: nxv, kypd, kblok, k2blok, order         nxv = size(q,1);  kypd = size(q,2); kblok = size(q,3)         k2blok = size(q2,3)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PDBLSIN2D(q(1,1,1),q2,nx,ny,kstrt,nxv,kyp,kypd,kyp2,kbl&     &ok,k2blok)         else            call PDBLSIN2D(q(2,2,1),q2,nx,ny,kstrt,nxv,kyp,kypd,kyp2,kbl&     &ok,k2blok)         endif         end subroutine ipdblsin2d!         subroutine iphafdbl2c(fxy,fxy2,nx,ny,kstrt,kyp,kyp2,inorder)         implicit none         integer :: nx, ny, kstrt, kyp, kyp2         integer, optional :: inorder         real, dimension(:,:,:,:) :: fxy         real, dimension(:,:,:,:) :: fxy2         integer :: nxv, kypd, kblok, k2blok, order         nxv = size(fxy,2);  kypd = size(fxy,3); kblok = size(fxy,4)         k2blok = size(fxy2,4)         order = QUADRATIC         if (present(inorder)) order = inorder         if (size(fxy,1)==2) then            if (order==LINEAR) then               call PHAFDBL2C(fxy(1,1,1,1),fxy2,nx,ny,kstrt,nxv,kyp,kypd&     &,kyp2,kblok,k2blok)            else               call PHAFDBL2C(fxy(1,2,2,1),fxy2,nx,ny,kstrt,nxv,kyp,kypd&     &,kyp2,kblok,k2blok)            endif         else if (size(fxy,1)==3) then            if (order==LINEAR) then               call PHAFDBL2B(fxy(1,1,1,1),fxy2,nx,ny,kstrt,nxv,kyp,kypd&     &,kyp2,kblok,k2blok)            else               call PHAFDBL2B(fxy(1,2,2,1),fxy2,nx,ny,kstrt,nxv,kyp,kypd&     &,kyp2,kblok,k2blok)            endif         endif         end subroutine iphafdbl2c!         subroutine iphafdbl2d(q,q2,nx,ny,kstrt,kyp,kyp2,inorder)         implicit none         integer :: nx, ny, kstrt, kyp, kyp2         integer, optional :: inorder         real, dimension(:,:,:) :: q         real, dimension(:,:,:) :: q2         integer :: nxv, kypd, kblok, k2blok, order         nxv = size(q,1);  kypd = size(q,2); kblok = size(q,3)         k2blok = size(q2,3)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PHAFDBL2D(q(1,1,1),q2,nx,ny,kstrt,nxv,kyp,kypd,kyp2,kbl&     &ok,k2blok)         else            call PHAFDBL2D(q(2,2,1),q2,nx,ny,kstrt,nxv,kyp,kypd,kyp2,kbl&     &ok,k2blok)         endif         end subroutine iphafdbl2d!         subroutine ipmove2(part,edges,npp,ny,kstrt,nvp,nbmax,vt,ierr)         implicit none         integer :: ny, kstrt, nvp, nbmax, vt, ierr         real, dimension(:,:,:) :: part         real, dimension(:,:) :: edges         integer, dimension(:) :: npp         integer, dimension(1+vt*(size(part,2)-1),size(part,3)) :: maskp         real, dimension(size(part,1),nbmax,size(part,3)) :: sbufl         real, dimension(size(part,1),nbmax,size(part,3)) :: sbufr         real, dimension(size(part,1),nbmax,size(part,3)) :: rbufl         real, dimension(size(part,1),nbmax,size(part,3)) :: rbufr         integer, dimension(size(edges,1),size(edges,2)) :: jsl, jsr         integer, dimension(size(edges,1),size(edges,2)) :: jss         integer, dimension(2*nbmax,size(part,3)) :: ihole         integer :: idimp, npmax, nblok, idps, ntmax         idimp = size(part,1); npmax = size(part,2)         nblok = size(part,3)         idps = size(edges,1)         ntmax = 2*nbmax         if (vt.eq.1) then            call PXMOV2(part,edges,npp,sbufr,sbufl,rbufr,rbufl,ihole,jsr&     &,jsl,jss,ny,kstrt,nvp,idimp,npmax,nblok,idps,nbmax,ntmax,maskp,ier&     &r)         else            call PMOVE2(part,edges,npp,sbufr,sbufl,rbufr,rbufl,ihole,jsr&     &,jsl,jss,ny,kstrt,nvp,idimp,npmax,nblok,idps,nbmax,ntmax,ierr)         endif         end subroutine ipmove2!         subroutine ipsum2(f)         implicit none         real, dimension(:,:) :: f         integer :: nxyp, nblok         real, dimension(size(f,1),size(f,2)) :: g         nxyp = size(f,1)*size(f,2); nblok = 1         call PSUM(f,g,nxyp,nblok)         end subroutine ipsum2!         subroutine ipbcast2(f)         implicit none         real, dimension(:,:) :: f         integer :: nxp         nxp = size(f)         call PBCAST(f,nxp)         end subroutine ipbcast2!         subroutine ipwrite2(f,nx,kyp,iunit,nrec,name,inorder)         implicit none         integer :: nx, kyp, iunit, nrec         integer, optional :: inorder         real, dimension(:,:,:) :: f         character(len=*) :: name         integer :: nxv, order         nxv = size(f,1)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PWRITE2(f(1,1,1),nx,kyp,nxv,iunit,nrec,name)         else            call PWRITE2(f(2,2,1),nx,kyp,nxv,iunit,nrec,name)         endif         end subroutine ipwrite2!         subroutine ipwrdata2(f,nvp,iunit)         implicit none         integer :: nvp, iunit         real, dimension(:,:,:) :: f         integer :: nxv, kyp, nblok         nxv = size(f,1); kyp = size(f,2)         nblok = size(f,3)         call PWRDATA(f,nvp,nxv*kyp,nblok,iunit)         end subroutine ipwrdata2!         subroutine iprddata2(f,nvp,iunit,ierror)         implicit none         integer :: nvp, iunit, ierror         real, dimension(:,:,:) :: f         integer :: nxv, kyp, nblok         nxv = size(f,1); kyp = size(f,2)         nblok = size(f,3)         call PRDDATA(f,nvp,nxv*kyp,nblok,iunit,ierror)         end subroutine iprddata2!         subroutine ipwrrdata2(f,nvp,iunit)         implicit none         integer :: nvp, iunit         real, dimension(:,:,:,:) :: f         integer :: nxv, kyp, nblok         nxv = size(f,1)*size(f,2); kyp = size(f,3)         nblok = size(f,4)         call PWRDATA(f,nvp,nxv*kyp,nblok,iunit)         end subroutine ipwrrdata2!         subroutine iprdrdata2(f,nvp,iunit,ierror)         implicit none         integer :: nvp, iunit, ierror         real, dimension(:,:,:,:) :: f         integer :: nxv, kyp, nblok         nxv = size(f,1)*size(f,2); kyp = size(f,3)         nblok = size(f,4)         call PRDDATA(f,nvp,nxv*kyp,nblok,iunit,ierror)         end subroutine iprdrdata2!         subroutine ipwrcdata2(f,nvp,iunit)         implicit none         integer :: nvp, iunit         complex, dimension(:,:,:,:) :: f         integer :: nxv, kyp, nblok         nxv = size(f,1)*size(f,2); kyp = size(f,3)         nblok = size(f,4)         call PWRDATA(f,nvp,2*nxv*kyp,nblok,iunit)         end subroutine ipwrcdata2!         subroutine iprdcdata2(f,nvp,iunit,ierror)         implicit none         integer :: nvp, iunit, ierror         complex, dimension(:,:,:,:) :: f         integer :: nxv, kyp, nblok         nxv = size(f,1)*size(f,2); kyp = size(f,3)         nblok = size(f,4)         call PRDDATA(f,nvp,2*nxv*kyp,nblok,iunit,ierror)         end subroutine iprdcdata2!      end module p2d