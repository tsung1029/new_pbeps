!-----------------------------------------------------------------------!      module pinit2d!! Fortran90 interface to 2d parallel PIC Fortran77 library pinit2lib.f! written by viktor k. decyk, ucla! copyright 1999, regents of the university of california! update: august 9, 2003!      use globals, only: LINEAR, QUADRATIC, STANDARD, LOOKAHEAD, VECTOR,&     & PERIODIC_2D, DIRICHLET_2D, MIXED_2D      implicit none      private      public :: LINEAR, QUADRATIC, STANDARD, LOOKAHEAD, VECTOR      public :: PERIODIC_2D, DIRICHLET_2D, MIXED_2D      public :: idrun, indx, indy, npx, npy, npxb, npyb, inorder, popt      public :: dopt, djopt, ntw, ntp, ntd, nta, ntv, nts, nustrt, ntr      public :: tend, dt, qme, vtx, vty, vtz, vx0, vy0, vz0       public :: vdx, vdy, vdz, vtdx, vtdy, vtdz      public :: psolve, relativity, omx, omy, omz, ci, ax, ay      public :: movion, npxi, npyi, npxbi, npybi      public :: qmi, rmass, rtempxi, rtempyi, rtempzi, vxi0, vyi0, vzi0      public :: vdxi, vdyi, vdzi, rtempdxi, rtempdyi, rtempdzi, v0, w0      public :: sortime, sortimi, nplot, idpal, ndstyle, itpon, ionoff      public :: pinput2, sendnml, distr, ldistr, sdistr, gdistr, vdistr!! Namelist Input      save! idrun = run identifier      integer :: idrun = 0! indx/indy = exponent which determines length in x/y direction,! where nx=2**indx, ny=2**indy! npx/npy = initial number of particles distributed in x/y direction!     integer :: indx =   5, indy =   6, npx =      96, npy =     192      integer :: indx =   6, indy =   7, npx =     384, npy =     768!     integer :: indx =   7, indy =   8, npx =    1280, npy =    2560! npxb/npyb = initial number of particles in beam in x/y direction      integer :: npxb =   0, npyb =   0!     integer :: npxb =  32, npyb =  64!     integer :: npxb = 128, npyb = 256!     integer :: npxb = 384, npyb = 768! inorder = interpolation order! popt = particle optimization scheme! dopt = charge deposit optimization scheme! djopt = current deposit optimization scheme      integer :: inorder = LINEAR, popt = STANDARD, dopt = LOOKAHEAD      integer :: djopt = STANDARD! ntw = number of time steps between energy diagnostic! ntp = number of time steps between potential diagnostic! ntd = number of time steps between density diagnostic! nta = number of time steps between vector potential diagnostic! ntv = number of time steps between velocity-space diagnostic! nts = number of time steps between phase space diagnostic      integer :: ntw = 1, ntp = 0, ntd = 0, nta = 0, ntv = 0, nts = 0! nustrt = (0,1,2) = this is an (old start,new start,restart)! ntr = number of time steps between restart routine      integer :: nustrt = 1, ntr = 0! tend = time at end of simulation, in units of plasma frequency! dt = time interval between successive calculations      real :: tend =  65.000, dt = 0.2000000e+00! qme = charge on electron, in units of e! vtx/vty/vtz = thermal velocity of electrons in x/y/z direction      real :: qme = -1.0, vtx = 1.0, vty = 1.0, vtz = 1.0! vx0/vy0/vz0 = drift velocity of electrons in x/y/z direction      real :: vx0 = 0.0, vy0 = 0.0, vz0 = 0.0! vdx/vdy/vdz = drift velocity of beam electrons in x/y/z direction      real :: vdx = 0.0, vdy = 0.0, vdz = 0.0! vtdx/vtdy/vtdz = thermal velocity of beam electrons in x/y/z direction      real :: vtdx = 1.0, vtdy = 1.0, vtdz = 1.0! psolve = type of poisson solver = (1,2,3)      integer :: psolve = PERIODIC_2D! relativity = (no,yes) = (0,1) = relativity is used      integer :: relativity = 0! omx/omy/omz = magnetic field electron cyclotron frequency in x/y/z       real :: omx = 0.0, omy = 0.0, omz = 0.0! ci = reciprical of velocity of light      real :: ci = 1.0! ax/ay = half-width of particle in x/y direction!     real :: ax = .866667, ay = .866667      real :: ax = .912871, ay = .912871! movion = (0,1) = (no,yes) move the ions! npxi/npyi = initial number of ions distributed in x/y/z direction      integer :: movion = 0, npxi =  384, npyi =  768! npxbi/npybi = initial number of ions in beam in x/y/z direction      integer :: npxbi =   0, npybi =   0! qmi = charge on ion, in units of 3! rmass = ion/electron mass ratio      real :: qmi = 1.0, rmass = 100.0! rtempxi/rtempyi/rtempzi = electron/ion temperature ratio of background! ions in x/y/z direction      real :: rtempxi = 1.0, rtempyi = 1.0, rtempzi = 1.0! vxi0/vyi0/vzi0 = drift velocity of ions in x/y/z direction      real :: vxi0 = 0.0, vyi0 = 0.0, vzi0 = 0.0! vdxi/vdyi/vdzi = drift velocity of beam ions in x/y/z direction      real :: vdxi = 0.0, vdyi = 0.0, vdzi = 0.0! rtempdxi/rtempdyi/rtempdzi = electron/ion temperature ratio of beam! ions in x/y/z direction      real :: rtempdxi = 1.0, rtempdyi = 1.0, rtempdzi = 1.0! v0 = external pump strength, in units vos/vthermal! w0 = external pump frequency, in units of wpe      real :: v0 = 0.0, w0 = 0.0! sortime = number of time steps between electron sorting! sortimi = number of time steps between ion sorting      integer :: sortime = 50, sortimi = 250! nplot = maximum number of plots per page! idpal = palette id number: 1 = cold/hot, 2 = color wheel, 3 = rainbow! ndstyle = (1,2,3) = display (color map,contour plot,both)      integer :: nplot = 4, idpal = 1, ndstyle = 1! itpon = time when external pump is turned on (-1=never)! ionoff = time when ions are frozen and their charge saved (-1=never)      integer :: itpon = -1, ionoff = -1! define namelist      namelist /pinput2/ idrun, indx, indy, npx, npy, npxb, npyb,       &     &inorder, popt, dopt, djopt, ntw, ntp, ntd, nta, ntv, nts, nustrt, &     &ntr, tend, dt, qme, vtx, vty, vtz, vx0, vy0, vz0, vdx, vdy, vdz,  &     &vtdx, vtdy, vtdz, psolve, relativity, omx, omy, omz, ci, ax, ay,  &     &movion, npxi, npyi, npxbi, npybi, qmi, rmass, rtempxi, rtempyi,   &     &rtempzi, vxi0, vyi0, vzi0, vdxi, vdyi, vdzi, rtempdxi, rtempdyi,  &     &rtempdzi, v0, w0, sortime, sortimi, nplot, idpal, ndstyle, itpon, &     &ionoff!! define interface to original Fortran77 procedures!      interface         subroutine PISTR2(part,edges,npp,nps,vtx,vty,vdx,vdy,npx,npy,nx&     &,ny,idimp,npmax,nblok,idps,ipbc,ierr)         implicit none         integer :: npx, npy, nx, ny, idimp, npmax, nblok, idps, ipbc         integer :: ierr         real :: vtx, vty, vdx, vdy         real, dimension(idimp,npmax,nblok) :: part         real, dimension(idps,nblok) :: edges         integer, dimension(nblok) :: npp, nps         end subroutine      end interface      interface         subroutine PVISTR2(part,npp,nps,vtx,vty,vdx,vdy,npx,npy,nx,ny,i&     &dimp,npmax,nblok,ipbc,vranx,vrany,kstrt,nvp,ndv,nvrp,ierr)         implicit none         integer :: npx, npy, nx, ny, idimp, npmax, nblok, ipbc, kstrt         integer :: nvp, ndv, nvrp, ierr         real :: vtx, vty, vdx, vdy         real, dimension(idimp,npmax,nblok) :: part         integer, dimension(nblok) :: npp, nps         double precision, dimension(nvrp,nblok) :: vranx, vrany         end subroutine      end interface      interface         subroutine PISTR2H(part,edges,npp,nps,vtx,vty,vtz,vdx,vdy,vdz,n&     &px,npy,nx,ny,idimp,npmax,nblok,idps,ipbc,ierr)         implicit none         integer :: npx, npy, nx, ny, idimp, npmax, nblok, idps, ipbc         integer :: ierr         real :: vtx, vty, vtz, vdx, vdy, vdz         real, dimension(idimp,npmax,nblok) :: part         real, dimension(idps,nblok) :: edges         integer, dimension(nblok) :: npp, nps         end subroutine      end interface      interface         subroutine PVISTR2H(part,npp,nps,vtx,vty,vtz,vdx,vdy,vdz,npx,np&     &y,nx,ny,idimp,npmax,nblok,ipbc,vranx,vrany,vranz,kstrt,nvp,ndv,nvr&     &p,ierr)         implicit none         integer :: npx, npy, nx, ny, idimp, npmax, nblok, ipbc, kstrt         integer :: nvp, ndv, nvrp, ierr         real :: vtx, vty, vtz, vdx, vdy, vdz         real, dimension(idimp,npmax,nblok) :: part         integer, dimension(nblok) :: npp, nps         double precision, dimension(nvrp,nblok) :: vranx, vrany, vranz         end subroutine      end interface      interface         subroutine PLDISTR2(part,nps,anlx,anly,npx,npy,nx,ny,idimp,npma&     &x,nblok,kstrt,nvp,ipbc,ierr)         implicit none         integer :: npx, npy, nx, ny, idimp, npmax, nblok, kstrt, nvp         integer :: ipbc, ierr         real :: anlx, anly         real, dimension(idimp,npmax,nblok) :: part         integer, dimension(nblok) :: nps         end subroutine      end interface      interface         subroutine PFDISTR2X(part,nps,fnx,argx1,argx2,argx3,fny,argy1,a&     &rgy2,argy3,npx,npy,nx,ny,idimp,npmax,nblok,kstrt,nvp,ipbc,ierr)         implicit none         integer :: npx, npy, nx, ny, idimp, npmax, nblok, kstrt, nvp         integer :: ipbc, ierr         real :: argx1, argx2, argx3, argy1, argy2, argy3         real, dimension(idimp,npmax,nblok) :: part         integer, dimension(nblok) :: nps         real, external :: fnx, fny         end subroutine      end interface      interface         subroutine PVDISTR2(part,npp,nps,vtx,vty,vdx,vdy,npx,npy,idimp,&     &npmax,nblok,kstrt,nvp,ierr)         implicit none         integer :: npx, npy, idimp, npmax, nblok, kstrt, nvp, ierr         real :: vtx, vty, vdx, vdy         real, dimension(idimp,npmax,nblok) :: part         integer, dimension(nblok) :: npp, nps         end subroutine      end interface      interface         subroutine PVVISTR2(part,npp,nps,vtx,vty,vdx,vdy,npx,npy,idimp,&     &npmax,nblok,vranx,vrany,kstrt,nvp,ndv,nvrp,ierr)         implicit none         integer :: npx, npy, idimp, npmax, nblok, kstrt, nvp, ndv, nvrp         integer :: ierr         real :: vtx, vty, vdx, vdy         real, dimension(idimp,npmax,nblok) :: part         integer, dimension(nblok) :: npp, nps         double precision, dimension(nvrp,nblok) :: vranx, vrany         end subroutine      end interface      interface         subroutine PVDISTR2H(part,npp,nps,vtx,vty,vtz,vdx,vdy,vdz,npx,n&     &py,idimp,npmax,nblok,kstrt,nvp,ierr)         implicit none         integer :: npx, npy, idimp, npmax, nblok, kstrt, nvp, ierr         real :: vtx, vty, vtz, vdx, vdy, vdz         real, dimension(idimp,npmax,nblok) :: part         integer, dimension(nblok) :: npp, nps         end subroutine      end interface      interface         subroutine PVVISTR2H(part,npp,nps,vtx,vty,vtz,vdx,vdy,vdz,npx,n&     &py,idimp,npmax,nblok,vranx,vrany,vranz,kstrt,nvp,ndv,nvrp,ierr)         implicit none         integer :: npx, npy, idimp, npmax, nblok, kstrt, nvp, ndv, nvrp         integer :: ierr         real :: vtx, vty, vtz, vdx, vdy, vdz         real, dimension(idimp,npmax,nblok) :: part         integer, dimension(nblok) :: npp, nps         double precision, dimension(nvrp,nblok) :: vranx, vrany, vranz         end subroutine      end interface      interface         subroutine PBDISTR2L(part,bx,by,bz,npp,noff,qbm,nx,ny,idimp,npm&     &ax,nblok,nxv,nypmx)         implicit none         integer :: nx, ny, idimp, npmax, nblok, nxv, nypmx         real :: qbm         real, dimension(idimp,npmax,nblok) :: part         real, dimension(nxv,nypmx,nblok):: bx, by, bz         integer, dimension(nblok) :: npp, noff         end subroutine      end interface      interface         subroutine PGBDISTR2L(part,bxy,npp,noff,qbm,nx,ny,idimp,npmax,n&     &blok,nxv,nypmx,ipbc)         implicit none         integer :: nx, ny, idimp, npmax, nblok, nxv, nypmx, ipbc         real :: qbm         real, dimension(idimp,npmax,nblok) :: part         real :: bxy         integer, dimension(nblok) :: npp, noff         end subroutine      end interface      interface         subroutine PGBZDISTR2L(part,bz,npp,noff,qbm,nx,ny,idimp,npmax,n&     &blok,nxv,nypmx,ipbc)         implicit none         integer :: nx, ny, idimp, npmax, nblok, nxv, nypmx, ipbc         real :: qbm         real, dimension(idimp,npmax,nblok) :: part         real :: bz         integer, dimension(nblok) :: npp, noff         end subroutine      end interface      interface         subroutine PGRBDISTR2L(part,bxy,npp,noff,qbm,ci,nx,ny,idimp,npm&     &ax,nblok,nxv,nypmx,ipbc)         implicit none         integer :: nx, ny, idimp, npmax, nblok, nxv, nypmx, ipbc         real :: qbm, ci         real, dimension(idimp,npmax,nblok) :: part         real :: bxy         integer, dimension(nblok) :: npp, noff         end subroutine      end interface      interface         subroutine PGRBZDISTR2L(part,bz,npp,noff,qbm,ci,nx,ny,idimp,npm&     &ax,nblok,nxv,nypmx,ipbc)         implicit none         integer :: nx, ny, idimp, npmax, nblok, nxv, nypmx, ipbc         real :: qbm, ci         real, dimension(idimp,npmax,nblok) :: part         real :: bz         integer, dimension(nblok) :: npp, noff         end subroutine      end interface!! define generic interfaces to Fortran90 library!      interface distr         module procedure ipistr2         module procedure ipistrh2         module procedure ibpistr2         module procedure irbpistr2      end interface!      interface ldistr         module procedure ipldistr2      end interface!      interface sdistr         module procedure ipfsdistr2      end interface!      interface gdistr         module procedure ipfgdistr2      end interface!      interface vdistr         module procedure ipvdistr2         module procedure ipvdistrh2      end interface!      interface sendnml         module procedure sendnml2      end interface!! define Fortran90 interface functions to Fortran77 library!      contains!         subroutine sendnml2()! this subroutine packs 2d namelist variables into a double precision! buffer and broadcasts them to other nodes         integer, parameter :: lenml = 70         double precision, dimension(lenml) :: ddata! pack data         ddata(1) = idrun; ddata(2) = indx; ddata(3) = indy         ddata(4) = npx; ddata(5) = npy         ddata(6) = npxb; ddata(7) = npyb         ddata(8) = inorder; ddata(9) = popt; ddata(10) = dopt         ddata(11) = djopt; ddata(12) = ntw; ddata(13) = ntp         ddata(14) = ntd; ddata(15) = nta; ddata(16) = ntv         ddata(17) = nts; ddata(18) = nustrt; ddata(19) = ntr         ddata(20) = tend; ddata(21) = dt; ddata(22) = qme         ddata(23) = vtx; ddata(24) = vty; ddata(25) = vtz         ddata(26) = vx0; ddata(27) = vy0; ddata(28) = vz0         ddata(29) = vdx; ddata(30) = vdy; ddata(31) = vdz         ddata(32) = vtdx; ddata(33) = vtdy; ddata(34) = vtdz         ddata(35) = psolve; ddata(36) = relativity         ddata(37) = omx; ddata(38) = omy; ddata(39) = omz         ddata(40) = ci; ddata(41) = ax; ddata(42) = ay         ddata(43) = movion; ddata(44) = npxi; ddata(45) = npyi         ddata(46) = npxbi; ddata(47) = npybi         ddata(48) = qmi; ddata(49) = rmass         ddata(50) = rtempxi; ddata(51) = rtempyi; ddata(52) = rtempzi         ddata(53) = vxi0; ddata(54) = vyi0; ddata(55) = vzi0         ddata(56) = vdxi; ddata(57) = vdyi; ddata(58) = vdzi         ddata(59) = rtempdxi; ddata(60) = rtempdyi;         ddata(61) = rtempdzi; ddata(62) = v0; ddata(63) = w0         ddata(64) = sortime; ddata(65) = sortimi         ddata(66) = nplot; ddata(67) = idpal; ddata(68) = ndstyle         ddata(69) = itpon; ddata(70) = ionoff! broadcast data         call PBDCAST(ddata,lenml)! unpack data         idrun = ddata(1); indx = ddata(2); indy = ddata(3)         npx = ddata(4); npy = ddata(5)         npxb = ddata(6); npyb = ddata(7)         inorder = ddata(8); popt = ddata(9); dopt = ddata(10)         djopt = ddata(11); ntw = ddata(12); ntp = ddata(13)         ntd = ddata(14); nta = ddata(15); ntv=ddata(16)         nts = ddata(17); nustrt = ddata(18); ntr = ddata(19)         tend = ddata(20); dt = ddata(21); qme = ddata(22)         vtx = ddata(23); vty = ddata(24); vtz = ddata(25)         vx0 = ddata(26); vy0 = ddata(27); vz0 = ddata(28)         vdx = ddata(29); vdy = ddata(30); vdz = ddata(31)         vtdx = ddata(32); vtdy = ddata(33); vtdz = ddata(34)         psolve = ddata(35); relativity = ddata(36)         omx = ddata(37); omy = ddata(38); omy = ddata(39)         ci = ddata(40); ax = ddata(41); ay = ddata(42)         movion = ddata(43); npxi = ddata(44); npyi = ddata(45)         npxbi = ddata(46); npybi = ddata(47)         qmi = ddata(48); rmass = ddata(49)         rtempxi = ddata(50); rtempyi = ddata(51); rtempzi = ddata(52)         vxi0 = ddata(53); vyi0 = ddata(54); vzi0 = ddata(55)         vdxi = ddata(56); vdyi = ddata(57); vdzi = ddata(58)         rtempdxi = ddata(59); rtempdyi = ddata(60)         rtempdzi = ddata(61); v0 = ddata(62); w0 = ddata(63)         sortime = ddata(64); sortimi = ddata(65)         nplot = ddata(66); idpal = ddata(67); ndstyle = ddata(68)         itpon = ddata(69); ionoff = ddata(70)         end subroutine sendnml2!         subroutine ipistr2(part,edges,npp,nps,vtx,vty,vdx,vdy,npx,npy,n&     &x,ny,ipbc)         implicit none         integer :: npx, npy, nx, ny, ipbc         real :: vtx, vty, vdx, vdy         real, dimension(:,:,:) :: part         real, dimension(:,:) :: edges         integer, dimension(:) :: npp, nps         integer :: idimp, npmax, nblok, idps, ierr         idimp = size(part,1); npmax = size(part,2)         nblok = size(part,3); idps = size(edges,1)         call PISTR2(part,edges,npp,nps,vtx,vty,vdx,vdy,npx,npy,nx,ny,id&     &imp,npmax,nblok,idps,ipbc,ierr)         end subroutine ipistr2!         subroutine ipistrh2(part,edges,npp,nps,vtx,vty,vtz,vdx,vdy,vdz,&     &npx,npy,nx,ny,ipbc)         implicit none         integer :: npx, npy, nx, ny, ipbc         real :: vtx, vty, vtz, vdx, vdy, vdz         real, dimension(:,:,:) :: part         real, dimension(:,:) :: edges         integer, dimension(:) :: npp, nps         integer :: idimp, npmax, nblok, idps, ierr         idimp = size(part,1); npmax = size(part,2)         nblok = size(part,3); idps = size(edges,1)         call PISTR2H(part,edges,npp,nps,vtx,vty,vtz,vdx,vdy,vdz,npx,npy&     &,nx,ny,idimp,npmax,nblok,idps,ipbc,ierr)         end subroutine ipistrh2!         subroutine ipldistr2(part,nps,anlx,anly,npx,npy,nx,ny,kstrt,nvp&     &,ipbc)         implicit none         integer :: npx, npy, nx, ny, kstrt, nvp, ipbc         real :: anlx, anly         real, dimension(:,:,:) :: part         integer, dimension(:) :: nps         integer :: idimp, npmax, nblok, ierr         idimp = size(part,1); npmax = size(part,2)         nblok = size(part,3)         call PLDISTR2(part,nps,anlx,anly,npx,npy,nx,ny,idimp,npmax,nblo&     &k,kstrt,nvp,ipbc,ierr)         end subroutine ipldistr2!         subroutine ipfsdistr2(part,nps,ansx,dkx,phsx,ansy,dky,phsy,npx,&     &npy,nx,ny,kstrt,nvp,ipbc)! sinusoidal density         implicit none         integer :: npx, npy, nx, ny, kstrt, nvp, ipbc         real :: ansx, dkx, phsx, ansy, dky, phsy         real, dimension(:,:,:) :: part         integer, dimension(:) :: nps         integer :: idimp, npmax, nblok, ierr         real, external :: FSDISTR1         idimp = size(part,1); npmax = size(part,2)         nblok = size(part,3)         call PFDISTR2X(part,nps,FSDISTR1,ansx,dkx,phsx,FSDISTR1,ansy,dk&     &y,phsy,npx,npy,nx,ny,idimp,npmax,nblok,kstrt,nvp,ipbc,ierr)         end subroutine ipfsdistr2!         subroutine ipfgdistr2(part,nps,angx,x0,wx,angy,y0,wy,npx,npy,nx&     &,ny,kstrt,nvp,ipbc)! gaussian density         implicit none         integer :: npx, npy, nx, ny, kstrt, nvp, ipbc         real :: angx, x0, wx, angy, y0, wy         real, dimension(:,:,:) :: part         integer, dimension(:) :: nps         integer :: idimp, npmax, nblok, ierr         real wix, wiy         real, external :: FGDISTR1         idimp = size(part,1); npmax = size(part,2)         nblok = size(part,3)         wix = 0.         if (wx.ne.0.) wix = 1.0/wx         wiy = 0.         if (wy.ne.0.) wiy = 1.0/wy         call PFDISTR2X(part,nps,FGDISTR1,angx,wix,x0,FGDISTR1,angy,wiy,&     &y0,npx,npy,nx,ny,idimp,npmax,nblok,kstrt,nvp,ipbc,ierr)         end subroutine ipfgdistr2!         subroutine ipvdistr2(part,npp,nps,vtx,vty,vdx,vdy,npx,npy,kstrt&     &,nvp)         implicit none         integer :: npx, npy, kstrt, nvp         real :: vtx, vty, vdx, vdy         real, dimension(:,:,:) :: part         integer, dimension(:) :: npp, nps         integer :: idimp, npmax, nblok, ierr         idimp = size(part,1); npmax = size(part,2)         nblok = size(part,3)         call PVDISTR2(part,npp,nps,vtx,vty,vdx,vdy,npx,npy,idimp,npmax,&     &nblok,kstrt,nvp,ierr)         end subroutine ipvdistr2!         subroutine ipvdistrh2(part,npp,nps,vtx,vty,vtz,vdx,vdy,vdz,npx,&     &npy,kstrt,nvp)         implicit none         integer :: npx, npy, kstrt, nvp         real :: vtx, vty, vtz, vdx, vdy, vdz         real, dimension(:,:,:) :: part         integer, dimension(:) :: npp, nps         integer :: idimp, npmax, nblok, ierr         idimp = size(part,1); npmax = size(part,2)         nblok = size(part,3)         call PVDISTR2H(part,npp,nps,vtx,vty,vtz,vdx,vdy,vdz,npx,npy,idi&     &mp,npmax,nblok,kstrt,nvp,ierr)         end subroutine ipvdistrh2!         subroutine ibpistr2(part,bxy,npp,noff,qbm,nx,ny,ipbc,inorder)         implicit none         integer :: nx, ny, ipbc         integer, optional :: inorder         real :: qbm         real, dimension(:,:,:) :: part         real, dimension(:,:,:,:) :: bxy         integer, dimension(:) :: npp, noff         integer :: idimp, npmax, nblok, nxv, nypmx, order         idimp = size(part,1); npmax = size(part,2)         nblok = size(part,3)         nxv = size(bxy,2); nypmx = size(bxy,3)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PGBDISTR2L(part,bxy(1,1,1,1),npp,noff,qbm,nx,ny,idimp,n&     &pmax,nblok,nxv,nypmx,ipbc)         else            call PGBDISTR2L(part,bxy(1,2,2,1),npp,noff,qbm,nx,ny,idimp,n&     &pmax,nblok,nxv,nypmx,ipbc)         endif         end subroutine ibpistr2!         subroutine irbpistr2(part,bxy,npp,noff,qbm,ci,nx,ny,ipbc,inorde&     &r)         implicit none         integer :: nx, ny, ipbc         integer, optional :: inorder         real :: qbm, ci         real, dimension(:,:,:) :: part         real, dimension(:,:,:,:) :: bxy         integer, dimension(:) :: npp, noff         integer :: idimp, npmax, nblok, nxv, nypmx, order         idimp = size(part,1); npmax = size(part,2)         nblok = size(part,3)         nxv = size(bxy,2); nypmx = size(bxy,3)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PGRBDISTR2L(part,bxy(1,1,1,1),npp,noff,qbm,ci,nx,ny,idi&     &mp,npmax,nblok,nxv,nypmx,ipbc)         else            call PGRBDISTR2L(part,bxy(1,2,2,1),npp,noff,qbm,ci,nx,ny,idi&     &mp,npmax,nblok,nxv,nypmx,ipbc)         endif         end subroutine irbpistr2!      end module pinit2d