!-----------------------------------------------------------------------!      module pinit2d!! Fortran90 interface to 2d parallel PIC Fortran77 library pinit2lib.f! written by viktor k. decyk, ucla! copyright 1999, regents of the university of california! update: february 16, 2008!      use globals, only: LINEAR, QUADRATIC, STANDARD, LOOKAHEAD, VECTOR,&     & PERIODIC_2D, DIRICHLET_2D, DIRICHLET_PERIODIC_2D, VACUUM_2D,     &     &VACUUM_3D, NEUMANN_2D      implicit none      private      public :: LINEAR, QUADRATIC, STANDARD, LOOKAHEAD, VECTOR      public :: PERIODIC_2D, DIRICHLET_2D, DIRICHLET_PERIODIC_2D      public :: VACUUM_2D, VACUUM_3D, NEUMANN_2D      public :: idrun, indx, indy, npx, npy, npxb, npyb, inorder, popt      public :: dopt, djopt, ntw, ntp, ntd, nta, ntv, nts, nustrt, ntr      public :: tend, dt, qme, vtx, vty, vtz, vx0, vy0, vz0       public :: vdx, vdy, vdz, vtdx, vtdy, vtdz      public :: psolve, relativity, omx, omy, omz, ci, ax, ay      public :: movion, npxi, npyi, npxbi, npybi      public :: qmi, rmass, rtempxi, rtempyi, rtempzi, vxi0, vyi0, vzi0      public :: vdxi, vdyi, vdzi, rtempdxi, rtempdyi, rtempdzi, v0, w0      public :: sortime, sortimi, nplot, idpal, ndstyle, sntasks      public :: itpon, ionoff, nsrand, ndprof, nsrandi, ndprofi      public :: ampdx, scaledx, shiftdx, ampdy, scaledy, shiftdy      public :: ampdxi, scaledxi, shiftdxi, ampdyi, scaledyi, shiftdyi      public :: imbalance, mpimon      public :: pinput2, sendnml, distr, ldistr, fdistr, vdistr, fedges!! Namelist Input      save! idrun = run identifier      integer :: idrun = 0! indx/indy = exponent which determines length in x/y direction,! where nx=2**indx, ny=2**indy! npx/npy = initial number of particles distributed in x/y direction!     integer :: indx =   5, indy =   6, npx =      96, npy =     192      integer :: indx =   6, indy =   7, npx =     384, npy =     768!     integer :: indx =   7, indy =   8, npx =    1280, npy =    2560! npxb/npyb = initial number of particles in beam in x/y direction      integer :: npxb =   0, npyb =   0!     integer :: npxb =  32, npyb =  64!     integer :: npxb = 128, npyb = 256!     integer :: npxb = 384, npyb = 768! inorder = interpolation order! popt = particle optimization scheme! dopt = charge deposit optimization scheme! djopt = current deposit optimization scheme      integer :: inorder = LINEAR, popt = STANDARD, dopt = LOOKAHEAD      integer :: djopt = STANDARD! ntw = number of time steps between energy diagnostic! ntp = number of time steps between potential diagnostic! ntd = number of time steps between density diagnostic! nta = number of time steps between vector potential diagnostic! ntv = number of time steps between velocity-space diagnostic! nts = number of time steps between phase space diagnostic      integer :: ntw = 1, ntp = 0, ntd = 0, nta = 0, ntv = 0, nts = 0! nustrt = (0,1,2) = this is an (old start,new start,restart)! ntr = number of time steps between restart routine      integer :: nustrt = 1, ntr = 0! tend = time at end of simulation, in units of plasma frequency! dt = time interval between successive calculations      real :: tend =  65.000, dt = 0.2000000e+00! qme = charge on electron, in units of e! vtx/vty/vtz = thermal velocity of electrons in x/y/z direction      real :: qme = -1.0, vtx = 1.0, vty = 1.0, vtz = 1.0! vx0/vy0/vz0 = drift velocity of electrons in x/y/z direction      real :: vx0 = 0.0, vy0 = 0.0, vz0 = 0.0! vdx/vdy/vdz = drift velocity of beam electrons in x/y/z direction      real :: vdx = 0.0, vdy = 0.0, vdz = 0.0! vtdx/vtdy/vtdz = thermal velocity of beam electrons in x/y/z direction      real :: vtdx = 1.0, vtdy = 1.0, vtdz = 1.0! psolve = type of poisson solver = (1,2,3)      integer :: psolve = PERIODIC_2D! relativity = (no,yes) = (0,1) = relativity is used      integer :: relativity = 0! omx/omy/omz = magnetic field electron cyclotron frequency in x/y/z       real :: omx = 0.0, omy = 0.0, omz = 0.0! ci = reciprical of velocity of light      real :: ci = 1.0! ax/ay = half-width of particle in x/y direction!     real :: ax = .866667, ay = .866667      real :: ax = .912871, ay = .912871! movion = (0,1) = (no,yes) move the ions! npxi/npyi = initial number of ions distributed in x/y/z direction      integer :: movion = 0, npxi =  384, npyi =  768! npxbi/npybi = initial number of ions in beam in x/y/z direction      integer :: npxbi =   0, npybi =   0! qmi = charge on ion, in units of 3! rmass = ion/electron mass ratio      real :: qmi = 1.0, rmass = 100.0! rtempxi/rtempyi/rtempzi = electron/ion temperature ratio of background! ions in x/y/z direction      real :: rtempxi = 1.0, rtempyi = 1.0, rtempzi = 1.0! vxi0/vyi0/vzi0 = drift velocity of ions in x/y/z direction      real :: vxi0 = 0.0, vyi0 = 0.0, vzi0 = 0.0! vdxi/vdyi/vdzi = drift velocity of beam ions in x/y/z direction      real :: vdxi = 0.0, vdyi = 0.0, vdzi = 0.0! rtempdxi/rtempdyi/rtempdzi = electron/ion temperature ratio of beam! ions in x/y/z direction      real :: rtempdxi = 1.0, rtempdyi = 1.0, rtempdzi = 1.0! v0 = external pump strength, in units vos/vthermal! w0 = external pump frequency, in units of wpe      real :: v0 = 0.0, w0 = 0.0! sortime = number of time steps between electron sorting! sortimi = number of time steps between ion sorting      integer :: sortime = 50, sortimi = 250! nplot = maximum number of plots per page! idpal = palette id number: 1 = cold/hot, 2 = color wheel, 3 = rainbow! ndstyle = (1,2,3) = display (color map,contour plot,both)      integer :: nplot = 4, idpal = 1, ndstyle = 1! sntasks = (-1,n) = set maximum number of tasks (-1 = number of cpus-1)      integer :: sntasks = -1! itpon = time when external pump is turned on (-1=never)! ionoff = time when ions are frozen and their charge saved (-1=never)      integer :: itpon = -1, ionoff = -1! nsrand = (0,1) = (no,yes) randomize spatially positions locally! ndprof = profile type (uniform=0,linear=1,sinusoidal=2,gaussian=3,!                        hyperbolic secant squared=4)! nsrandi = (0,1) = (no,yes) randomize spatially ion positions locally! ndprofi = ion profile (uniform=0,linear=1,sinusoidal=2,gaussian=3,!                        hyperbolic secant squared=4)      integer :: nsrand = 0, ndprof = 0, nsrandi = 0, ndprofi = 0! ampdx/ampdx = amplitude of density compared to uniform in x/y! scaledx/scaledx = scale length for spatial coordinate in x/y! shiftdx/shiftdx = shift of spatial coordinate in x/y      real :: ampdx = 0.0, scaledx = 0.0, shiftdx = 0.0      real :: ampdy = 0.0, scaledy = 0.0, shiftdy = 0.0! ampdxi/ampdxi = amplitude of ion density compared to uniform in x/y! scaledxi/scaledxi = scale length for spatial ion coordinate in x/y! shiftdxi/shiftdxi = shift of spatial ion coordinate in x/y      real :: ampdxi = 0.0, scaledxi = 0.0, shiftdxi = 0.0      real :: ampdyi = 0.0, scaledyi = 0.0, shiftdyi = 0.0! imbalance = load imbalance fraction repartition trigger! (< 0.  to suppress repartion)      real :: imbalance = .08! mpimon = (0,1,2) = (suppress,display,display and log) mpi messages      integer :: mpimon = 1! define namelist      namelist /pinput2/ idrun, indx, indy, npx, npy, npxb, npyb,       &     &inorder, popt, dopt, djopt, ntw, ntp, ntd, nta, ntv, nts, nustrt, &     &ntr, tend, dt, qme, vtx, vty, vtz, vx0, vy0, vz0, vdx, vdy, vdz,  &     &vtdx, vtdy, vtdz, psolve, relativity, omx, omy, omz, ci, ax, ay,  &     &movion, npxi, npyi, npxbi, npybi, qmi, rmass, rtempxi, rtempyi,   &     &rtempzi, vxi0, vyi0, vzi0, vdxi, vdyi, vdzi, rtempdxi, rtempdyi,  &     &rtempdzi, v0, w0, sortime, sortimi, nplot, idpal, ndstyle,        &     &sntasks, itpon, ionoff, nsrand, ndprof, ampdx, scaledx, shiftdx,  &     &ampdy, scaledy,  shiftdy, nsrandi, ndprofi, ampdxi, scaledxi,     &     &shiftdxi, ampdyi, scaledyi, shiftdyi, imbalance, mpimon!! define interface to original Fortran77 procedures!      interface         subroutine PISTR2(part,edges,npp,nps,vtx,vty,vdx,vdy,npx,npy,nx&     &,ny,idimp,npmax,nblok,idps,ipbc,ierr)         implicit none         integer :: npx, npy, nx, ny, idimp, npmax, nblok, idps, ipbc         integer :: ierr         real :: vtx, vty, vdx, vdy         real, dimension(idimp,npmax,nblok) :: part         real, dimension(idps,nblok) :: edges         integer, dimension(nblok) :: npp, nps         end subroutine      end interface      interface         subroutine PVISTR2(part,npp,nps,vtx,vty,vdx,vdy,npx,npy,nx,ny,i&     &dimp,npmax,nblok,ipbc,vranx,vrany,kstrt,nvp,ndv,nvrp,ierr)         implicit none         integer :: npx, npy, nx, ny, idimp, npmax, nblok, ipbc, kstrt         integer :: nvp, ndv, nvrp, ierr         real :: vtx, vty, vdx, vdy         real, dimension(idimp,npmax,nblok) :: part         integer, dimension(nblok) :: npp, nps         double precision, dimension(nvrp,nblok) :: vranx, vrany         end subroutine      end interface      interface         subroutine PISTR2H(part,edges,npp,nps,vtx,vty,vtz,vdx,vdy,vdz,n&     &px,npy,nx,ny,idimp,npmax,nblok,idps,ipbc,ierr)         implicit none         integer :: npx, npy, nx, ny, idimp, npmax, nblok, idps, ipbc         integer :: ierr         real :: vtx, vty, vtz, vdx, vdy, vdz         real, dimension(idimp,npmax,nblok) :: part         real, dimension(idps,nblok) :: edges         integer, dimension(nblok) :: npp, nps         end subroutine      end interface      interface         subroutine PVISTR2H(part,npp,nps,vtx,vty,vtz,vdx,vdy,vdz,npx,np&     &y,nx,ny,idimp,npmax,nblok,ipbc,vranx,vrany,vranz,kstrt,nvp,ndv,nvr&     &p,ierr)         implicit none         integer :: npx, npy, nx, ny, idimp, npmax, nblok, ipbc, kstrt         integer :: nvp, ndv, nvrp, ierr         real :: vtx, vty, vtz, vdx, vdy, vdz         real, dimension(idimp,npmax,nblok) :: part         integer, dimension(nblok) :: npp, nps         double precision, dimension(nvrp,nblok) :: vranx, vrany, vranz         end subroutine      end interface      interface         subroutine PLDISTR2(part,nps,anlx,anly,npx,npy,nx,ny,idimp,npma&     &x,nblok,kstrt,nvp,ipbc,ierr)         implicit none         integer :: npx, npy, nx, ny, idimp, npmax, nblok, kstrt, nvp         integer :: ipbc, ierr         real :: anlx, anly         real, dimension(idimp,npmax,nblok) :: part         integer, dimension(nblok) :: nps         end subroutine      end interface      interface         subroutine PFDISTR2(part,nps,fnx,argx1,argx2,argx3,fny,argy1,ar&     &gy2,argy3,npx,npy,nx,ny,idimp,npmax,nblok,kstrt,nvp,ipbc,ierr)         implicit none         integer :: npx, npy, nx, ny, idimp, npmax, nblok, kstrt, nvp         integer :: ipbc, ierr         real :: argx1, argx2, argx3, argy1, argy2, argy3         real, dimension(idimp,npmax,nblok) :: part         integer, dimension(nblok) :: nps         real, external :: fnx, fny         end subroutine      end interface      interface         subroutine PRDISTR2(part,nps,fnx,argx1,argx2,argx3,fny,argy1,ar&     &gy2,argy3,npx,npy,nx,ny,idimp,npmax,nblok,kstrt,nvp,ipbc)         implicit none         integer :: npx, npy, nx, ny, idimp, npmax, nblok, kstrt, nvp         integer :: ipbc         real :: argx1, argx2, argx3, argy1, argy2, argy3         real, dimension(idimp,npmax,nblok) :: part         integer, dimension(nblok) :: nps         real, external :: fnx, fny         end subroutine      end interface      interface         subroutine PVRDISTR2(part,nps,fnx,argx1,argx2,argx3,fny,argy1,a&     &rgy2,argy3,npx,npy,nx,ny,idimp,npmax,nblok,vranx,vrany,kstrt,nvp,n&     &dv,nvrp,ipbc,ierr)         implicit none         integer :: npx, npy, nx, ny, idimp, npmax, nblok, kstrt, nvp         integer :: ndv, nvrp, ipbc, ierr         real :: argx1, argx2, argx3, argy1, argy2, argy3         real, dimension(idimp,npmax,nblok) :: part         integer, dimension(nblok) :: nps         double precision, dimension(nvrp,nblok) :: vranx, vrany         real, external :: fnx, fny         end subroutine      end interface      interface         subroutine PVDISTR2(part,npp,nps,vtx,vty,vdx,vdy,npx,npy,idimp,&     &npmax,nblok,kstrt,nvp,ierr)         implicit none         integer :: npx, npy, idimp, npmax, nblok, kstrt, nvp, ierr         real :: vtx, vty, vdx, vdy         real, dimension(idimp,npmax,nblok) :: part         integer, dimension(nblok) :: npp, nps         end subroutine      end interface      interface         subroutine PVVISTR2(part,npp,nps,vtx,vty,vdx,vdy,npx,npy,idimp,&     &npmax,nblok,vranx,vrany,kstrt,nvp,ndv,nvrp,ierr)         implicit none         integer :: npx, npy, idimp, npmax, nblok, kstrt, nvp, ndv, nvrp         integer :: ierr         real :: vtx, vty, vdx, vdy         real, dimension(idimp,npmax,nblok) :: part         integer, dimension(nblok) :: npp, nps         double precision, dimension(nvrp,nblok) :: vranx, vrany         end subroutine      end interface      interface         subroutine PVDISTR2H(part,npp,nps,vtx,vty,vtz,vdx,vdy,vdz,npx,n&     &py,idimp,npmax,nblok,kstrt,nvp,ierr)         implicit none         integer :: npx, npy, idimp, npmax, nblok, kstrt, nvp, ierr         real :: vtx, vty, vtz, vdx, vdy, vdz         real, dimension(idimp,npmax,nblok) :: part         integer, dimension(nblok) :: npp, nps         end subroutine      end interface      interface         subroutine PVVISTR2H(part,npp,nps,vtx,vty,vtz,vdx,vdy,vdz,npx,n&     &py,idimp,npmax,nblok,vranx,vrany,vranz,kstrt,nvp,ndv,nvrp,ierr)         implicit none         integer :: npx, npy, idimp, npmax, nblok, kstrt, nvp, ndv, nvrp         integer :: ierr         real :: vtx, vty, vtz, vdx, vdy, vdz         real, dimension(idimp,npmax,nblok) :: part         integer, dimension(nblok) :: npp, nps         double precision, dimension(nvrp,nblok) :: vranx, vrany, vranz         end subroutine      end interface      interface         subroutine PBDISTR2L(part,bx,by,bz,npp,noff,qbm,nx,ny,idimp,npm&     &ax,nblok,nxv,nypmx)         implicit none         integer :: nx, ny, idimp, npmax, nblok, nxv, nypmx         real :: qbm         real, dimension(idimp,npmax,nblok) :: part         real, dimension(nxv,nypmx,nblok):: bx, by, bz         integer, dimension(nblok) :: npp, noff         end subroutine      end interface      interface         subroutine PGBDISTR2L(part,bxy,npp,noff,qbm,nx,ny,idimp,npmax,n&     &blok,nxv,nypmx,ipbc)         implicit none         integer :: nx, ny, idimp, npmax, nblok, nxv, nypmx, ipbc         real :: qbm         real, dimension(idimp,npmax,nblok) :: part         real :: bxy         integer, dimension(nblok) :: npp, noff         end subroutine      end interface      interface         subroutine PGBZDISTR2L(part,bz,npp,noff,qbm,nx,ny,idimp,npmax,n&     &blok,nxv,nypmx,ipbc)         implicit none         integer :: nx, ny, idimp, npmax, nblok, nxv, nypmx, ipbc         real :: qbm         real, dimension(idimp,npmax,nblok) :: part         real :: bz         integer, dimension(nblok) :: npp, noff         end subroutine      end interface      interface         subroutine PGRBDISTR2L(part,bxy,npp,noff,qbm,ci,nx,ny,idimp,npm&     &ax,nblok,nxv,nypmx,ipbc)         implicit none         integer :: nx, ny, idimp, npmax, nblok, nxv, nypmx, ipbc         real :: qbm, ci         real, dimension(idimp,npmax,nblok) :: part         real :: bxy         integer, dimension(nblok) :: npp, noff         end subroutine      end interface      interface         subroutine PGRBZDISTR2L(part,bz,npp,noff,qbm,ci,nx,ny,idimp,npm&     &ax,nblok,nxv,nypmx,ipbc)         implicit none         integer :: nx, ny, idimp, npmax, nblok, nxv, nypmx, ipbc         real :: qbm, ci         real, dimension(idimp,npmax,nblok) :: part         real :: bz         integer, dimension(nblok) :: npp, noff         end subroutine      end interface      interface         subroutine FEDGES2(edges,noff,nyp,fny,arg1,arg2,arg3,ny,nypmin,&     &nypmax,kstrt,nvp,nblok,idps,ipbc)         implicit none         integer :: ny, nypmin, nypmax, kstrt, nvp, nblok, idps, ipbc         real :: arg1, arg2, arg3         real, dimension(idps,nblok) :: edges         integer, dimension(nblok) :: noff, nyp         real, external :: fny         end subroutine      end interface!! define generic interfaces to Fortran90 library!      interface distr         module procedure ipistr2         module procedure ipistrh2         module procedure ibpistr2         module procedure irbpistr2      end interface!      interface ldistr         module procedure ipldistr2      end interface!      interface fdistr         module procedure ipfdistr2      end interface!      interface vdistr         module procedure ipvdistr2         module procedure ipvdistrh2      end interface!      interface fedges         module procedure ifedges2      end interface!      interface sendnml         module procedure sendnml2      end interface!! define Fortran90 interface functions to Fortran77 library!      contains!         subroutine sendnml2()! this subroutine packs 2d namelist variables into a double precision! buffer and broadcasts them to other nodes         integer, parameter :: lenml = 89         double precision, dimension(lenml) :: ddata! pack data         ddata(1) = idrun; ddata(2) = indx; ddata(3) = indy         ddata(4) = npx; ddata(5) = npy         ddata(6) = npxb; ddata(7) = npyb         ddata(8) = inorder; ddata(9) = popt; ddata(10) = dopt         ddata(11) = djopt; ddata(12) = ntw; ddata(13) = ntp         ddata(14) = ntd; ddata(15) = nta; ddata(16) = ntv         ddata(17) = nts; ddata(18) = nustrt; ddata(19) = ntr         ddata(20) = tend; ddata(21) = dt; ddata(22) = qme         ddata(23) = vtx; ddata(24) = vty; ddata(25) = vtz         ddata(26) = vx0; ddata(27) = vy0; ddata(28) = vz0         ddata(29) = vdx; ddata(30) = vdy; ddata(31) = vdz         ddata(32) = vtdx; ddata(33) = vtdy; ddata(34) = vtdz         ddata(35) = psolve; ddata(36) = relativity         ddata(37) = omx; ddata(38) = omy; ddata(39) = omz         ddata(40) = ci; ddata(41) = ax; ddata(42) = ay         ddata(43) = movion; ddata(44) = npxi; ddata(45) = npyi         ddata(46) = npxbi; ddata(47) = npybi         ddata(48) = qmi; ddata(49) = rmass         ddata(50) = rtempxi; ddata(51) = rtempyi; ddata(52) = rtempzi         ddata(53) = vxi0; ddata(54) = vyi0; ddata(55) = vzi0         ddata(56) = vdxi; ddata(57) = vdyi; ddata(58) = vdzi         ddata(59) = rtempdxi; ddata(60) = rtempdyi;         ddata(61) = rtempdzi; ddata(62) = v0; ddata(63) = w0         ddata(64) = sortime; ddata(65) = sortimi         ddata(66) = nplot; ddata(67) = idpal; ddata(68) = ndstyle         ddata(69) = sntasks; ddata(70) = itpon; ddata(71) = ionoff         ddata(72) = nsrand; ddata(73) = ndprof         ddata(74) = nsrandi; ddata(75) = ndprofi         ddata(76) = ampdx; ddata(77) = scaledx; ddata(78) = shiftdx         ddata(79) = ampdy; ddata(80) = scaledy; ddata(81) = shiftdy         ddata(82) = ampdxi; ddata(83) = scaledxi; ddata(84) = shiftdxi         ddata(85) = ampdyi; ddata(86) = scaledyi; ddata(87) = shiftdyi         ddata(88) = imbalance; ddata(89) = mpimon! broadcast data         call PBDCAST(ddata,lenml)! unpack data         idrun = ddata(1); indx = ddata(2); indy = ddata(3)         npx = ddata(4); npy = ddata(5)         npxb = ddata(6); npyb = ddata(7)         inorder = ddata(8); popt = ddata(9); dopt = ddata(10)         djopt = ddata(11); ntw = ddata(12); ntp = ddata(13)         ntd = ddata(14); nta = ddata(15); ntv=ddata(16)         nts = ddata(17); nustrt = ddata(18); ntr = ddata(19)         tend = ddata(20); dt = ddata(21); qme = ddata(22)         vtx = ddata(23); vty = ddata(24); vtz = ddata(25)         vx0 = ddata(26); vy0 = ddata(27); vz0 = ddata(28)         vdx = ddata(29); vdy = ddata(30); vdz = ddata(31)         vtdx = ddata(32); vtdy = ddata(33); vtdz = ddata(34)         psolve = ddata(35); relativity = ddata(36)         omx = ddata(37); omy = ddata(38); omy = ddata(39)         ci = ddata(40); ax = ddata(41); ay = ddata(42)         movion = ddata(43); npxi = ddata(44); npyi = ddata(45)         npxbi = ddata(46); npybi = ddata(47)         qmi = ddata(48); rmass = ddata(49)         rtempxi = ddata(50); rtempyi = ddata(51); rtempzi = ddata(52)         vxi0 = ddata(53); vyi0 = ddata(54); vzi0 = ddata(55)         vdxi = ddata(56); vdyi = ddata(57); vdzi = ddata(58)         rtempdxi = ddata(59); rtempdyi = ddata(60)         rtempdzi = ddata(61); v0 = ddata(62); w0 = ddata(63)         sortime = ddata(64); sortimi = ddata(65)         nplot = ddata(66); idpal = ddata(67); ndstyle = ddata(68)         sntasks = ddata(69); itpon = ddata(70); ionoff = ddata(71)         nsrand = ddata(72); ndprof = ddata(73)         nsrandi = ddata(74); ndprofi = ddata(75)         ampdx = ddata(76); scaledx = ddata(77); shiftdx = ddata(78)         ampdy = ddata(79); scaledy = ddata(80); shiftdy = ddata(81)         ampdxi = ddata(82); scaledxi = ddata(83); shiftdxi = ddata(84)         ampdyi = ddata(85); scaledyi = ddata(86); shiftdyi = ddata(87)         imbalance = ddata(88); mpimon = ddata(89)         end subroutine sendnml2!         subroutine ipistr2(part,edges,npp,nps,vtx,vty,vdx,vdy,npx,npy,n&     &x,ny,ipbc)! calculates initial particle co-ordinates and velocities in 2d! with uniform density and maxwellian velocity with drift         implicit none         integer :: npx, npy, nx, ny, ipbc         real :: vtx, vty, vdx, vdy         real, dimension(:,:,:), pointer :: part         real, dimension(:,:), pointer :: edges         integer, dimension(:), pointer :: npp, nps! local data         integer :: idimp, npmax, nblok, idps, ierr         idimp = size(part,1); npmax = size(part,2)         nblok = size(part,3); idps = size(edges,1)         call PISTR2(part,edges,npp,nps,vtx,vty,vdx,vdy,npx,npy,nx,ny,id&     &imp,npmax,nblok,idps,ipbc,ierr)         end subroutine ipistr2!         subroutine ipistrh2(part,edges,npp,nps,vtx,vty,vtz,vdx,vdy,vdz,&     &npx,npy,nx,ny,ipbc)! calculates initial particle co-ordinates and velocities in 2-1/2d! with uniform density and maxwellian velocity with drift         implicit none         integer :: npx, npy, nx, ny, ipbc         real :: vtx, vty, vtz, vdx, vdy, vdz         real, dimension(:,:,:), pointer :: part         real, dimension(:,:), pointer :: edges         integer, dimension(:), pointer :: npp, nps! local data         integer :: idimp, npmax, nblok, idps, ierr         idimp = size(part,1); npmax = size(part,2)         nblok = size(part,3); idps = size(edges,1)         call PISTR2H(part,edges,npp,nps,vtx,vty,vtz,vdx,vdy,vdz,npx,npy&     &,nx,ny,idimp,npmax,nblok,idps,ipbc,ierr)         end subroutine ipistrh2!         subroutine ipldistr2(part,nps,anlx,anly,npx,npy,nx,ny,kstrt,nvp&     &,ipbc)! calculates initial particle co-ordinates in 2d! with bi-linear density profile         implicit none         integer :: npx, npy, nx, ny, kstrt, nvp, ipbc         real :: anlx, anly         real, dimension(:,:,:), pointer :: part         integer, dimension(:), pointer :: nps! local data         integer :: idimp, npmax, nblok, ierr         idimp = size(part,1); npmax = size(part,2)         nblok = size(part,3)         call PLDISTR2(part,nps,anlx,anly,npx,npy,nx,ny,idimp,npmax,nblo&     &k,kstrt,nvp,ipbc,ierr)         end subroutine ipldistr2!         subroutine ipfdistr2(part,nps,ampx,scalex,shiftx,ampy,scaley,sh&     &ifty,npx,npy,nx,ny,kstrt,nvp,ipbc,ndpro,nsran)! calculates initial particle co-ordinates in 2d! with various density profiles         implicit none         integer :: npx, npy, nx, ny, kstrt, nvp, ipbc, ndpro, nsran         real :: ampx, scalex, shiftx, ampy, scaley, shifty         real, dimension(:,:,:), pointer :: part         integer, dimension(:), pointer :: nps! local data         integer :: idimp, npmax, nblok, ierr         real :: sxi, syi, zero         real, external :: FLDISTR1, FSDISTR1, FGDISTR1, FHDISTR1         idimp = size(part,1); npmax = size(part,2)         nblok = size(part,3)         sxi = 0.         if (scalex /= 0.) sxi = 1.0/scalex         syi = 0.         if (scaley /= 0.) syi = 1.0/scaley         zero = 0.0! uniform density         if (ndpro==0) then            call PFDISTR2(part,nps,FLDISTR1,zero,zero,zero,FLDISTR1,zero&     &,zero,zero,npx,npy,nx,ny,idimp,npmax,nblok,kstrt,nvp,ipbc,ierr)            if (nsran /= 0) then               call PRDISTR2(part,nps,FLDISTR1,zero,zero,zero,FLDISTR1,z&     &ero,zero,zero,npx,npy,nx,ny,idimp,npmax,nblok,kstrt,nvp,ipbc)            endif! linear density         else if (ndpro==1) then            call PFDISTR2(part,nps,FLDISTR1,ampx,sxi,shiftx,FLDISTR1,amp&     &y,syi,shifty,npx,npy,nx,ny,idimp,npmax,nblok,kstrt,nvp,ipbc,ierr)            if (nsran /= 0) then               call PRDISTR2(part,nps,FLDISTR1,ampx,sxi,shiftx,FLDISTR1,&     &ampy,syi,shifty,npx,npy,nx,ny,idimp,npmax,nblok,kstrt,nvp,ipbc)            endif! sinusoidal density         else if (ndpro==2) then            call PFDISTR2(part,nps,FSDISTR1,ampx,sxi,shiftx,FSDISTR1,amp&     &y,syi,shifty,npx,npy,nx,ny,idimp,npmax,nblok,kstrt,nvp,ipbc,ierr)            if (nsran /= 0) then               call PRDISTR2(part,nps,FSDISTR1,ampx,sxi,shiftx,FSDISTR1,&     &ampy,syi,shifty,npx,npy,nx,ny,idimp,npmax,nblok,kstrt,nvp,ipbc)            endif! gaussian density         else if (ndpro==3) then            call PFDISTR2(part,nps,FGDISTR1,ampx,sxi,shiftx,FGDISTR1,amp&     &y,syi,shifty,npx,npy,nx,ny,idimp,npmax,nblok,kstrt,nvp,ipbc,ierr)            if (nsran /= 0) then               call PRDISTR2(part,nps,FGDISTR1,ampx,sxi,shiftx,FGDISTR1,&     &ampy,syi,shifty,npx,npy,nx,ny,idimp,npmax,nblok,kstrt,nvp,ipbc)            endif! hyperbolic secant squared density         else if (ndpro==4) then            call PFDISTR2(part,nps,FHDISTR1,ampx,sxi,shiftx,FHDISTR1,amp&     &y,syi,shifty,npx,npy,nx,ny,idimp,npmax,nblok,kstrt,nvp,ipbc,ierr)            if (nsran /= 0) then               call PRDISTR2(part,nps,FHDISTR1,ampx,sxi,shiftx,FHDISTR1,&     &ampy,syi,shifty,npx,npy,nx,ny,idimp,npmax,nblok,kstrt,nvp,ipbc)            endif         endif         end subroutine ipfdistr2!         subroutine ipvdistr2(part,npp,nps,vtx,vty,vdx,vdy,npx,npy,kstrt&     &,nvp)! calculates initial particle velocities in 2d! with maxwellian velocity with drift         implicit none         integer :: npx, npy, kstrt, nvp         real :: vtx, vty, vdx, vdy         real, dimension(:,:,:), pointer :: part         integer, dimension(:), pointer :: npp, nps! local data         integer :: idimp, npmax, nblok, ierr         idimp = size(part,1); npmax = size(part,2)         nblok = size(part,3)         call PVDISTR2(part,npp,nps,vtx,vty,vdx,vdy,npx,npy,idimp,npmax,&     &nblok,kstrt,nvp,ierr)         end subroutine ipvdistr2!         subroutine ipvdistrh2(part,npp,nps,vtx,vty,vtz,vdx,vdy,vdz,npx,&     &npy,kstrt,nvp)! calculates initial particle velocities in 2-1/2d! with maxwellian velocity with drift         implicit none         integer :: npx, npy, kstrt, nvp         real :: vtx, vty, vtz, vdx, vdy, vdz         real, dimension(:,:,:), pointer :: part         integer, dimension(:), pointer :: npp, nps! local data         integer :: idimp, npmax, nblok, ierr         idimp = size(part,1); npmax = size(part,2)         nblok = size(part,3)         call PVDISTR2H(part,npp,nps,vtx,vty,vtz,vdx,vdy,vdz,npx,npy,idi&     &mp,npmax,nblok,kstrt,nvp,ierr)         end subroutine ipvdistrh2!         subroutine ibpistr2(part,bxy,npp,noff,qbm,nx,ny,ipbc,inorder)! reinterprets curent particle positions as positions of guiding centers! and calculates the actual particle positions for 2d         implicit none         integer :: nx, ny, ipbc         integer, optional :: inorder         real :: qbm         real, dimension(:,:,:), pointer :: part         real, dimension(:,:,:,:), pointer :: bxy         integer, dimension(:), pointer :: npp, noff! local data         integer :: idimp, npmax, nblok, nxv, nypmx, order         idimp = size(part,1); npmax = size(part,2)         nblok = size(part,3)         nxv = size(bxy,2); nypmx = size(bxy,3)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PGBDISTR2L(part,bxy(1,1,1,1),npp,noff,qbm,nx,ny,idimp,n&     &pmax,nblok,nxv,nypmx,ipbc)         else            call PGBDISTR2L(part,bxy(1,2,2,1),npp,noff,qbm,nx,ny,idimp,n&     &pmax,nblok,nxv,nypmx,ipbc)         endif         end subroutine ibpistr2!         subroutine irbpistr2(part,bxy,npp,noff,qbm,ci,nx,ny,ipbc,inorde&     &r)! reinterprets curent particle positions as positions of guiding centers! and calculates the actual particle positions for relativistic 2d         implicit none         integer :: nx, ny, ipbc         integer, optional :: inorder         real :: qbm, ci         real, dimension(:,:,:), pointer :: part         real, dimension(:,:,:,:), pointer :: bxy         integer, dimension(:), pointer :: npp, noff! local data         integer :: idimp, npmax, nblok, nxv, nypmx, order         idimp = size(part,1); npmax = size(part,2)         nblok = size(part,3)         nxv = size(bxy,2); nypmx = size(bxy,3)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PGRBDISTR2L(part,bxy(1,1,1,1),npp,noff,qbm,ci,nx,ny,idi&     &mp,npmax,nblok,nxv,nypmx,ipbc)         else            call PGRBDISTR2L(part,bxy(1,2,2,1),npp,noff,qbm,ci,nx,ny,idi&     &mp,npmax,nblok,nxv,nypmx,ipbc)         endif         end subroutine irbpistr2!         subroutine ifedges2(edges,noff,nyp,ampy,scaley,shifty,ny,kstrt,&     &nvp,nypmx,ipbc,ndpro,nterg,ierr,inorder)! finds new 1d partitions from initial analytic distribution function         implicit none         integer :: ny, kstrt, nvp, nypmx, ipbc, ndpro, nterg, ierr         real :: ampy, scaley, shifty         integer, optional :: inorder         real, dimension(:,:), pointer :: edges         integer, dimension(:), pointer :: noff, nyp! local data         integer :: idps, nblok, nypmin, nypmax, order         real :: syi, zero         real, external :: FLDISTR1, FSDISTR1, FGDISTR1, FHDISTR1         idps = size(edges,1); nblok = size(edges,2)         syi = 0.         if (scaley /= 0.) syi = 1.0/scaley         zero = 0.0         ierr = 0         order = QUADRATIC         if (present(inorder)) order = inorder! uniform density         if (ndpro==0) then            call FEDGES2(edges,noff,nyp,FLDISTR1,zero,zero,zero,ny,nypmi&     &n,nypmax,kstrt,nvp,nblok,idps,ipbc)! linear density         else if (ndpro==1) then            call FEDGES2(edges,noff,nyp,FLDISTR1,ampy,syi,shifty,ny,nypm&     &in,nypmax,kstrt,nvp,nblok,idps,ipbc)! sinusoidal density         else if (ndpro==2) then            call FEDGES2(edges,noff,nyp,FSDISTR1,ampy,syi,shifty,ny,nypm&     &in,nypmax,kstrt,nvp,nblok,idps,ipbc)! gaussian density         else if (ndpro==3) then            call FEDGES2(edges,noff,nyp,FGDISTR1,ampy,syi,shifty,ny,nypm&     &in,nypmax,kstrt,nvp,nblok,idps,ipbc)! hyperbolic secant squared density         else if (ndpro==4) then            call FEDGES2(edges,noff,nyp,FHDISTR1,ampy,syi,shifty,ny,nypm&     &in,nypmax,kstrt,nvp,nblok,idps,ipbc)         endif         if (order==LINEAR) then            nypmax = nypmax + 1         else            nypmax = nypmax + 3         endif         if ((nypmin.lt.1).or.(nypmax.gt.nypmx)) then            write (2,*) 'Field size error: nypmin,nypmax=',nypmin,nypmax            ierr = 1         endif         nterg = nypmin - 1         end subroutine ifedges2!      end module pinit2d