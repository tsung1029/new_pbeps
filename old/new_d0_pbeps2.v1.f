!-----------------------------------------------------------------------! * * * periodic 2d electrostatic particle simulation kernel code * * *! this is a simple 2d skeleton particle-in-cell code designed for! exploring new computer architectures.  it contains the critical pieces! needed for depositing charge, advancing particles, and solving the! field.  the code moves only electrons, with periodic electrostatic! forces obtained by solving poisson's equation with fast fourier! transforms.  the only diagnostic is particle and field energy.! portable gcpic kernel code, using algorithm described in:! p. c. liewer and v. k. decyk, j. computational phys. 85, 302 (1989).! written by viktor k. decyk, ucla! for mpi distributed memory computers! update: december 5, 2002      program pbeps2      use pinit2d!     use mppush2d      use ppush2d      use pdfield2d      use p2d      implicit none! idps = number of partition boundaries! idimp = dimension of phase space = 4! mshare = (0,1) = (no,yes) architecture is shared memory! ipbc = particle boundary condition = (0,1,2,3) =! (none,2d periodic,2d reflecting,mixed reflecting/periodic      integer :: idps =    2, idimp =   4, mshare =   0, ipbc = 2      integer :: sortime = 25, vect = 0      integer :: npxy, npxyb, np, nx, ny, nxh, nyh, nyv, nxe, nxeh      integer :: nloop, nvp, nblok, npmax, nypmx      integer :: kyp, kxp, kyb, kxb, kxyb, kbmin, kblok, jbmin, jblok      integer :: ngds, nxyh, nxhy, nbmax      integer :: idproc, id0, kstrt, itime, isign, ierr      integer :: it, nx1, lprec, nrec, irc      integer :: ntasks      real :: zero = 0.0      real :: qbme, affp, qi0, we, wke      double precision :: dtime      real, dimension(:,:,:), allocatable :: part      real, dimension(:,:,:), allocatable :: qe      real, dimension(:,:,:,:), allocatable :: fxye      complex, dimension(:,:,:), allocatable :: qt      complex, dimension(:,:,:,:), allocatable :: fxyt      complex, dimension(:,:,:), allocatable :: ffc      integer, dimension(:), allocatable :: mixup      complex, dimension(:), allocatable :: sct      real, dimension(:,:), allocatable  :: edges      integer, dimension(:), allocatable :: nyp, noff      integer, dimension(:), allocatable :: npp, nps      complex, dimension(:,:,:), allocatable :: pott      real, dimension(:,:,:), allocatable :: pot! potential and display      real, dimension(:,:,:), allocatable :: fx, fy, pit      real, dimension(:,:,:), allocatable :: g      integer, dimension(:,:,:), allocatable :: lf!      integer ::indx1, indy1, nx2, ny2, nx2e, nxhy2, nxyh2      integer :: kyp2, kxp2, kyb2, kxb2, kxyb2      integer :: kbmin2, k2blok, jbmin2, j2blok      real, dimension(:,:,:), allocatable :: q2, pot2      real, dimension(:,:,:,:), allocatable :: fxy2      complex, dimension(:,:,:,:), allocatable :: fxyt2      complex, dimension(:,:,:), allocatable :: qt2, fxt2, fyt2      complex, dimension(:,:,:), allocatable :: ffd      integer, dimension(:), allocatable :: mixup2      complex, dimension(:), allocatable :: sct2!! wtot = total energy      real, dimension(3) :: wtot! time = timing array      real, dimension(2) :: time! msg = heartbeat array      double precision, dimension(3) :: msg      character(len=16) :: fname      character(len=12) :: label, potname      character(len=4) :: nlabel  991 format (5h t = ,i7)  992 format (19h * * * q.e.d. * * *)  993 format (34h field, kinetic, total energies = ,3e14.7)! nvp = number of real or virtual processors! initialize for parallel processing      call PPINIT(idproc,id0,nvp)      kstrt = idproc + 1! read namelist      if (id0==0) then         open(unit=8,file='pinput2',form='formatted',status='old')         read (8,pinput2)         open(unit=18,file='poutput2',form='formatted',status='unknown')         write (18,pinput2)      endif! broadcast namelist to other nodes      call sendnml()! np = total number of electrons in simulation      npxy = npx*npy; npxyb = npxb*npyb; np = npxy + npxyb      nx = 2**indx; ny = 2**indy; nxh = nx/2; nyh = ny/2      nxe = nx + 4; nyv = ny + 2! kyp = number of complex grids in each field partition in y direction! nypmx = maximum size of particle partition, including guard cells.      kyp = (ny - 1)/nvp + 1; nypmx = kyp + 3! ngds = number of guard cells      ngds = 3*((idps - 1)/2 + 1)      if (inorder==LINEAR) then         ax = .912871; ay = .912871         nxe = nx + 2; ; nypmx = kyp + 1         ngds = (idps - 1)/2 + 1      endif! check if too many processors      if (nvp > ny) then         write (2,*) 'Too many processors requested, ny, nvp=', ny, nvp         call PPEXIT         stop      endif! initialize for multiprocessing!     call mpinit(ntasks)      if (popt==VECTOR) vect = 1      nxeh = nxe/2! nloop = number of time steps in simulation      nloop = tend/dt + .0001! nblok = number of particle partitions      nblok = 1 + mshare*(nvp - 1)! npmax = maximum number of particles in each partition      npmax = (np/nvp)*1.01 + 7000! kxp = number of complex grids in each field partition in x direction      kxp = (nxh - 1)/nvp + 1! kyb = number of processors in y! kxb = number of processors in x      kyb = ny/kyp; kxb = nxh/kxp! kxyb = maximum(kxb,kyb)      kxyb = max(kxb,kyb)! kblok = number of field partitions in y direction      kbmin = 1 + (1 - mshare)*(kxyb/kxb - 1)      kblok = 1 + mshare*(ny/kyp - 1)! jblok = number of field partitions in x direction      jbmin = 1 + (1 - mshare)*(kxyb/kyb - 1)      jblok = 1 + mshare*(nxh/kxp - 1)! nxyh = maximum(nx,ny)/2      nxyh = max(nx,ny)/2! nxhy = maximum(nx/2,ny)      nxhy = max(nxh,ny)! nbmax = size of buffer for passing particles between processors      nbmax = 1 + (2*(npxy*vty + npxyb*vtdy) + 1.4*npxyb*abs(vdy))*dt/ny! diagnostics! potential diagnostics      if (ntp > 0) then         nx1 = nx + 1         allocate(pot(nx1,kyp,kblok))         inquire(iolength=lprec) pot         potname = 'pot2'         if (id0==0) call PHEAD2(10,nx1,kyp,nvp,trim(potname))      endif!! diagnostic nodes have special processing      if (idproc < 0) call diag2nodes!! part(1,n,l) = position x of particle n in partition l! part(2,n,l) = position y of particle n in partition l! part(3,n,l) = velocity vx of particle n in partition l! part(4,n,l) = velocity vy of particle n in partition l      allocate(part(idimp,npmax,nblok))! in real space, qe(j+1,k,l) = charge density at grid point (j,kk)! in real space, fxye(i,j+1,k,l) = i component of force/charge at ! grid point (j,kk)! in other words, fxye are the convolutions of the electric field! over the particle shape, where kk = k + noff(l) - 1      allocate(qe(nxe,nypmx*kbmin,kblok),fxye(2,nxe,nypmx*kbmin,kblok))! qt(k,j,l) = complex charge density for fourier mode jj-1,k-1! fxyt(1,k,j,l) = x component of force/charge for fourier mode jj-1,k-1! fxyt(2,k,j,l) = y component of force/charge for fourier mode jj-1,k-1! where jj = j + kxp*(l - 1)      allocate(qt(nyv,kxp,jblok),fxyt(2,nyv,kxp,jblok))! ffc = form factor array for poisson solver      allocate(ffc(nyh,kxp,jblok))! mixup, sct = arrays for fft      allocate(mixup(nxhy),sct(nxyh))! edges(1,l) = lower boundary of particle partition l! edges(2,l) = upper boundary of particle partition l      allocate(edges(idps,nblok))! nyp(l) = number of primary gridpoints in particle partition l.! noff(l) = lowermost global gridpoint in particle partition l.      allocate(nyp(nblok),noff(nblok))! npp(l) = number of particles in partition l! nps(l) = starting address of particles in partition l      allocate(npp(nblok),nps(nblok))! potential      if (ntp > 0) allocate(pott(nyv,kxp,jblok))! potential and display      allocate(fx(nx+1,kyp+1,kblok),fy(nx+1,kyp+1,kblok))      allocate(pit(nxe,nypmx,kblok))      allocate(g(nxe,nypmx,kblok),lf(nxe,nypmx,kblok))!      indx1 = indx+1; indy1 = indy+1; nx2 = 2*nx; ny2 = 2*ny      nx2e = 2*nxe; nxhy2 = 2*nxhy; nxyh2 = 2*nxyh      kyp2 = (ny2-1)/nvp + 1; kxp2 = (nx-1)/nvp + 1      kyb2 = ny2/kyp2; kxb2 = nx/kxp2      kxyb2 = max(kxb2,kyb2)      kbmin2 = 1 + (1 - mshare)*(kxyb2/kxb2 - 1)      k2blok = 1 + mshare*(ny2/kyp2 - 1)      jbmin2 = 1 + (1 - mshare)*(kxyb2/kyb2 - 1)      j2blok = 1 + mshare*(nx/kxp2 - 1)      allocate(q2(nx2e,kyp2*kbmin2,k2blok))      allocate(fxy2(2,nx2e,kyp2*kbmin2,k2blok))      allocate(pot2(nx2e,kyp2*kbmin2,k2blok))      allocate(qt2(ny2,kxp2,j2blok),fxyt2(2,ny2,kxp2,j2blok))      allocate(fxt2(ny2,kxp2,j2blok),fyt2(ny2,kxp2,j2blok))      allocate(ffd(ny,kxp2,j2blok))      allocate(mixup2(nxhy2),sct2(nxyh2))!! open graphics device      call GROPEN      call SETNPLT(3,irc)      call STPALIT(1)! initialize parallel timer      call pwtimer(time,dtime,-1)! initialize constants      itime = 0      qbme = qme      if (ipbc.eq.1) then         affp = float(nx*ny)/float(np)      else if (ipbc.eq.2) then         affp = float((nx-2)*(ny-2))/float(np)      endif      qi0 = -qme/affp! calculate partition variables      call dcomp(edges,nyp,noff,ny,kstrt,nvp,inorder)! prepare fft tables      call fft_init(mixup,sct,indx,indy)! calculate form factors      call pois_init(ffc,ax,ay,affp,nx,ny,kstrt)!      call fft_init(mixup2,sct2,indx1,indy1)      call poisd_init(ffd,ax,ay,affp,nx,ny,kstrt)!! initialize density profile and velocity distribution      if (ipbc.eq.2) vdy = 0.! background electrons      nps = 1      npp = 0      if (npxy > 0) call distr(part,edges,npp,nps,vtx,vty,zero,zero,npx,&     &npy,nx,ny,ipbc)! beam electrons      nps = npp + 1      if (npxyb > 0) call distr(part,edges,npp,nps,vtdx,vtdy,vdx,vdy,npx&     &b,npyb,nx,ny,ipbc)! initialize charge density to background      call sguardp(qe,kstrt,nvp,nyp,qi0,nx,ipbc,inorder)! deposit charge for initial distribution      call dpost(part,qe,qme,npp,noff,inorder,STANDARD)!     call dpost(part,qe,qme,npp,nps,noff,ntasks,inorder,STANDARD)! add guard cells in x direction      call aguardp(qe,nyp,nx,ipbc,inorder)! copy data from particle to field partition, and add up guard cells in y      call paguardp(qe,kstrt,nvp,nx,kyp,ngds,ipbc)! send initial CPU Time to diagnostic nodes      call pwtimer(time,dtime)      msg(1) = time(1); msg(2) = time(2)      call HARTBEAT(msg,2)      if (id0==0) then         write (18,*) 'init max/min real time=', time(1), time(2), 'sec'      endif!! * * * start main iteration loop * * *!  500 if (nloop <= itime) go to 2000! send time step to diagnostic nodes      msg(1) = itime      call HARTBEAT(msg,1)      if (id0==0) write (18,991) itime      write (label,991) itime      call LOGNAME(label)!! dirchlet boundary conditions      if (ipbc.eq.2) then      call dblsin(qe,q2,nx,ny,kstrt,kyp,kyp2,inorder)      isign = -1      call fft(q2,qt2,isign,mixup2,sct2,indx1,indy1,kstrt,kyp2,LINEAR)! solve for electric fields      call poisd(qt2,fxyt2,ffd,we,nx,ny,kstrt)      call fft(fxy2,fxyt2,mixup2,sct2,indx1,indy1,kstrt,kyp2,LINEAR)      call hafdbl(fxye,fxy2,nx,ny,kstrt,kyp,kyp2,inorder)      call plcguard(fxye,kstrt,nvp,nx,kyp,inorder)      call lcguard(fxye,nyp,nx,inorder)! solve for potential      call poisd(qt2,fxt2,ffd,we,nx,ny,kstrt)      isign = 1      call fft(pot2,fxt2,isign,mixup2,sct2,indx1,indy1,kstrt,kyp2,LINEAR&     &)      call hafdbl(pit,pot2,nx,ny,kstrt,kyp,kyp2,inorder)      call plcguard(pit,kstrt,nvp,nx,kyp,inorder)      call lcguard(pit,nyp,nx,inorder)! display      if (inorder==QUADRATIC) then         fx = fxye(1,2:nx+2,2:kyp+2,1:kblok)         fy = fxye(2,2:nx+2,2:kyp+2,1:kblok)      else         fx = fxye(1,1:nx+1,1:kyp+1,1:kblok)         fy = fxye(2,1:nx+1,1:kyp+1,1:kblok)      endif      if (inorder==QUADRATIC) then!     call PCONTUR(pit(2,2,1),g,lf,nvp,'BOUND POT',999,0,nx+1,ny,nxe,nyp&!    &mx,kblok,' ',6,irc)      call PCARPET(pit(2,2,1),g,nvp,'BOUND POT',999,0,nx+1,ny,nxe,nypmx,&     &kblok,' ',64,irc)      else!     call PCONTUR(pit(1,1,1),g,lf,nvp,'BOUND POT',999,0,nx+1,ny,nxe,nyp&!    &mx,kblok,' ',6,irc)      call PCARPET(pit(1,1,1),g,nvp,'BOUND POT',999,0,nx+1,ny,nxe,nypmx,&     &kblok,' ',64,irc)      endif      if (irc.eq.1) go to 3000!     call PCONTUR(fx,g,lf,nvp,'BOUND FX',999,0,nx+1,ny,nx+1,kyp+1,kblok&!    &,' ',6,irc)      call PCARPET(fx,g,nvp,'BOUND FX',999,0,nx+1,ny,nx+1,kyp+1,kblok,' &     &',64,irc)      if (irc.eq.1) go to 3000!     call PCONTUR(fy,g,lf,nvp,'BOUND FY',999,0,nx+1,ny,nx+1,kyp+1,kblok&!    &,' ',6,irc)      call PCARPET(fy,g,nvp,'BOUND FY',999,0,nx+1,ny,nx+1,kyp+1,kblok,' &     &',64,irc)      if (irc.eq.1) go to 3000!! periodic boundary conditions      else if (ipbc.eq.1) then!! transform charge to fourier space      isign = -1      call fft(qe,qt,isign,mixup,sct,indx,indy,kstrt,kyp,inorder)! potential diagnostic      if (ntp > 0) then         it = itime/ntp         if (itime==ntp*it) then! calculate potential in fourier space            call pois(qt,pott,ffc,we,nx,ny,kstrt)! transform potential to real space (result stored in qe)            isign = 1            call fft(qe,pott,isign,mixup,sct,indx,indy,kstrt,kyp,LINEAR)            call pcguard(qe,kstrt,nvp,kyp,LINEAR)            call cguard(qe,nyp,nx,LINEAR)!           call PCONTUR(qe,g,lf,nvp,'PERIOD POT',999,0,nx+1,ny,nxe,nypm&!    &x,kblok,' ',6,irc)            call PCARPET(qe,g,nvp,'PERIOD POT',999,0,nx+1,ny,nxe,nypmx,k&     &blok,' ',64,irc)      if (irc.eq.1) go to 3000!            pot = qe(1:nx1,1:kyp,:)! write diagnostic output            write (nlabel,'(i4)') it            if (nlabel(1:1)==' ') nlabel(1:1) = '0'            if (nlabel(2:2)==' ') nlabel(2:2) = '0'            if (nlabel(3:3)==' ') nlabel(3:3) = '0'            fname = trim(potname)//'_'//trim(nlabel)            nrec = -lprec!           call writef(pot,10,nrec,trim(fname))         endif      endif! calculate force/charge in fourier space      call pois(qt,fxyt,ffc,we,nx,ny,kstrt)! transform force/charge to real space      call fft(fxye,fxyt,mixup,sct,indx,indy,kstrt,kyp,inorder)! copy data from field to particle partition, and copy to guard cells      call pcguard(fxye,kstrt,nvp,kyp,inorder)! particle push and charge density update      call cguard(fxye,nyp,nx,inorder)!     call lcguard(fxye,nyp,nx,inorder)! display      if (inorder==QUADRATIC) then         fx = fxye(1,2:nx+2,2:kyp+2,1:kblok)         fy = fxye(2,2:nx+2,2:kyp+2,1:kblok)      else         fx = fxye(1,1:nx+1,1:kyp+1,1:kblok)         fy = fxye(2,1:nx+1,1:kyp+1,1:kblok)      endif!     call PCONTUR(fx,g,lf,nvp,'PERIOD FX',999,0,nx+1,ny,nx+1,kyp+1,kblo&!    &k,' ',6,irc)      call PCARPET(fx,g,nvp,'PERIOD FX',999,0,nx+1,ny,nx+1,kyp+1,kblok,'&     &',64,irc)      if (irc.eq.1) go to 3000!     call PCONTUR(fy,g,lf,nvp,'PERIOD FY',999,0,nx+1,ny,nx+1,kyp+1,kblo&!    &,' ',6,irc)      call PCARPET(fy,g,nvp,'PERIOD FY',999,0,nx+1,ny,nx+1,kyp+1,kblok,'&     &',64,irc)      if (irc.eq.1) go to 3000      endif!      wke = 0.! push particles      call push(part,fxye,npp,noff,qbme,dt,wke,nx,ny,ipbc,inorder,popt)!     call push(part,fxye,npp,nps,noff,qbme,dt,wke,nx,ny,ipbc,ntasks,ino&!    &rder,popt)! move particles into appropriate spatial regions      call pmove(part,edges,npp,ny,kstrt,nvp,nbmax,vect,ierr)      if (ierr /= 0) then!        call MP_END         call PPEXIT         stop      endif! initialize charge density to background      call sguardp(qe,kstrt,nvp,nyp,qi0,nx,ipbc,inorder)! deposit charge      call dpost(part,qe,qme,npp,noff,inorder,dopt)!     call dpost(part,qe,qme,npp,nps,noff,ntasks,inorder,dopt)! merge density arrays in x direction      call aguardp(qe,nyp,nx,ipbc,inorder)!     call laguard(qe,nyp,nx,inorder)! copy data from particle to field partition, and add up guard cells in y      call paguardp(qe,kstrt,nvp,nx,kyp,ngds,ipbc)!     call ipaguard2p(qe,kstrt,nvp,nx,kyp,ngds,ipbc)! sort particles      if (mod(itime,sortime)==0) then         call sortp(part,npp,noff,kyp,inorder)      endif ! energy diagnostic      if (ntw > 0) then         it = itime/ntw         if (itime==ntw*it) then            wtot(1) = we            wtot(2) = wke            wtot(3) = we + wke            call plsum(wtot)! send energy values to diagnostic node            msg(1) = wtot(1); msg(2) = wtot(2); msg(3) = wtot(3)            call HARTBEAT(msg,3)            if (id0==0) write (18,993) wtot(1), wtot(2), wtot(3)         endif      endif      itime = itime + 1      go to 500 2000 continue!! * * * end main iteration loop * * *!! close graphics device 3000 continue      call PGRCLOSE! send QUIT message to diagnostic nodes      msg = -1.      call HARTBEAT(msg,1)      call pwtimer(time,dtime)! send main CPU Time to diagnostic nodes      msg(1) = time(1); msg(2) = time(2)      call HARTBEAT(msg,2)      if (id0==0) then         write (18,*) 'main max/min real time=', time(1), time(2), 'sec'         write (18,992)       endif!     call MP_END      call PPEXIT      stop!      contains!         subroutine diag2nodes         implicit none! diagnostic nodes have special processing  991    format (5h t = ,i7)  992    format (19h * * * q.e.d. * * *)  993    format (34h field, kinetic, total energies = ,3e14.7)! get initial CPU Time         call HARTBEAT(msg,2)         time(1) = msg(1); time(2) = msg(2)         if (id0==0) then         write (18,*) 'init max/min real time=', time(1), time(2), 'sec'         endif! get time step   10    call HARTBEAT(msg,1)         itime = msg(1)         if (itime < 0) then! get main CPU Time            call HARTBEAT(msg,2)            time(1) = msg(1); time(2) = msg(2)            if (id0==0) then               write (18,*) 'main max/min real time=', time(1), time(2),&     &'sec'               write (18,992)             endif            call PPEXIT            stop         endif         if (id0==0) write (18,991) itime         write (label,991) itime         call LOGNAME(label)! potential diagnostic         if (ntp > 0) then            it = itime/ntp            if (itime==ntp*it) then               write (nlabel,'(i4)') it               if (nlabel(1:1)==' ') nlabel(1:1) = '0'               if (nlabel(2:2)==' ') nlabel(2:2) = '0'               if (nlabel(3:3)==' ') nlabel(3:3) = '0'               fname = trim(potname)//'_'//trim(nlabel)               nrec = -lprec               call writef(pot,10,nrec,trim(fname))               close(unit=10)            endif         endif! energy diagnostic         if (ntw > 0) then            it = itime/ntw            if (itime==ntw*it) then! get energy values               call HARTBEAT(msg,3)               wtot(1) = msg(1); wtot(2) = msg(2); wtot(3) = msg(3)               if (id0==0) write (18,993) wtot(1), wtot(2), wtot(3)            endif         endif         go to 10      end subroutine!      end program pbeps2