c 2d PIC parallel multi-tasking library for pushing particlesc and depositing chargec written by viktor k. decyk, uclac copyright 2000, regents of the university of californiac update: february 8, 2001c-----------------------------------------------------------------------      subroutine MPDOST2(part,q,npp,nps,noff,qm,nx,idimp,npmax,nblok,nxv     1,nypmx,qp,idtask,nmt,ierr)c reusable parallel multitasking charge depositionc qp = charge density arrays for tasksc idtask = index to notify queue for task (0 if error)c nmt = number of tasksc ierr = ierror indicator (0 = no error)      implicit none      real part, q, qm, qp      integer npp, nps, noff      integer nx, idimp, npmax, nblok, nxv, nypmx, idtask, nmt, ierr      dimension part(idimp,npmax,nblok), q(nxv,nypmx,nblok)      dimension npp(nblok), nps(nblok), noff(nblok)      dimension qp(nxv,nypmx,nblok,nmt), idtask(nmt)c local data      integer first, nargs, npt, npl, npo, i, j, k, l      integer MP_SNDSIG, MP_WAITSIG      external PDOST2      save first, nargs      data first, nargs /1,11/c find minimum of npp      npo = npp(1)      do 10 l = 1, nblok      if (npo.gt.npp(l)) npo = npp(l)   10 continue      npt = npo/(nmt + 1)      npl = npt*nmt      ierr = 0c start charge deposit tasks      do 50 i = 1, nmt      npo = npt*(i - 1) + 1c clear charge arrays      do 40 l = 1, nblok      nps(l) = npt      do 30 k = 1, nypmx      do 20 j = 1, nx      qp(j,k,l,i) = 0.   20 continue   30 continue   40 continue      if (first.eq.1) then         call MP_TASKINIT(idtask(i),PDOST2,nargs,part(1,npo,1),qp(1,1,1,     1i),nps,noff,qm,nx,idimp,npmax,nblok,nxv,nypmx)      endifc check for errors      if (idtask(i).eq.0) then        ierr = -1        return      endif      ierr = 5*ierr + MP_SNDSIG(idtask(i))   50 continue      if (ierr.ne.0) return      first = 0c deposit remaining charge      npo = npl + 1      do 60 l = 1, nblok      npp(l) = npp(l) - npl   60 continue      call PDOST2(part(1,npo,1),q,npp,noff,qm,nx,idimp,npmax,nblok,nxv,n     1ypmx)      do 70 l = 1, nblok      npp(l) = npp(l) + npl   70 continuec wait for tasks to complete      do 110 i = 1, nmt      ierr = 5*ierr + MP_WAITSIG(idtask(i))c sum charge arrays      do 100 l = 1, nblok      do 90 k = 1, nypmx      do 80 j = 1, nx      q(j,k,l) = q(j,k,l) + qp(j,k,l,i)   80 continue   90 continue  100 continue  110 continue      return      endc-----------------------------------------------------------------------      subroutine MPGPOST2(part,q,npp,nps,noff,qm,idimp,npmax,nblok,nxv,n     1ypmx,qp,idtask,nmt,ierr)c reusable parallel multitasking charge depositionc qp = charge density arrays for tasksc idtask = index to notify queue for task (0 if error)c nmt = number of tasksc ierr = ierror indicator (0 = no error)      implicit none      real part, q, qm, qp      integer npp, nps, noff      integer idimp, npmax, nblok, nxv, nypmx, idtask, nmt, ierr      dimension part(idimp,npmax,nblok), q(nxv,nypmx,nblok)      dimension npp(nblok), nps(nblok), noff(nblok)      dimension qp(nxv,nypmx,nblok,nmt), idtask(nmt)c local data      integer first, nargs, npt, npl, npo, i, j, k, l      integer MP_SNDSIG, MP_WAITSIG      external PGPOST2      save first, nargs      data first, nargs /1,10/c find minimum of npp      npo = npp(1)      do 10 l = 1, nblok      if (npo.gt.npp(l)) npo = npp(l)   10 continue      npt = npo/(nmt + 1)      npl = npt*nmt      ierr = 0c start charge deposit tasks      do 50 i = 1, nmt      npo = npt*(i - 1) + 1c clear charge arrays      do 40 l = 1, nblok      nps(l) = npt      do 30 k = 1, nypmx      do 20 j = 1, nxv      qp(j,k,l,i) = 0.   20 continue   30 continue   40 continue      if (first.eq.1) then         call MP_TASKINIT(idtask(i),PGPOST2,nargs,part(1,npo,1),qp(1,1,1     1,i),nps,noff,qm,idimp,npmax,nblok,nxv,nypmx)      endifc check for errors      if (idtask(i).eq.0) then        ierr = -1        return      endif      ierr = 5*ierr + MP_SNDSIG(idtask(i))   50 continue      if (ierr.ne.0) return      first = 0c deposit remaining charge      npo = npl + 1      do 60 l = 1, nblok      npp(l) = npp(l) - npl   60 continue      call PGPOST2(part(1,npo,1),q,npp,noff,qm,idimp,npmax,nblok,nxv,nyp     1mx)      do 70 l = 1, nblok      npp(l) = npp(l) + npl   70 continuec wait for tasks to complete      do 110 i = 1, nmt      ierr = 5*ierr + MP_WAITSIG(idtask(i))c sum charge arrays      do 100 l = 1, nblok      do 90 k = 1, nypmx      do 80 j = 1, nxv      q(j,k,l) = q(j,k,l) + qp(j,k,l,i)   80 continue   90 continue  100 continue  110 continue      return      endc-----------------------------------------------------------------------      subroutine MPGSPOST2(part,q,npp,nps,noff,qm,idimp,npmax,nblok,nxv,     1nxyp,qp,idtask,nmt,ierr)c reusable parallel multitasking charge depositionc qp = charge density arrays for tasksc idtask = index to notify queue for task (0 if error)c nmt = number of tasksc ierr = ierror indicator (0 = no error)      implicit none      real part, q, qm, qp      integer npp, nps, noff      integer idimp, npmax, nblok, nxv, nxyp, idtask, nmt, ierr      dimension part(idimp,npmax,nblok), q(nxyp,nblok)      dimension npp(nblok), nps(nblok), noff(nblok)      dimension qp(nxyp,nblok,nmt), idtask(nmt)c local data      integer first, nargs, npt, npl, npo, i, j, l      integer MP_SNDSIG, MP_WAITSIG      external PGSPOST2      save first, nargs      data first, nargs /1,10/c find minimum of npp      npo = npp(1)      do 10 l = 1, nblok      if (npo.gt.npp(l)) npo = npp(l)   10 continue      npt = npo/(nmt + 1)      npl = npt*nmt      ierr = 0c start charge deposit tasks      do 40 i = 1, nmt      npo = npt*(i - 1) + 1c clear charge arrays      do 30 l = 1, nblok      nps(l) = npt      do 20 j = 1, nxyp      qp(j,l,i) = 0.   20 continue   30 continue      if (first.eq.1) then         call MP_TASKINIT(idtask(i),PGSPOST2,nargs,part(1,npo,1),qp(1,1,     1i),nps,noff,qm,idimp,npmax,nblok,nxv,nxyp)      endifc check for errors      if (idtask(i).eq.0) then        ierr = -1        return      endif      ierr = 5*ierr + MP_SNDSIG(idtask(i))   40 continue      if (ierr.ne.0) return      first = 0c deposit remaining charge      npo = npl + 1      do 50 l = 1, nblok      npp(l) = npp(l) - npl   50 continue      call PGSPOST2(part(1,npo,1),q,npp,noff,qm,idimp,npmax,nblok,nxv,nx     1yp)      do 60 l = 1, nblok      npp(l) = npp(l) + npl   60 continuec wait for tasks to complete      do 90 i = 1, nmt      ierr = 5*ierr + MP_WAITSIG(idtask(i))c sum charge arrays      do 80 l = 1, nblok      do 70 j = 1, nxyp      q(j,l) = q(j,l) + qp(j,l,i)   70 continue   80 continue   90 continue      return      endc-----------------------------------------------------------------------      subroutine MPSOST2X(part,q,npp,nps,noff,nn,amxy,qm,nx,idimp,npmax,     1nblok,nxv,nxvyp,npd,nine,qp,idtask,nmt,ierr)c reusable parallel multitasking charge depositionc qp = charge density arrays for tasksc idtask = index to notify queue for task (0 if error)c nmt = number of tasksc ierr = ierror indicator (0 = no error)      implicit none      real part, q, amxy, qm, qp      integer npp, nps, noff, nn      integer nx, idimp, npmax, nblok, nxv, nxvyp, npd, nine      integer idtask, nmt, ierr      dimension part(idimp,npmax,nblok), q(nxvyp,nblok)      dimension npp(nblok), nps(nblok), noff(nblok)      dimension nn(nine,npd,nblok,nmt+1), amxy(nine,npd,nblok,nmt+1)      dimension qp(nxvyp,nblok,nmt), idtask(nmt)c local data      integer first, nargs, npt, npl, npo, i, j, l      integer MP_SNDSIG, MP_WAITSIG      external PSOST2X      save first, nargs      data first, nargs /1,15/c find minimum of npp      npo = npp(1)      do 10 l = 1, nblok      if (npo.gt.npp(l)) npo = npp(l)   10 continue      npt = npo/(nmt + 1)      npl = npt*nmt      ierr = 0c start charge deposit tasks      do 40 i = 1, nmt      npo = npt*(i - 1) + 1c clear charge arrays      do 30 l = 1, nblok      nps(l) = npt      do 20 j = 1, nxvyp      qp(j,l,i) = 0.   20 continue   30 continue      if (first.eq.1) then         call MP_TASKINIT(idtask(i),PSOST2X,nargs,part(1,npo,1),qp(1,1,i     1),nps,noff,nn(1,1,1,i+1),amxy(1,1,1,i+1),qm,nx,idimp,npmax,nblok,n     2xv,nxvyp,npd,nine)      endifc check for errors      if (idtask(i).eq.0) then        ierr = -1        return      endif      ierr = 5*ierr + MP_SNDSIG(idtask(i))   40 continue      if (ierr.ne.0) return      first = 0c deposit remaining charge      npo = npl + 1      do 50 l = 1, nblok      npp(l) = npp(l) - npl   50 continue      call PSOST2X(part(1,npo,1),q,npp,noff,nn,amxy,qm,nx,idimp,npmax,nb     1lok,nxv,nxvyp,npd,nine)      do 60 l = 1, nblok      npp(l) = npp(l) + npl   60 continuec wait for tasks to complete      do 90 i = 1, nmt      ierr = 5*ierr + MP_WAITSIG(idtask(i))c sum charge arrays      do 80 l = 1, nblok      do 70 j = 1, nxvyp      q(j,l) = q(j,l) + qp(j,l,i)   70 continue   80 continue   90 continue      return      endc-----------------------------------------------------------------------      subroutine MPGSOST2X(part,q,npp,nps,noff,nn,amxy,qm,idimp,npmax,nb     1lok,nxv,nxvyp,npd,nine,qp,idtask,nmt,ierr)c reusable parallel multitasking charge depositionc qp = charge density arrays for tasksc idtask = index to notify queue for task (0 if error)c nmt = number of tasksc ierr = ierror indicator (0 = no error)      implicit none      real part, q, amxy, qm, qp      integer npp, nps, noff, nn      integer idimp, npmax, nblok, nxv, nxvyp, npd, nine      integer idtask, nmt, ierr      dimension part(idimp,npmax,nblok), q(nxvyp,nblok)      dimension npp(nblok), nps(nblok), noff(nblok)      dimension nn(nine,npd,nblok,nmt+1), amxy(nine,npd,nblok,nmt+1)      dimension qp(nxvyp,nblok,nmt), idtask(nmt)c local data      integer first, nargs, npt, npl, npo, i, j, l      integer MP_SNDSIG, MP_WAITSIG      external PGSOST2X      save first, nargs      data first, nargs /1,14/c find minimum of npp      npo = npp(1)      do 10 l = 1, nblok      if (npo.gt.npp(l)) npo = npp(l)   10 continue      npt = npo/(nmt + 1)      npl = npt*nmt      ierr = 0c start charge deposit tasks      do 40 i = 1, nmt      npo = npt*(i - 1) + 1c clear charge arrays      do 30 l = 1, nblok      nps(l) = npt      do 20 j = 1, nxvyp      qp(j,l,i) = 0.   20 continue   30 continue      if (first.eq.1) then         call MP_TASKINIT(idtask(i),PGSOST2X,nargs,part(1,npo,1),qp(1,1,     1i),nps,noff,nn(1,1,1,i+1),amxy(1,1,1,i+1),qm,idimp,npmax,nblok,nxv     2,nxvyp,npd,nine)      endifc check for errors      if (idtask(i).eq.0) then        ierr = -1        return      endif      ierr = 5*ierr + MP_SNDSIG(idtask(i))   40 continue      if (ierr.ne.0) return      first = 0c deposit remaining charge      npo = npl + 1      do 50 l = 1, nblok      npp(l) = npp(l) - npl   50 continue      call PGSOST2X(part(1,npo,1),q,npp,noff,nn,amxy,qm,idimp,npmax,nblo     1k,nxv,nxvyp,npd,nine)      do 60 l = 1, nblok      npp(l) = npp(l) + npl   60 continuec wait for tasks to complete      do 90 i = 1, nmt      ierr = 5*ierr + MP_WAITSIG(idtask(i))c sum charge arrays      do 80 l = 1, nblok      do 70 j = 1, nxvyp      q(j,l) = q(j,l) + qp(j,l,i)   70 continue   80 continue   90 continue      return      endc-----------------------------------------------------------------------      subroutine MPDOST2L(part,q,npp,nps,noff,qm,nx,idimp,npmax,nblok,nx     1v,nypmx,qp,idtask,nmt,ierr)c reusable parallel multitasking charge depositionc qp = charge density arrays for tasksc idtask = index to notify queue for task (0 if error)c nmt = number of tasksc ierr = ierror indicator (0 = no error)      implicit none      real part, q, qm, qp      integer npp, nps, noff      integer nx, idimp, npmax, nblok, nxv, nypmx, idtask, nmt, ierr      dimension part(idimp,npmax,nblok), q(nxv,nypmx,nblok)      dimension npp(nblok), nps(nblok), noff(nblok)      dimension qp(nxv,nypmx,nblok,nmt), idtask(nmt)c local data      integer first, nargs, npt, npl, npo, i, j, k, l      integer MP_SNDSIG, MP_WAITSIG      external PDOST2L      save first, nargs      data first, nargs /1,11/c find minimum of npp      npo = npp(1)      do 10 l = 1, nblok      if (npo.gt.npp(l)) npo = npp(l)   10 continue      npt = npo/(nmt + 1)      npl = npt*nmt      ierr = 0c start charge deposit tasks      do 50 i = 1, nmt      npo = npt*(i - 1) + 1c clear charge arrays      do 40 l = 1, nblok      nps(l) = npt      do 30 k = 1, nypmx      do 20 j = 1, nx      qp(j,k,l,i) = 0.   20 continue   30 continue   40 continue      if (first.eq.1) then         call MP_TASKINIT(idtask(i),PDOST2L,nargs,part(1,npo,1),qp(1,1,1     1,i),nps,noff,qm,nx,idimp,npmax,nblok,nxv,nypmx)      endifc check for errors      if (idtask(i).eq.0) then        ierr = -1        return      endif      ierr = 5*ierr + MP_SNDSIG(idtask(i))   50 continue      if (ierr.ne.0) return      first = 0c deposit remaining charge      npo = npl + 1      do 60 l = 1, nblok      npp(l) = npp(l) - npl   60 continue      call PDOST2L(part(1,npo,1),q,npp,noff,qm,nx,idimp,npmax,nblok,nxv,     1nypmx)      do 70 l = 1, nblok      npp(l) = npp(l) + npl   70 continuec wait for tasks to complete      do 110 i = 1, nmt      ierr = 5*ierr + MP_WAITSIG(idtask(i))c sum charge arrays      do 100 l = 1, nblok      do 90 k = 1, nypmx      do 80 j = 1, nx      q(j,k,l) = q(j,k,l) + qp(j,k,l,i)   80 continue   90 continue  100 continue  110 continue      return      endc-----------------------------------------------------------------------      subroutine MPGPOST2L(part,q,npp,nps,noff,qm,idimp,npmax,nblok,nxv,     1nypmx,qp,idtask,nmt,ierr)c reusable parallel multitasking charge depositionc qp = charge density arrays for tasksc idtask = index to notify queue for task (0 if error)c nmt = number of tasksc ierr = ierror indicator (0 = no error)      implicit none      real part, q, qm, qp      integer npp, nps, noff      integer idimp, npmax, nblok, nxv, nypmx, idtask, nmt, ierr      dimension part(idimp,npmax,nblok), q(nxv,nypmx,nblok)      dimension npp(nblok), nps(nblok), noff(nblok)      dimension qp(nxv,nypmx,nblok,nmt), idtask(nmt)c local data      integer first, nargs, npt, npl, npo, i, j, k, l      integer MP_SNDSIG, MP_WAITSIG      external PGPOST2L      save first, nargs      data first, nargs /1,10/c find minimum of npp      npo = npp(1)      do 10 l = 1, nblok      if (npo.gt.npp(l)) npo = npp(l)   10 continue      npt = npo/(nmt + 1)      npl = npt*nmt      ierr = 0c start charge deposit tasks      do 50 i = 1, nmt      npo = npt*(i - 1) + 1c clear charge arrays      do 40 l = 1, nblok      nps(l) = npt      do 30 k = 1, nypmx      do 20 j = 1, nxv      qp(j,k,l,i) = 0.   20 continue   30 continue   40 continue      if (first.eq.1) then         call MP_TASKINIT(idtask(i),PGPOST2L,nargs,part(1,npo,1),qp(1,1,     11,i),nps,noff,qm,idimp,npmax,nblok,nxv,nypmx)      endifc check for errors      if (idtask(i).eq.0) then        ierr = -1        return      endif      ierr = 5*ierr + MP_SNDSIG(idtask(i))   50 continue      if (ierr.ne.0) return      first = 0c deposit remaining charge      npo = npl + 1      do 60 l = 1, nblok      npp(l) = npp(l) - npl   60 continue      call PGPOST2L(part(1,npo,1),q,npp,noff,qm,idimp,npmax,nblok,nxv,ny     1pmx)      do 70 l = 1, nblok      npp(l) = npp(l) + npl   70 continuec wait for tasks to complete      do 110 i = 1, nmt      ierr = 5*ierr + MP_WAITSIG(idtask(i))c sum charge arrays      do 100 l = 1, nblok      do 90 k = 1, nypmx      do 80 j = 1, nxv      q(j,k,l) = q(j,k,l) + qp(j,k,l,i)   80 continue   90 continue  100 continue  110 continue      return      endc-----------------------------------------------------------------------      subroutine MPGSPOST2L(part,q,npp,nps,noff,qm,idimp,npmax,nblok,nxv     1,nxyp,qp,idtask,nmt,ierr)c reusable parallel multitasking charge depositionc qp = charge density arrays for tasksc idtask = index to notify queue for task (0 if error)c nmt = number of tasksc ierr = ierror indicator (0 = no error)      implicit none      real part, q, qm, qp      integer npp, nps, noff      integer idimp, npmax, nblok, nxv, nxyp, idtask, nmt, ierr      dimension part(idimp,npmax,nblok), q(nxyp,nblok)      dimension npp(nblok), nps(nblok), noff(nblok)      dimension qp(nxyp,nblok,nmt), idtask(nmt)c local data      integer first, nargs, npt, npl, npo, i, j, l      integer MP_SNDSIG, MP_WAITSIG      external PGSPOST2L      save first, nargs      data first, nargs /1,10/c find minimum of npp      npo = npp(1)      do 10 l = 1, nblok      if (npo.gt.npp(l)) npo = npp(l)   10 continue      npt = npo/(nmt + 1)      npl = npt*nmt      ierr = 0c start charge deposit tasks      do 40 i = 1, nmt      npo = npt*(i - 1) + 1c clear charge arrays      do 30 l = 1, nblok      nps(l) = npt      do 20 j = 1, nxyp      qp(j,l,i) = 0.   20 continue   30 continue      if (first.eq.1) then         call MP_TASKINIT(idtask(i),PGSPOST2L,nargs,part(1,npo,1),qp(1,1     1,i),nps,noff,qm,idimp,npmax,nblok,nxv,nxyp)      endifc check for errors      if (idtask(i).eq.0) then        ierr = -1        return      endif      ierr = 5*ierr + MP_SNDSIG(idtask(i))   40 continue      if (ierr.ne.0) return      first = 0c deposit remaining charge      npo = npl + 1      do 50 l = 1, nblok      npp(l) = npp(l) - npl   50 continue      call PGSPOST2L(part(1,npo,1),q,npp,noff,qm,idimp,npmax,nblok,nxv,n     1xyp)      do 60 l = 1, nblok      npp(l) = npp(l) + npl   60 continuec wait for tasks to complete      do 90 i = 1, nmt      ierr = 5*ierr + MP_WAITSIG(idtask(i))c sum charge arrays      do 80 l = 1, nblok      do 70 j = 1, nxyp      q(j,l) = q(j,l) + qp(j,l,i)   70 continue   80 continue   90 continue      return      endc-----------------------------------------------------------------------      subroutine MPSOST2XL(part,q,npp,nps,noff,nn,amxy,qm,nx,idimp,npmax     1,nblok,nxv,nxvyp,npd,ifour,qp,idtask,nmt,ierr)c reusable parallel multitasking charge depositionc qp = charge density arrays for tasksc idtask = index to notify queue for task (0 if error)c nmt = number of tasksc ierr = ierror indicator (0 = no error)      implicit none      real part, q, amxy, qm, qp      integer npp, nps, noff, nn      integer nx, idimp, npmax, nblok, nxv, nxvyp, npd, ifour      integer idtask, nmt, ierr      dimension part(idimp,npmax,nblok), q(nxvyp,nblok)      dimension npp(nblok), nps(nblok), noff(nblok)      dimension nn(ifour,npd,nblok,nmt+1), amxy(ifour,npd,nblok,nmt+1)      dimension qp(nxvyp,nblok,nmt), idtask(nmt)c local data      integer first, nargs, npt, npl, npo, i, j, l      integer MP_SNDSIG, MP_WAITSIG      external PSOST2XL      save first, nargs      data first, nargs /1,15/c find minimum of npp      npo = npp(1)      do 10 l = 1, nblok      if (npo.gt.npp(l)) npo = npp(l)   10 continue      npt = npo/(nmt + 1)      npl = npt*nmt      ierr = 0c start charge deposit tasks      do 40 i = 1, nmt      npo = npt*(i - 1) + 1c clear charge arrays      do 30 l = 1, nblok      nps(l) = npt      do 20 j = 1, nxvyp      qp(j,l,i) = 0.   20 continue   30 continue      if (first.eq.1) then         call MP_TASKINIT(idtask(i),PSOST2XL,nargs,part(1,npo,1),qp(1,1,     1i),nps,noff,nn(1,1,1,i+1),amxy(1,1,1,i+1),qm,nx,idimp,npmax,nblok,     2nxv,nxvyp,npd,ifour)      endifc check for errors      if (idtask(i).eq.0) then        ierr = -1        return      endif      ierr = 5*ierr + MP_SNDSIG(idtask(i))   40 continue      if (ierr.ne.0) return      first = 0c deposit remaining charge      npo = npl + 1      do 50 l = 1, nblok      npp(l) = npp(l) - npl   50 continue      call PSOST2XL(part(1,npo,1),q,npp,noff,nn,amxy,qm,nx,idimp,npmax,n     1blok,nxv,nxvyp,npd,ifour)      do 60 l = 1, nblok      npp(l) = npp(l) + npl   60 continuec wait for tasks to complete      do 90 i = 1, nmt      ierr = 5*ierr + MP_WAITSIG(idtask(i))c sum charge arrays      do 80 l = 1, nblok      do 70 j = 1, nxvyp      q(j,l) = q(j,l) + qp(j,l,i)   70 continue   80 continue   90 continue      return      endc-----------------------------------------------------------------------      subroutine MPGSOST2XL(part,q,npp,nps,noff,nn,amxy,qm,idimp,npmax,n     1blok,nxv,nxvyp,npd,ifour,qp,idtask,nmt,ierr)c reusable parallel multitasking charge depositionc qp = charge density arrays for tasksc idtask = index to notify queue for task (0 if error)c nmt = number of tasksc ierr = ierror indicator (0 = no error)      implicit none      real part, q, amxy, qm, qp      integer npp, nps, noff, nn      integer idimp, npmax, nblok, nxv, nxvyp, npd, ifour      integer idtask, nmt, ierr      dimension part(idimp,npmax,nblok), q(nxvyp,nblok)      dimension npp(nblok), nps(nblok), noff(nblok)      dimension nn(ifour,npd,nblok,nmt+1), amxy(ifour,npd,nblok,nmt+1)      dimension qp(nxvyp,nblok,nmt), idtask(nmt)c local data      integer first, nargs, npt, npl, npo, i, j, l      integer MP_SNDSIG, MP_WAITSIG      external PGSOST2XL      save first, nargs      data first, nargs /1,14/c find minimum of npp      npo = npp(1)      do 10 l = 1, nblok      if (npo.gt.npp(l)) npo = npp(l)   10 continue      npt = npo/(nmt + 1)      npl = npt*nmt      ierr = 0c start charge deposit tasks      do 40 i = 1, nmt      npo = npt*(i - 1) + 1c clear charge arrays      do 30 l = 1, nblok      nps(l) = npt      do 20 j = 1, nxvyp      qp(j,l,i) = 0.   20 continue   30 continue      if (first.eq.1) then         call MP_TASKINIT(idtask(i),PGSOST2XL,nargs,part(1,npo,1),qp(1,1     1,i),nps,noff,nn(1,1,1,i+1),amxy(1,1,1,i+1),qm,idimp,npmax,nblok,nx     2v,nxvyp,npd,ifour)      endifc check for errors      if (idtask(i).eq.0) then        ierr = -1        return      endif      ierr = 5*ierr + MP_SNDSIG(idtask(i))   40 continue      if (ierr.ne.0) return      first = 0c deposit remaining charge      npo = npl + 1      do 50 l = 1, nblok      npp(l) = npp(l) - npl   50 continue      call PGSOST2XL(part(1,npo,1),q,npp,noff,nn,amxy,qm,idimp,npmax,nbl     1ok,nxv,nxvyp,npd,ifour)      do 60 l = 1, nblok      npp(l) = npp(l) + npl   60 continuec wait for tasks to complete      do 90 i = 1, nmt      ierr = 5*ierr + MP_WAITSIG(idtask(i))c sum charge arrays      do 80 l = 1, nblok      do 70 j = 1, nxvyp      q(j,l) = q(j,l) + qp(j,l,i)   70 continue   80 continue   90 continue      return      endc-----------------------------------------------------------------------      subroutine MPPUSH2(part,fx,fy,npp,nps,noff,qbm,dt,ek,nx,idimp,npma     1x,nblok,nxv,nypmx,ekp,idtask,nmt,ierr)c reusable parallel multitasking particle pushc ekp = kinetic energy arrays for tasksc idtask = index to notify queue for task (0 if error)c nmt = number of tasksc ierr = ierror indicator (0 = no error)      implicit none      real part, fx, fy, qbm, dt, ek, ekp      integer npp, nps, noff      integer nx, idimp, npmax, nblok, nxv, nypmx, idtask, nmt, ierr      dimension part(idimp,npmax,nblok)      dimension fx(nxv,nypmx,nblok), fy(nxv,nypmx,nblok)      dimension npp(nblok), nps(nblok), noff(nblok)      dimension ekp(nmt), idtask(nmt)c local data      integer first, nargs, npt, npl, npo, i, l      integer MP_SNDSIG, MP_WAITSIG      external PPUSH2      save first, nargs      data first, nargs /1,14/c find minimum of npp      npo = npp(1)      do 10 l = 1, nblok      if (npo.gt.npp(l)) npo = npp(l)   10 continue      npt = npo/(nmt + 1)      npl = npt*nmt      ierr = 0c start particle push tasks      do 30 i = 1, nmt      npo = npt*(i - 1) + 1      do 20 l = 1, nblok      nps(l) = npt   20 continue      ekp(i) = 0.      if (first.eq.1) then         call MP_TASKINIT(idtask(i),PPUSH2,nargs,part(1,npo,1),fx,fy,nps     1,noff,qbm,dt,ekp(i),nx,idimp,npmax,nblok,nxv,nypmx)      endifc check for errors      if (idtask(i).eq.0) then        ierr = -1        return      endif      ierr = 5*ierr + MP_SNDSIG(idtask(i))   30 continue      if (ierr.ne.0) return      first = 0c push remaining particles      npo = npl + 1      do 40 l = 1, nblok      npp(l) = npp(l) - npl   40 continue      call PPUSH2(part(1,npo,1),fx,fy,npp,noff,qbm,dt,ek,nx,idimp,npmax,     1nblok,nxv,nypmx)      do 50 l = 1, nblok      npp(l) = npp(l) + npl   50 continuec wait for tasks to complete      do 60 i = 1, nmt      ierr = 5*ierr + MP_WAITSIG(idtask(i))      ek = ek + ekp(i)   60 continue      return      endc-----------------------------------------------------------------------      subroutine MPGPUSH2(part,fxy,npp,nps,noff,qbm,dt,ek,nx,idimp,npmax     1,nblok,nxv,nypmx,ekp,idtask,nmt,ierr)c reusable parallel multitasking particle pushc ekp = kinetic energy arrays for tasksc idtask = index to notify queue for task (0 if error)c nmt = number of tasksc ierr = ierror indicator (0 = no error)      implicit none      real part, fxy, qbm, dt, ek, ekp      integer npp, nps, noff      integer nx, idimp, npmax, nblok, nxv, nypmx, idtask, nmt, ierr      dimension part(idimp,npmax,nblok)      dimension fxy(2,nxv,nypmx,nblok)      dimension npp(nblok), nps(nblok), noff(nblok)      dimension ekp(nmt), idtask(nmt)c local data      integer first, nargs, npt, npl, npo, i, l      integer MP_SNDSIG, MP_WAITSIG      external PGPUSH2      save first, nargs      data first, nargs /1,13/c find minimum of npp      npo = npp(1)      do 10 l = 1, nblok      if (npo.gt.npp(l)) npo = npp(l)   10 continue      npt = npo/(nmt + 1)      npl = npt*nmt      ierr = 0c start particle push tasks      do 30 i = 1, nmt      npo = npt*(i - 1) + 1      do 20 l = 1, nblok      nps(l) = npt   20 continue      ekp(i) = 0.      if (first.eq.1) then         call MP_TASKINIT(idtask(i),PGPUSH2,nargs,part(1,npo,1),fxy,nps,     1noff,qbm,dt,ekp(i),nx,idimp,npmax,nblok,nxv,nypmx)      endifc check for errors      if (idtask(i).eq.0) then        ierr = -1        return      endif      ierr = 5*ierr + MP_SNDSIG(idtask(i))   30 continue      if (ierr.ne.0) return      first = 0c push remaining particles      npo = npl + 1      do 40 l = 1, nblok      npp(l) = npp(l) - npl   40 continue      call PGPUSH2(part(1,npo,1),fxy,npp,noff,qbm,dt,ek,nx,idimp,npmax,n     1blok,nxv,nypmx)      do 50 l = 1, nblok      npp(l) = npp(l) + npl   50 continuec wait for tasks to complete      do 60 i = 1, nmt      ierr = 5*ierr + MP_WAITSIG(idtask(i))      ek = ek + ekp(i)   60 continue      return      endc-----------------------------------------------------------------------      subroutine MPGSPUSH2(part,fxy,npp,nps,noff,qbm,dt,ek,nx,idimp,npma     1x,nblok,nxv,nxyp,ekp,idtask,nmt,ierr)c reusable parallel multitasking particle pushc ekp = kinetic energy arrays for tasksc idtask = index to notify queue for task (0 if error)c nmt = number of tasksc ierr = ierror indicator (0 = no error)      implicit none      real part, fxy, qbm, dt, ek, ekp      integer npp, nps, noff      integer nx, idimp, npmax, nblok, nxv, nxyp, idtask, nmt, ierr      dimension part(idimp,npmax,nblok)      dimension fxy(2,nxyp,nblok)      dimension npp(nblok), nps(nblok), noff(nblok)      dimension ekp(nmt), idtask(nmt)c local data      integer first, nargs, npt, npl, npo, i, l      integer MP_SNDSIG, MP_WAITSIG      external PGSPUSH2      save first, nargs      data first, nargs /1,13/c find minimum of npp      npo = npp(1)      do 10 l = 1, nblok      if (npo.gt.npp(l)) npo = npp(l)   10 continue      npt = npo/(nmt + 1)      npl = npt*nmt      ierr = 0c start particle push tasks      do 30 i = 1, nmt      npo = npt*(i - 1) + 1      do 20 l = 1, nblok      nps(l) = npt   20 continue      ekp(i) = 0.      if (first.eq.1) then         call MP_TASKINIT(idtask(i),PGSPUSH2,nargs,part(1,npo,1),fxy,nps     1,noff,qbm,dt,ekp(i),nx,idimp,npmax,nblok,nxv,nxyp)      endifc check for errors      if (idtask(i).eq.0) then        ierr = -1        return      endif      ierr = 5*ierr + MP_SNDSIG(idtask(i))   30 continue      if (ierr.ne.0) return      first = 0c push remaining particles      npo = npl + 1      do 40 l = 1, nblok      npp(l) = npp(l) - npl   40 continue      call PGSPUSH2(part(1,npo,1),fxy,npp,noff,qbm,dt,ek,nx,idimp,npmax,     1nblok,nxv,nxyp)      do 50 l = 1, nblok      npp(l) = npp(l) + npl   50 continuec wait for tasks to complete      do 60 i = 1, nmt      ierr = 5*ierr + MP_WAITSIG(idtask(i))      ek = ek + ekp(i)   60 continue      return      endc-----------------------------------------------------------------------      subroutine MPPUSH2L(part,fx,fy,npp,nps,noff,qbm,dt,ek,nx,idimp,npm     1ax,nblok,nxv,nypmx,ekp,idtask,nmt,ierr)c reusable parallel multitasking particle pushc ekp = kinetic energy arrays for tasksc idtask = index to notify queue for task (0 if error)c nmt = number of tasksc ierr = ierror indicator (0 = no error)      implicit none      real part, fx, fy, qbm, dt, ek, ekp      integer npp, nps, noff      integer nx, idimp, npmax, nblok, nxv, nypmx, idtask, nmt, ierr      dimension part(idimp,npmax,nblok)      dimension fx(nxv,nypmx,nblok), fy(nxv,nypmx,nblok)      dimension npp(nblok), nps(nblok), noff(nblok)      dimension ekp(nmt), idtask(nmt)c local data      integer first, nargs, npt, npl, npo, i, l      integer MP_SNDSIG, MP_WAITSIG      external PPUSH2L      save first, nargs      data first, nargs /1,14/c find minimum of npp      npo = npp(1)      do 10 l = 1, nblok      if (npo.gt.npp(l)) npo = npp(l)   10 continue      npt = npo/(nmt + 1)      npl = npt*nmt      ierr = 0c start particle push tasks      do 30 i = 1, nmt      npo = npt*(i - 1) + 1      do 20 l = 1, nblok      nps(l) = npt   20 continue      ekp(i) = 0.      if (first.eq.1) then         call MP_TASKINIT(idtask(i),PPUSH2L,nargs,part(1,npo,1),fx,fy,np     1s,noff,qbm,dt,ekp(i),nx,idimp,npmax,nblok,nxv,nypmx)      endifc check for errors      if (idtask(i).eq.0) then        ierr = -1        return      endif      ierr = 5*ierr + MP_SNDSIG(idtask(i))   30 continue      if (ierr.ne.0) return      first = 0c push remaining particles      npo = npl + 1      do 40 l = 1, nblok      npp(l) = npp(l) - npl   40 continue      call PPUSH2L(part(1,npo,1),fx,fy,npp,noff,qbm,dt,ek,nx,idimp,npmax     1,nblok,nxv,nypmx)      do 50 l = 1, nblok      npp(l) = npp(l) + npl   50 continuec wait for tasks to complete      do 60 i = 1, nmt      ierr = 5*ierr + MP_WAITSIG(idtask(i))      ek = ek + ekp(i)   60 continue      return      endc-----------------------------------------------------------------------      subroutine MPGPUSH2L(part,fxy,npp,nps,noff,qbm,dt,ek,nx,idimp,npma     1x,nblok,nxv,nypmx,ekp,idtask,nmt,ierr)c reusable parallel multitasking particle pushc ekp = kinetic energy arrays for tasksc idtask = index to notify queue for task (0 if error)c nmt = number of tasksc ierr = ierror indicator (0 = no error)      implicit none      real part, fxy, qbm, dt, ek, ekp      integer npp, nps, noff      integer nx, idimp, npmax, nblok, nxv, nypmx, idtask, nmt, ierr      dimension part(idimp,npmax,nblok)      dimension fxy(2,nxv,nypmx,nblok)      dimension npp(nblok), nps(nblok), noff(nblok)      dimension ekp(nmt), idtask(nmt)c local data      integer first, nargs, npt, npl, npo, i, l      integer MP_SNDSIG, MP_WAITSIG      external PGPUSH2L      save first, nargs      data first, nargs /1,13/c find minimum of npp      npo = npp(1)      do 10 l = 1, nblok      if (npo.gt.npp(l)) npo = npp(l)   10 continue      npt = npo/(nmt + 1)      npl = npt*nmt      ierr = 0c start particle push tasks      do 30 i = 1, nmt      npo = npt*(i - 1) + 1      do 20 l = 1, nblok      nps(l) = npt   20 continue      ekp(i) = 0.      if (first.eq.1) then         call MP_TASKINIT(idtask(i),PGPUSH2L,nargs,part(1,npo,1),fxy,nps     1,noff,qbm,dt,ekp(i),nx,idimp,npmax,nblok,nxv,nypmx)      endifc check for errors      if (idtask(i).eq.0) then        ierr = -1        return      endif      ierr = 5*ierr + MP_SNDSIG(idtask(i))   30 continue      if (ierr.ne.0) return      first = 0c push remaining particles      npo = npl + 1      do 40 l = 1, nblok      npp(l) = npp(l) - npl   40 continue      call PGPUSH2L(part(1,npo,1),fxy,npp,noff,qbm,dt,ek,nx,idimp,npmax,     1nblok,nxv,nypmx)      do 50 l = 1, nblok      npp(l) = npp(l) + npl   50 continuec wait for tasks to complete      do 60 i = 1, nmt      ierr = 5*ierr + MP_WAITSIG(idtask(i))      ek = ek + ekp(i)   60 continue      return      endc-----------------------------------------------------------------------      subroutine MPGSPUSH2L(part,fxy,npp,nps,noff,qbm,dt,ek,nx,idimp,npm     1ax,nblok,nxv,nxyp,ekp,idtask,nmt,ierr)c reusable parallel multitasking particle pushc ekp = kinetic energy arrays for tasksc idtask = index to notify queue for task (0 if error)c nmt = number of tasksc ierr = ierror indicator (0 = no error)      implicit none      real part, fxy, qbm, dt, ek, ekp      integer npp, nps, noff      integer nx, idimp, npmax, nblok, nxv, nxyp, idtask, nmt, ierr      dimension part(idimp,npmax,nblok)      dimension fxy(2,nxyp,nblok)      dimension npp(nblok), nps(nblok), noff(nblok)      dimension ekp(nmt), idtask(nmt)c local data      integer first, nargs, npt, npl, npo, i, l      integer MP_SNDSIG, MP_WAITSIG      external PGSPUSH2L      save first, nargs      data first, nargs /1,13/c find minimum of npp      npo = npp(1)      do 10 l = 1, nblok      if (npo.gt.npp(l)) npo = npp(l)   10 continue      npt = npo/(nmt + 1)      npl = npt*nmt      ierr = 0c start particle push tasks      do 30 i = 1, nmt      npo = npt*(i - 1) + 1      do 20 l = 1, nblok      nps(l) = npt   20 continue      ekp(i) = 0.      if (first.eq.1) then         call MP_TASKINIT(idtask(i),PGSPUSH2L,nargs,part(1,npo,1),fxy,np     1s,noff,qbm,dt,ekp(i),nx,idimp,npmax,nblok,nxv,nxyp)      endifc check for errors      if (idtask(i).eq.0) then        ierr = -1        return      endif      ierr = 5*ierr + MP_SNDSIG(idtask(i))   30 continue      if (ierr.ne.0) return      first = 0c push remaining particles      npo = npl + 1      do 40 l = 1, nblok      npp(l) = npp(l) - npl   40 continue      call PGSPUSH2L(part(1,npo,1),fxy,npp,noff,qbm,dt,ek,nx,idimp,npmax     1,nblok,nxv,nxyp)      do 50 l = 1, nblok      npp(l) = npp(l) + npl   50 continuec wait for tasks to complete      do 60 i = 1, nmt      ierr = 5*ierr + MP_WAITSIG(idtask(i))      ek = ek + ekp(i)   60 continue      return      end