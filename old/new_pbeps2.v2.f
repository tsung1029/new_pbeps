!-----------------------------------------------------------------------! * * * periodic 2d electrostatic particle simulation kernel code * * *! this is a simple 2d skeleton particle-in-cell code designed for! exploring new computer architectures.  it contains the critical pieces! needed for depositing charge, advancing particles, and solving the! field.  the code moves only electrons, with periodic electrostatic! forces obtained by solving poisson's equation with fast fourier! transforms.  the only diagnostic is particle and field energy.! portable gcpic kernel code, using algorithm described in:! p. c. liewer and v. k. decyk, j. computational phys. 85, 302 (1989).! written by viktor k. decyk, ucla! for mpi distributed memory computers! update: july 15, 2000      program pbeps2      use pinit2d      use ppush2d      use pfield2d      use p2d      implicit none! indx/indy = exponent which determines length in x/y direction,! where nx=2**indx, ny=2**indy! npx/npy = initial number of particles distributed in x/y direction!     integer :: indx =   5, indy =   6, npx =      96, npy =     192      integer :: indx =   6, indy =   7, npx =     384, npy =     768!     integer :: indx =   7, indy =   8, npx =    1280, npy =    2560! npxb/npyb = initial number of particles in beam in x/y direction!     integer :: npxb =  32, npyb =  64      integer :: npxb = 128, npyb = 256!     integer :: npxb = 384, npyb = 768! indnvp = exponent determining number of real or virtual processors! indnvp must be <= indy! idps = number of partition boundaries! idimp = dimension of phase space = 4! mshare = (0,1) = (no,yes) architecture is shared memory      integer :: indnvp =   1, idps =    2, idimp =   4, mshare =   0      integer :: inorder = QUADRATIC, popt = LOOKAHEAD, dopt = LOOKAHEAD      integer :: sortime = 25, vect = 0! tend = time at end of simulation, in units of plasma frequency! dt = time interval between successive calculations      real :: tend =  65.000, dt = 0.2000000e+00! vtx/vty = thermal velocity of electrons in x/y direction! qme = charge on electron, in units of e      real :: vtx = 1.0, vty = 1.0, qme = -1.0! vdx/vdy = drift velocity of beam electrons in x/y direction! vtdx/vtdy = thermal velocity of beam electrons in x/y direction      real :: vdx = 0.0, vdy = 5.0, vtdx = 0.5, vtdy = 0.5! ax/ay = half-width of particle in x/y direction      real :: ax = .866667, ay = .866667!     real :: ax = .912871, ay = .912871      integer :: npxy, npxyb, np, nx, ny, nxh, nyh, nyv, nxe, nxeh      integer :: nloop, nvp, nblok, npmax, nypmx      integer :: kyp, kxp, kyb, kxb, kxyb, kbmin, kblok, jbmin, jblok      integer :: ngds, nxyh, nxhy, nbmax      integer :: idproc, kstrt, itime, isign, ierr      real :: zero = 0.0      real :: qbme, affp, qi0, we, wke      double precision :: dtime      real, dimension(:,:,:), allocatable :: part      real, dimension(:,:,:), allocatable :: qe      real, dimension(:,:,:,:), allocatable :: fxye      complex, dimension(:,:,:), allocatable :: qt      complex, dimension(:,:,:,:), allocatable :: fxyt      complex, dimension(:,:,:), allocatable :: ffc      integer, dimension(:), allocatable :: mixup      complex, dimension(:), allocatable :: sct      real, dimension(:,:), allocatable  :: edges      integer, dimension(:), allocatable :: nyp, noff      integer, dimension(:), allocatable :: npp, nps      complex, dimension(:,:,:), allocatable :: pott! wtot = total energy      real, dimension(3) :: wtot! time = timing array      real, dimension(2) :: time      character(len=12) :: label! define namelist      namelist /pinput/ indx,indy,npx,npy,npxb,npyb,indnvp,inorder,popt,&     &dopt,tend,dt,vtx,vty,qme,vdx,vdy,vtdx,vtdy,ax,ay  991 format (5h t = ,i7)  992 format (19h * * * q.e.d. * * *)  993 format (34h field, kinetic, total energies = ,3e14.7)! read namelist      open(unit=8,file='pinput2',form='formatted',status='old')      read (8,pinput)! nvp = number of real or virtual processors, nvp = 2**indnvp      nvp = 2**indnvp! initialize for parallel processing      call PPINIT(idproc,nvp)      kstrt = idproc + 1      if (kstrt.eq.1) then         open(unit=18,file='poutput2',form='formatted',status='unknown')         write (18,pinput)      endif! np = total number of electrons in simulation      npxy = npx*npy; npxyb = npxb*npyb; np = npxy + npxyb      nx = 2**indx; ny = 2**indy; nxh = nx/2; nyh = ny/2      nxe = nx + 4; nyv = ny + 2! ngds = number of guard cells      ngds = 3*((idps - 1)/2 + 1)      if (inorder.eq.LINEAR) then         ax = .912871; ay = .912871         nxe = nx + 2; ngds = (idps - 1)/2 + 1      endif      if (popt.eq.VECTOR) vect = 1      nxeh = nxe/2! nloop = number of time steps in simulation      nloop = tend/dt + .0001! nblok = number of particle partitions      nblok = 1 + mshare*(nvp - 1)! npmax = maximum number of particles in each partition! nypmx = maximum size of particle partition, including guard cells.      npmax = (np/nvp)*1.01 + 7000; nypmx = (ny - 1)/nvp + 4! kyp = number of complex grids in each field partition in y direction! kxp = number of complex grids in each field partition in x direction      kyp = (ny - 1)/nvp + 1; kxp = (nxh - 1)/nvp + 1! kyb = number of processors in y! kxb = number of processors in x      kyb = ny/kyp; kxb = nxh/kxp! kxyb = maximum(kxb,kyb)      kxyb = max(kxb,kyb)! kblok = number of field partitions in y direction      kbmin = kxyb/kxb; kblok = kbmin + mshare*(ny/kyp - kbmin)! jblok = number of field partitions in x direction      jbmin = kxyb/kyb; jblok = jbmin + mshare*(nxh/kxp - jbmin)! nxyh = maximum(nx,ny)/2      nxyh = max(nx,ny)/2! nxhy = maximum(nx/2,ny)      nxhy = max(nxh,ny)! nbmax = size of buffer for passing particles between processors      nbmax = 1 + (2*(npxy*vty + npxyb*vtdy) + 1.4*npxyb*abs(vdy))*dt/ny! part(1,n,l) = position x of particle n in partition l! part(2,n,l) = position y of particle n in partition l! part(3,n,l) = velocity vx of particle n in partition l! part(4,n,l) = velocity vy of particle n in partition l      allocate(part(idimp,npmax,nblok))! in real space, qe(j+1,k,l) = charge density at grid point (j,kk)! in real space, fxye(i,j+1,k,l) = i component of force/charge at ! grid point (j,kk)! in other words, fxye are the convolutions of the electric field! over the particle shape, where kk = k + noff(l) - 1      allocate(qe(nxe,nypmx,kblok),fxye(2,nxe,nypmx,kblok))! qt(k,j,l) = complex charge density for fourier mode jj-1,k-1! fxyt(1,k,j,l) = x component of force/charge for fourier mode jj-1,k-1! fxyt(2,k,j,l) = y component of force/charge for fourier mode jj-1,k-1! where jj = j + kxp*(l - 1)      allocate(qt(nyv,kxp,jblok),fxyt(2,nyv,kxp,jblok))! ffc = form factor array for poisson solver      allocate(ffc(nyh,kxp,jblok))! mixup, sct = arrays for fft      allocate(mixup(nxhy),sct(nxyh))! edges(1,l) = lower boundary of particle partition l! edges(2,l) = upper boundary of particle partition l      allocate(edges(idps,nblok))! nyp(l) = number of primary gridpoints in particle partition l.! noff(l) = lowermost global gridpoint in particle partition l.      allocate(nyp(nblok),noff(nblok))! npp(l) = number of particles in partition l! nps(l) = starting address of particles in partition l      allocate(npp(nblok),nps(nblok))! potential      allocate(pott(nyv,kxp,jblok))! initialize parallel timer      call pwtimer(time,dtime,-1)! initialize constants      itime = 0      qbme = qme      affp = float(nx*ny)/float(np)! calculate partition variables      call dcomp(edges,nyp,noff,ny,kstrt,nvp,inorder)! prepare fft tables      call fft_init(mixup,sct,indx,indy)! calculate form factors      call pois_init(ffc,ax,ay,affp,nx,ny,kstrt)! initialize density profile and velocity distribution      nps = 1      npp = 0      if (npxy.gt.0) call distr(part,edges,npp,nps,vtx,vty,zero,zero,npx&     &,npy,nx,ny)! beam electrons      nps = npp + 1      if (npxyb.gt.0) call distr(part,edges,npp,nps,vtdx,vtdy,vdx,vdy,np&     &xb,npyb,nx,ny)! initialize charge density to background      qi0 = -qme/affp      call sguard(qe,nyp,qi0,nx,inorder)! deposit charge for initial distribution      call dpost(part,qe,qme,npp,noff,inorder,STANDARD)! add guard cells in x direction      call aguard(qe,nyp,nx,inorder)      call pwtimer(time,dtime)      write (18,*) 'init max/min real time = ', time(1), time(2), 'sec'!! * * * start main iteration loop * * *!  500 if (nloop.le.itime) go to 2000      if (kstrt.eq.1) write (18,991) itime      write (label,991) itime      call LOGNAME(label)! copy data from particle to field partition, and add up guard cells      call paguard(qe,kstrt,nvp,kyp,ngds)! transform charge to fourier space      isign = -1      call fft(qe,qt,isign,mixup,sct,indx,indy,kstrt,kyp,inorder)! calculate potential in fourier space      call pois(qt,pott,ffc,we,nx,ny,kstrt)! transform potential to real space (result stored in qe)      isign = 1      call fft(qe,pott,isign,mixup,sct,indx,indy,kstrt,kyp,inorder)! calculate force/charge in fourier space      call pois(qt,fxyt,ffc,we,nx,ny,kstrt)! transform force/charge to real space      call fft(fxye,fxyt,mixup,sct,indx,indy,kstrt,kyp,inorder)! copy data from field to particle partition, and copy to guard cells      call pcguard(fxye,kstrt,nvp,kyp,inorder)! particle push and charge density update      call cguard(fxye,nyp,nx,inorder)      wke = 0.! push particles      call push(part,fxye,npp,noff,qbme,dt,wke,nx,inorder,popt)! move particles into appropriate spatial regions      call pmove(part,edges,npp,ny,kstrt,nvp,nbmax,vect,ierr)      if (ierr.ne.0) then         call PPEXIT         stop      endif! initialize charge density to background      call sguard(qe,nyp,qi0,nx,inorder)! deposit charge      call dpost(part,qe,qme,npp,noff,inorder,dopt)! merge density arrays in x direction      call aguard(qe,nyp,nx,inorder)! sort particles      if (mod(itime,sortime).eq.0) then         call sortp(part,npp,noff,kyp,inorder)      endif ! energy diagnostic      wtot(1) = we      wtot(2) = wke      wtot(3) = we + wke      call plsum(wtot)      if (kstrt.eq.1) write (18,993) wtot(1), wtot(2), wtot(3)      itime = itime + 1      go to 500 2000 continue!! * * * end main iteration loop * * *!      if (kstrt.eq.1) write (6,992)      call pwtimer(time,dtime)      write (18,*) 'main max/min real time = ', time(1), time(2), 'sec'      call PPEXIT      stop      end