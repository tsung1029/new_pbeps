c-----------------------------------------------------------------------      program dbltestc indnvp = exponent which determines number of virtual processorsc mshare = (0,1) = (no,yes) architecture is shared memory      parameter( indx =   5, indy =   6, indnvp =   2, mshare =   0)c     parameter( indx =   2, indy =   3, indnvp =   3, mshare =   0)      parameter(nx=2**indx,ny=2**indy,nx2=2*nx,ny2=2*ny,nxh=nx/2)      parameter(nvp=2**indnvp,kyp=(ny-1)/nvp+1,kyp2=(ny2-1)/nvp+1)      parameter(kblok=1+mshare*(ny/kyp-1),k2blok=1+mshare*(ny2/kyp2-1))      parameter(nxv=nx+4,nyv=ny+3,nx2v=2*nxv,nypmx=kyp+3)      parameter(kxp=(nxh-1)/nvp+1,kxp2=(nx-1)/nvp+1)      parameter(jblok=1+mshare*(nxh/kxp-1),j2blok=1+mshare*(nx/kxp2-1))      parameter(idps=2,ngds=3*((idps-1)/2+1))      double precision ranorm      dimension q(nxv,nypmx,kblok), q2(nx2v,kyp2,k2blok)      dimension scr(nxv,ngds,kblok)      dimension edges(idps,kblok), nyp(kblok), noff(kblok)      dimension f(2,nxv,nypmx,kblok), fxy2(2,nx2v,kyp2,k2blok)      dimension g(nxv,nyv), g2(nx2v,ny2)      dimension hxy(2,nxv,nyv), hxy2(2,nx2v,ny2)      complex ffd, ffp      dimension ffd(nxv,ny), ffp(ny,kxp2,j2blok)      complex h2      dimension h2(nxv,ny2)      dimension hx(nx2v,ny2), hy(nx2v,ny2)      complex gt, fx, fy, fxy      dimension gt(ny2,kxp2,j2blok)      dimension fx(ny2,kxp2,j2blok), fy(ny2,kxp2,j2blok)      dimension fxy(2,ny2,kxp2,j2blok)c debug      complex sct, gxy      dimension gxy(2,nxv,ny2)      dimension mixup(ny2), sct(ny)      data ax,ay,affp /.866667,.866667,0.25/c initialize for parallel processingc     idproc = 0      call ppinit(idproc,nvp)      kstrt = idproc + 1      ks = kstrt - 2c calculate partition variables      call dcomp2(edges,nyp,noff,ny,kstrt,nvp,idps,kblok)c create tables      isign = 0      call POISD2(g2,hx,hy,isign,ffd,ax,ay,affp,we,nx,ny,nx2v,ny2)      call PPOISD2(gt,fx,fy,isign,ffp,ax,ay,affp,we,nx,ny,kstrt,ny2,kxp2     1,j2blok,ny)c create test function      do 30 k = 1, ny      kk = (k - 1)/kyp      k1 = k - kyp*kk      do 20 j = 1, nxv      g(j,k) = ranorm(d)      do 10 l = 1, kblok      if (kk.eq.(l+ks)) q(j,k1,l) = g(j,k)   10 continue   20 continue   30 continue      do 60 j = 1, nx      jj = (j - 1)/kxp2      j1 = j - kxp2*jj      do 50 k = 1, ny2      at1 = ranorm(d)      at2 = ranorm(d)      h2(j,k) = cmplx(at1,at2)      do 40 l = 1, j2blok      if (jj.eq.(l+ks)) gt(k,j1,l) = h2(j,k)   40 continue   50 continue   60 continue      do 65 k = 1, ny2      kk = (k - 1)/kyp2      k1 = k - kyp2*kk      do 55 j = 1, nx2      hxy2(1,j,k) = ranorm(d)      hxy2(2,j,k) = ranorm(d)      do 45 l = 1, k2blok      if (kk.eq.(l+ks)) then         fxy2(1,j,k1,l) = hxy2(1,j,k)         fxy2(2,j,k1,l) = hxy2(2,j,k)      endif   45 continue   55 continue   65 continuec create guard cellsc shift and split them      do 455 k = 1, ny      do 445 j = 1, nxv      g(j,ny+2-k) = g(j,ny+1-k)  445 continue  455 continue      do 465 j = 1, nxv      g(j,1) = .5*g(j,2)      g(j,ny+3) = .25*g(j,ny+1)      g(j,ny+2) = .5*g(j,ny+1)  465 continuec create distributed guard cellsc shift and split them      if (kstrt.gt.ny) go to 436      do 435 l = 1, kblok      koff = kyp*(l + ks)      do 415 k = 1, kyp      do 405 j = 1, nxv      q(j,kyp+2-k,l) = q(j,kyp+1-k,l)  405 continue  415 continue      do 425 j = 1, nxv      if (koff.gt.0) then         q(j,1,l) = .5*g(j,koff+1)         q(j,2,l) = .5*g(j,koff+2)         q(j,3,l) = .5*g(j,koff+3)c        q(j,1,l) = .25*g(j,koff+1)c        q(j,2,l) = .25*g(j,koff+2)c        q(j,3,l) = .25*g(j,koff+3)c        if (koff.eq.kyp) q(j,2,l) = 2.*q(j,2,l)      elsec        q(j,2,l) = .75*g(j,koff+2)         q(j,1,l) = g(j,koff+1)      endif      if ((koff+kyp).lt.ny) then         q(j,kyp+1,l) = .5*g(j,koff+kyp+1)         q(j,kyp+2,l) = .5*g(j,koff+kyp+2)         q(j,kyp+3,l) = .5*g(j,koff+kyp+3)c        if (koff.gt.kyp) thenc           q(j,kyp+1,l) = .25*g(j,koff+kyp+1)c        endifc        q(j,kyp+2,l) = .25*g(j,koff+kyp+2)c        q(j,kyp+3,l) = .25*g(j,koff+kyp+3)      elsec        if (koff.gt.0) thenc           q(j,kyp+1,l) = .5*g(j,koff+kyp+1)c        endif         q(j,kyp+2,l) = g(j,ny+2)c        q(j,kyp+2,l) = .75*g(j,ny+2)         q(j,kyp+3,l) = g(j,ny+3)      endif  425 continue  435 continue  436 continuec fold guard cells      call LAGUARD2(g,nx,ny,nxv,nyv)      call PLAGUARD2X(q,nyp,nx,nxv,nypmx,kblok)      call PLAGUARD2(q,scr,kstrt,nvp,nx,nxv,nypmx,kyp,kblok,ngds)c verify interior guard cell data      sum1 = 0.      epsmax = 0.      ierr = 0      if (kstrt.gt.ny) go to 327      do 325 l = 1, kblok      koff = kyp*(l + ks)      do 315 k = 1, kyp      k1 = k + koff      do 305 j = 1, nx+3      eps = abs(q(j,k+1,l) - g(j,k1+1))      if (eps.gt.epsmax) then         write (51,*) j,k+1,l,k1+1,q(j,k+1,l),g(j,k1+1)         ierr = ierr + 1c        epsmax = eps      endif      sum1 = sum1 + eps  305 continue  315 continue  325 continue      write (6,*) 'interior error=',kstrt,sum1,ierr,epsmaxc verify last guard cells      sum1 = 0.      epsmax = 0.      ierr = 0      do 349 l = 1, kblok      koff = kyp*(l + ks)      if ((koff+kyp).lt.ny) go to 349      k1 = 2 + koff + kyp      if (k1.le.ny+3) then         do 437 j = 1, nx+3         eps = abs(q(j,kyp+2,l) - g(j,k1))         if (eps.gt.epsmax) then            write (82,*) '2:',j,kyp+2,l,k1,q(j,kyp+2,l),g(j,k1)            ierr = ierr + 1c           epsmax = eps         endif         sum1 = sum1 + eps  437    continue      endif      k1 = 3 + koff + kyp      if (k1.le.ny+3) then         do 338 j = 1, nx+3         eps = abs(q(j,kyp+3,l) - g(j,k1))         if (eps.gt.epsmax) then            write (82,*) '3:',j,kyp+3,l,k1,q(j,kyp+3,l),g(j,k1)            ierr = ierr + 1c           epsmax = eps         endif         sum1 = sum1 + eps  338    continue      endif  349 continue      if (kstrt.eq.nvp) then      write (6,*) 'last guard error=',kstrt,sum1,ierr,epsmax      endif  327 continuec double data      call DBLSIN2(g,g2,nx,ny,nxv,nyv,nx2v,ny2)      call PDBLSIN2(q,q2,nx,ny,kstrt,nxv,kyp,nypmx,kyp2,kblok,k2blok)c verify doubled data      sum1 = 0.      epsmax = 0.      ierr = 0      if (kstrt.gt.ny2) go to 100      do 90 l = 1, k2blok      koff = kyp2*(l + ks)      do 80 k = 1, kyp2      k1 = k + koff      do 70 j = 1, nx2      eps = abs(q2(j,k,l) - g2(j,k1))      if (eps.gt.epsmax) then         write (60,*) j,k,l,k1,q2(j,k,l),g2(j,k1)         ierr = ierr + 1c        epsmax = eps      endif      sum1 = sum1 + eps   70 continue   80 continue   90 continue      write (6,*) 'dbl error=',kstrt,sum1,ierr,epsmax  100 continuec half data      call HAFDBL2C(hxy,hxy2,nx,ny,nxv,nyv,nx2v,ny2)      call PHAFDBL2C(f,fxy2,nx,ny,kstrt,nxv,kyp,nypmx,kyp2,kblok,k2blok)c verify halfed data      sum1 = 0.      epsmax = 0.      ierr = 0      if (kstrt.gt.ny) go to 135      do 95 l = 1, kblok      koff = kyp*(l + ks)      do 85 k = 1, kyp      k1 = k + koff      do 75 j = 1, nx+1      eps = abs(f(1,j,k,l) - hxy(1,j,k1))      if (eps.gt.epsmax) then         write (61,*) j,k,l,k1,f(1,j,k,l),hxy(1,j,k1)         ierr = ierr + 1c        epsmax = eps      endif      sum1 = sum1 + eps   75 continue   85 continue   95 continue      write (6,*) 'fxy(1) half error=',kstrt,sum1,ierr,epsmax      sum1 = 0.      epsmax = 0.      ierr = 0      do 125 l = 1, kblok      koff = kyp*(l + ks)      do 115 k = 1, kyp      k1 = k + koff      do 105 j = 1, nx+1      eps = abs(f(2,j,k,l) - hxy(2,j,k1))      if (eps.gt.epsmax) then         write (62,*) j,k,l,k1,f(2,j,k,l),hxy(2,j,k1)         ierr = ierr + 1c        epsmax = eps      endif      sum1 = sum1 + eps  105 continue  115 continue  125 continue      write (6,*) 'fxy(2) half error=',kstrt,sum1,ierr,epsmax  135 continuec verify guard cells      sum1 = 0.      epsmax = 0.      ierr = 0      if (kstrt.gt.ny) go to 185      do 155 l = 1, kblok      koff = kyp*(l + ks)      k1 = 1 + koff + kyp      do 145 j = 1, nx+1      eps = abs(f(1,j,kyp+1,l) - hxy(1,j,k1))      if (eps.gt.epsmax) then         write (63,*) j,kyp+1,l,k1,f(1,j,kyp+1,l),hxy(1,j,k1)         ierr = ierr + 1c        epsmax = eps      endif      sum1 = sum1 + eps  145 continue  155 continue      write (6,*) 'fxy(1) guard error=',kstrt,sum1,ierr,epsmax      sum1 = 0.      epsmax = 0.      ierr = 0      do 175 l = 1, kblok      koff = kyp*(l + ks)      k1 = 1 + koff + kyp      do 165 j = 1, nx+1      eps = abs(f(2,j,kyp+1,l) - hxy(2,j,k1))      if (eps.gt.epsmax) then         write (64,*) j,kyp+1,l,k1,f(2,j,kyp+1,l),hxy(2,j,k1)         ierr = ierr + 1c        epsmax = eps      endif      sum1 = sum1 + eps  165 continue  175 continue      write (6,*) 'fxy(2) guard error=',kstrt,sum1,ierr,epsmax  185 continuec create and shift guard cells      do 655 k = 1, ny+1      do 645 j = 1, nx+1      hxy(1,nx+3-j,ny+3-k) = hxy(1,nx+2-j,ny+2-k)      hxy(2,nx+3-j,ny+3-k) = hxy(2,nx+2-j,ny+2-k)  645 continue  655 continuec create and shift distributed guard cells      if (kstrt.gt.ny) go to 637      do 635 l = 1, kblok      koff = kyp*(l + ks)      if ((koff+kyp).eq.ny) then         do 600 j = 1, nx+1         f(1,nx+3-j,kyp+2,l) = f(1,nx+2-j,kyp+1,l)         f(2,nx+3-j,kyp+2,l) = f(2,nx+2-j,kyp+1,l)  600    continue      endif      do 615 k = 1, kyp      do 605 j = 1, nx+1      f(1,nx+3-j,kyp+2-k,l) = f(1,nx+2-j,kyp+1-k,l)      f(2,nx+3-j,kyp+2-k,l) = f(2,nx+2-j,kyp+1-k,l)  605 continue  615 continue  635 continue  637 continuec replicate guard cells      call LCGUARD2(hxy,nx,ny,nxv,nyv)c     call PLDGUARD2(f,kstrt,nvp,2*nx+2,2*nxv,nypmx,kyp,kblok)      call PLCGUARD2(f,kstrt,nvp,nx,nxv,nypmx,kyp,kblok)      call PLCGUARD2X(f,nyp,nx,nxv,nypmx,kblok)c verify exterior guard cells      sum1 = 0.      epsmax = 0.      ierr = 0      if (kstrt.gt.ny) go to 355      do 345 l = 1, kblok      koff = kyp*(l + ks)      k1 = 1 + koff      do 335 j = 1, nx+3      eps = abs(f(2,j,1,l) - hxy(2,j,k1))      if (eps.gt.epsmax) then         write (52,*) '1:',j,1,l,k1,f(2,j,1,l),hxy(2,j,k1)         ierr = ierr + 1         epsmax = eps      endif      sum1 = sum1 + eps  335 continue      k1 = 2 + koff + kyp      if (k1.le.ny+3) then         do 336 j = 1, nx+3         eps = abs(f(2,j,kyp+2,l) - hxy(2,j,k1))         if (eps.gt.epsmax) then            write (52,*) '2:',j,kyp+2,l,k1,f(2,j,kyp+2,l),hxy(2,j,k1)            ierr = ierr + 1            epsmax = eps         endif         sum1 = sum1 + eps  336    continue      endif      k1 = 3 + koff + kyp      if (k1.le.ny+3) then         do 337 j = 1, nx+3         eps = abs(f(2,j,kyp+3,l) - hxy(2,j,k1))         if (eps.gt.epsmax) then            write (52,*) '3:',j,kyp+3,l,k1,f(2,j,kyp+3,l),hxy(2,j,k1)            ierr = ierr + 1            epsmax = eps         endif         sum1 = sum1 + eps  337    continue      endif  345 continue      write (6,*) 'exterior guard error=',kstrt,sum1,ierr,epsmax  355 continuec half scalar data      call HAFDBL2D(g,g2,nx,ny,nxv,nyv,nx2v,ny2)      call PHAFDBL2D(q,q2,nx,ny,kstrt,nxv,kyp,nypmx,kyp2,kblok,k2blok)c verify halfed scalar data      sum1 = 0.      epsmax = 0.      ierr = 0      if (kstrt.gt.ny) go to 201      do 197 l = 1, kblok      koff = kyp*(l + ks)      do 196 k = 1, kyp      k1 = k + koff      do 195 j = 1, nx+1      eps = abs(q(j,k,l) - g(j,k1))      if (eps.gt.epsmax) then         write (69,*) j,k,l,k1,q(j,k,l),g(j,k1)         ierr = ierr + 1c        epsmax = eps      endif      sum1 = sum1 + eps  195 continue  196 continue  197 continue      write (6,*) 'q half error=',kstrt,sum1,ierr,epsmaxc verify scalar guard cells      sum1 = 0.      epsmax = 0.      ierr = 0      do 199 l = 1, kblok      koff = kyp*(l + ks)      k1 = 1 + koff + kyp      do 198 j = 1, nx+1      eps = abs(q(j,kyp+1,l) - g(j,k1))      if (eps.gt.epsmax) then         write (70,*) j,kyp+1,l,k1,q(j,kyp+1,l),g(j,k1)         ierr = ierr + 1c        epsmax = eps      endif      sum1 = sum1 + eps  198 continue  199 continue      write (6,*) 'q guard error=',kstrt,sum1,ierr,epsmax  201 continuec solve field equations      isign = -1      call POISD2(h2,hx,hy,isign,ffd,ax,ay,affp,we,nx,ny,nx2v,ny2)      call PPOISD2(gt,fx,fy,isign,ffp,ax,ay,affp,wf,nx,ny,kstrt,ny2,kxp2     1,j2blok,ny)      call psum(wf,at1,1,1)      call POISD22(h2,gxy,isign,ffd,ax,ay,affp,wg,nx,ny,nxv,ny2)      call PPOISD22(gt,fxy,isign,ffp,ax,ay,affp,wh,nx,ny,kstrt,ny2,kxp2,     1j2blok,ny)      call psum(wh,at1,1,1)      if (kstrt.eq.1) then         print *, 'we,wf,wg,wh=',we,wf,wg,wh      endifc debug      ierr = 0      epsmax = 0.      if (kstrt.gt.nx) go to 217      do 213 l = 1, j2blok      joff = kxp2*(l + ks)      do 212 j = 1, kxp2      j1 = j + joff      do 211 k = 1, ny2      eps = abs(fx(k,j,l) - gxy(1,j1,k))      if (eps.gt.epsmax) then         write (65,*) j,k,l,j1,fx(k,j,l),gxy(1,j1,k)         ierr = ierr + 1         epsmax = eps      endif  211 continue  212 continue  213 continue      write (6,*) 'gxy(1) error=',kstrt,ierr,epsmax      ierr = 0      epsmax = 0.      do 216 l = 1, j2blok      joff = kxp2*(l + ks)      do 215 j = 1, kxp2      j1 = j + joff      do 214 k = 1, ny2      eps = abs(fy(k,j,l) - gxy(2,j1,k))      if (eps.gt.epsmax) then         write (66,*) j,k,l,j1,fy(k,j,l),gxy(2,j1,k)         ierr = ierr + 1         epsmax = eps      endif  214 continue  215 continue  216 continue      write (6,*) 'gxy(2) error=',kstrt,ierr,epsmax  217 continuec end debugc verify field equations      sum1 = 0.c     epsmax = 1.0e-7      epsmax = 0.      ierr = 0      if (kstrt.gt.nx) go to 170      do 130 l = 1, j2blok      joff = kxp2*(l + ks)      do 120 j = 1, kxp2      j1 = j + joff      do 110 k = 1, ny2      eps = abs(fx(k,j,l) - cmplx(hx(2*j1-1,k),hx(2*j1,k)))      if (eps.gt.epsmax) then         write (67,*) j,k,l,j1,fx(k,j,l),cmplx(hx(2*j1-1,k),hx(2*j1,k))         ierr = ierr + 1         epsmax = eps      endif      sum1 = sum1 + eps  110 continue  120 continue  130 continue      write (6,*) 'fx error=',kstrt,sum1,ierr,epsmax      sum1 = 0.c     epsmax = 1.0e-7      epsmax = 0.0      ierr = 0      do 160 l = 1, j2blok      joff = kxp2*(l + ks)      do 150 j = 1, kxp2      j1 = j + joff      do 140 k = 1, ny2      eps = abs(fy(k,j,l) - cmplx(hy(2*j1-1,k),hy(2*j1,k)))      if (eps.gt.epsmax) then         write (68,*) j,k,l,j1,fy(k,j,l),cmplx(hy(2*j1-1,k),hy(2*j1,k))         ierr = ierr + 1         epsmax = eps      endif      sum1 = sum1 + eps  140 continue  150 continue  160 continue      write (6,*) 'fy error=',kstrt,sum1,ierr,epsmax  170 continue      call psum (sum1,at1,1,1)      write (6,*) 'global error=',kstrt,sum1      call ppexitc     if (kstrt.eq.1) pause      stop      endc-----------------------------------------------------------------------      subroutine PDBLSIN2(q,q2,nx,ny,kstrt,nxv,kyp,kypd,kyp2,kblok,k2blo     1k)c this subroutine creates an odd array q2 from an array q, so thatc a 2d sine transform can be performed with a 2d real to complex fft.c linear interpolation for distributed datac q2 array may be modifiedc nx/ny = system length in x/y directionc kstrt = starting data block numberc nxv = first dimension of input array q, must be >= nxc kyp = number of data values per block in yc kypd = second dimension of input array q, must be >= kypc kyp2 = second dimension of output array q2, must be >= kyp2c kblok = number of data blocks in yc k2blok = number of data blocks in y for doubled data      implicit none      real q, q2      integer nx, ny, kstrt, nxv, kyp, kypd, kyp2, kblok, k2blok      dimension q(nxv,kypd,kblok), q2(2*nxv,kyp2,k2blok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=8)c lgrp = current communicatorc mreal = default datatype for reals      common /pparms/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer istatus, lsid, msid, nsid, ierr      integer j, k, l, nxs, nys, ny2, kyb, kyb2, ks, koff, moff      integer kk, ll, lm, k1, k2, joff      dimension istatus(lstat)      nxs = nx - 1      nys = ny - 1      kyb = ny/kyp      ny2 = ny + ny      kyb2 = ny2/kyp2      ks = kstrt - 2      moff = kypd + kybc copy to double array in x direction      do 80 l = 1, k2blok      koff = kyp2*(l + ks)      ll = koff/kyp + 1      koff = kyp*(l + ks)      lm = koff/kyp2 + 1c special case for one processor      if (kyb2.eq.1) then         do 20 k = 1, nys         do 10 j = 1, nxs         q2(j+1,k+1,l) = q(j+1,k+1,l)         q2(nx+j+1,k+1,l) = -q(nx-j+1,k+1,l)         q2(j+1,ny+k+1,l) = -q(j+1,ny-k+1,l)         q2(nx+j+1,ny+k+1,l) = q(nx-j+1,ny-k+1,l)   10    continue         q2(1,k+1,l) = 0.         q2(nx+1,k+1,l) = 0.         q2(1,k+ny+1,l) = 0.         q2(nx+1,k+ny+1,l) = 0.   20    continue         do 30 j = 1, nx         q2(j,1,l) = 0.         q2(j+nx,1,l) = 0.         q2(j,ny+1,l) = 0.         q2(j+nx,ny+1,l) = 0.   30    continue         return      endifc this segment is used for shared memory computersc     if (ll.le.kyb) thenc        do 50 k = 1, kypc        do 40 j = 1, nxc        q2(j,k,l) = q(j,k,ll)c  40    continuec  50    continuec        if (kyp.lt.kyp2) thenc           do 70 k = 1, kypc           do 60 j = 1, nxc           q2(j,k+kyp,l) = q(j,k,ll+1)c  60       continuec  70       continuec        endifc     endifc this segment is used for mpi computers      if (ll.le.kyb) then         call MPI_IRECV(q2(1,1,l),kyp*nxv,mreal,ll-1,moff+1,lgrp,msid,ie     1rr)         if (kyp.lt.kyp2) then            call MPI_IRECV(q2(1,kyp+1,l),kyp*nxv,mreal,ll,moff+1,lgrp,ns     1id,ierr)         endif      endif      if (lm.le.(kyb2/2)) then         call MPI_SEND(q(1,1,l),kyp*nxv,mreal,lm-1,moff+1,lgrp,ierr)      endifc wait for data and unpack it      if (ll.le.kyb) then         call MPI_WAIT(msid,istatus,ierr)         do 50 k = 2, kyp         k1 = kyp - k + 2         k2 = (k1 - 1)/2 + 1         joff = nxv*(k1 - 2*k2 + 1)         do 40 j = 1, nxv         q2(j,k1,l) = q2(j+joff,k2,l)   40    continue   50    continue         if (kyp.lt.kyp2) then            call MPI_WAIT(nsid,istatus,ierr)            do 70 k = 2, kyp            k1 = kyp - k + 2            k2 = (k1 - 1)/2 + 1            joff = nxv*(k1 - 2*k2 + 1)            do 60 j = 1, nxv            q2(j,k1+kyp,l) = q2(j+joff,k2+kyp,l)   60       continue   70       continue         endif      endif   80 continuec copy to double array in y direction      do 140 l = 1, k2blok      koff = kyp2*(l + ks)      ll = (ny2 - koff - 1)/kyp + 1      koff = kyp*(l + ks)      lm = (ny2 - koff - 1)/kyp2 + 1      koff = koff + kyp2*lm - ny2c this segment is used for shared memory computersc     if (ll.le.kyb) thenc        if ((ll+1).le.kyb) thenc           do 90 j = 1, nxc           q2(j,1,l) = q(j,1,ll+1)c  90       continuec        endifc        if (kyp.lt.kyp2) thenc           do 110 k = 1, kypc           do 100 j = 1, nxc           q2(j,k+kyp,l) = q(j,k,ll)c 100       continuec 110       continuec        endifc        if (kyp.gt.1) thenc           do 130 k = 2, kypc           do 120 j = 1, nxc           q2(j,k,l) = q(j,k,ll-1)c 120       continuec 130       continuec        endifc     endifc this segment is used for mpi computers      if (ll.le.kyb) then         if ((ll+1).le.kyb) then            call MPI_IRECV(q2(1,1,l),nxv,mreal,ll,moff+2,lgrp,lsid,ierr)         endif         if (kyp.lt.kyp2) then            call MPI_IRECV(q2(1,kyp+1,l),kyp*nxv,mreal,ll-1,moff+2,lgrp,     1msid,ierr)         endif         if (kyp.gt.1) then            call MPI_IRECV(q2(1,2,l),(kyp-1)*nxv,mreal,ll-2,moff+2,lgrp,     1nsid,ierr)         endif      endif      if ((lm.gt.(kyb2/2)).and.(lm.le.kyb2)) then         if (koff.eq.0) then            if ((lm+1).le.kyb2) then               call MPI_SEND(q(1,1,l),nxv,mreal,lm,moff+2,lgrp,ierr)            endif            if (kyp.gt.1) then               call MPI_SEND(q(1,2,l),(kyp-1)*nxv,mreal,lm-1,moff+2,lgrp     1,ierr)            endif         else            call MPI_SEND(q(1,1,l),kyp*nxv,mreal,lm-1,moff+2,lgrp,ierr)         endif      endifc wait for data and unpack it      if (ll.le.kyb) then         if ((ll+1).le.kyb) then            call MPI_WAIT(lsid,istatus,ierr)         endif         if (kyp.lt.kyp2) then            call MPI_WAIT(msid,istatus,ierr)            do 100 k = 2, kyp            k1 = kyp - k + 2            k2 = (k1 - 1)/2 + 1            joff = nxv*(k1 - 2*k2 + 1)            do 90 j = 1, nxv            q2(j,k1+kyp,l) = q2(j+joff,k2+kyp,l)   90       continue  100       continue         endif         if (kyp.gt.1) then            call MPI_WAIT(nsid,istatus,ierr)            do 120 k = 3, kyp            k1 = kyp - k + 3            k2 = k1/2 + 1            joff = nxv*(k1 - 2*k2 + 2)            do 110 j = 1, nxv            q2(j,k1,l) = q2(j+joff,k2,l)  110       continue  120       continue         endif      endif  140 continuec create odd array      do 200 l = 1, k2blok      koff = kyp2*(l + ks)      do 190 k = 1, kyp2      kk = k + koff      if ((kk.eq.1).or.(kk.eq.(ny+1))) then         do 150 j = 1, nx         q2(j,k,l) = 0.         q2(j+nx,k,l) = 0.  150    continue      else if (kk.le.ny) then         do 160 j = 1, nxs         q2(nx+j+1,k,l) = -q2(nx-j+1,k,l)  160    continue         q2(1,k,l) = 0.         q2(nx+1,k,l) = 0.      else if (kk.gt.(ny+1)) then         if (k.eq.1) then            do 170 j = 1, nxs            q2(nx+j+1,k,l) = q2(nx-j+1,k,l)  170       continue         else            do 180 j = 1, nxs            q2(nx+j+1,kyp2-k+2,l) = q2(nx-j+1,k,l)  180       continue         endif         q2(1,k,l) = 0.         q2(nx+1,k,l) = 0.      endif  190 continue  200 continuec finish odd array      do 230 l = 1, k2blok      koff = kyp2*(l + ks)      do 220 k = 1, kyp2      kk = k + koff      if (kk.gt.(ny+1)) then         do 210 j = 1, nxs         q2(nx-j+1,k,l) = -q2(nx+j+1,k,l)  210    continue         q2(nx+1,k,l) = -q2(nx+1,k,l)      endif  220 continue  230 continue      return      endc-----------------------------------------------------------------------      subroutine PHAFDBL2C(fxy,fxy2,nx,ny,kstrt,nxv,kyp,kypd,kyp2,kblok,     1k2blok)c this subroutine copies data from a double array to regular arrayc with guard cells for vector field and linear interpolationc for distributed datac fxy array may be modifiedc nx/ny = system length in x/y directionc kstrt = starting data block numberc nxv = second dimension of output array fxy, must be >= nxc kyp = number of data values per block in yc kypd = third dimension of output array fxy, must be >= kyp+1c kyp2 = third dimension of output array fxy2, must be >= kyp2c kblok = number of data blocks in yc k2blok = number of data blocks in y for doubled data      implicit none      real fxy, fxy2      integer nx, ny, kstrt, nxv, kyp, kypd, kyp2, kblok, k2blok      dimension fxy(2,nxv,kypd,kblok), fxy2(2,2*nxv,kyp2,k2blok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=8)c lgrp = current communicatorc mreal = default datatype for reals      common /pparms/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer istatus, msid, nsid, ierr      integer j, k, l, nx1, ny1, kyb, kyb2, kyp1, ks, joff, koff, moff      integer kk, ll, lm      dimension istatus(lstat)      nx1 = nx + 1      ny1 = ny + 1      kyb = ny/kyp      kyb2 = (ny + ny)/kyp2      kyp1 = kyp + 1      ks = kstrt - 2      moff = kypd + kyb      do 90 l = 1, k2blok      koff = kyp2*(l + ks)      lm = koff/kyp + 1      koff = kyp*(l + ks)      ll = koff/kyp2 + 1      koff = koff - kyp2*(ll - 1)c special case for one processor      if (kyb2.eq.1) then         do 20 k = 1, ny1         do 10 j = 1, nx1         fxy(1,j,k,l) = fxy2(1,j,k,l)         fxy(2,j,k,l) = fxy2(2,j,k,l)   10    continue   20    continue         go to 90      endifc this segment is used for shared memory computersc     if (ll.le.kyb) thenc        if ((koff.eq.0).and.(kyp.lt.kyp2)) thenc           do 40 k = 1, kyp1c           do 30 j = 1, nx1c           fxy(1,j,k,l) = fxy2(1,j,k,ll)c           fxy(2,j,k,l) = fxy2(2,j,k,ll)c  30       continuec  40       continuec        elsec           do 60 k = 1, kypc           do 50 j = 1, nx1c           fxy(1,j,k,l) = fxy2(1,j,k+koff,ll)c           fxy(2,j,k,l) = fxy2(2,j,k+koff,ll)c  50       continuec  60       continuec           do 70 j = 1, nx1c           fxy(1,j,kyp+1,l) = fxy2(1,j,1,ll+1)c           fxy(2,j,kyp+1,l) = fxy2(2,j,1,ll+1)c  70       continuec        endifc     endifc this segment is used for mpi computers      if (ll.le.kyb) then         if ((koff.eq.0).and.(kyp.lt.kyp2)) then            call MPI_IRECV(fxy(1,1,1,l),2*nxv*kyp1,mreal,ll-1,moff+3,lgr     1p,msid,ierr)         else            call MPI_IRECV(fxy(1,1,1,l),2*nxv*kyp,mreal,ll-1,moff+3,lgrp,     1,msid,ierr)            call MPI_IRECV(fxy(1,1,kyp+1,l),2*nxv,mreal,ll,moff+3,lgrp,n     1sid,ierr)         endif      endifc pack data and send it      if (lm.le.kyb) then         if (kyp.lt.kyp2) then            do 40 k = 2, kyp1            kk = (k - 1)/2 + 1            joff = nxv*(k - 2*kk + 1)            do 30 j = 1, nxv            fxy2(1,j+joff,kk,l) = fxy2(1,j,k,l)            fxy2(2,j+joff,kk,l) = fxy2(2,j,k,l)   30       continue   40       continue            call MPI_SEND(fxy2(1,1,1,l),2*nxv*kyp1,mreal,lm-1,moff+3,lgr     1p,ierr)            do 60 k = 2, kyp            kk = (k - 1)/2 + 1            joff = nxv*(k - 2*kk + 1)            do 50 j = 1, nxv            fxy2(1,j+joff,kk+kyp,l) = fxy2(1,j,k+kyp,l)            fxy2(2,j+joff,kk+kyp,l) = fxy2(2,j,k+kyp,l)   50       continue   60       continue            call MPI_SEND(fxy2(1,1,kyp+1,l),2*nxv*kyp,mreal,lm,moff+3,lg     1rp,ierr)         else            do 80 k = 2, kyp            kk = (k - 1)/2 + 1            joff = nxv*(k - 2*kk + 1)            do 70 j = 1, nxv            fxy2(1,j+joff,kk,l) = fxy2(1,j,k,l)            fxy2(2,j+joff,kk,l) = fxy2(2,j,k,l)   70       continue   80       continue            call MPI_SEND(fxy2(1,1,1,l),2*nxv*kyp,mreal,lm-1,moff+3,lgrp     1,ierr)         endif         if (lm.gt.1) then            call MPI_SEND(fxy2(1,1,1,l),2*nxv,mreal,lm-2,moff+3,lgrp,ier     1r)         endif      else if (lm.eq.(kyb+1)) then         call MPI_SEND(fxy2(1,1,1,l),2*nxv,mreal,lm-2,moff+3,lgrp,ierr)      endifc wait for data      if (ll.le.kyb) then         if ((koff.eq.0).and.(kyp.lt.kyp2)) then            call MPI_WAIT(msid,istatus,ierr)         else            call MPI_WAIT(msid,istatus,ierr)            call MPI_WAIT(nsid,istatus,ierr)         endif      endif   90 continue      return      endc-----------------------------------------------------------------------      subroutine PHAFDBL2D(q,q2,nx,ny,kstrt,nxv,kyp,kypd,kyp2,kblok,k2bl     1ok)c this subroutine copies data from a double array to regular arrayc with guard cells for scalar field and linear interpolationc for distributed datac q2 array may be modifiedc nx/ny = system length in x/y directionc kstrt = starting data block numberc nxv = second dimension of output array fxy, must be >= nxc kyp = number of data values per block in yc kypd = third dimension of output array fxy, must be >= kyp+1c kyp2 = third dimension of output array fxy2, must be >= kyp2c kblok = number of data blocks in yc k2blok = number of data blocks in y for doubled data      implicit none      real q, q2      integer nx, ny, kstrt, nxv, kyp, kypd, kyp2, kblok, k2blok      dimension q(nxv,kypd,kblok), q2(2*nxv,kyp2,k2blok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=8)c lgrp = current communicatorc mreal = default datatype for reals      common /pparms/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer istatus, msid, nsid, ierr      integer j, k, l, nx1, ny1, kyb, kyb2, kyp1, ks, joff, koff, moff      integer  kk, ll, lm      dimension istatus(lstat)      nx1 = nx + 1      ny1 = ny + 1      kyb = ny/kyp      kyb2 = (ny + ny)/kyp2      kyp1 = kyp + 1      ks = kstrt - 2      moff = kypd + kyb      do 90 l = 1, k2blok      koff = kyp2*(l + ks)      lm = koff/kyp + 1      koff = kyp*(l + ks)      ll = koff/kyp2 + 1      koff = koff - kyp2*(ll - 1)c special case for one processor      if (kyb2.eq.1) then         do 20 k = 1, ny1         do 10 j = 1, nx1         q(j,k,l) = q2(j,k,l)   10    continue   20    continue         go to 90      endifc this segment is used for shared memory computersc     if (ll.le.kyb) thenc        if ((koff.eq.0).and.(kyp.lt.kyp2)) thenc           do 40 k = 1, kyp1c           do 30 j = 1, nx1c           q(j,k,l) = q2(j,k,ll)c  30       continuec  40       continuec        elsec           do 60 k = 1, kypc           do 50 j = 1, nx1c           q(j,k,l) = q2(j,k+koff,ll)c  50       continuec  60       continuec           do 70 j = 1, nx1c           q(j,kyp+1,l) = q2(j,1,ll+1)c  70       continuec        endifc     endifc this segment is used for mpi computers      if (ll.le.kyb) then         if ((koff.eq.0).and.(kyp.lt.kyp2)) then            call MPI_IRECV(q(1,1,l),nxv*kyp1,mreal,ll-1,moff+4,lgrp,msid     1,ierr)         else            call MPI_IRECV(q(1,1,l),nxv*kyp,mreal,ll-1,moff+4,lgrp,msid,     1ierr)            call MPI_IRECV(q(1,kyp+1,l),nxv,mreal,ll,moff+4,lgrp,nsid,ie     1rr)         endif      endifc pack data and send it      if (lm.le.kyb) then         if (kyp.lt.kyp2) then            do 40 k = 2, kyp1            kk = (k - 1)/2 + 1            joff = nxv*(k - 2*kk + 1)            do 30 j = 1, nxv            q2(j+joff,kk,l) = q2(j,k,l)   30       continue   40       continue            call MPI_SEND(q2(1,1,l),nxv*kyp1,mreal,lm-1,moff+4,lgrp,ierr     1)            do 60 k = 2, kyp            kk = (k - 1)/2 + 1            joff = nxv*(k - 2*kk + 1)            do 50 j = 1, nxv            q2(j+joff,kk+kyp,l) = q2(j,k+kyp,l)   50       continue   60       continue            call MPI_SEND(q2(1,kyp+1,l),nxv*kyp,mreal,lm,moff+4,lgrp,ier     1r)         else            do 80 k = 2, kyp            kk = (k - 1)/2 + 1            joff = nxv*(k - 2*kk + 1)            do 70 j = 1, nxv            q2(j+joff,kk,l) = q2(j,k,l)   70       continue   80       continue            call MPI_SEND(q2(1,1,l),nxv*kyp,mreal,lm-1,moff+4,lgrp,ierr)         endif         if (lm.gt.1) then            call MPI_SEND(q2(1,1,l),nxv,mreal,lm-2,moff+4,lgrp,ierr)         endif      else if (lm.eq.(kyb+1)) then         call MPI_SEND(q2(1,1,l),nxv,mreal,lm-2,moff+4,lgrp,ierr)      endifc wait for data      if (ll.le.kyb) then         if ((koff.eq.0).and.(kyp.lt.kyp2)) then            call MPI_WAIT(msid,istatus,ierr)         else            call MPI_WAIT(msid,istatus,ierr)            call MPI_WAIT(nsid,istatus,ierr)         endif      endif   90 continue      return      endc-----------------------------------------------------------------------      subroutine PLCGUARD2(f,kstrt,nvp,nx,nxv,nypmx,kyp,kblok)c this subroutine copies data from field to particle partitions, copyingc data to guard cells, where the field and particle partitions are c assumed to be the same.  for vector datac the field is replicated so as to disable quadratic interpolationc within half a cell of the edges, and reduce it to linear interpolationc in the y direction.c f(j,k,l) = real data for grid j,k in particle partition l.  the numberc grids per partition is uniform and includes three extra guard cells.c kstrt = starting data block numberc nvp = number of real or virtual processorsc nx = system length in x directionc nxv = first dimension of f, must be >= nxc nypmx = maximum size of particle partition, including guard cells.c kyp = number of complex grids in each field partition.c kblok = number of field partitions.c quadratic interpolation, for distributed data      implicit none      real f      integer kstrt, nvp, nx, nxv, nypmx, kyp, kblok      dimension f(2,nxv,nypmx,kblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=8)c lgrp = current communicatorc mreal = default datatype for reals      common /pparms/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer istatus, msid, nsid, ierr      integer nx2, ks, moff, kr, krr, kl, kll, ngc, j, l      dimension istatus(lstat)      nx2 = nx + 2      ks = kstrt - 2      moff = nypmx*nvpc copy to guard cells      do 70 l = 1, kblok      kr = l + ks + 2      krr = kr      kl = l + ks      kll = kl      ngc = 2c special case of only one grid per processor      if (kyp.eq.1) then         krr = krr + 1         kll = kll - 1         ngc = 1      endifc this segment is used for shared memory computersc     if (kl.ge.1) thenc        do 10 j = 1, nxvc        f(1,j,1,l) = f(1,j,kyp+1,kl)c        f(2,j,1,l) = f(2,j,kyp+1,kl)c  10    continuec     elsec        do 20 j = 1, nxvc        f(1,j,1,l) = f(1,j,3,l)c        f(2,j,1,l) = f(2,j,3,l)c  20    continuec     endifc     if (kr.le.nvp) thenc        do 30 j = 1, nxvc        f(1,j,kyp+2,l) = f(1,j,2,kr)c        f(2,j,kyp+2,l) = f(2,j,2,kr)c        f(1,j,kyp+3,l) = f(1,j,ngc+1,krr)c        f(2,j,kyp+3,l) = f(2,j,ngc+1,krr)c  30    continuec     elsec        do 40 j = 2, nx2c        f(1,j,kyp+3,l) = 2.*f(1,j,kyp+2,l) - f(1,j,kyp+1,l)c        f(2,j,kyp+3,l) = 2.*f(2,j,kyp+2,l) - f(2,j,kyp+1,l)c  40    continuec     endifc     if (kyp.eq.1) thenc        if ((kl.eq.0).and.(kr.le.nvp)) thenc           do 50 j = 1, nxvc           f(1,j,1,l) = f(1,j,2,kr)c           f(2,j,1,l) = f(2,j,2,kr)c  50       continuec        endifc        if (kr.eq.nvp) thenc           do 60 j = 1, nxvc           f(1,j,kyp+3,l) = f(1,j,kyp+2,kr)c           f(2,j,kyp+3,l) = f(2,j,kyp+2,kr)c  60       continuec        endifc     endifc this segment is used for mpi computers      if (kl.ge.1) then         call MPI_IRECV(f(1,1,1,l),2*nxv,mreal,kl-1,moff+3,lgrp,msid,ier     1r)      endif      if (kr.le.nvp) then         call MPI_SEND(f(1,1,kyp+1,l),2*nxv,mreal,kr-1,moff+3,lgrp,ierr)      endif      if (kl.ge.1) then         call MPI_WAIT(msid,istatus,ierr)      else         do 20 j = 1, nxv         f(1,j,1,l) = f(1,j,3,l)         f(2,j,1,l) = f(2,j,3,l)   20    continue      endif      if (kr.le.nvp) then         call MPI_IRECV(f(1,1,kyp+2,l),2*ngc*nxv,mreal,kr-1,moff+4,lgrp,     1msid,ierr)      endif      if (kl.ge.1) then         call MPI_SEND(f(1,1,2,l),2*ngc*nxv,mreal,kl-1,moff+4,lgrp,ierr)      endif      if (kr.le.nvp) then         call MPI_WAIT(msid,istatus,ierr)      else         do 40 j = 2, nx2         f(1,j,kyp+3,l) = 2.*f(1,j,kyp+2,l) - f(1,j,kyp+1,l)         f(2,j,kyp+3,l) = 2.*f(2,j,kyp+2,l) - f(2,j,kyp+1,l)   40    continue      endifc special case of only one grid per processor      if (kyp.eq.1) then         if (krr.le.nvp) then            call MPI_IRECV(f(1,1,kyp+3,l),2*nxv,mreal,krr-1,moff+6,lgrp,     1msid,ierr)         else if (kr.le.nvp) then            call MPI_IRECV(f(1,1,kyp+3,l),2*nxv,mreal,kr-1,moff+6,lgrp,m     1sid,ierr)         endif         if ((kl.eq.0).and.(kr.le.nvp)) then            call MPI_IRECV(f(1,1,1,l),2*nxv,mreal,kr-1,moff+6,lgrp,nsid,     1ierr)         endif         if (kll.ge.1) then            call MPI_SEND(f(1,1,2,l),2*nxv,mreal,kll-1,moff+6,lgrp,ierr)         else if (kl.eq.1) then            call MPI_SEND(f(1,1,2,l),2*nxv,mreal,kl-1,moff+6,lgrp,ierr)         endif         if ((kl.eq.(nvp-1)).and.(kl.ge.1)) then            call MPI_SEND(f(1,1,kyp+2,l),2*nxv,mreal,kl-1,moff+6,lgrp,ie     1rr)         endif         if (kr.le.nvp) then            call MPI_WAIT(msid,istatus,ierr)         endif         if (kl.eq.0) then            call MPI_WAIT(nsid,istatus,ierr)         endif      endif   70 continuec fix left edge      do 100 l = 1, kblok      kl = l + ks      if (kl.eq.0) then         do 90 j = 2, nx2         f(1,j,1,l) = 2.*f(1,j,2,l) - f(1,j,1,l)         f(2,j,1,l) = 2.*f(2,j,2,l) - f(2,j,1,l)   90    continue      endif  100 continue      return      endc-----------------------------------------------------------------------      subroutine PLDGUARD2(f,kstrt,nvp,nx,nxv,nypmx,kyp,kblok)c this subroutine copies data from field to particle partitions, copyingc data to guard cells, where the field and particle partitions are c assumed to be the same.c the field is replicated so as to disable quadratic interpolationc within half a cell of the edges, and reduce it to linear interpolationc in the y direction.c f(j,k,l) = real data for grid j,k in particle partition l.  the numberc grids per partition is uniform and includes three extra guard cells.c kstrt = starting data block numberc nvp = number of real or virtual processorsc nx = system length in x directionc nxv = first dimension of f, must be >= nxc nypmx = maximum size of particle partition, including guard cells.c kyp = number of complex grids in each field partition.c kblok = number of field partitions.c quadratic interpolation, for distributed data      implicit none      real f      integer kstrt, nvp, nx, nxv, nypmx, kyp, kblok      dimension f(nxv,nypmx,kblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=8)c lgrp = current communicatorc mreal = default datatype for reals      common /pparms/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer istatus, msid, nsid, ierr      integer nx2, ks, moff, kr, krr, kl, kll, ngc, j, l      dimension istatus(lstat)      nx2 = nx + 2      ks = kstrt - 2      moff = nypmx*nvpc copy to guard cells      do 70 l = 1, kblok      kr = l + ks + 2      krr = kr      kl = l + ks      kll = kl      ngc = 2c special case of only one grid per processor      if (kyp.eq.1) then         krr = krr + 1         kll = kll - 1         ngc = 1      endifc this segment is used for shared memory computersc     if (kl.ge.1) thenc        do 10 j = 1, nxvc        f(j,1,l) = f(j,kyp+1,kl)c  10    continuec     elsec        do 20 j = 1, nxvc        f(j,1,l) = f(j,3,l)c  20    continuec     endifc     if (kr.le.nvp) thenc        do 30 j = 1, nxvc        f(j,kyp+2,l) = f(j,2,kr)c        f(j,kyp+3,l) = f(j,ngc+1,krr)c  30    continuec     elsec        do 40 j = 2, nx2c        f(j,kyp+3,l) = 2.*f(j,kyp+2,l) - f(j,kyp+1,l)c  40    continuec     endifc     if (kyp.eq.1) thenc        if ((kl.eq.0).and.(kr.le.nvp)) thenc           do 50 j = 1, nxvc           f(j,1,l) = f(j,2,kr)c  50       continuec        endifc        if (kr.eq.nvp) thenc           do 60 j = 1, nxvc           f(j,kyp+3,l) = f(j,kyp+2,kr)c  60       continuec        endifc     endifc this segment is used for mpi computers      if (kl.ge.1) then         call MPI_IRECV(f(1,1,l),nxv,mreal,kl-1,moff+3,lgrp,msid,ierr)      endif      if (kr.le.nvp) then         call MPI_SEND(f(1,kyp+1,l),nxv,mreal,kr-1,moff+3,lgrp,ierr)      endif      if (kl.ge.1) then         call MPI_WAIT(msid,istatus,ierr)      else         do 20 j = 1, nxv         f(j,1,l) = f(j,3,l)   20    continue      endif      if (kr.le.nvp) then         call MPI_IRECV(f(1,kyp+2,l),ngc*nxv,mreal,kr-1,moff+4,lgrp,msid     1,ierr)      endif      if (kl.ge.1) then         call MPI_SEND(f(1,2,l),ngc*nxv,mreal,kl-1,moff+4,lgrp,ierr)      endif      if (kr.le.nvp) then         call MPI_WAIT(msid,istatus,ierr)      else         do 40 j = 2, nx2         f(j,kyp+3,l) = 2.*f(j,kyp+2,l) - f(j,kyp+1,l)   40    continue      endifc special case of only one grid per processor      if (kyp.eq.1) then         if (krr.le.nvp) then            call MPI_IRECV(f(1,kyp+3,l),nxv,mreal,krr-1,moff+6,lgrp,msid     1,ierr)         else if (kr.le.nvp) then            call MPI_IRECV(f(1,kyp+3,l),nxv,mreal,kr-1,moff+6,lgrp,msid,     1ierr)         endif         if ((kl.eq.0).and.(kr.le.nvp)) then            call MPI_IRECV(f(1,1,l),nxv,mreal,kr-1,moff+6,lgrp,nsid,ierr     1)         endif         if (kll.ge.1) then            call MPI_SEND(f(1,2,l),nxv,mreal,kll-1,moff+6,lgrp,ierr)         else if (kl.eq.1) then            call MPI_SEND(f(1,2,l),nxv,mreal,kl-1,moff+6,lgrp,ierr)         endif         if ((kl.eq.(nvp-1)).and.(kl.ge.1)) then            call MPI_SEND(f(1,kyp+2,l),nxv,mreal,kl-1,moff+6,lgrp,ierr)         endif         if (kr.le.nvp) then            call MPI_WAIT(msid,istatus,ierr)         endif         if (kl.eq.0) then            call MPI_WAIT(nsid,istatus,ierr)         endif      endif   70 continuec fix left edge      do 100 l = 1, kblok      kl = l + ks      if (kl.eq.0) then         do 90 j = 2, nx2         f(j,1,l) = 2.*f(j,2,l) - f(j,1,l)   90    continue      endif  100 continue      return      endc-----------------------------------------------------------------------      subroutine PLAGUARD2(f,scr,kstrt,nvp,nx,nxv,nypmx,kyp,kblok,ngds)c this subroutine copies data from particle to field partitions, addingc data from guard cells, where the field and particle partitions are c assumed to be the same.c the field is added up so as to disable quadratic interpolationc within half a cell of the edges, and reduce it to linear interpolationc in the y direction.c f(j,k,l) = real data for grid j,k in particle partition l.  the numberc grids per partition is uniform and includes three extra guard cells.c scr(j,idps,k) = scratch array for particle partition kc kstrt = starting data block numberc nvp = number of real or virtual processorsc nx = system length in x directionc nxv = first dimension of f, must be >= nxc nypmx = maximum size of particle partition, including guard cells.c kyp = number of complex grids in each field partition.c kblok = number of field partitions.c ngds = number of guard cellsc quadratic interpolation, for distributed data      implicit none      real f, scr      integer kstrt, nvp, nx, nxv, nypmx, kyp, kblok, ngds      dimension f(nxv,nypmx,kblok), scr(nxv,ngds,kblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=8)c lgrp = current communicatorc mreal = default datatype for reals      common /pparms/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer istatus, msid, ierr      integer nx3, ks, moff, kr, krr, kl, kll, ngc, j, l      dimension istatus(lstat)      nx3 = nx + 3      ks = kstrt - 2      moff = nypmx*nvpc add guard cells      do 90 l = 1, kblok      kr = l + ks + 2      krr = kr      kl = l + ks      kll = kl      ngc = 2c special case of only one grid per processor      if (kyp.eq.1) then         krr = krr + 1         kll = kll - 1         ngc = 1      endifc this segment is used for shared memory computersc     if (kl.ge.1) thenc        do 10 j = 1, nx3c        scr(j,1,l) = f(j,kyp+2,kl)c        scr(j,2,l) = f(j,kyp+3,kll)c  10    continuec     elsec        do 20 j = 1, nx3c        scr(j,1,l) = 2.*f(j,1,l)c        scr(j,2,l) = -f(j,1,l)c  20    continuec     endifc     if (kr.le.nvp) thenc        do 30 j = 1, nx3c        scr(j,3,l) = f(j,1,kr)c  30    continuec     elsec        do 40 j = 1, nx3c        scr(j,3,l) = -f(j,kyp+3,l)c        f(j,kyp+2,l) = f(j,kyp+2,l) + 2.*f(j,kyp+3,l)c        f(j,kyp+3,l) = 0.c  40    continuec     endifc     if (kyp.eq.1) thenc        if (kl.eq.1) thenc           do 50 j = 1, nx3c           scr(j,1,l) = f(j,kyp+2,kl)c           scr(j,2,l) = -f(j,1,kl)c  50       continuec        else if (kl.eq.0) thenc           do 60 j = 1, nx3c           scr(j,2,l) = 0.c  60       continuec        endifc last point is special with only one gridc        if ((kl.eq.(nvp-1)).and.(kl.ge.1)) thenc           do 70 j = 1, nx3c           f(j,kyp+2,l) = f(j,kyp+2,l) + f(j,kyp+3,kl)c  70    continuec        endifc     endifc this segment is used for mpi computers      if (kl.ge.1) then         call MPI_IRECV(scr,ngc*nxv,mreal,kl-1,moff+1,lgrp,msid,ierr)      endif      if (kr.le.nvp) then         call MPI_SEND(f(1,kyp+2,l),ngc*nxv,mreal,kr-1,moff+1,lgrp,ierr)      endif      if (kl.ge.1) then         call MPI_WAIT(msid,istatus,ierr)      else         do 10 j = 1, nx3         scr(j,1,l) = 2.*f(j,1,l)         scr(j,2,l) = -f(j,1,l)   10    continue      endif      if (kr.le.nvp) then         call MPI_IRECV(scr(1,3,l),nxv,mreal,kr-1,moff+2,lgrp,msid,ierr)      endif      if (kl.ge.1) then         call MPI_SEND(f(1,1,l),nxv,mreal,kl-1,moff+2,lgrp,ierr)      endif      if (kr.le.nvp) then         call MPI_WAIT(msid,istatus,ierr)      else         do 20 j = 1, nx3         scr(j,3,l) = -f(j,kyp+3,l)         f(j,kyp+2,l) = f(j,kyp+2,l) + 2.*f(j,kyp+3,l)         f(j,kyp+3,l) = 0.   20    continue      endifc special case of only one grid per processor      if (kyp.eq.1) then         if (kll.ge.1) then            call MPI_IRECV(scr(1,2,l),nxv,mreal,kll-1,moff+5,lgrp,msid,i     1err)         else if (kl.eq.1) then            call MPI_IRECV(scr(1,2,l),nxv,mreal,kl-1,moff+5,lgrp,msid,ie     1rr)         endif         if (krr.le.nvp) then            call MPI_SEND(f(1,kyp+3,l),nxv,mreal,krr-1,moff+5,lgrp,ierr)         endif         if ((kl.eq.0).and.(kr.le.nvp)) then            call MPI_SEND(f(1,1,l),nxv,mreal,kr-1,moff+5,lgrp,ierr)         endif         if (kl.ge.1) then            call MPI_WAIT(msid,istatus,ierr)            if (kl.eq.1) then               do 30 j = 1, nx3               scr(j,2,l) = -scr(j,2,l)   30          continue            endif         else            do 40 j = 1, nx3            scr(j,2,l) = 0.   40       continue         endifc last point is special with only one grid         if ((kl.eq.(nvp-1)).and.(kl.ge.1)) then            call MPI_IRECV(f(1,kyp+3,l),nxv,mreal,kl-1,moff+6,lgrp,msid,     1ierr)         endif         if (kr.eq.nvp) then            call MPI_SEND(f(1,kyp+3,l),nxv,mreal,kr-1,moff+6,lgrp,ierr)         endif         if ((kl.eq.(nvp-1)).and.(kl.ge.1)) then            call MPI_WAIT(msid,istatus,ierr)            do 70 j = 1, nx3            f(j,kyp+2,l) = f(j,kyp+2,l) + f(j,kyp+3,l)            f(j,kyp+3,l) = 0.   70       continue         endif      endifc add up the guard cells      do 80 j = 1, nx3      f(j,2,l) = f(j,2,l) + scr(j,1,l)      f(j,ngc+1,l) = f(j,ngc+1,l) + scr(j,2,l)      f(j,kyp+1,l) = f(j,kyp+1,l) + scr(j,3,l)   80 continue   90 continuec zero out the left edge      do 110 l = 1, kblok      kl = l + ks      if (kl.eq.0) then         do 100 j = 1, nx3         f(j,1,l) = 0.  100    continue      endif  110 continue      return      endc-----------------------------------------------------------------------      subroutine PLAGUARD2L(f,scr,kstrt,nvp,nx,nxv,nypmx,kyp,kblok)c this subroutine copies data from particle to field partitions, addingc data from guard cells, where the field and particle partitions are c assumed to be the same.c no copying is done at the boundary edges.c f(j,k,l) = real data for grid j,k in particle partition l.  the numberc grids per partition is uniform and includes one extra guard cell.c scr(j,k) = scratch array for particle partition kc kstrt = starting data block numberc nvp = number of real or virtual processorsc nx = system length in x directionc nxv = first dimension of f, must be >= nxc nypmx = maximum size of particle partition, including guard cells.c kyp = number of complex grids in each field partition.c kblok = number of field partitions.c linear interpolation, for distributed data      implicit none      real f, scr      integer kstrt, nvp, nx, nxv, nypmx, kyp, kblok      dimension f(nxv,nypmx,kblok), scr(nxv,kblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=8)c lgrp = current communicatorc mreal = default datatype for reals      common /pparms/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer istatus, msid, ierr      integer nx1, ks, moff, kl, kr, j, l      dimension istatus(lstat)      nx1 = nx + 1      ks = kstrt - 2      moff = nypmx*nvpc add guard cells      do 40 l = 1, kblok      kr = l + ks + 2      kl = l + ksc this segment is used for shared memory computersc     if (kl.ge.1) thenc        do 10 j = 1, nx1c        scr(j,l) = f(j,kyp+1,kl)c  10    continuec     elsec        do 20 j = 1, nx1c        scr(j,l) = 0.c  20    continuec     endifc this segment is used for mpi computers      if (kl.ge.1) then         call MPI_IRECV(scr,nxv,mreal,kl-1,moff+1,lgrp,msid,ierr)      endif      if (kr.le.nvp) then         call MPI_SEND(f(1,kyp+1,l),nxv,mreal,kr-1,moff+1,lgrp,ierr)      endif      if (kl.ge.1) then         call MPI_WAIT(msid,istatus,ierr)      else         do 20 j = 1, nx1         scr(j,l) = 0.   20    continue      endifc add up the guard cells      do 30 j = 1, nx1      f(j,1,l) = f(j,1,l) + scr(j,l)   30 continue   40 continue      return      endc-----------------------------------------------------------------------      subroutine PLCGUARD2X(fxy,nyp,nx,nxe,nypmx,nblok)c this subroutine replicates field so as to disablec quadratic interpolation within a half a cell of the edges,c and reduce it to linear interpolation in the x directionc for distributed data      implicit none      real fxy      integer nyp, nx, nxe, nypmx, nblok      dimension fxy(2,nxe,nypmx,nblok), nyp(nblok)c local data      integer k, l, nyp3      do 20 l = 1, nblok      nyp3 = nyp(l) + 3      do 10 k = 1, nyp3      fxy(1,1,k,l) = 2.*fxy(1,2,k,l) - fxy(1,3,k,l)      fxy(2,1,k,l) = 2.*fxy(2,2,k,l) - fxy(2,3,k,l)      fxy(1,nx+3,k,l) = 2.*fxy(1,nx+2,k,l) - fxy(1,nx+1,k,l)      fxy(2,nx+3,k,l) = 2.*fxy(2,nx+2,k,l) - fxy(2,nx+1,k,l)   10 continue   20 continue      return      endc-----------------------------------------------------------------------      subroutine PLAGUARD2X(q,nyp,nx,nxe,nypmx,nblok)c this subroutine adds adds up guard cells so as to disablec quadratic interpolation within a half a cell of the edges,c and reduce it to linear interpolation in the x directionc for distributed data      implicit none      real q      integer nyp, nx, nxe, nypmx, nblok      dimension q(nxe,nypmx,nblok), nyp(nblok)c local data      integer k, l, nyp3c add up guard cells      do 20 l = 1, nblok      nyp3 = nyp(l) + 3      do 10 k = 1, nyp3      q(2,k,l) = q(2,k,l) + 2.*q(1,k,l)      q(3,k,l) = q(3,k,l) - q(1,k,l)      q(nx+1,k,l) = q(nx+1,k,l) - q(nx+3,k,l)      q(nx+2,k,l) = q(nx+2,k,l) + 2.*q(nx+3,k,l)      q(1,k,l) = 0.      q(nx+3,k,l) = 0.   10 continue   20 continue      return      endc-----------------------------------------------------------------------      subroutine PPOISD2(q,fx,fy,isign,ffd,ax,ay,affp,we,nx,ny,kstrt,ny2     1d,kxp2,j2blok,nyd)c this subroutine solves 2d poisson's equation in fourier space forc force/charge (or convolution of electric field over particle shape)c or for potential, or provides a smoothing function, with diricheletc boundary conditions (zero potential), for distributed data.c fourier coefficients are constructed so that a real to complex fftc will perform the appropriate sin-sin, sin-cos, or cos-sin transformc for isign = 0,input: isign,ax,ay,affp,nx,ny,kstrt,ny2d,kxp2,j2blok,nydc               output: ffdc for isign = -1, input: q,ffd,isign,nx,ny,kstrt,ny2d,kxp2,j2blok,nydc                output: fx,fy,wec approximate flop count is: 11*nx*nyc for isign = 1, input: q,ffd,isign,nx,ny,kstrt,ny2d,kxp2,j2blok,nydc                output: fx,wec approximate flop count is: 6*nc*nyc for isign = 2, input: q,ffd,isign,nx,ny,kstrt,ny2d,kxp2,j2blok,nydc                output: fyc approximate flop count is: 2*nx*nyc if isign < 0, force/charge is calculated using the equations:c fx(kx,ky) = -sqrt(-1)*kx*g(kx,ky)*s(kx,ky)*q(kx,ky),c fy(kx,ky) = -sqrt(-1)*ky*g(kx,ky)*s(kx,ky)*q(kx,ky),c where kx = pi*j/nx, ky = pi*k/ny, and j,k = fourier mode numbers,c g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky),c s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2), except forc if isign = 1, potential is calculated using the equation:c fx(kx,ky) = g(kx,ky)*q(kx,ky)*s(kx,ky)c if isign = 2, smoothing is calculated using the equation:c fy(kx,ky) = q(kx,ky)*s(kx,ky)c q(k,j,l) = complex charge density for fourier mode (jj-1,k-1)c fx(k,j,l) = x component of complex force/charge,c fy(k,j,l) = y component of complex force/charge,c all for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c if isign = 0, form factor array is preparedc ffd(k,2*j,l) = finite-size particle shape factor sc ffd(k,2*j-1,l) = potential green's function gc all for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c j2blok = number of data blocksc kxp2 = number of data values per blockc kstrt = starting data block numberc ax/ay = half-width of particle in x/y directionc affp = normalization constant = nx*ny/np, where np=number of particlesc electric field energy is also calculated, usingc we = 2*nx*ny*sum((affp/(kx**2+ky**2))*|q(kx,ky)*s(kx,ky)|**2)c nx/ny = system length in x/y directionc ny2d = first dimension of field arrays, must be >= 2*nyc nyd = first dimension of form factor array, must be >= ny      double precision wp      complex q, fx, fy, ffd, zero      dimension q(ny2d,kxp2,j2blok)      dimension fx(ny2d,kxp2,j2blok), fy(ny2d,kxp2,j2blok)      dimension ffd(nyd,kxp2,j2blok)      ny2 = 2*ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx + nx)      dny = 6.28318530717959/float(ny + ny)      zero = cmplx(0.,0.)      if (isign.ne.0) go to 40      if (kstrt.gt.nx) returnc prepare form factor array      do 30 l = 1, j2blok      joff = kxp2*(l + ks) - 1      do 20 j = 1, kxp2      dkx = dnx*float(j + joff)      at1 = dkx*dkx      at2 = (dkx*ax)**2      do 10 k = 1, ny      dky = dny*float(k - 1)      at3 = dky*dky + at1      at4 = exp(-.5*((dky*ay)**2 + at2))      if (at3.eq.0.) then         ffd(k,j,l) = cmplx(affp,1.)      else         ffd(k,j,l) = cmplx(affp*at4/at3,at4)      endif   10 continue   20 continue   30 continue      return   40 if (isign.gt.0) go to 100c calculate force/charge and sum field energy      wp = 0.0d0      if (kstrt.gt.nx) go to 90      do 80 l = 1, j2blokc mode numbers kx > 0 and 0 < ky < ny      joff = kxp2*(l + ks) - 1      do 60 j = 1, kxp2      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 50 k = 2, ny         k1 = ny2 - k         at1 = real(ffd(k,j,l))*aimag(ffd(k,j,l))         at3 = -at1*real(q(k,j,l))         at2 = dkx*at3         at3 = dny*float(k - 1)*at3         fx(k,j,l) = cmplx(0.,at2)         fx(k1,j,l) = cmplx(0.,-at2)         fy(k,j,l) = cmplx(0.,at3)         fy(k1,j,l) = cmplx(0.,at3)         wp = wp + at1*real(q(k,j,l))**2   50    continue      endifc mode numbers ky = 0, ny      at1 = real(ffd(1,j,l))*aimag(ffd(1,j,l))      fx(1,j,l) = zero      fx(ny+1,j,l) = zero      fy(1,j,l) = zero      fy(ny+1,j,l) = zero      wp = wp + at1*real(q(1,j,l))**2   60 continuec mode number kx = 0      if ((l+ks).eq.0) then         do 70 k = 2, ny         k1 = ny2 - k         at1 = real(ffd(k,1,l))*aimag(ffd(k,1,l))         fx(k,1,l) = zero         fx(k1,1,l) = zero         fy(k,1,l) = zero         fy(k1,1,l) = zero         wp = wp + at1*real(q(k,1,l))**2   70    continue      endif   80 continue   90 continue      we = 2.0*float(nx*ny)*wp      returnc calculate potential and sum field energy  100 if (isign.gt.1) go to 160      wp = 0.0d0      if (kstrt.gt.nx) go to 150      do 140 l = 1, j2blokc mode numbers kx > 0 and 0 < ky < ny      joff = kxp2*(l + ks) - 1      do 120 j = 1, kxp2      if ((j+joff).gt.0) then         do 110 k = 2, ny         k1 = ny2 - k         at2 = real(ffd(k,j,l))         at1 = at2*aimag(ffd(k,j,l))         at3 = at2*real(q(k,j,l))         fx(k,j,l) = cmplx(at3,0.)         fx(k1,j,l) = cmplx(-at3,0.)         wp = wp + at1*real(q(k,j,l))**2  110    continue      endifc mode numbers ky = 0, ny      at1 = real(ffd(1,j,l))*aimag(ffd(1,j,l))      fx(1,j,l) = zero      fx(ny+1,j,l) = zero      wp = wp + at1*real(q(1,j,l))**2  120 continuec mode number kx = 0      if ((l+ks).eq.0) then         do 130 k = 2, ny         k1 = ny2 - k         at1 = real(ffd(k,1,l))*aimag(ffd(k,1,l))         fx(k,1,l) = zero         fx(k1,1,l) = zero         wp = wp + at1*real(q(k,1,l))**2  130    continue      endif  140 continue  150 continue      we = 2.0*float(nx*ny)*wp      returnc calculate smoothing  160 if (kstrt.gt.nx) go to 210      do 200 l = 1, j2blokc mode numbers kx > 0 and 0 < ky < ny      joff = kxp2*(l + ks) - 1      do 180 j = 1, kxp2      if ((j+joff).gt.0) then         do 170 k = 2, ny         k1 = ny2 - k         at1 = aimag(ffd(k,j,l))         at2 = at1*real(q(k,j,l))         fy(k,j,l) = cmplx(at2,0.)         fy(k1,j,l) = cmplx(-at2,0.)  170    continue      endifc mode numbers ky = 0, ny      fy(1,j,l) = zero      fy(ny+1,j,l) = zero  180 continuec mode number kx = 0      if ((l+ks).eq.0) then         do 190 k = 2, ny         k1 = ny2 - k         fy(k,1,l) = zero         fy(k1,1,l) = zero  190    continue      endif  200 continue  210 continue      return      endc-----------------------------------------------------------------------      subroutine PPOISD22(q,fxy,isign,ffd,ax,ay,affp,we,nx,ny,kstrt,ny2d     1,kxp2,j2blok,nyd)c this subroutine solves 2d poisson's equation in fourier space forc force/charge (or convolution of electric field over particle shape)c with dirichelet boundary conditions (zero potential),c for distributed data.c fourier coefficients are constructed so that a real to complex fftc will perform the appropriate sin-cos, or cos-sin transformc for isign = 0,input: isign,ax,ay,affp,nx,ny,kstrt,ny2d,kxp2,j2blok,nydc               output: ffdc for isign /= 0, input: q,ffd,isign,nx,ny,kstrt,ny2d,kxp2,j2blok,nydc                output: fxy,wec approximate flop count is: 11*nx*nyc eqwuation used is:c fx(kx,ky) = -sqrt(-1)*kx*g(kx,ky)*s(kx,ky)*q(kx,ky),c fy(kx,ky) = -sqrt(-1)*ky*g(kx,ky)*s(kx,ky)*q(kx,ky),c where kx = pi*j/nx, ky = pi*k/ny, and j,k = fourier mode numbers,c g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky),c s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2), except forc q(k,j,l) = complex charge density for fourier mode (jj-1,k-1)c fxy(1,k,j,l) = x component of complex force/charge,c fxy(2,k,j,l) = y component of complex force/charge,c all for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c if isign = 0, form factor array is preparedc ffd(k,2*j,l) = finite-size particle shape factor sc ffd(k,2*j-1,l) = potential green's function gc all for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c j2blok = number of data blocksc kxp2 = number of data values per blockc kstrt = starting data block numberc ax/ay = half-width of particle in x/y directionc affp = normalization constant = nx*ny/np, where np=number of particlesc electric field energy is also calculated, usingc we = 2*nx*ny*sum((affp/(kx**2+ky**2))*|q(kx,ky)*s(kx,ky)|**2)c nx/ny = system length in x/y directionc ny2d = first dimension of field arrays, must be >= 2*nyc nyd = first dimension of form factor array, must be >= ny      double precision wp      complex q, fxy, ffd, zero      dimension q(ny2d,kxp2,j2blok), fxy(2,ny2d,kxp2,j2blok)      dimension ffd(nyd,kxp2,j2blok)      ny2 = 2*ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx + nx)      dny = 6.28318530717959/float(ny + ny)      zero = cmplx(0.,0.)      if (isign.ne.0) go to 40      if (kstrt.gt.nx) returnc prepare form factor array      do 30 l = 1, j2blok      joff = kxp2*(l + ks) - 1      do 20 j = 1, kxp2      dkx = dnx*float(j + joff)      at1 = dkx*dkx      at2 = (dkx*ax)**2      do 10 k = 1, ny      dky = dny*float(k - 1)      at3 = dky*dky + at1      at4 = exp(-.5*((dky*ay)**2 + at2))      if (at3.eq.0.) then         ffd(k,j,l) = cmplx(affp,1.)      else         ffd(k,j,l) = cmplx(affp*at4/at3,at4)      endif   10 continue   20 continue   30 continue      returnc calculate force/charge and sum field energy   40 wp = 0.0d0      if (kstrt.gt.nx) go to 90      do 80 l = 1, j2blokc mode numbers kx > 0 and 0 < ky < ny      joff = kxp2*(l + ks) - 1      do 60 j = 1, kxp2      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 50 k = 2, ny         k1 = ny2 - k         at1 = real(ffd(k,j,l))*aimag(ffd(k,j,l))         at3 = -at1*real(q(k,j,l))         at2 = dkx*at3         at3 = dny*float(k - 1)*at3         fxy(1,k,j,l) = cmplx(0.,at2)         fxy(2,k,j,l) = cmplx(0.,at3)         fxy(1,k1,j,l) = cmplx(0.,-at2)         fxy(2,k1,j,l) = cmplx(0.,at3)         wp = wp + at1*real(q(k,j,l))**2   50    continue      endifc mode numbers ky = 0, ny      at1 = real(ffd(1,j,l))*aimag(ffd(1,j,l))      fxy(1,1,j,l) = zero      fxy(2,1,j,l) = zero      fxy(1,ny+1,j,l) = zero      fxy(2,ny+1,j,l) = zero      wp = wp + at1*real(q(1,j,l))**2   60 continuec mode number kx = 0      if ((l+ks).eq.0) then         do 70 k = 2, ny         k1 = ny2 - k         at1 = real(ffd(k,1,l))*aimag(ffd(k,1,l))         fxy(1,k,1,l) = zero         fxy(2,k,1,l) = zero         fxy(1,k1,1,l) = zero         fxy(2,k1,1,l) = zero         wp = wp + at1*real(q(k,1,l))**2   70    continue      endif   80 continue   90 continue      we = 2.0*float(nx*ny)*wp      return      endc-----------------------------------------------------------------------      subroutine DBLSIN2(q,q2,nx,ny,nxv,nyv,nx2v,ny2)c this subroutine creates an odd array q2 from an array q, so thatc a 2d sine transform can be performed with a 2d real to complex fft.c linear interpolationc nx/ny = system length in x/y directionc nxv = first dimension of input array q, must be >= nxc nyv = second dimension of input array q, must be >= nyc nx2v = first dimension of output array q2, must be >= 2*nxc ny2 = second dimension of output array q2, must be >= 2*ny      implicit none      real q, q2      integer nx, ny, nxv, nyv, nx2v, ny2      dimension q(nxv,nyv), q2(nx2v,ny2)c local data      integer j, k, nxs, nysc copy to double array      nxs = nx - 1      nys = ny - 1      do 20 k = 1, nys      do 10 j = 1, nxs      q2(j+1,k+1) = q(j+1,k+1)      q2(nx+j+1,k+1) = -q(nx-j+1,k+1)      q2(j+1,ny+k+1) = -q(j+1,ny-k+1)      q2(nx+j+1,ny+k+1) = q(nx-j+1,ny-k+1)   10 continue      q2(1,k+1) = 0.      q2(nx+1,k+1) = 0.      q2(1,k+ny+1) = 0.      q2(nx+1,k+ny+1) = 0.   20 continue      do 30 j = 1, nx      q2(j,1) = 0.      q2(j+nx,1) = 0.      q2(j,ny+1) = 0.      q2(j+nx,ny+1) = 0.   30 continue      return      endc-----------------------------------------------------------------------      subroutine HAFDBL2C(fxy,fxy2,nx,ny,nxe,nye,nx2v,ny2)c this subroutine copies data from a double array to regular arrayc with guard cells for vector field and linear interpolationc nx/ny = system length in x/y directionc nxe = first dimension of output array q, must be >= nx+1c nye = first dimension of ouput array q, must be >= ny+1c nx2v = first dimension of input array q2, must be >= 2*nxc ny2 = second dimension of input array q2, must be >= 2*ny      implicit none      real fxy, fxy2      integer nx, ny, nxe, nye, nx2v, ny2      dimension fxy(2,nxe,nye), fxy2(2,nx2v,ny2)c local data      integer j, k, nx1, ny1      nx1 = nx + 1      ny1 = ny + 1      do 20 k = 1, ny1      do 10 j = 1, nx1      fxy(1,j,k) = fxy2(1,j,k)      fxy(2,j,k) = fxy2(2,j,k)   10 continue   20 continue      return      endc-----------------------------------------------------------------------      subroutine HAFDBL2D(q,q2,nx,ny,nxe,nye,nx2v,ny2)c this subroutine copies data from a double array to regular arrayc with guard cells for scalar field and linear interpolationc nx/ny = system length in x/y directionc nxe = first dimension of output array q, must be >= nx+1c nye = first dimension of ouput array q, must be >= ny+1c nx2v = first dimension of input array q2, must be >= 2*nxc ny2 = second dimension of input array q2, must be >= 2*ny      implicit none      real q, q2      integer nx, ny, nxe, nye, nx2v, ny2      dimension q(nxe,nye), q2(nx2v,ny2)c local data      integer j, k, nx1, ny1      nx1 = nx + 1      ny1 = ny + 1      do 20 k = 1, ny1      do 10 j = 1, nx1      q(j,k) = q2(j,k)   10 continue   20 continue      return      endc-----------------------------------------------------------------------      subroutine LCGUARD2(fxy,nx,ny,nxe,nye)c this subroutine replicates field so as to disablec quadratic interpolation within a half a cell of the edges,c and reduce it to linear interpolation on both boundariesc nx/ny = system length in x/y directionc nxe = first dimension of input array fxy, must be >= nx+3c nxe = second dimension of input array fxy, must be >= ny+3      implicit none      real fxy      integer nx, ny, nxe, nye      dimension fxy(2,nxe,nye)c local data      integer j, k, ny1, nx3      ny1 = ny + 1      nx3 = nx + 3      do 10 k = 1, ny1      fxy(1,1,k+1) = 2.*fxy(1,2,k+1) - fxy(1,3,k+1)      fxy(2,1,k+1) = 2.*fxy(2,2,k+1) - fxy(2,3,k+1)      fxy(1,nx3,k+1) = 2.*fxy(1,nx+2,k+1) - fxy(1,nx+1,k+1)      fxy(2,nx3,k+1) = 2.*fxy(2,nx+2,k+1) - fxy(2,nx+1,k+1)   10 continue      do 20 j = 1, nx3      fxy(1,j,1) = 2.*fxy(1,j,2) - fxy(1,j,3)      fxy(2,j,1) = 2.*fxy(2,j,2) - fxy(2,j,3)      fxy(1,j,ny+3) = 2.*fxy(1,j,ny+2) - fxy(1,j,ny+1)      fxy(2,j,ny+3) = 2.*fxy(2,j,ny+2) - fxy(2,j,ny+1)   20 continue      return      endc-----------------------------------------------------------------------      subroutine LAGUARD2(q,nx,ny,nxe,nye)c this subroutine adds adds up guard cells so as to disablec quadratic interpolation within a half a cell of the edges,c and reduce it to linear interpolation on both boundariesc nx/ny = system length in x/y directionc nxe = first dimension of input array q, must be >= nx+3c nxe = second dimension of input array q, must be >= ny+3      implicit none      real q      integer nx, ny, nxe, nye      dimension q(nxe,nye)c local data      integer j, k, nx1, ny3      nx1 = nx + 1      ny3 = ny + 3c add up guard cells      do 10 k = 1, ny3      q(2,k) = q(2,k) + 2.*q(1,k)      q(3,k) = q(3,k) - q(1,k)      q(nx+1,k) = q(nx+1,k) - q(nx+3,k)      q(nx+2,k) = q(nx+2,k) + 2.*q(nx+3,k)      q(1,k) = 0.      q(nx+3,k) = 0.   10 continue      do 20 j = 1, nx1      q(j+1,2) = q(j+1,2) + 2.*q(j+1,1)      q(j+1,3) = q(j+1,3) - q(j+1,1)      q(j+1,ny+1) = q(j+1,ny+1) - q(j+1,ny+3)      q(j+1,ny+2) = q(j+1,ny+2) + 2.*q(j+1,ny+3)      q(j+1,1) = 0.      q(j+1,ny+3) = 0.   20 continue      return      endc-----------------------------------------------------------------------      subroutine POISD2(q,fx,fy,isign,ffd,ax,ay,affp,we,nx,ny,nx2v,ny2d)c this subroutine solves 2d poisson's equation in fourier space forc force/charge (or convolution of electric field over particle shape)c or for potential, or provides a smoothing functionc with dirichelet boundary conditions (zero potential).c fourier coefficients are constructed so that a real to complex fftc will perform the appropriate sin-sin, sin-cos, or cos-sin transformc for isign = 0, input: isign,ax,ay,affp,nx,ny,nx2v,ny2d, output: ffdc for isign = -1, input: q,ffd,isign,nx,ny,nx2v,ny2d, output: fx,fy,wec approximate flop count is: 11*nx*nyc for isign = 1, input: q,ffd,isign,nx,ny,nx2v,ny2d, output: fx,wec approximate flop count is: 6*nc*nyc for isign = 2, input: q,ffd,isign,nx,ny,nx2v,ny2d, output: fyc approximate flop count is: 2*nx*nyc if isign < 0, force/charge is calculated using the equations:c fx(kx,ky) = -sqrt(-1)*kx*g(kx,ky)*s(kx,ky)*q(kx,ky),c fy(kx,ky) = -sqrt(-1)*ky*g(kx,ky)*s(kx,ky)*q(kx,ky),c where kx = pi*j/nx, ky = pi*k/ny, and j,k = fourier mode numbers,c g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky),c s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2), except forc if isign = 1, potential is calculated using the equation:c fx(kx,ky) = g(kx,ky)*q(kx,ky)*s(kx,ky)c if isign = 2, smoothing is calculated using the equation:c fy(kx,ky) = q(kx,ky)*s(kx,ky)c cmplx(q(2*j-1,k),q(2*j,k)) = complex charge densityc for fourier mode (j-1,k-1)c cmplx(fx(2*j-1,k),fx(2*j,k)) = x component of complex force/charge,c cmplx(fy(2*j-1,k),fy(2*j,k)) = y component of complex force/charge,c for fourier mode (j-1,k-1)c if isign = 0, form factor array is preparedc ffd(2*j,k) = finite-size particle shape factor sc for fourier mode (j-1,k-1)c ffd(2*j-1,k) = potential green's function g for fourier mode (j-1,k-1)c ax/ay = half-width of particle in x/y directionc affp = normalization constant = nx*ny/np, where np=number of particlesc electric field energy is also calculated, usingc we = 2*nx*ny*sum((affp/(kx**2+ky**2))*|q(kx,ky)*s(kx,ky)|**2)c nx/ny = system length in x/y directionc nx2v = first dimension of field arrays, must be >= 2*nxc ny2d = second dimension of field arrays, must be >= 2*ny      double precision wp      dimension q(nx2v,ny2d), fx(nx2v,ny2d), fy(nx2v,ny2d)      dimension ffd(nx2v,ny)      ny2 = 2*ny + 2      dnx = 6.28318530717959/float(nx + nx)      dny = 6.28318530717959/float(ny + ny)      if (isign.ne.0) go to 30c prepare form factor array      do 20 k = 1, ny      dky = dny*float(k - 1)      at1 = dky*dky      at2 = (dky*ay)**2      do 10 j = 1, nx      dkx = dnx*float(j - 1)      at3 = dkx*dkx + at1      if (at3.eq.0.) then         ffd(2*j,k) = 1.         ffd(2*j-1,k) = affp      else         ffd(2*j,k) = exp(-.5*((dkx*ax)**2 + at2))         ffd(2*j-1,k) = affp*ffd(2*j,k)/at3      endif   10 continue   20 continue      return   30 if (isign.gt.0) go to 70c calculate force/charge and sum field energy      wp = 0.0d0      do 50 k = 2, ny      k1 = ny2 - k      dky = dny*float(k - 1)      do 40 j = 2, nx      at1 = ffd(2*j-1,k)*ffd(2*j,k)      at3 = -at1*q(2*j-1,k)      at2 = dnx*float(j - 1)*at3      at3 = dky*at3      fx(2*j-1,k) = 0.      fx(2*j,k) = at2      fx(2*j-1,k1) = 0.      fx(2*j,k1) = -at2      fy(2*j-1,k) = 0.      fy(2*j,k) = at3      fy(2*j-1,k1) = 0.      fy(2*j,k1) = at3      wp = wp + at1*q(2*j-1,k)**2   40 continue      at1 = ffd(1,k)*ffd(2,k)      fx(1,k) = 0.      fx(2,k) = 0.      fx(1,k1) = 0.      fx(2,k1) = 0.      fy(1,k) = 0.      fy(2,k) = 0.      fy(1,k1) = 0.      fy(2,k1) = 0.      wp = wp + at1*q(1,k)**2   50 continue      do 60 j = 1, nx      at1 = ffd(2*j-1,1)*ffd(2*j,1)      fx(2*j-1,1) = 0.      fx(2*j,1) = 0.      fx(2*j-1,ny+1) = 0.      fx(2*j,ny+1) = 0.      fy(2*j-1,1) = 0.      fy(2*j,1) = 0.      fy(2*j-1,ny+1) = 0.      fy(2*j,ny+1) = 0.      wp = wp + at1*q(2*j-1,1)**2   60 continue      we = 2.0*float(nx*ny)*wp      returnc calculate potential and sum field energy   70 if (isign.gt.1) go to 110      wp = 0.0d0      do 90 k = 2, ny      k1 = ny2 - k      do 80 j = 2, nx      at2 = ffd(2*j-1,k)      at1 = at2*ffd(2*j,k)      at3 = at2*q(2*j-1,k)      fx(2*j-1,k) = at3      fx(2*j,k) = 0.      fx(2*j-1,k1) = -at3      fx(2*j,k1) = 0.      wp = wp + at1*q(2*j-1,k)**2   80 continue      at1 = ffd(1,k)*ffd(2,k)      fx(1,k) = 0.      fx(2,k) = 0.      fx(1,k1) = 0.      fx(2,k1) = 0.      wp = wp + at1*q(1,k)**2   90 continue      do 100 j = 1, nx      at1 = ffd(2*j-1,1)*ffd(2*j,1)      fx(2*j-1,1) = 0.      fx(2*j,1) = 0.      fx(2*j-1,ny+1) = 0.      fx(2*j,ny+1) = 0.      wp = wp + at1*q(2*j-1,1)**2  100 continue      we = 2.0*float(nx*ny)*wp      returnc calculate smoothing  110 do 130 k = 2, ny      k1 = ny2 - k      do 120 j = 2, nx      at1 = ffd(2*j,k)      at2 = at1*q(2*j-1,k)      fy(2*j-1,k) = at2      fy(2*j,k) = 0.      fy(2*j-1,k1) = -at2      fy(2*j,k1) = 0  120 continue      fy(1,k) = 0.      fy(2,k) = 0.      fy(1,k1) = 0.      fy(2,k1) = 0  130 continue      do 140 j = 1, nx      fy(2*j-1,1) = 0.      fy(2*j,1) = 0.      fy(2*j-1,ny+1) = 0.      fy(2*j,ny+1) = 0.  140 continue      return      endc-----------------------------------------------------------------------      subroutine POISD22(q,fxy,isign,ffd,ax,ay,affp,we,nx,ny,nxv,ny2d)c this subroutine solves 2d poisson's equation in fourier space forc force/charge (or convolution of electric field over particle shape)c with dirchelet boundary conditions (zero potential).c fourier coefficients are constructed so that a real to complex fftc will perform the appropriate ssin-cos, or cos-sin transformc for isign = 0, input: isign,ax,ay,affp,nx,ny,nx2v,ny2d, output: ffdc for isign /= 0, input: q,ffd,isign,nx,ny,nx2v,ny2d, output: fxy,wec approximate flop count is: 11*nx*nyc equation used is:c fx(kx,ky) = -sqrt(-1)*kx*g(kx,ky)*s(kx,ky)*q(kx,ky),c fy(kx,ky) = -sqrt(-1)*ky*g(kx,ky)*s(kx,ky)*q(kx,ky),c where kx = pi*j/nx, ky = pi*k/ny, and j,k = fourier mode numbers,c g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky),c s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2), except forc q(j,k) = complex charge density for fourier mode (j-1,k-1)c fxy(1,j,k) = x component of complex force/charge,c fxy(2,j,k) = y component of complex force/charge,c all for fourier mode (j-1,k-1)c if isign = 0, form factor array is preparedc if isign is not equal to 0, force/charge is calculatedc aimag(ffd(j,k)) = finite-size particle shape factor sc for fourier mode (j-1,k-1)c real(ffd(j,k)) = potential green's function gc for fourier mode (j-1,k-1)c ax/ay = half-width of particle in x/y directionc affp = normalization constant = nx*ny/np, where np=number of particlesc electric field energy is also calculated, usingc we = 2*nx*ny*sum((affp/(kx**2+ky**2))*|q(kx,ky)*s(kx,ky)|**2)c nx/ny = system length in x/y directionc nxv = first dimension of field arrays, must be >= nxc ny2d = second dimension of field arrays, must be >= 2*ny      double precision wp      complex q, fxy, ffd, zero      dimension q(nxv,ny2d), fxy(2,nxv,ny2d)      dimension ffd(nxv,ny)      ny2 = 2*ny + 2      dnx = 6.28318530717959/float(nx + nx)      dny = 6.28318530717959/float(ny + ny)      zero = cmplx(0.,0.)      if (isign.ne.0) go to 30c prepare form factor array      do 20 k = 1, ny      dky = dny*float(k - 1)      at1 = dky*dky      at2 = (dky*ay)**2      do 10 j = 1, nx      dkx = dnx*float(j - 1)      at3 = dkx*dkx + at1      at4 = exp(-.5*((dkx*ax)**2 + at2))      if (at3.eq.0.) then         ffd(j,k) = cmplx(affp,1.)      else         ffd(j,k) = cmplx(affp*at4/at3,at4)      endif   10 continue   20 continue      returnc calculate force/charge and sum field energy   30 wp = 0.0d0      do 50 k = 2, ny      k1 = ny2 - k      dky = dny*float(k - 1)      do 40 j = 2, nx      at1 = real(ffd(j,k))*aimag(ffd(j,k))      at3 = -at1*real(q(j,k))      at2 = dnx*float(j - 1)*at3      at3 = dky*at3      fxy(1,j,k) = cmplx(0.,at2)      fxy(2,j,k) = cmplx(0.,at3)      fxy(1,j,k1) = cmplx(0.,-at2)      fxy(2,j,k1) = cmplx(0.,at3)      wp = wp + at1*real(q(j,k))**2   40 continue      at1 = real(ffd(1,k))*aimag(ffd(1,k))      fxy(1,1,k) = zero      fxy(2,1,k) = zero      fxy(1,1,k1) = zero      fxy(2,1,k1) = zero      wp = wp + at1*real(q(1,k))**2   50 continue      do 60 j = 1, nx      at1 = real(ffd(j,1))*aimag(ffd(j,1))      fxy(1,j,1) = zero      fxy(2,j,1) = zero      fxy(1,j,ny+1) = zero      fxy(2,j,ny+1) = zero      wp = wp + at1*real(q(j,1))**2   60 continue      we = 2.0*float(nx*ny)*wp      return      endc-----------------------------------------------------------------------      function ranorm(d)c this program calculates a random number y from a gaussian distributionc with zero mean and unit variance, according to the method ofc mueller and box:c    y(k) = (-2*ln(x(k)))**1/2*sin(2*pi*x(k+1))c    y(k+1) = (-2*ln(x(k)))**1/2*cos(2*pi*x(k+1)),c where x is a random number uniformly distributed on (0,1).c written for the ibm by viktor k. decyk, ucla      integer r1,r2,r4,r5      double precision ranorm,h1l,h1u,h2l,r0,r3,asc,bsc,temp      save iflg,r1,r2,r4,r5,h1l,h1u,h2l,r0      data r1,r2,r4,r5 /885098780,1824280461,1396483093,55318673/      data h1l,h1u,h2l /65531.0d0,32767.0d0,65525.0d0/      data iflg,r0 /0,0.0d0/      if (iflg.eq.0) go to 10      ranorm = r0      r0 = 0.0d0      iflg = 0      return   10 isc = 65536      asc = dfloat(isc)      bsc = asc*asc      i1 = r1 - (r1/isc)*isc      r3 = h1l*dfloat(r1) + asc*h1u*dfloat(i1)      i1 = r3/bsc      r3 = r3 - dfloat(i1)*bsc      bsc = 0.5d0*bsc      i1 = r2/isc      isc = r2 - i1*isc      r0 = h1l*dfloat(r2) + asc*h1u*dfloat(isc)      asc = 1.0d0/bsc      isc = r0*asc      r2 = r0 - dfloat(isc)*bsc      r3 = r3 + (dfloat(isc) + 2.0d0*h1u*dfloat(i1))      isc = r3*asc      r1 = r3 - dfloat(isc)*bsc      temp = dsqrt(-2.0d0*dlog((dfloat(r1) + dfloat(r2)*asc)*asc))      isc = 65536      asc = dfloat(isc)      bsc = asc*asc      i1 = r4 - (r4/isc)*isc      r3 = h2l*dfloat(r4) + asc*h1u*dfloat(i1)      i1 = r3/bsc      r3 = r3 - dfloat(i1)*bsc      bsc = 0.5d0*bsc      i1 = r5/isc      isc = r5 - i1*isc      r0 = h2l*dfloat(r5) + asc*h1u*dfloat(isc)      asc = 1.0d0/bsc      isc = r0*asc      r5 = r0 - dfloat(isc)*bsc      r3 = r3 + (dfloat(isc) + 2.0d0*h1u*dfloat(i1))      isc = r3*asc      r4 = r3 - dfloat(isc)*bsc      r0 = 6.28318530717959d0*((dfloat(r4) + dfloat(r5)*asc)*asc)      ranorm = temp*dsin(r0)      r0 = temp*dcos(r0)      iflg = 1      return      endc-----------------------------------------------------------------------      subroutine ppinit(idproc,nvp)c this subroutine initializes parallel processingc input: nvp, output: idprocc idproc = processor idc nvp = number of real or virtual processors requested      implicit none      integer idproc, nvpc get definition of MPI constants      include 'mpif.h'c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplxc lstat = length of status array      parameter(lstat=8)c nproc = number of real or virtual processors obtainedc lgrp = current communicatorc mreal = default datatype for realsc mint = default datatype for integersc mcplx = default datatype for complex type      common /pparms/ nproc, lgrp, mreal, mint, mcplxc local data      integer ierror, ndprec      save /pparms/c ndprec = (0,1) = (no,yes) use (normal,autodouble) precision      data ndprec /1/c this segment is used for shared memory computersc     nproc = nvpc     idproc = 0c this segment is used for mpi computers      if (MPI_STATUS_SIZE.gt.lstat) then         write (2,*) ' status size too small, actual/required = ', lstat     1, MPI_STATUS_SIZE         stop      endifc initialize the MPI execution environment      call MPI_INIT(ierror)      if (ierror.ne.0) stop      lgrp = MPI_COMM_WORLDc determine the rank of the calling process in the communicator      call MPI_COMM_RANK(lgrp,idproc,ierror)c determine the size of the group associated with a communicator      call MPI_COMM_SIZE(lgrp,nproc,ierror)c set default datatypes         mint = MPI_INTEGERc single precision      if (ndprec.eq.0) then         mreal = MPI_REAL         mcplx = MPI_COMPLEXc double precision      else         mreal = MPI_DOUBLE_PRECISION         mcplx = MPI_DOUBLE_COMPLEX      endifc requested number of processors not obtained      if (nproc.ne.nvp) then         write (2,*) ' processor number error: nvp, nproc=', nvp, nproc         call ppexit         stop      endif      return      endc-----------------------------------------------------------------------      subroutine ppexitc this subroutine terminates parallel processing      implicit nonec common block for parallel processing      integer nproc, lgrp, mreal, mint, mcplxc lgrp = current communicator      common /pparms/ nproc, lgrp, mreal, mint, mcplx      integer ierrorc synchronize processes      call MPI_BARRIER(lgrp,ierror)c terminate MPI execution environment      call MPI_FINALIZE(ierror)      return      endc-----------------------------------------------------------------------      subroutine psum (f,g,nxp,nblok)c this subroutine performs a parallel sum of a vector, that is:c f(j,k) = sum over k of f(j,k)c assumes the number of processors nproc is a power of two.c the algorithm performs partial sums in binary pairs, as follows:c first, adjacent processors exchange vectors and sum them.  next,c processors separated by 2 exchange the new vectors and sum them, thenc those separated by 4, up to processors separated by nproc/2.  at thec end, all processors contain the same summation.c f = input and output datac g = scratch arrayc nxp = number of data values in vectorc nblok = number of data blocksc written by viktor k. decyk, ucla      implicit none      real f, g      integer nxp, nblok      dimension f(nxp,nblok), g(nxp,nblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplxc lstat = length of status array      parameter(lstat=8)c nproc = number of real or virtual processors obtainedc lgrp = current communicatorc mreal = default datatype for reals      common /pparms/ nproc, lgrp, mreal, mint, mcplxc local data      integer istatus      integer idproc, ierr, kstrt, ks, l, kxs, k, kb, lb, msid, j      dimension istatus(lstat)c find processor idc this line is used for shared memory computersc     idproc = 0c this line is used for mpi computers      call MPI_COMM_RANK(lgrp,idproc,ierr)      kstrt = idproc + 1      if (kstrt.gt.nproc) return      ks = kstrt - 2      l = 1      kxs = 1c main iteration loop   10 if (kxs.ge.nproc) go to 60c shift data      do 30 k = 1, nblok      kb = k + ks      lb = kb/kxs      kb = kb + 1      lb = lb - 2*(lb/2)c this loop is used for shared memory computersc     do 20 j = 1, nxpc     if (lb.eq.0) thenc        g(j,k) = f(j,kb+kxs)c     elsec        g(j,k) = f(j,kb-kxs)c     endifc  20 continuec this segment is used for mpi computers      if (lb.eq.0) then         call MPI_IRECV(g,nxp,mreal,kb+kxs-1,l+nxp,lgrp,msid,ierr)         call MPI_SEND(f,nxp,mreal,kb+kxs-1,l+nxp,lgrp,ierr)      else         call MPI_IRECV(g,nxp,mreal,kb-kxs-1,l+nxp,lgrp,msid,ierr)         call MPI_SEND(f,nxp,mreal,kb-kxs-1,l+nxp,lgrp,ierr)      endif      call MPI_WAIT(msid,istatus,ierr)   30 continuec perform sum      do 50 k = 1, nblok      do 40 j = 1, nxp      f(j,k) = f(j,k) + g(j,k)   40 continue   50 continue      l = l + 1      kxs = kxs + kxs      go to 10   60 return      endc-----------------------------------------------------------------------      subroutine dcomp2(edges,nyp,noff,ny,kstrt,nvp,idps,nblok)c this subroutine determines spatial boundaries for particlec decomposition, calculates number of grid points in each spatialc region, and the offset of these grid points from the global addressc edges(1,l) = lower boundary of particle partition lc edges(2,l) = upper boundary of particle partition lc nyp(l) = number of primary gridpoints in particle partition l.c noff(l) = lowermost global gridpoint in particle partition l.c ny = system length in y directionc kstrt = starting data block numberc nvp = number of real or virtual processorsc idps = number of partition boundariesc nblok = number of particle partitions.      implicit none      real edges      integer nyp, noff, ny, kstrt, nvp, idps, nblok      dimension edges(idps,nblok)      dimension nyp(nblok), noff(nblok)c local data      integer ks, kb, kr, l      real at1      ks = kstrt - 2      at1 = float(ny)/float(nvp)      do 10 l = 1, nblok      kb = l + ks      edges(1,l) = at1*float(kb)      noff(l) = edges(1,l) + .5      edges(2,l) = at1*float(kb + 1)      kr = edges(2,l) + .5      nyp(l) = kr - noff(l)   10 continue      return      end