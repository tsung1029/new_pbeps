c 2d parallel PIC library for initializationc written by viktor k. decyk, uclac copyright 1995, regents of the university of californiac update: november 10, 2000c-----------------------------------------------------------------------      subroutine PISTR2(part,edges,npp,nps,vtx,vty,vdx,vdy,npx,npy,nx,ny     1,idimp,npmax,nblok,idps,ierr)c for 2d code, this subroutine calculates initial particle co-ordinatesc and velocities with uniform density and maxwellian velocity with driftc for distributed data.c part(1,n,l) = position x of particle n in partition lc part(2,n,l) = position y of particle n in partition lc part(3,n,l) = velocity vx of particle n in partition lc part(4,n,l) = velocity vy of particle n in partition lc edges(1,l) = lower boundary of particle partition lc edges(2,l) = upper boundary of particle partition lc npp(l) = number of particles in partition lc nps(l) = starting address of particles in partition lc vtx/vty = thermal velocity of electrons in x/y directionc vdx/vdy = drift velocity of beam electrons in x/y directionc npx/npy = initial number of particles distributed in x/y directionc nx/ny = system length in x/y directionc idimp = size of phase space = 4c npmax = maximum number of particles in each partitionc nblok = number of particle partitions.c idps = number of partition boundariesc ierr = (0,1) = (no,yes) error condition existsc ranorm = gaussian random number with zero mean and unit variancec with spatial decomposition      double precision ranorm      double precision sum0, sum1      dimension part(idimp,npmax,nblok)      dimension edges(idps,nblok), npp(nblok), nps(nblok)      dimension sum2(2), isum2(2)      dimension work2(2), iwork2(2)      ierr = 0      at1 = float(nx)/float(npx)      at2 = float(ny)/float(npy)      do 30 k = 1, npy      yt = at2*(float(k) - .5)      do 20 j = 1, npxc uniform density profile      xt = at1*(float(j) - .5)c maxwellian velocity distribution      vxt = vtx*ranorm()      vyt = vty*ranorm()      do 10 l = 1, nblok      if ((yt.ge.edges(1,l)).and.(yt.lt.edges(2,l))) then         npt = npp(l) + 1         if (npt.le.npmax) then            part(1,npt,l) = xt            part(2,npt,l) = yt            part(3,npt,l) = vxt            part(4,npt,l) = vyt            npp(l) = npt         else            ierr = ierr + 1         endif      endif   10 continue   20 continue   30 continue      npxy = 0c add correct drift      sum2(1) = 0.      sum2(2) = 0.      do 50 l = 1, nblok      sum0 = 0.0d0      sum1 = 0.0d0      do 40 j = nps(l), npp(l)      npxy = npxy + 1      sum0 = sum0 + part(3,j,l)      sum1 = sum1 + part(4,j,l)   40 continue      sum2(1) = sum2(1) + sum0      sum2(2) = sum2(2) + sum1   50 continue      isum2(1) = ierr      isum2(2) = npxy      call PISUM(isum2,iwork2,2,1)      ierr = isum2(1)      npxy = isum2(2)      call PSUM(sum2,work2,2,1)      at1 = 1./float(npxy)      sum2(1) = at1*sum2(1) - vdx      sum2(2) = at1*sum2(2) - vdy      do 70 l = 1, nblok      do 60 j = nps(l), npp(l)      part(3,j,l) = part(3,j,l) - sum2(1)      part(4,j,l) = part(4,j,l) - sum2(2)   60 continue   70 continuec process errors      if (ierr.gt.0) then         write (2,*) 'particle overflow error, ierr = ', ierr      else if (npxy.ne.(npx*npy)) then         write (2,*) 'particle distribution truncated, np = ', npxy      endif      return      endc-----------------------------------------------------------------------      function ranorm()c this program calculates a random number y from a gaussian distributionc with zero mean and unit variance, according to the method ofc mueller and box:c    y(k) = (-2*ln(x(k)))**1/2*sin(2*pi*x(k+1))c    y(k+1) = (-2*ln(x(k)))**1/2*cos(2*pi*x(k+1)),c where x is a random number uniformly distributed on (0,1).c written for the ibm by viktor k. decyk, ucla      integer r1,r2,r4,r5      double precision ranorm,h1l,h1u,h2l,r0,r3,asc,bsc,temp      save iflg,r1,r2,r4,r5,h1l,h1u,h2l,r0      data r1,r2,r4,r5 /885098780,1824280461,1396483093,55318673/      data h1l,h1u,h2l /65531.0d0,32767.0d0,65525.0d0/      data iflg,r0 /0,0.0d0/      if (iflg.eq.0) go to 10      ranorm = r0      r0 = 0.0d0      iflg = 0      return   10 isc = 65536      asc = dble(isc)      bsc = asc*asc      i1 = r1 - (r1/isc)*isc      r3 = h1l*dble(r1) + asc*h1u*dble(i1)      i1 = r3/bsc      r3 = r3 - dble(i1)*bsc      bsc = 0.5d0*bsc      i1 = r2/isc      isc = r2 - i1*isc      r0 = h1l*dble(r2) + asc*h1u*dble(isc)      asc = 1.0d0/bsc      isc = r0*asc      r2 = r0 - dble(isc)*bsc      r3 = r3 + (dble(isc) + 2.0d0*h1u*dble(i1))      isc = r3*asc      r1 = r3 - dble(isc)*bsc      temp = dsqrt(-2.0d0*dlog((dble(r1) + dble(r2)*asc)*asc))      isc = 65536      asc = dble(isc)      bsc = asc*asc      i1 = r4 - (r4/isc)*isc      r3 = h2l*dble(r4) + asc*h1u*dble(i1)      i1 = r3/bsc      r3 = r3 - dble(i1)*bsc      bsc = 0.5d0*bsc      i1 = r5/isc      isc = r5 - i1*isc      r0 = h2l*dble(r5) + asc*h1u*dble(isc)      asc = 1.0d0/bsc      isc = r0*asc      r5 = r0 - dble(isc)*bsc      r3 = r3 + (dble(isc) + 2.0d0*h1u*dble(i1))      isc = r3*asc      r4 = r3 - dble(isc)*bsc      r0 = 6.28318530717959d0*((dble(r4) + dble(r5)*asc)*asc)      ranorm = temp*dsin(r0)      r0 = temp*dcos(r0)      iflg = 1      return      endc-----------------------------------------------------------------------      function random()c this is a version of the random number generator dprandom due toc c. bingham and the yale computer center, producing numbersc in the interval (0,1).  written for the sun by viktor k. decyk, ucla      integer r1,r2      double precision random,h1l,h1u,r0,r3,asc,bsc      save r1,r2,h1l,h1u      data r1,r2 /1271199957,1013501921/      data h1l,h1u /65533.0d0,32767.0d0/      isc = 65536      asc = dble(isc)      bsc = asc*asc      i1 = r1 - (r1/isc)*isc      r3 = h1l*dble(r1) + asc*h1u*dble(i1)      i1 = r3/bsc      r3 = r3 - dble(i1)*bsc      bsc = 0.5d0*bsc      i1 = r2/isc      isc = r2 - i1*isc      r0 = h1l*dble(r2) + asc*h1u*dble(isc)      asc = 1.0d0/bsc      isc = r0*asc      r2 = r0 - dble(isc)*bsc      r3 = r3 + (dble(isc) + 2.0d0*h1u*dble(i1))      isc = r3*asc      r1 = r3 - dble(isc)*bsc      random = (dble(r1) + dble(r2)*asc)*asc      return      end