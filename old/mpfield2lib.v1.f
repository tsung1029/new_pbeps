c 2d parallel PIC multi-tasking library for solving field equationsc written by viktor k. decyk, uclac copyright 1995, regents of the university of californiac update: september 24, 2004c-----------------------------------------------------------------------      subroutine MPFFT2R(f,g,bs,br,isign,ntpose,mixup,sct,indx,indy,kstr     1t,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd,kxyip,iftask,nmt,i     2err)c multi-tasking real to complex fftc kxyip = initial index arrays for tasksc iftask = index to notify queue for task (0 if error)c nmt = number of tasksc ierr = ierror indicator (0 = no error)      implicit none      integer isign, ntpose, indx, indy, kstrt, nxvh, nyv, kxp, kyp      integer kypd, jblok, kblok, nxhyd, nxyhd, mixup      integer kxyip, iftask, nmt, ierr      complex f, g, bs, br, sct      dimension f(nxvh,kypd,kblok), g(nyv,kxp,jblok)      dimension bs(kxp,kyp,kblok), br(kxp,kyp,jblok)      dimension mixup(nxhyd), sct(nxyhd)      dimension kxyip(nmt), iftask(nmt)c local data      integer nargs, nx, ny, nxh, kxpi, kxpp, kxpl, kypi, kypp, kypl      integer i      external PFFT2RXX, PFFT2RXY      data nargs /14/c calculate range of indices      nx = 2**indx      ny = 2**indy      nxh = nx/2      kxpp = kxp/(nmt + 1)      kypp = kyp/(nmt + 1)      kxpi = kxpp*nmt      kypi = kypp*nmt      kxpl = kxp - kxpi      kypl = kyp - kypi      kxpi = kxpi + 1      kypi = kypi + 1      ierr = 0c inverse fourier transform      if (isign.lt.0) thenc start x fft tasks         do 10 i = 1, nmt         kxyip(i) = kypp*(i - 1) + 1         call MP_TASKSTART(iftask(i),PFFT2RXX,nargs,f,isign,mixup,sct,in     1dx,indy,kstrt,kxyip(i),kypp,nxvh,kypd,kblok,nxhyd,nxyhd)c check for errors         if (iftask(i).eq.0) then           ierr = -1           return         endif   10    continuec finish x fft         call PFFT2RXX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kypl,nxvh,     1kypd,kblok,nxhyd,nxyhd)c wait for tasks to complete         do 20 i = 1, nmt         call MP_TASKWAIT(iftask(i))c check for errors         if (iftask(i).ne.0) then            ierr = -2            return         endif   20    continuec transpose f array to g         call PTPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kypd,jb     1lok,kblok)c start y fft tasks         do 30 i = 1, nmt         kxyip(i) = kxpp*(i - 1) + 1         call MP_TASKSTART(iftask(i),PFFT2RXY,nargs,g,isign,mixup,sct,in     1dx,indy,kstrt,kxyip(i),kxpp,nyv,kxp,jblok,nxhyd,nxyhd)c check for errors         if (iftask(i).eq.0) then           ierr = -1           return         endif   30    continuec finish y fft         call PFFT2RXY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxpl,nyv,k     1xp,jblok,nxhyd,nxyhd)c wait for tasks to complete         do 40 i = 1, nmt         call MP_TASKWAIT(iftask(i))c check for errors         if (iftask(i).ne.0) ierr = -2   40    continuec transpose g array to f         if (ntpose.eq.0) call PTPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,ky     1p,kxp,kypd,kxp,kblok,jblok)c forward fourier transform      else if (isign.gt.0) thenc transpose f array to g         if (ntpose.eq.0) call PTPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,kx     1p,kyp,kxp,kypd,jblok,kblok)c start y fft tasks         do 50 i = 1, nmt         kxyip(i) = kxpp*(i - 1) + 1         call MP_TASKSTART(iftask(i),PFFT2RXY,nargs,g,isign,mixup,sct,in     1dx,indy,kstrt,kxyip(i),kxpp,nyv,kxp,jblok,nxhyd,nxyhd)c check for errors         if (iftask(i).eq.0) then           ierr = -1           return         endif   50    continuec finish y fft         call PFFT2RXY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxpl,nyv,k     1xp,jblok,nxhyd,nxyhd)c wait for tasks to complete         do 60 i = 1, nmt         call MP_TASKWAIT(iftask(i))c check for errors         if (iftask(i).ne.0) ierr = -2   60    continuec transpose g array to f         call PTPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kxp,kb     1lok,jblok)c start x fft tasks         do 70 i = 1, nmt         kxyip(i) = kypp*(i - 1) + 1         call MP_TASKSTART(iftask(i),PFFT2RXX,nargs,f,isign,mixup,sct,in     1dx,indy,kstrt,kxyip(i),kypp,nxvh,kypd,kblok,nxhyd,nxyhd)c check for errors         if (iftask(i).eq.0) then           ierr = -1           return         endif   70    continuec finish x fft         call PFFT2RXX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kypl,nxvh,     1kypd,kblok,nxhyd,nxyhd)c wait for tasks to complete         do 80 i = 1, nmt         call MP_TASKWAIT(iftask(i))c check for errors         if (iftask(i).ne.0) then            ierr = -2            return         endif   80    continue      endif      return      endc-----------------------------------------------------------------------      subroutine MPFFT2RX(f,g,isign,ntpose,mixup,sct,indx,indy,kstrt,nxv     1h,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd,kxyip,iftask,nmt,ierr)c multi-tasking real to complex fftc kxyip = initial index arrays for tasksc iftask = index to notify queue for task (0 if error)c nmt = number of tasksc ierr = ierror indicator (0 = no error)      implicit none      integer isign, ntpose, mixup, indx, indy, kstrt, nxvh      integer nyv, kxp, kyp, kypd, jblok, kblok, nxhyd, nxyhd      integer kxyip, iftask, nmt, ierr      complex f, g, sct      dimension f(nxvh,kypd,kblok), g(nyv,kxp,jblok)      dimension mixup(nxhyd), sct(nxyhd)      dimension kxyip(nmt), iftask(nmt)c local data      integer nargs, nx, ny, nxh, kxpi, kxpp, kxpl, kypi, kypp, kypl      integer i      external PFFT2RXX, PFFT2RXY      data nargs /14/c calculate range of indices      nx = 2**indx      ny = 2**indy      nxh = nx/2      kxpp = kxp/(nmt + 1)      kypp = kyp/(nmt + 1)      kxpi = kxpp*nmt      kypi = kypp*nmt      kxpl = kxp - kxpi      kypl = kyp - kypi      kxpi = kxpi + 1      kypi = kypi + 1      ierr = 0c inverse fourier transform      if (isign.lt.0) thenc start x fft tasks         do 10 i = 1, nmt         kxyip(i) = kypp*(i - 1) + 1         call MP_TASKSTART(iftask(i),PFFT2RXX,nargs,f,isign,mixup,sct,in     1dx,indy,kstrt,kxyip(i),kypp,nxvh,kypd,kblok,nxhyd,nxyhd)c check for errors         if (iftask(i).eq.0) then           ierr = -1           return         endif   10    continuec finish x fft         call PFFT2RXX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kypl,nxvh,     1kypd,kblok,nxhyd,nxyhd)c wait for tasks to complete         do 20 i = 1, nmt         call MP_TASKWAIT(iftask(i))c check for errors         if (iftask(i).ne.0) then            ierr = -2            return         endif   20    continuec transpose f array to g         call PTPOSEX(f,g,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kypd,jblok,k     1blok)c start y fft tasks         do 30 i = 1, nmt         kxyip(i) = kxpp*(i - 1) + 1         call MP_TASKSTART(iftask(i),PFFT2RXY,nargs,g,isign,mixup,sct,in     1dx,indy,kstrt,kxyip(i),kxpp,nyv,kxp,jblok,nxhyd,nxyhd)c check for errors         if (iftask(i).eq.0) then           ierr = -1           return         endif   30    continuec finish y fft         call PFFT2RXY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxpl,nyv,k     1xp,jblok,nxhyd,nxyhd)c wait for tasks to complete         do 40 i = 1, nmt         call MP_TASKWAIT(iftask(i))c check for errors         if (iftask(i).ne.0) ierr = -2   40    continuec transpose g array to f         if (ntpose.eq.0) call PTPOSEX(g,f,ny,nxh,kstrt,nyv,nxvh,kyp,kxp     1,kypd,kxp,kblok,jblok)c forward fourier transform      else if (isign.gt.0) thenc transpose f array to g         if (ntpose.eq.0) call PTPOSEX(f,g,nxh,ny,kstrt,nxvh,nyv,kxp,kyp     1,kxp,kypd,jblok,kblok)c start y fft tasks         do 50 i = 1, nmt         kxyip(i) = kxpp*(i - 1) + 1         call MP_TASKSTART(iftask(i),PFFT2RXY,nargs,g,isign,mixup,sct,in     1dx,indy,kstrt,kxyip(i),kxpp,nyv,kxp,jblok,nxhyd,nxyhd)c check for errors         if (iftask(i).eq.0) then           ierr = -1           return         endif   50    continuec finish y fft         call PFFT2RXY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxpl,nyv,k     1xp,jblok,nxhyd,nxyhd)c wait for tasks to complete         do 60 i = 1, nmt         call MP_TASKWAIT(iftask(i))c check for errors         if (iftask(i).ne.0) ierr = -2   60    continuec transpose g array to f         call PTPOSEX(g,f,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kxp,kblok,j     1blok)c start x fft tasks         do 70 i = 1, nmt         kxyip(i) = kypp*(i - 1) + 1         call MP_TASKSTART(iftask(i),PFFT2RXX,nargs,f,isign,mixup,sct,in     1dx,indy,kstrt,kxyip(i),kypp,nxvh,kypd,kblok,nxhyd,nxyhd)c check for errors         if (iftask(i).eq.0) then           ierr = -1           return         endif   70    continuec finish x fft         call PFFT2RXX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kypl,nxvh,     1kypd,kblok,nxhyd,nxyhd)c wait for tasks to complete         do 80 i = 1, nmt         call MP_TASKWAIT(iftask(i))c check for errors         if (iftask(i).ne.0) then            ierr = -2            return         endif   80    continue      endif      return      endc-----------------------------------------------------------------------      subroutine MPFFT2R2(f,g,bs,br,isign,ntpose,mixup,sct,indx,indy,kst     1rt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd,kxyip,iftask,nmt,     2ierr)c multi-tasking real to complex fftc kxyip = initial index arrays for tasksc iftask = index to notify queue for task (0 if error)c nmt = number of tasksc ierr = ierror indicator (0 = no error)      implicit none      integer isign, ntpose, indx, indy, kstrt, nxvh, nyv, kxp, kyp      integer kypd, jblok, kblok, nxhyd, nxyhd, mixup      integer kxyip, iftask, nmt, ierr      complex f, g, bs, br, sct      dimension f(2,nxvh,kypd,kblok), g(2,nyv,kxp,jblok)      dimension bs(2,kxp,kyp,kblok), br(2,kxp,kyp,jblok)      dimension mixup(nxhyd), sct(nxyhd)      dimension kxyip(nmt), iftask(nmt)c local data      integer nargs, nx, ny, nxh, kxpi, kxpp, kxpl, kypi, kypp, kypl      integer i      external PFFT2R2XX, PFFT2R2XY      data nargs /14/c calculate range of indices      nx = 2**indx      ny = 2**indy      nxh = nx/2      kxpp = kxp/(nmt + 1)      kypp = kyp/(nmt + 1)      kxpi = kxpp*nmt      kypi = kypp*nmt      kxpl = kxp - kxpi      kypl = kyp - kypi      kxpi = kxpi + 1      kypi = kypi + 1      ierr = 0c inverse fourier transform      if (isign.lt.0) thenc start x fft tasks         do 10 i = 1, nmt         kxyip(i) = kypp*(i - 1) + 1         call MP_TASKSTART(iftask(i),PFFT2R2XX,nargs,f,isign,mixup,sct,i     1ndx,indy,kstrt,kxyip(i),kypp,nxvh,kypd,kblok,nxhyd,nxyhd)c check for errors         if (iftask(i).eq.0) then           ierr = -1           return         endif   10    continuec finish x fft         call PFFT2R2XX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kypl,nxvh     1,kypd,kblok,nxhyd,nxyhd)c wait for tasks to complete         do 20 i = 1, nmt         call MP_TASKWAIT(iftask(i))c check for errors         if (iftask(i).ne.0) then            ierr = -2            return         endif   20    continuec transpose f array to g         call P2TPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kypd,j     1blok,kblok)c start y fft tasks         do 30 i = 1, nmt         kxyip(i) = kxpp*(i - 1) + 1         call MP_TASKSTART(iftask(i),PFFT2R2XY,nargs,g,isign,mixup,sct,i     1ndx,indy,kstrt,kxyip(i),kxpp,nyv,kxp,jblok,nxhyd,nxyhd)c check for errors         if (iftask(i).eq.0) then           ierr = -1           return         endif   30    continuec finish y fft         call PFFT2R2XY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxpl,nyv,     1kxp,jblok,nxhyd,nxyhd)c wait for tasks to complete         do 40 i = 1, nmt         call MP_TASKWAIT(iftask(i))c check for errors         if (iftask(i).ne.0) ierr = -2   40    continuec transpose g array to f         if (ntpose.eq.0) call P2TPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,k     1yp,kxp,kypd,kxp,kblok,jblok)c forward fourier transform      else if (isign.gt.0) thenc transpose f array to g         if (ntpose.eq.0) call P2TPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,k     1xp,kyp,kxp,kypd,jblok,kblok)c start y fft tasks         do 50 i = 1, nmt         kxyip(i) = kxpp*(i - 1) + 1         call MP_TASKSTART(iftask(i),PFFT2R2XY,nargs,g,isign,mixup,sct,i     1ndx,indy,kstrt,kxyip(i),kxpp,nyv,kxp,jblok,nxhyd,nxyhd)c check for errors         if (iftask(i).eq.0) then           ierr = -1           return         endif   50    continuec finish y fft         call PFFT2R2XY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxpl,nyv,     1kxp,jblok,nxhyd,nxyhd)c wait for tasks to complete         do 60 i = 1, nmt         call MP_TASKWAIT(iftask(i))c check for errors         if (iftask(i).ne.0) ierr = -2   60    continuec transpose g array to f         call P2TPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kxp,k     1blok,jblok)c start x fft tasks         do 70 i = 1, nmt         kxyip(i) = kypp*(i - 1) + 1         call MP_TASKSTART(iftask(i),PFFT2R2XX,nargs,f,isign,mixup,sct,i     1ndx,indy,kstrt,kxyip(i),kypp,nxvh,kypd,kblok,nxhyd,nxyhd)c check for errors         if (iftask(i).eq.0) then           ierr = -1           return         endif   70    continuec finish x fft         call PFFT2R2XX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kypl,nxvh     1,kypd,kblok,nxhyd,nxyhd)c wait for tasks to complete         do 80 i = 1, nmt         call MP_TASKWAIT(iftask(i))c check for errors         if (iftask(i).ne.0) then            ierr = -2            return         endif   80    continue      endif      return      endc-----------------------------------------------------------------------      subroutine MPFFT2R3(f,g,bs,br,isign,ntpose,mixup,sct,indx,indy,kst     1rt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd,kxyip,iftask,nmt,     2ierr)c multi-tasking real to complex fftc kxyip = initial index arrays for tasksc iftask = index to notify queue for task (0 if error)c nmt = number of tasksc ierr = ierror indicator (0 = no error)      implicit none      integer isign, ntpose, indx, indy, kstrt, nxvh, nyv, kxp, kyp      integer kypd, jblok, kblok, nxhyd, nxyhd, mixup      integer kxyip, iftask, nmt, ierr      complex f, g, bs, br, sct      dimension f(3,nxvh,kypd,kblok), g(3,nyv,kxp,jblok)      dimension bs(3,kxp,kyp,kblok), br(3,kxp,kyp,jblok)      dimension mixup(nxhyd), sct(nxyhd)      dimension kxyip(nmt), iftask(nmt)c local data      integer nargs, nx, ny, nxh, kxpi, kxpp, kxpl, kypi, kypp, kypl      integer i      external PFFT2R3XX, PFFT2R3XY      data nargs /14/c calculate range of indices      nx = 2**indx      ny = 2**indy      nxh = nx/2      kxpp = kxp/(nmt + 1)      kypp = kyp/(nmt + 1)      kxpi = kxpp*nmt      kypi = kypp*nmt      kxpl = kxp - kxpi      kypl = kyp - kypi      kxpi = kxpi + 1      kypi = kypi + 1      ierr = 0c inverse fourier transform      if (isign.lt.0) thenc start x fft tasks         do 10 i = 1, nmt         kxyip(i) = kypp*(i - 1) + 1         call MP_TASKSTART(iftask(i),PFFT2R3XX,nargs,f,isign,mixup,sct,i     1ndx,indy,kstrt,kxyip(i),kypp,nxvh,kypd,kblok,nxhyd,nxyhd)c check for errors         if (iftask(i).eq.0) then           ierr = -1           return         endif   10    continuec finish x fft         call PFFT2R3XX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kypl,nxvh     1,kypd,kblok,nxhyd,nxyhd)c wait for tasks to complete         do 20 i = 1, nmt         call MP_TASKWAIT(iftask(i))c check for errors         if (iftask(i).ne.0) then            ierr = -2            return         endif   20    continuec transpose f array to g         call P3TPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kypd,j     1blok,kblok)c start y fft tasks         do 30 i = 1, nmt         kxyip(i) = kxpp*(i - 1) + 1         call MP_TASKSTART(iftask(i),PFFT2R3XY,nargs,g,isign,mixup,sct,i     1ndx,indy,kstrt,kxyip(i),kxpp,nyv,kxp,jblok,nxhyd,nxyhd)c check for errors         if (iftask(i).eq.0) then           ierr = -1           return         endif   30    continuec finish y fft         call PFFT2R3XY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxpl,nyv,     1kxp,jblok,nxhyd,nxyhd)c wait for tasks to complete         do 40 i = 1, nmt         call MP_TASKWAIT(iftask(i))c check for errors         if (iftask(i).ne.0) ierr = -2   40    continuec transpose g array to f         if (ntpose.eq.0) call P3TPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,k     1yp,kxp,kypd,kxp,kblok,jblok)c forward fourier transform      else if (isign.gt.0) thenc transpose f array to g         if (ntpose.eq.0) call P3TPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,k     1xp,kyp,kxp,kypd,jblok,kblok)c start y fft tasks         do 50 i = 1, nmt         kxyip(i) = kxpp*(i - 1) + 1         call MP_TASKSTART(iftask(i),PFFT2R3XY,nargs,g,isign,mixup,sct,i     1ndx,indy,kstrt,kxyip(i),kxpp,nyv,kxp,jblok,nxhyd,nxyhd)c check for errors         if (iftask(i).eq.0) then           ierr = -1           return         endif   50    continuec finish y fft         call PFFT2R3XY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxpl,nyv,     1kxp,jblok,nxhyd,nxyhd)c wait for tasks to complete         do 60 i = 1, nmt         call MP_TASKWAIT(iftask(i))c check for errors         if (iftask(i).ne.0) ierr = -2   60    continuec transpose g array to f         call P3TPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kxp,k     1blok,jblok)c start x fft tasks         do 70 i = 1, nmt         kxyip(i) = kypp*(i - 1) + 1         call MP_TASKSTART(iftask(i),PFFT2R3XX,nargs,f,isign,mixup,sct,i     1ndx,indy,kstrt,kxyip(i),kypp,nxvh,kypd,kblok,nxhyd,nxyhd)c check for errors         if (iftask(i).eq.0) then           ierr = -1           return         endif   70    continuec finish x fft         call PFFT2R3XX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kypl,nxvh     1,kypd,kblok,nxhyd,nxyhd)c wait for tasks to complete         do 80 i = 1, nmt         call MP_TASKWAIT(iftask(i))c check for errors         if (iftask(i).ne.0) then            ierr = -2            return         endif   80    continue      endif      return      endc-----------------------------------------------------------------------      subroutine MPFFT2RX2(f,g,isign,ntpose,mixup,sct,indx,indy,kstrt,nx     1vh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd,kxyip,iftask,nmt,ierr)c multi-tasking real to complex fftc kxyip = initial index arrays for tasksc iftask = index to notify queue for task (0 if error)c nmt = number of tasksc ierr = ierror indicator (0 = no error)      implicit none      integer isign, ntpose, mixup, indx, indy, kstrt, nxvh      integer nyv, kxp, kyp, kypd, jblok, kblok, nxhyd, nxyhd      integer kxyip, iftask, nmt, ierr      complex f, g, sct      dimension f(2,nxvh,kypd,kblok), g(2,nyv,kxp,jblok)      dimension mixup(nxhyd), sct(nxyhd)      dimension kxyip(nmt), iftask(nmt)c local data      integer nargs, nx, ny, nxh, kxpi, kxpp, kxpl, kypi, kypp, kypl      integer i      external PFFT2R2XX, PFFT2R2XY      data nargs /14/c calculate range of indices      nx = 2**indx      ny = 2**indy      nxh = nx/2      kxpp = kxp/(nmt + 1)      kypp = kyp/(nmt + 1)      kxpi = kxpp*nmt      kypi = kypp*nmt      kxpl = kxp - kxpi      kypl = kyp - kypi      kxpi = kxpi + 1      kypi = kypi + 1      ierr = 0c inverse fourier transform      if (isign.lt.0) thenc start x fft tasks         do 10 i = 1, nmt         kxyip(i) = kypp*(i - 1) + 1         call MP_TASKSTART(iftask(i),PFFT2R2XX,nargs,f,isign,mixup,sct,i     1ndx,indy,kstrt,kxyip(i),kypp,nxvh,kypd,kblok,nxhyd,nxyhd)c check for errors         if (iftask(i).eq.0) then           ierr = -1           return         endif   10    continuec finish x fft         call PFFT2R2XX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kypl,nxvh     1,kypd,kblok,nxhyd,nxyhd)c wait for tasks to complete         do 20 i = 1, nmt         call MP_TASKWAIT(iftask(i))c check for errors         if (iftask(i).ne.0) then            ierr = -2            return         endif   20    continuec transpose f array to g         call P2TPOSEX(f,g,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kypd,jblok,     1kblok)c start y fft tasks         do 30 i = 1, nmt         kxyip(i) = kxpp*(i - 1) + 1         call MP_TASKSTART(iftask(i),PFFT2R2XY,nargs,g,isign,mixup,sct,i     1ndx,indy,kstrt,kxyip(i),kxpp,nyv,kxp,jblok,nxhyd,nxyhd)c check for errors         if (iftask(i).eq.0) then           ierr = -1           return         endif   30    continuec finish y fft         call PFFT2R2XY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxpl,nyv,     1kxp,jblok,nxhyd,nxyhd)c wait for tasks to complete         do 40 i = 1, nmt         call MP_TASKWAIT(iftask(i))c check for errors         if (iftask(i).ne.0) ierr = -2   40    continuec transpose g array to f         if (ntpose.eq.0) call P2TPOSEX(g,f,ny,nxh,kstrt,nyv,nxvh,kyp,kx     1p,kypd,kxp,kblok,jblok)c forward fourier transform      else if (isign.gt.0) thenc transpose f array to g         if (ntpose.eq.0) call P2TPOSEX(f,g,nxh,ny,kstrt,nxvh,nyv,kxp,ky     1p,kxp,kypd,jblok,kblok)c start y fft tasks         do 50 i = 1, nmt         kxyip(i) = kxpp*(i - 1) + 1         call MP_TASKSTART(iftask(i),PFFT2R2XY,nargs,g,isign,mixup,sct,i     1ndx,indy,kstrt,kxyip(i),kxpp,nyv,kxp,jblok,nxhyd,nxyhd)c check for errors         if (iftask(i).eq.0) then           ierr = -1           return         endif   50    continuec finish y fft         call PFFT2R2XY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxpl,nyv,     1kxp,jblok,nxhyd,nxyhd)c wait for tasks to complete         do 60 i = 1, nmt         call MP_TASKWAIT(iftask(i))c check for errors         if (iftask(i).ne.0) ierr = -2   60    continuec transpose g array to f         call P2TPOSEX(g,f,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kxp,kblok,     1jblok)c start x fft tasks         do 70 i = 1, nmt         kxyip(i) = kypp*(i - 1) + 1         call MP_TASKSTART(iftask(i),PFFT2R2XX,nargs,f,isign,mixup,sct,i     1ndx,indy,kstrt,kxyip(i),kypp,nxvh,kypd,kblok,nxhyd,nxyhd)c check for errors         if (iftask(i).eq.0) then           ierr = -1           return         endif   70    continuec finish x fft         call PFFT2R2XX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kypl,nxvh     1,kypd,kblok,nxhyd,nxyhd)c wait for tasks to complete         do 80 i = 1, nmt         call MP_TASKWAIT(iftask(i))c check for errors         if (iftask(i).ne.0) then            ierr = -2            return         endif   80    continue      endif      return      endc-----------------------------------------------------------------------      subroutine MPFFT2RX3(f,g,isign,ntpose,mixup,sct,indx,indy,kstrt,nx     1vh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd,kxyip,iftask,nmt,ierr)c multi-tasking real to complex fftc kxyip = initial index arrays for tasksc iftask = index to notify queue for task (0 if error)c nmt = number of tasksc ierr = ierror indicator (0 = no error)      implicit none      integer isign, ntpose, indx, indy, kstrt, nxvh, nyv, kxp, kyp      integer kypd, jblok, kblok, nxhyd, nxyhd, mixup      integer kxyip, iftask, nmt, ierr      complex f, g, sct      dimension f(3,nxvh,kypd,kblok), g(3,nyv,kxp,jblok)      dimension mixup(nxhyd), sct(nxyhd)      dimension kxyip(nmt), iftask(nmt)c local data      integer nargs, nx, ny, nxh, kxpi, kxpp, kxpl, kypi, kypp, kypl      integer i      external PFFT2R3XX, PFFT2R3XY      data nargs /14/c calculate range of indices      nx = 2**indx      ny = 2**indy      nxh = nx/2      kxpp = kxp/(nmt + 1)      kypp = kyp/(nmt + 1)      kxpi = kxpp*nmt      kypi = kypp*nmt      kxpl = kxp - kxpi      kypl = kyp - kypi      kxpi = kxpi + 1      kypi = kypi + 1      ierr = 0c inverse fourier transform      if (isign.lt.0) thenc start x fft tasks         do 10 i = 1, nmt         kxyip(i) = kypp*(i - 1) + 1         call MP_TASKSTART(iftask(i),PFFT2R3XX,nargs,f,isign,mixup,sct,i     1ndx,indy,kstrt,kxyip(i),kypp,nxvh,kypd,kblok,nxhyd,nxyhd)c check for errors         if (iftask(i).eq.0) then           ierr = -1           return         endif   10    continuec finish x fft         call PFFT2R3XX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kypl,nxvh     1,kypd,kblok,nxhyd,nxyhd)c wait for tasks to complete         do 20 i = 1, nmt         call MP_TASKWAIT(iftask(i))c check for errors         if (iftask(i).ne.0) then            ierr = -2            return         endif   20    continuec transpose f array to g         call P3TPOSEX(f,g,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kypd,jblok,     1kblok)c start y fft tasks         do 30 i = 1, nmt         kxyip(i) = kxpp*(i - 1) + 1         call MP_TASKSTART(iftask(i),PFFT2R3XY,nargs,g,isign,mixup,sct,i     1ndx,indy,kstrt,kxyip(i),kxpp,nyv,kxp,jblok,nxhyd,nxyhd)c check for errors         if (iftask(i).eq.0) then           ierr = -1           return         endif   30    continuec finish y fft         call PFFT2R3XY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxpl,nyv,     1kxp,jblok,nxhyd,nxyhd)c wait for tasks to complete         do 40 i = 1, nmt         call MP_TASKWAIT(iftask(i))c check for errors         if (iftask(i).ne.0) ierr = -2   40    continuec transpose g array to f         if (ntpose.eq.0) call P3TPOSEX(g,f,ny,nxh,kstrt,nyv,nxvh,kyp,kx     1p,kypd,kxp,kblok,jblok)c forward fourier transform      else if (isign.gt.0) thenc transpose f array to g         if (ntpose.eq.0) call P3TPOSEX(f,g,nxh,ny,kstrt,nxvh,nyv,kxp,ky     1p,kxp,kypd,jblok,kblok)c start y fft tasks         do 50 i = 1, nmt         kxyip(i) = kxpp*(i - 1) + 1         call MP_TASKSTART(iftask(i),PFFT2R3XY,nargs,g,isign,mixup,sct,i     1ndx,indy,kstrt,kxyip(i),kxpp,nyv,kxp,jblok,nxhyd,nxyhd)c check for errors         if (iftask(i).eq.0) then           ierr = -1           return         endif   50    continuec finish y fft         call PFFT2R3XY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxpl,nyv,     1kxp,jblok,nxhyd,nxyhd)c wait for tasks to complete         do 60 i = 1, nmt         call MP_TASKWAIT(iftask(i))c check for errors         if (iftask(i).ne.0) ierr = -2   60    continuec transpose g array to f         call P3TPOSEX(g,f,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kxp,kblok,     1jblok)c start x fft tasks         do 70 i = 1, nmt         kxyip(i) = kypp*(i - 1) + 1         call MP_TASKSTART(iftask(i),PFFT2R3XX,nargs,f,isign,mixup,sct,i     1ndx,indy,kstrt,kxyip(i),kypp,nxvh,kypd,kblok,nxhyd,nxyhd)c check for errors         if (iftask(i).eq.0) then           ierr = -1           return         endif   70    continuec finish x fft         call PFFT2R3XX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kypl,nxvh     1,kypd,kblok,nxhyd,nxyhd)c wait for tasks to complete         do 80 i = 1, nmt         call MP_TASKWAIT(iftask(i))c check for errors         if (iftask(i).ne.0) then            ierr = -2            return         endif   80    continue      endif      return      endc-----------------------------------------------------------------------      subroutine MPFFT2RN(f,g,bs,br,ss,isign,ntpose,mixup,sct,indx,indy,     1kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,ndim,nxhyd,nxyhd,kxyip,ift     2ask,nmt,ierr)c multi-tasking real to complex fftc kxyip = initial index arrays for tasksc iftask = index to notify queue for task (0 if error)c nmt = number of tasksc ierr = ierror indicator (0 = no error)      implicit none      integer isign, ntpose, indx, indy, kstrt, nxvh, nyv, kxp, kyp      integer kypd, jblok, kblok, ndim, nxhyd, nxyhd, mixup      integer kxyip, iftask, nmt, ierr      complex f, g, bs, br, ss, sct      dimension f(3,nxvh,kypd,kblok), g(3,nyv,kxp,jblok)      dimension bs(3,kxp,kyp,kblok), br(3,kxp,kyp,jblok)      dimension ss(ndim,nxvh,nmt+1)      dimension mixup(nxhyd), sct(nxyhd)      dimension kxyip(nmt), iftask(nmt)c local data      integer i, nargs, margs, nx, ny, nxh, nmtt, kxpi, kxpp, kxpl      integer kypi, kypp, kypl      external PFFT2RNXX, PFFT2RNXY      data nargs, margs /15,16/c calculate range of indices      nx = 2**indx      ny = 2**indy      nxh = nx/2      nmtt = nmt + 1      kxpp = kxp/nmtt      kypp = kyp/nmtt      kxpi = kxpp*nmt      kypi = kypp*nmt      kxpl = kxp - kxpi      kypl = kyp - kypi      kxpi = kxpi + 1      kypi = kypi + 1      ierr = 0c inverse fourier transform      if (isign.lt.0) thenc start x fft tasks         do 10 i = 1, nmt         kxyip(i) = kypp*(i - 1) + 1         call MP_TASKSTART(iftask(i),PFFT2RNXX,margs,f,ss(1,1,i),isign,m     1ixup,sct,indx,indy,kstrt,kxyip(i),kypp,nxvh,kypd,kblok,ndim,nxhyd,     2nxyhd)c check for errors         if (iftask(i).eq.0) then           ierr = -1           return         endif   10    continuec finish x fft         call PFFT2RNXX(f,ss(1,1,nmtt),isign,mixup,sct,indx,indy,kstrt,k     1ypi,kypl,nxvh,kypd,kblok,ndim,nxhyd,nxyhd)c wait for tasks to complete         do 20 i = 1, nmt         call MP_TASKWAIT(iftask(i))c check for errors         if (iftask(i).ne.0) then            ierr = -2            return         endif   20    continuec transpose f array to g         call PNTPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kypd,j     1blok,kblok,ndim)c start y fft tasks         do 30 i = 1, nmt         kxyip(i) = kxpp*(i - 1) + 1         call MP_TASKSTART(iftask(i),PFFT2RNXY,nargs,g,isign,mixup,sct,i     1ndx,indy,kstrt,kxyip(i),kxpp,nyv,kxp,jblok,ndim,nxhyd,nxyhd)c check for errors         if (iftask(i).eq.0) then           ierr = -1           return         endif   30    continuec finish y fft         call PFFT2RNXY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxpl,nyv,     1kxp,jblok,ndim,nxhyd,nxyhd)c wait for tasks to complete         do 40 i = 1, nmt         call MP_TASKWAIT(iftask(i))c check for errors         if (iftask(i).ne.0) ierr = -2   40    continuec transpose g array to f         if (ntpose.eq.0) call PNTPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,k     1yp,kxp,kypd,kxp,kblok,jblok,ndim)c forward fourier transform      else if (isign.gt.0) thenc transpose f array to g         if (ntpose.eq.0) call PNTPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,k     1xp,kyp,kxp,kypd,jblok,kblok,ndim)c start y fft tasks         do 50 i = 1, nmt         kxyip(i) = kxpp*(i - 1) + 1         call MP_TASKSTART(iftask(i),PFFT2RNXY,nargs,g,isign,mixup,sct,i     1ndx,indy,kstrt,kxyip(i),kxpp,nyv,kxp,jblok,ndim,nxhyd,nxyhd)c check for errors         if (iftask(i).eq.0) then           ierr = -1           return         endif   50    continuec finish y fft         call PFFT2RNXY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxpl,nyv,     1kxp,jblok,ndim,nxhyd,nxyhd)c wait for tasks to complete         do 60 i = 1, nmt         call MP_TASKWAIT(iftask(i))c check for errors         if (iftask(i).ne.0) ierr = -2   60    continuec transpose g array to f         call PNTPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kxp,k     1blok,jblok,ndim)c start x fft tasks         do 70 i = 1, nmt         kxyip(i) = kypp*(i - 1) + 1         call MP_TASKSTART(iftask(i),PFFT2RNXX,margs,f,ss(1,1,i),isign,m     1ixup,sct,indx,indy,kstrt,kxyip(i),kypp,nxvh,kypd,kblok,ndim,nxhyd,     2nxyhd)c check for errors         if (iftask(i).eq.0) then           ierr = -1           return         endif   70    continuec finish x fft         call PFFT2RNXX(f,ss(1,1,nmtt),isign,mixup,sct,indx,indy,kstrt,k     1ypi,kypl,nxvh,kypd,kblok,ndim,nxhyd,nxyhd)c wait for tasks to complete         do 80 i = 1, nmt         call MP_TASKWAIT(iftask(i))c check for errors         if (iftask(i).ne.0) then            ierr = -2            return         endif   80    continue      endif      return      endc-----------------------------------------------------------------------      subroutine MPFFT2RXN(f,g,ss,isign,ntpose,mixup,sct,indx,indy,kstrt     1,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,ndim,nxhyd,nxyhd,kxyip,iftask,n     2mt,ierr)c multi-tasking real to complex fftc kxyip = initial index arrays for tasksc iftask = index to notify queue for task (0 if error)c nmt = number of tasksc ierr = ierror indicator (0 = no error)      implicit none      integer isign, ntpose, indx, indy, kstrt, nxvh, nyv, kxp, kyp      integer kypd, jblok, kblok, ndim, nxhyd, nxyhd, mixup      integer kxyip, iftask, nmt, ierr      complex f, g, ss, sct      dimension f(3,nxvh,kypd,kblok), g(3,nyv,kxp,jblok)      dimension ss(ndim,nxvh,nmt+1)      dimension mixup(nxhyd), sct(nxyhd)      dimension kxyip(nmt), iftask(nmt)c local data      integer i, nargs, margs, nx, ny, nxh, nmtt, kxpi, kxpp, kxpl      integer kypi, kypp, kypl      external PFFT2RNXX, PFFT2RNXY      data nargs, margs /15,16/c calculate range of indices      nx = 2**indx      ny = 2**indy      nxh = nx/2      nmtt = nmt + 1      kxpp = kxp/nmtt      kypp = kyp/nmtt      kxpi = kxpp*nmt      kypi = kypp*nmt      kxpl = kxp - kxpi      kypl = kyp - kypi      kxpi = kxpi + 1      kypi = kypi + 1      ierr = 0c inverse fourier transform      if (isign.lt.0) thenc start x fft tasks         do 10 i = 1, nmt         kxyip(i) = kypp*(i - 1) + 1         call MP_TASKSTART(iftask(i),PFFT2RNXX,margs,f,ss(1,1,i),isign,m     1ixup,sct,indx,indy,kstrt,kxyip(i),kypp,nxvh,kypd,kblok,ndim,nxhyd,     2nxyhd)c check for errors         if (iftask(i).eq.0) then           ierr = -1           return         endif   10    continuec finish x fft         call PFFT2RNXX(f,ss(1,1,nmtt),isign,mixup,sct,indx,indy,kstrt,k     1ypi,kypl,nxvh,kypd,kblok,ndim,nxhyd,nxyhd)c wait for tasks to complete         do 20 i = 1, nmt         call MP_TASKWAIT(iftask(i))c check for errors         if (iftask(i).ne.0) then            ierr = -2            return         endif   20    continuec transpose f array to g         call PNTPOSEX(f,g,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kypd,jblok,     1kblok,ndim)c start y fft tasks         do 30 i = 1, nmt         kxyip(i) = kxpp*(i - 1) + 1         call MP_TASKSTART(iftask(i),PFFT2RNXY,nargs,g,isign,mixup,sct,i     1ndx,indy,kstrt,kxyip(i),kxpp,nyv,kxp,jblok,ndim,nxhyd,nxyhd)c check for errors         if (iftask(i).eq.0) then           ierr = -1           return         endif   30    continuec finish y fft         call PFFT2RNXY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxpl,nyv,     1kxp,jblok,ndim,nxhyd,nxyhd)c wait for tasks to complete         do 40 i = 1, nmt         call MP_TASKWAIT(iftask(i))c check for errors         if (iftask(i).ne.0) ierr = -2   40    continuec transpose g array to f         if (ntpose.eq.0) call PNTPOSEX(g,f,ny,nxh,kstrt,nyv,nxvh,kyp,kx     1p,kypd,kxp,kblok,jblok,ndim)c forward fourier transform      else if (isign.gt.0) thenc transpose f array to g         if (ntpose.eq.0) call PNTPOSEX(f,g,nxh,ny,kstrt,nxvh,nyv,kxp,ky     1p,kxp,kypd,jblok,kblok,ndim)c start y fft tasks         do 50 i = 1, nmt         kxyip(i) = kxpp*(i - 1) + 1         call MP_TASKSTART(iftask(i),PFFT2RNXY,nargs,g,isign,mixup,sct,i     1ndx,indy,kstrt,kxyip(i),kxpp,nyv,kxp,jblok,ndim,nxhyd,nxyhd)c check for errors         if (iftask(i).eq.0) then           ierr = -1           return         endif   50    continuec finish y fft         call PFFT2RNXY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxpl,nyv,     1kxp,jblok,ndim,nxhyd,nxyhd)c wait for tasks to complete         do 60 i = 1, nmt         call MP_TASKWAIT(iftask(i))c check for errors         if (iftask(i).ne.0) ierr = -2   60    continuec transpose g array to f         call PNTPOSEX(g,f,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kxp,kblok,     1jblok,ndim)c start x fft tasks         do 70 i = 1, nmt         kxyip(i) = kypp*(i - 1) + 1         call MP_TASKSTART(iftask(i),PFFT2RNXX,margs,f,ss(1,1,i),isign,m     1ixup,sct,indx,indy,kstrt,kxyip(i),kypp,nxvh,kypd,kblok,ndim,nxhyd,     2nxyhd)c check for errors         if (iftask(i).eq.0) then           ierr = -1           return         endif   70    continuec finish x fft         call PFFT2RNXX(f,ss(1,1,nmtt),isign,mixup,sct,indx,indy,kstrt,k     1ypi,kypl,nxvh,kypd,kblok,ndim,nxhyd,nxyhd)c wait for tasks to complete         do 80 i = 1, nmt         call MP_TASKWAIT(iftask(i))c check for errors         if (iftask(i).ne.0) then            ierr = -2            return         endif   80    continue      endif      return      endc-----------------------------------------------------------------------      subroutine WPFFT2R(f,g,bs,br,isign,ntpose,mixup,sct,indx,indy,kstr     1t,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)c wrapper function for real to complex fft      implicit none      integer isign, ntpose, indx, indy, kstrt, nxvh, nyv, kxp, kyp      integer kypd, jblok, kblok, nxhyd, nxyhd, mixup      complex f, g, bs, br, sct      dimension f(nxvh,kypd,kblok), g(nyv,kxp,jblok)      dimension bs(kxp,kyp,kblok), br(kxp,kyp,jblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer nxh, ny, kxpi, kypi      data kxpi, kypi /1,1/c calculate range of indices      nxh = 2**(indx - 1)      ny = 2**indyc inverse fourier transform      if (isign.lt.0) thenc perform x fft         call PFFT2RXX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kyp,nxvh,k     1ypd,kblok,nxhyd,nxyhd)c transpose f array to g         call PTPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kypd,jb     1lok,kblok)c perform y fft         call PFFT2RXY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxp,nyv,kx     1p,jblok,nxhyd,nxyhd)c transpose g array to f         if (ntpose.eq.0) call PTPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,ky     1p,kxp,kypd,kxp,kblok,jblok)c forward fourier transform      else if (isign.gt.0) thenc transpose f array to g         if (ntpose.eq.0) call PTPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,kx     1p,kyp,kxp,kypd,jblok,kblok)c perform y fft         call PFFT2RXY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxp,nyv,kx     1p,jblok,nxhyd,nxyhd)c transpose g array to f         call PTPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kxp,kb     1lok,jblok)c perform x fft         call PFFT2RXX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kyp,nxvh,k     1ypd,kblok,nxhyd,nxyhd)      endif      return      endc-----------------------------------------------------------------------      subroutine WPFFT2RX(f,g,isign,ntpose,mixup,sct,indx,indy,kstrt,nxv     1h,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)c wrapper function for real to complex fft      implicit none      integer isign, ntpose, mixup, indx, indy, kstrt, nxvh      integer nyv, kxp, kyp, kypd, jblok, kblok, nxhyd, nxyhd      complex f, g, sct      dimension f(nxvh,kypd,kblok), g(nyv,kxp,jblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer nxh, ny, kxpi, kypi      data kxpi, kypi /1,1/c calculate range of indices      nxh = 2**(indx - 1)      ny = 2**indyc inverse fourier transform      if (isign.lt.0) thenc perform x fft         call PFFT2RXX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kyp,nxvh,k     1ypd,kblok,nxhyd,nxyhd)c transpose f array to g         call PTPOSEX(f,g,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kypd,jblok,k     1blok)c perform y fft         call PFFT2RXY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxp,nyv,kx     1p,jblok,nxhyd,nxyhd)c transpose g array to f         if (ntpose.eq.0) call PTPOSEX(g,f,ny,nxh,kstrt,nyv,nxvh,kyp,kxp     1,kypd,kxp,kblok,jblok)c forward fourier transform      else if (isign.gt.0) thenc transpose f array to g         if (ntpose.eq.0) call PTPOSEX(f,g,nxh,ny,kstrt,nxvh,nyv,kxp,kyp     1,kxp,kypd,jblok,kblok)c perform y fft         call PFFT2RXY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxp,nyv,kx     1p,jblok,nxhyd,nxyhd)c transpose g array to f         call PTPOSEX(g,f,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kxp,kblok,j     1blok)c perform x fft         call PFFT2RXX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kyp,nxvh,k     1ypd,kblok,nxhyd,nxyhd)      endif      return      endc-----------------------------------------------------------------------      subroutine WPFFT2R2(f,g,bs,br,isign,ntpose,mixup,sct,indx,indy,kst     1rt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)c wrapper function for real to complex fft      implicit none      integer isign, ntpose, indx, indy, kstrt, nxvh, nyv, kxp, kyp      integer kypd, jblok, kblok, nxhyd, nxyhd, mixup      complex f, g, bs, br, sct      dimension f(2,nxvh,kypd,kblok), g(2,nyv,kxp,jblok)      dimension bs(2,kxp,kyp,kblok), br(2,kxp,kyp,jblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer nxh, ny, kxpi, kypi      data kxpi, kypi /1,1/c calculate range of indices      nxh = 2**(indx - 1)      ny = 2**indyc inverse fourier transform      if (isign.lt.0) thenc perform x fft         call PFFT2R2XX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kyp,nxvh,     1kypd,kblok,nxhyd,nxyhd)c transpose f array to g         call P2TPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kypd,j     1blok,kblok)c perform y fft         call PFFT2R2XY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxp,nyv,k     1xp,jblok,nxhyd,nxyhd)c transpose g array to f         if (ntpose.eq.0) call P2TPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,k     1yp,kxp,kypd,kxp,kblok,jblok)c forward fourier transform      else if (isign.gt.0) thenc transpose f array to g         if (ntpose.eq.0) call P2TPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,k     1xp,kyp,kxp,kypd,jblok,kblok)c perform y fft         call PFFT2R2XY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxp,nyv,k     1xp,jblok,nxhyd,nxyhd)c transpose g array to f         call P2TPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kxp,k     1blok,jblok)c perform x fft         call PFFT2R2XX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kyp,nxvh,     1kypd,kblok,nxhyd,nxyhd)      endif      return      endc-----------------------------------------------------------------------      subroutine WPFFT2R3(f,g,bs,br,isign,ntpose,mixup,sct,indx,indy,kst     1rt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)c wrapper function for real to complex fft      implicit none      integer isign, ntpose, indx, indy, kstrt, nxvh, nyv, kxp, kyp      integer kypd, jblok, kblok, nxhyd, nxyhd, mixup      complex f, g, bs, br, sct      dimension f(3,nxvh,kypd,kblok), g(3,nyv,kxp,jblok)      dimension bs(3,kxp,kyp,kblok), br(3,kxp,kyp,jblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer nxh, ny, kxpi, kypi      data kxpi, kypi /1,1/c calculate range of indices      nxh = 2**(indx - 1)      ny = 2**indyc inverse fourier transform      if (isign.lt.0) thenc perform x fft         call PFFT2R3XX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kyp,nxvh,     1kypd,kblok,nxhyd,nxyhd)c transpose f array to g         call P3TPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kypd,j     1blok,kblok)c perform y fft         call PFFT2R3XY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxp,nyv,k     1xp,jblok,nxhyd,nxyhd)c transpose g array to f         if (ntpose.eq.0) call P3TPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,k     1yp,kxp,kypd,kxp,kblok,jblok)c forward fourier transform      else if (isign.gt.0) thenc transpose f array to g         if (ntpose.eq.0) call P3TPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,k     1xp,kyp,kxp,kypd,jblok,kblok)c perform y fft         call PFFT2R3XY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxp,nyv,k     1xp,jblok,nxhyd,nxyhd)c transpose g array to f         call P3TPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kxp,k     1blok,jblok)c perform x fft         call PFFT2R3XX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kyp,nxvh,     1kypd,kblok,nxhyd,nxyhd)      endif      return      endc-----------------------------------------------------------------------      subroutine WPFFT2RX2(f,g,isign,ntpose,mixup,sct,indx,indy,kstrt,nx     1vh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)c wrapper function for real to complex fft      implicit none      integer isign, ntpose, mixup, indx, indy, kstrt, nxvh      integer nyv, kxp, kyp, kypd, jblok, kblok, nxhyd, nxyhd      complex f, g, sct      dimension f(2,nxvh,kypd,kblok), g(2,nyv,kxp,jblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer nxh, ny, kxpi, kypi      data kxpi, kypi /1,1/c calculate range of indices      nxh = 2**(indx - 1)      ny = 2**indyc inverse fourier transform      if (isign.lt.0) thenc perform x fft         call PFFT2R2XX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kyp,nxvh,     1kypd,kblok,nxhyd,nxyhd)c transpose f array to g         call P2TPOSEX(f,g,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kypd,jblok,     1kblok)c perform y fft         call PFFT2R2XY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxp,nyv,k     1xp,jblok,nxhyd,nxyhd)c transpose g array to f         if (ntpose.eq.0) call P2TPOSEX(g,f,ny,nxh,kstrt,nyv,nxvh,kyp,kx     1p,kypd,kxp,kblok,jblok)c forward fourier transform      else if (isign.gt.0) thenc transpose f array to g         if (ntpose.eq.0) call P2TPOSEX(f,g,nxh,ny,kstrt,nxvh,nyv,kxp,ky     1p,kxp,kypd,jblok,kblok)c perform y fft         call PFFT2R2XY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxp,nyv,k     1xp,jblok,nxhyd,nxyhd)c transpose g array to f         call P2TPOSEX(g,f,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kxp,kblok,     1jblok)c perform x fft         call PFFT2R2XX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kyp,nxvh,     1kypd,kblok,nxhyd,nxyhd)      endif      return      endc-----------------------------------------------------------------------      subroutine WPFFT2RX3(f,g,isign,ntpose,mixup,sct,indx,indy,kstrt,nx     1vh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)c wrapper function for real to complex fft      implicit none      integer isign, ntpose, mixup, indx, indy, kstrt, nxvh      integer nyv, kxp, kyp, kypd, jblok, kblok, nxhyd, nxyhd      complex f, g, sct      dimension f(3,nxvh,kypd,kblok), g(3,nyv,kxp,jblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer nxh, ny, kxpi, kypi      data kxpi, kypi /1,1/c calculate range of indices      nxh = 2**(indx - 1)      ny = 2**indyc inverse fourier transform      if (isign.lt.0) thenc perform x fft         call PFFT2R3XX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kyp,nxvh,     1kypd,kblok,nxhyd,nxyhd)c transpose f array to g         call P3TPOSEX(f,g,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kypd,jblok,     1kblok)c perform y fft         call PFFT2R3XY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxp,nyv,k     1xp,jblok,nxhyd,nxyhd)c transpose g array to f         if (ntpose.eq.0) call P3TPOSEX(g,f,ny,nxh,kstrt,nyv,nxvh,kyp,kx     1p,kypd,kxp,kblok,jblok)c forward fourier transform      else if (isign.gt.0) thenc transpose f array to g         if (ntpose.eq.0) call P3TPOSEX(f,g,nxh,ny,kstrt,nxvh,nyv,kxp,ky     1p,kxp,kypd,jblok,kblok)c perform y fft         call PFFT2R3XY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxp,nyv,k     1xp,jblok,nxhyd,nxyhd)c transpose g array to f         call P3TPOSEX(g,f,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kxp,kblok,     1jblok)c perform x fft         call PFFT2R3XX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kyp,nxvh,     1kypd,kblok,nxhyd,nxyhd)      endif      return      endc-----------------------------------------------------------------------      subroutine PFFT2RXX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kypp,nx     1vh,kypd,kblok,nxhyd,nxyhd)c this subroutine performs the x part of a two dimensional real toc complex fast fourier transform and its inverse, for a subset of y,c using complex arithmetic, for data which is distributed in blocksc for isign = (-1,1), input: all, output: fc for isign = -1, approximate flop count: N*(5*log2(N) + 10)/nvpc for isign = 1,  approximate flop count: N*(5*log2(N) + 8)/nvpc where N = (nx/2)*ny, and nvp = number of procsc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, an inverse fourier transform is performedc f(n,m,i) = (1/nx*ny)*sum(f(j,k,i)*exp(-sqrt(-1)*2pi*n*j/nx)c if isign = 1, a forward fourier transform is performedc f(j,k,i) = sum(f(n,m,i)*exp(sqrt(-1)*2pi*n*j/nx)*c kstrt = starting data block numberc kypi = initial y index usedc kypp = number of y indices usedc nxvh = first dimension of fc kypd = second dimension of fc kblok = number of data blocks in yc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxhyd = maximum of (nx/2,ny)c nxyhd = one half of maximum of (nx,ny)c the real data is stored in a complex array of length nx/2, nyc with the odd/even x points stored in the real/imaginary parts.c in complex notation, fourier coefficients are stored as follows:c f(j,k,i) = mode j-1,kk-1, where kk = k + kyp*(i - 1)c 1 <= j <= nx/2 and 1 <= kk <= ny, except forc f(1,k,i) = mode nx/2,kk-1, where ny/2+2 <= kk <= ny, andc imaginary part of f(1,1,1) = real part of mode nx/2,0 andc imaginary part of f(1,1,(ny/2)/kyp+1) = real part of mode nx/2,ny/2c written by viktor k. decyk, uclac parallel, RISC optimized version      implicit none      integer isign, mixup, indx, indy, kstrt, nxvh, kypi, kypp      integer kypd, kblok, nxhyd, nxyhd      complex f, sct      dimension f(nxvh,kypd,kblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, nxh, nxhh, nxh2, ny      integer nxy, nxhy, ks, kypt, j, k, nrx      integer l, i, m, ns, ns2, km, kmr, k1, k2, j1, j2      real ani      complex s, t, t1      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nxh2 = nxh + 2      ny = 2**indy      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      kypt = kypi + kypp - 1      if (kstrt.gt.ny) return      if (isign.gt.0) go to 130c inverse fourier transform      ani = 1./float(2*nx*ny)      nrx = nxhy/nxh      do 30 l = 1, kblokc bit-reverse array elements in x      do 20 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 20      do 10 k = kypi, kypt      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = t   10 continue   20 continue   30 continuec first transform in x      nrx = nxy/nxh      do 80 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 70 l = 1, kblok      do 60 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 50 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 40 i = kypi, kypt      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t   40 continue   50 continue   60 continue   70 continue   80 continuec unscramble coefficients and normalize      kmr = nxy/nx      do 120 l = 1, kblok      do 100 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),-real(sct(1+kmr*(j-1))))      do 90 k = kypi, kypt      t = conjg(f(nxh2-j,k,l))      s = f(j,k,l) + t      t = (f(j,k,l) - t)*t1      f(j,k,l) = ani*(s + t)      f(nxh2-j,k,l) = ani*conjg(s - t)   90 continue  100 continue      do 110 k = kypi, kypt      f(nxhh+1,k,l) = 2.*ani*conjg(f(nxhh+1,k,l))      f(1,k,l) = 2.*ani*cmplx(real(f(1,k,l)) + aimag(f(1,k,l)),real(f(1,     1k,l)) - aimag(f(1,k,l)))  110 continue  120 continue      returnc forward fourier transform  130 kmr = nxy/nx      do 190 l = 1, kblokc scramble coefficients      do 150 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),real(sct(1+kmr*(j-1))))      do 140 k = kypi, kypt      t = conjg(f(nxh2-j,k,l))      s = f(j,k,l) + t      t = (f(j,k,l) - t)*t1      f(j,k,l) = s + t      f(nxh2-j,k,l) = conjg(s - t)  140 continue  150 continue      do 160 k = kypi, kypt      f(nxhh+1,k,l) = 2.*conjg(f(nxhh+1,k,l))      f(1,k,l) = cmplx(real(f(1,k,l)) + aimag(f(1,k,l)),real(f(1,k,l)) -     1 aimag(f(1,k,l)))  160 continue      nrx = nxhy/nxhc bit-reverse array elements in x      do 180 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 180      do 170 k = kypi, kypt      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = t  170 continue  180 continue  190 continuec then transform in x      nrx = nxy/nxh      do 240 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 230 l = 1, kblok      do 220 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 210 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 200 i = kypi, kypt      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t  200 continue  210 continue  220 continue  230 continue  240 continue      return      endc-----------------------------------------------------------------------      subroutine PFFT2RXY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxpp,ny     1v,kxp,jblok,nxhyd,nxyhd)c this subroutine performs the y part of a two dimensional real toc complex fast fourier transform and its inverse, for a subset of x,c using complex arithmetic, for data which is distributed in blocksc for isign = (-1,1), input: all, output: f, gc for isign = -1, approximate flop count: N*(5*log2(N) + 10)/nvpc for isign = 1,  approximate flop count: N*(5*log2(N) + 8)/nvpc where N = (nx/2)*ny, and nvp = number of procsc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, an inverse fourier transform is performedc g(m,n,i) = sum(g(k,j,i)*exp(-sqrt(-1)*2pi*m*k/ny))c if isign = 1, a forward fourier transform is performedc g(k,j,i) = sum(g(m,n,i)*exp(sqrt(-1)*2pi*m*k/ny))c kstrt = starting data block numberc kxpi = initial x index usedc kxpp = number of   indices usedc nyv = first dimension of gc kxp = number of data values per block in xc jblok = number of data blocks in xc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxhyd = maximum of (nx/2,ny)c nxyhd = one half of maximum of (nx,ny)c the real data is stored in a complex array of length nx/2, nyc with the odd/even x points stored in the real/imaginary parts.c in complex notation, fourier coefficients are stored as follows:c g(k,j,i) = mode jj-1,k-1, where jj = j + kxp*(i - 1)c 1 <= jj <= nx/2 and 1 <= k <= ny, except forc g(k,1,1) = mode nx/2,k-1, where ny/2+2 <= k <= ny, andc imaginary part of g(1,1,1) = real part of mode nx/2,0 andc imaginary part of g(ny/2+1,1,1) = real part of mode nx/2,ny/2c written by viktor k. decyk, uclac parallel, RISC optimized version      implicit none      integer isign, mixup, indx, indy, kstrt, kxpi, kxpp, nyv      integer kxp, jblok, nxhyd, nxyhd      complex g, sct      dimension g(nyv,kxp,jblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, nxh, ny, nyh, ny2      integer nxy, nxhy, ks, kxpt, j, k, nry      integer l, i, m, ns, ns2, km, kmr, k1, k2, j1, j2      complex s, t      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      ny = 2**indy      nyh = ny/2      ny2 = ny + 2      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      kxpt = kxpi + kxpp - 1      if (kstrt.gt.nxh) return      if (isign.gt.0) go to 110c inverse fourier transform      nry = nxhy/ny      do 30 l = 1, jblokc bit-reverse array elements in y      do 20 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 20      do 10 j = kxpi, kxpt      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = t   10 continue   20 continue   30 continuec then transform in y      nry = nxy/ny      do 80 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 70 l = 1, jblok      do 60 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 50 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 40 i = kxpi, kxpt      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t   40 continue   50 continue   60 continue   70 continue   80 continuec unscramble modes kx = 0, nx/2      do 100 l = 1, jblok      if ((l+ks).gt.0) go to 100      do 90 k = 2, nyh      if (kxpi.eq.1) then         s = g(ny2-k,1,l)         g(ny2-k,1,l) = .5*cmplx(aimag(g(k,1,l) + s),real(g(k,1,l) - s))         g(k,1,l) = .5*cmplx(real(g(k,1,l) + s),aimag(g(k,1,l) - s))      endif   90 continue  100 continue      returnc forward fourier transformc scramble modes kx = 0, nx/2  110 nry = nxhy/ny      do 160 l = 1, jblok      if ((l+ks).gt.0) go to 130      do 120 k = 2, nyh      if (kxpi.eq.1) then         s = cmplx(aimag(g(ny2-k,1,l)),real(g(ny2-k,1,l)))         g(ny2-k,1,l) = conjg(g(k,1,l) - s)         g(k,1,l) = g(k,1,l) + s      endif  120 continuec bit-reverse array elements in y  130 do 150 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 150      do 140 j = kxpi, kxpt      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = t  140 continue  150 continue  160 continuec first transform in y      nry = nxy/ny      do 210 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 200 l = 1, jblok      do 190 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 180 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 170 i = kxpi, kxpt      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t  170 continue  180 continue  190 continue  200 continue  210 continue      return      endc-----------------------------------------------------------------------      subroutine PFFT2R2XX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kypp,n     1xvh,kypd,kblok,nxhyd,nxyhd)c this subroutine performs the x part of 2 two dimensional real toc complex fast fourier transforms and their inverses, for a subset of y,c using complex arithmetic, for data which is distributed in blocksc for isign = (-1,1), input: all, output: fc for isign = -1, approximate flop count: N*(5*log2(N) + 10)/nvpc for isign = 1,  approximate flop count: N*(5*log2(N) + 8)/nvpc where N = (nx/2)*ny, and nvp = number of procsc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, an inverse fourier transform is performedc f(n,m,i) = (1/nx*ny)*sum(f(j,k,i)*exp(-sqrt(-1)*2pi*n*j/nx)c if isign = 1, a forward fourier transform is performedc f(j,k,i) = sum(f(n,m,i)*exp(sqrt(-1)*2pi*n*j/nx)*c kstrt = starting data block numberc kypi = initial y index usedc kypp = number of y indices usedc nxvh = first dimension of fc kypd = second dimension of fc kblok = number of data blocks in yc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxhyd = maximum of (nx/2,ny)c nxyhd = one half of maximum of (nx,ny)c the real data is stored in a complex array of length nx/2, nyc with the odd/even x points stored in the real/imaginary parts.c in complex notation, fourier coefficients are stored as follows:c f(j,k,i) = mode j-1,kk-1, where kk = k + kyp*(i - 1)c 1 <= j <= nx/2 and 1 <= kk <= ny, except forc f(1,k,i) = mode nx/2,kk-1, where ny/2+2 <= kk <= ny, andc imaginary part of f(1,1,1) = real part of mode nx/2,0 andc imaginary part of f(1,1,(ny/2)/kyp+1) = real part of mode nx/2,ny/2c written by viktor k. decyk, uclac parallel, RISC optimized version      implicit none      integer isign, mixup, indx, indy, kstrt, nxvh, kypi, kypp      integer kypd, kblok, nxhyd, nxyhd      complex f, sct      dimension f(2,nxvh,kypd,kblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, nxh, nxhh, nxh2, ny      integer nxy, nxhy, ks, kypt, j, k, nrx      integer l, i, m, ns, ns2, km, kmr, k1, k2, j1, j2, jj      real ani, at1      complex s, t, t1, t2      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nxh2 = nxh + 2      ny = 2**indy      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      kypt = kypi + kypp - 1      if (kstrt.gt.ny) return      if (isign.gt.0) go to 180c inverse fourier transform      ani = 1./float(2*nx*ny)c swap complex components      do 30 l = 1, kblok      do 20 k = kypi, kypt      do 10 j = 1, nxh      at1 = aimag(f(1,j,k,l))      f(1,j,k,l) = cmplx(real(f(1,j,k,l)),real(f(2,j,k,l)))      f(2,j,k,l) = cmplx(at1,aimag(f(2,j,k,l)))   10 continue   20 continue   30 continue      nrx = nxhy/nxh      do 60 l = 1, kblokc bit-reverse array elements in x      do 50 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 50      do 40 k = kypi, kypt      t1 = f(1,j1,k,l)      t2 = f(2,j1,k,l)      f(1,j1,k,l) = f(1,j,k,l)      f(2,j1,k,l) = f(2,j,k,l)      f(1,j,k,l) = t1      f(2,j,k,l) = t2   40 continue   50 continue   60 continuec first transform in x      nrx = nxy/nxh      do 110 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 100 l = 1, kblok      do 90 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 80 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 70 i = kypi, kypt      t1 = s*f(1,j2,i,l)      t2 = s*f(2,j2,i,l)      f(1,j2,i,l) = f(1,j1,i,l) - t1      f(2,j2,i,l) = f(2,j1,i,l) - t2      f(1,j1,i,l) = f(1,j1,i,l) + t1      f(2,j1,i,l) = f(2,j1,i,l) + t2   70 continue   80 continue   90 continue  100 continue  110 continuec unscramble coefficients and normalize      kmr = nxy/nx      do 170 l = 1, kblok      do 140 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),-real(sct(1+kmr*(j-1))))      do 130 k = kypi, kypt      do 120 jj = 1, 2      t = conjg(f(jj,nxh2-j,k,l))      s = f(jj,j,k,l) + t      t = (f(jj,j,k,l) - t)*t1      f(jj,j,k,l) = ani*(s + t)      f(jj,nxh2-j,k,l) = ani*conjg(s - t)  120 continue  130 continue  140 continue      do 160 k = kypi, kypt      do 150 jj = 1, 2      f(jj,nxhh+1,k,l) = 2.*ani*conjg(f(jj,nxhh+1,k,l))      f(jj,1,k,l) = 2.*ani*cmplx(real(f(jj,1,k,l)) + aimag(f(jj,1,k,l)),     1real(f(jj,1,k,l)) - aimag(f(jj,1,k,l)))  150 continue  160 continue  170 continue      returnc forward fourier transform  180 kmr = nxy/nx      do 260 l = 1, kblokc scramble coefficients      do 210 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),real(sct(1+kmr*(j-1))))      do 200 k = kypi, kypt      do 190 jj = 1, 2      t = conjg(f(jj,nxh2-j,k,l))      s = f(jj,j,k,l) + t      t = (f(jj,j,k,l) - t)*t1      f(jj,j,k,l) = s + t      f(jj,nxh2-j,k,l) = conjg(s - t)  190 continue  200 continue  210 continue      do 230 k = kypi, kypt      do 220 jj = 1, 2      f(jj,nxhh+1,k,l) = 2.*conjg(f(jj,nxhh+1,k,l))      f(jj,1,k,l) = cmplx(real(f(jj,1,k,l)) + aimag(f(jj,1,k,l)),real(f(     1jj,1,k,l)) - aimag(f(jj,1,k,l)))  220 continue  230 continue      nrx = nxhy/nxhc bit-reverse array elements in x      do 250 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 250      do 240 k = kypi, kypt      t1 = f(1,j1,k,l)      t2 = f(2,j1,k,l)      f(1,j1,k,l) = f(1,j,k,l)      f(2,j1,k,l) = f(2,j,k,l)      f(1,j,k,l) = t1      f(2,j,k,l) = t2  240 continue  250 continue  260 continuec then transform in x      nrx = nxy/nxh      do 310 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 300 l = 1, kblok      do 290 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 280 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 270 i = kypi, kypt      t1 = s*f(1,j2,i,l)      t2 = s*f(2,j2,i,l)      f(1,j2,i,l) = f(1,j1,i,l) - t1      f(2,j2,i,l) = f(2,j1,i,l) - t2      f(1,j1,i,l) = f(1,j1,i,l) + t1      f(2,j1,i,l) = f(2,j1,i,l) + t2  270 continue  280 continue  290 continue  300 continue  310 continuec swap complex components      do 340 l = 1, kblok      do 330 k = kypi, kypt      do 320 j = 1, nxh      at1 = aimag(f(1,j,k,l))      f(1,j,k,l) = cmplx(real(f(1,j,k,l)),real(f(2,j,k,l)))      f(2,j,k,l) = cmplx(at1,aimag(f(2,j,k,l)))  320 continue  330 continue  340 continue      return      endc-----------------------------------------------------------------------      subroutine PFFT2R2XY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxpp,n     1yv,kxp,jblok,nxhyd,nxyhd)c this subroutine performs the y part of 2 two dimensional real toc complex fast fourier transforms and their inverses, for a subset of x,c using complex arithmetic, for data which is distributed in blocksc for isign = (-1,1), input: all, output: f, gc for isign = -1, approximate flop count: N*(5*log2(N) + 10)/nvpc for isign = 1,  approximate flop count: N*(5*log2(N) + 8)/nvpc where N = (nx/2)*ny, and nvp = number of procsc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, an inverse fourier transform is performedc g(m,n,i) = sum(g(k,j,i)*exp(-sqrt(-1)*2pi*m*k/ny))c if isign = 1, a forward fourier transform is performedc g(k,j,i) = sum(g(m,n,i)*exp(sqrt(-1)*2pi*m*k/ny))c kstrt = starting data block numberc kxpi = initial x index usedc kxpp = number of   indices usedc nyv = first dimension of gc kxp = number of data values per block in xc jblok = number of data blocks in xc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxhyd = maximum of (nx/2,ny)c nxyhd = one half of maximum of (nx,ny)c the real data is stored in a complex array of length nx/2, nyc with the odd/even x points stored in the real/imaginary parts.c in complex notation, fourier coefficients are stored as follows:c g(k,j,i) = mode jj-1,k-1, where jj = j + kxp*(i - 1)c 1 <= jj <= nx/2 and 1 <= k <= ny, except forc g(k,1,1) = mode nx/2,k-1, where ny/2+2 <= k <= ny, andc imaginary part of g(1,1,1) = real part of mode nx/2,0 andc imaginary part of g(ny/2+1,1,1) = real part of mode nx/2,ny/2c written by viktor k. decyk, uclac parallel, RISC optimized version      implicit none      integer isign, mixup, indx, indy, kstrt, kxpi, kxpp, nyv      integer kxp, jblok, nxhyd, nxyhd      complex g, sct      dimension g(2,nyv,kxp,jblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, nxh, ny, nyh, ny2      integer nxy, nxhy, ks, kxpt, j, k, nry      integer l, i, m, ns, ns2, km, kmr, k1, k2, j1, j2, jj      complex s, t1, t2      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      ny = 2**indy      nyh = ny/2      ny2 = ny + 2      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      kxpt = kxpi + kxpp - 1      if (kstrt.gt.nxh) return      if (isign.gt.0) go to 120c inverse fourier transform      nry = nxhy/ny      do 30 l = 1, jblokc bit-reverse array elements in y      do 20 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 20      do 10 j = kxpi, kxpt      t1 = g(1,k1,j,l)      t2 = g(2,k1,j,l)      g(1,k1,j,l) = g(1,k,j,l)      g(2,k1,j,l) = g(2,k,j,l)      g(1,k,j,l) = t1      g(2,k,j,l) = t2   10 continue   20 continue   30 continuec then transform in y      nry = nxy/ny      do 80 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 70 l = 1, jblok      do 60 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 50 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 40 i = kxpi, kxpt      t1 = s*g(1,j2,i,l)      t2 = s*g(2,j2,i,l)      g(1,j2,i,l) = g(1,j1,i,l) - t1      g(2,j2,i,l) = g(2,j1,i,l) - t2      g(1,j1,i,l) = g(1,j1,i,l) + t1      g(2,j1,i,l) = g(2,j1,i,l) + t2   40 continue   50 continue   60 continue   70 continue   80 continuec unscramble modes kx = 0, nx/2      do 110 l = 1, jblok      if ((l+ks).gt.0) go to 110      do 100 k = 2, nyh      if (kxpi.eq.1) then         do 90 jj = 1, 2         s = g(jj,ny2-k,1,l)         g(jj,ny2-k,1,l) = .5*cmplx(aimag(g(jj,k,1,l) + s),real(g(jj,k,1     1,l)- s))         g(jj,k,1,l) = .5*cmplx(real(g(jj,k,1,l) + s),aimag(g(jj,k,1,l)      1- s))   90    continue      endif  100 continue  110 continue      returnc forward fourier transformc scramble modes kx = 0, nx/2  120 nry = nxhy/ny      do 180 l = 1, jblok      if ((l+ks).gt.0) go to 150      do 140 k = 2, nyh      if (kxpi.eq.1) then         do 130 jj = 1, 2         s = cmplx(aimag(g(jj,ny2-k,1,l)),real(g(jj,ny2-k,1,l)))         g(jj,ny2-k,1,l) = conjg(g(jj,k,1,l) - s)         g(jj,k,1,l) = g(jj,k,1,l) + s  130    continue      endif  140 continuec bit-reverse array elements in y  150 do 170 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 170      do 160 j = kxpi, kxpt      t1 = g(1,k1,j,l)      t2 = g(2,k1,j,l)      g(1,k1,j,l) = g(1,k,j,l)      g(2,k1,j,l) = g(2,k,j,l)      g(1,k,j,l) = t1      g(2,k,j,l) = t2  160 continue  170 continue  180 continuec first transform in y      nry = nxy/ny      do 230 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 220 l = 1, jblok      do 210 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 200 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 190 i = kxpi, kxpt      t1 = s*g(1,j2,i,l)      t2 = s*g(2,j2,i,l)      g(1,j2,i,l) = g(1,j1,i,l) - t1      g(2,j2,i,l) = g(2,j1,i,l) - t2      g(1,j1,i,l) = g(1,j1,i,l) + t1      g(2,j1,i,l) = g(2,j1,i,l) + t2  190 continue  200 continue  210 continue  220 continue  230 continue      return      endc-----------------------------------------------------------------------      subroutine PFFT2R3XX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kypp,n     1xvh,kypd,kblok,nxhyd,nxyhd)c this subroutine performs the x part of 3 two dimensional real toc complex fast fourier transforms and their inverses, for a subset of y,c using complex arithmetic, for data which is distributed in blocksc for isign = (-1,1), input: all, output: fc for isign = -1, approximate flop count: N*(5*log2(N) + 10)/nvpc for isign = 1,  approximate flop count: N*(5*log2(N) + 8)/nvpc where N = (nx/2)*ny, and nvp = number of procsc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, an inverse fourier transform is performedc f(n,m,i) = (1/nx*ny)*sum(f(j,k,i)*exp(-sqrt(-1)*2pi*n*j/nx)c if isign = 1, a forward fourier transform is performedc f(j,k,i) = sum(f(n,m,i)*exp(sqrt(-1)*2pi*n*j/nx)*c kstrt = starting data block numberc kypi = initial y index usedc kypp = number of y indices usedc nxvh = first dimension of fc kypd = second dimension of fc kblok = number of data blocks in yc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxhyd = maximum of (nx/2,ny)c nxyhd = one half of maximum of (nx,ny)c the real data is stored in a complex array of length nx/2, nyc with the odd/even x points stored in the real/imaginary parts.c in complex notation, fourier coefficients are stored as follows:c f(j,k,i) = mode j-1,kk-1, where kk = k + kyp*(i - 1)c 1 <= j <= nx/2 and 1 <= kk <= ny, except forc f(1,k,i) = mode nx/2,kk-1, where ny/2+2 <= kk <= ny, andc imaginary part of f(1,1,1) = real part of mode nx/2,0 andc imaginary part of f(1,1,(ny/2)/kyp+1) = real part of mode nx/2,ny/2c written by viktor k. decyk, uclac parallel, RISC optimized version      implicit none      integer isign, mixup, indx, indy, kstrt, nxvh, kypi, kypp      integer kypd, kblok, nxhyd, nxyhd      complex f, sct      dimension f(3,nxvh,kypd,kblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, nxh, nxhh, nxh2, ny      integer nxy, nxhy, ks, kypt, j, k, nrx      integer l, i, m, ns, ns2, km, kmr, k1, k2, j1, j2, jj      real ani, at1, at2      complex s, t, t1, t2, t3      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nxh2 = nxh + 2      ny = 2**indy      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      kypt = kypi + kypp - 1      if (kstrt.gt.ny) return      if (isign.gt.0) go to 180c inverse fourier transform      ani = 1./float(2*nx*ny)c swap complex components      do 30 l = 1, kblok      do 20 i = kypi, kypt      do 10 j = 1, nxh      at1 = real(f(3,j,i,l))      f(3,j,i,l) = cmplx(real(f(2,j,i,l)),aimag(f(3,j,i,l)))      at2 = aimag(f(2,j,i,l))      f(2,j,i,l) = cmplx(aimag(f(1,j,i,l)),at1)      f(1,j,i,l) = cmplx(real(f(1,j,i,l)),at2)   10 continue   20 continue   30 continue      nrx = nxhy/nxh      do 60 l = 1, kblokc bit-reverse array elements in x      do 50 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 50      do 40 k = kypi, kypt      t1 = f(1,j1,k,l)      t2 = f(2,j1,k,l)      t3 = f(3,j1,k,l)      f(1,j1,k,l) = f(1,j,k,l)      f(2,j1,k,l) = f(2,j,k,l)      f(3,j1,k,l) = f(3,j,k,l)      f(1,j,k,l) = t1      f(2,j,k,l) = t2      f(3,j,k,l) = t3   40 continue   50 continue   60 continuec first transform in x      nrx = nxy/nxh      do 110 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 100 l = 1, kblok      do 90 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 80 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 70 i = kypi, kypt      t1 = s*f(1,j2,i,l)      t2 = s*f(2,j2,i,l)      t3 = s*f(3,j2,i,l)      f(1,j2,i,l) = f(1,j1,i,l) - t1      f(2,j2,i,l) = f(2,j1,i,l) - t2      f(3,j2,i,l) = f(3,j1,i,l) - t3      f(1,j1,i,l) = f(1,j1,i,l) + t1      f(2,j1,i,l) = f(2,j1,i,l) + t2      f(3,j1,i,l) = f(3,j1,i,l) + t3   70 continue   80 continue   90 continue  100 continue  110 continuec unscramble coefficients and normalize      kmr = nxy/nx      do 170 l = 1, kblok      do 140 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),-real(sct(1+kmr*(j-1))))      do 130 k = kypi, kypt      do 120 jj = 1, 3      t = conjg(f(jj,nxh2-j,k,l))      s = f(jj,j,k,l) + t      t = (f(jj,j,k,l) - t)*t1      f(jj,j,k,l) = ani*(s + t)      f(jj,nxh2-j,k,l) = ani*conjg(s - t)  120 continue  130 continue  140 continue      do 160 k = kypi, kypt      do 150 jj = 1, 3      f(jj,nxhh+1,k,l) = 2.*ani*conjg(f(jj,nxhh+1,k,l))      f(jj,1,k,l) = 2.*ani*cmplx(real(f(jj,1,k,l)) + aimag(f(jj,1,k,l)),     1real(f(jj,1,k,l)) - aimag(f(jj,1,k,l)))  150 continue  160 continue  170 continue      returnc forward fourier transform  180 kmr = nxy/nx      do 260 l = 1, kblokc scramble coefficients      do 210 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),real(sct(1+kmr*(j-1))))      do 200 k = kypi, kypt      do 190 jj = 1, 3      t = conjg(f(jj,nxh2-j,k,l))      s = f(jj,j,k,l) + t      t = (f(jj,j,k,l) - t)*t1      f(jj,j,k,l) = s + t      f(jj,nxh2-j,k,l) = conjg(s - t)  190 continue  200 continue  210 continue      do 230 k = kypi, kypt      do 220 jj = 1, 3      f(jj,nxhh+1,k,l) = 2.*conjg(f(jj,nxhh+1,k,l))      f(jj,1,k,l) = cmplx(real(f(jj,1,k,l)) + aimag(f(jj,1,k,l)),real(f(     1jj,1,k,l)) - aimag(f(jj,1,k,l)))  220 continue  230 continue      nrx = nxhy/nxhc bit-reverse array elements in x      do 250 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 250      do 240 k = kypi, kypt      t1 = f(1,j1,k,l)      t2 = f(2,j1,k,l)      t3 = f(3,j1,k,l)      f(1,j1,k,l) = f(1,j,k,l)      f(2,j1,k,l) = f(2,j,k,l)      f(3,j1,k,l) = f(3,j,k,l)      f(1,j,k,l) = t1      f(2,j,k,l) = t2      f(3,j,k,l) = t3  240 continue  250 continue  260 continuec then transform in x      nrx = nxy/nxh      do 310 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 300 l = 1, kblok      do 290 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 280 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 270 i = kypi, kypt      t1 = s*f(1,j2,i,l)      t2 = s*f(2,j2,i,l)      t3 = s*f(3,j2,i,l)      f(1,j2,i,l) = f(1,j1,i,l) - t1      f(2,j2,i,l) = f(2,j1,i,l) - t2      f(3,j2,i,l) = f(3,j1,i,l) - t3      f(1,j1,i,l) = f(1,j1,i,l) + t1      f(2,j1,i,l) = f(2,j1,i,l) + t2      f(3,j1,i,l) = f(3,j1,i,l) + t3  270 continue  280 continue  290 continue  300 continue  310 continuec swap complex components      do 340 l = 1, kblok      do 330 i = kypi, kypt      do 320 j = 1, nxh      at1 = real(f(3,j,i,l))      f(3,j,i,l) = cmplx(aimag(f(2,j,i,l)),aimag(f(3,j,i,l)))      at2 = real(f(2,j,i,l))      f(2,j,i,l) = cmplx(at1,aimag(f(1,j,i,l)))      f(1,j,i,l) = cmplx(real(f(1,j,i,l)),at2)  320 continue  330 continue  340 continue      return      endc-----------------------------------------------------------------------      subroutine PFFT2R3XY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxpp,n     1yv,kxp,jblok,nxhyd,nxyhd)c this subroutine performs the y part of 3 two dimensional real toc complex fast fourier transforms and their inverses, for a subset of x,c using complex arithmetic, for data which is distributed in blocksc for isign = (-1,1), input: all, output: f, gc for isign = -1, approximate flop count: N*(5*log2(N) + 10)/nvpc for isign = 1,  approximate flop count: N*(5*log2(N) + 8)/nvpc where N = (nx/2)*ny, and nvp = number of procsc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, an inverse fourier transform is performedc g(m,n,i) = sum(g(k,j,i)*exp(-sqrt(-1)*2pi*m*k/ny))c if isign = 1, a forward fourier transform is performedc g(k,j,i) = sum(g(m,n,i)*exp(sqrt(-1)*2pi*m*k/ny))c kstrt = starting data block numberc kxpi = initial x index usedc kxpp = number of   indices usedc nyv = first dimension of gc kxp = number of data values per block in xc jblok = number of data blocks in xc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxhyd = maximum of (nx/2,ny)c nxyhd = one half of maximum of (nx,ny)c the real data is stored in a complex array of length nx/2, nyc with the odd/even x points stored in the real/imaginary parts.c in complex notation, fourier coefficients are stored as follows:c g(k,j,i) = mode jj-1,k-1, where jj = j + kxp*(i - 1)c 1 <= jj <= nx/2 and 1 <= k <= ny, except forc g(k,1,1) = mode nx/2,k-1, where ny/2+2 <= k <= ny, andc imaginary part of g(1,1,1) = real part of mode nx/2,0 andc imaginary part of g(ny/2+1,1,1) = real part of mode nx/2,ny/2c written by viktor k. decyk, uclac parallel, RISC optimized version      implicit none      integer isign, mixup, indx, indy, kstrt, kxpi, kxpp, nyv      integer kxp, jblok, nxhyd, nxyhd      complex g, sct      dimension g(3,nyv,kxp,jblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, nxh, ny, nyh, ny2      integer nxy, nxhy, ks, kxpt, j, k, nry      integer l, i, m, ns, ns2, km, kmr, k1, k2, j1, j2, jj      complex s, t1, t2, t3      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      ny = 2**indy      nyh = ny/2      ny2 = ny + 2      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      kxpt = kxpi + kxpp - 1      if (kstrt.gt.nxh) return      if (isign.gt.0) go to 120c inverse fourier transform      nry = nxhy/ny      do 30 l = 1, jblokc bit-reverse array elements in y      do 20 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 20      do 10 j = kxpi, kxpt      t1 = g(1,k1,j,l)      t2 = g(2,k1,j,l)      t3 = g(3,k1,j,l)      g(1,k1,j,l) = g(1,k,j,l)      g(2,k1,j,l) = g(2,k,j,l)      g(3,k1,j,l) = g(3,k,j,l)      g(1,k,j,l) = t1      g(2,k,j,l) = t2      g(3,k,j,l) = t3   10 continue   20 continue   30 continuec then transform in y      nry = nxy/ny      do 80 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 70 l = 1, jblok      do 60 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 50 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 40 i = kxpi, kxpt      t1 = s*g(1,j2,i,l)      t2 = s*g(2,j2,i,l)      t3 = s*g(3,j2,i,l)      g(1,j2,i,l) = g(1,j1,i,l) - t1      g(2,j2,i,l) = g(2,j1,i,l) - t2      g(3,j2,i,l) = g(3,j1,i,l) - t3      g(1,j1,i,l) = g(1,j1,i,l) + t1      g(2,j1,i,l) = g(2,j1,i,l) + t2      g(3,j1,i,l) = g(3,j1,i,l) + t3   40 continue   50 continue   60 continue   70 continue   80 continuec unscramble modes kx = 0, nx/2      do 110 l = 1, jblok      if ((l+ks).gt.0) go to 110      do 100 k = 2, nyh      if (kxpi.eq.1) then         do 90 jj = 1, 3         s = g(jj,ny2-k,1,l)         g(jj,ny2-k,1,l) = .5*cmplx(aimag(g(jj,k,1,l) + s),real(g(jj,k,1     1,l)- s))         g(jj,k,1,l) = .5*cmplx(real(g(jj,k,1,l) + s),aimag(g(jj,k,1,l)      1- s))   90    continue      endif  100 continue  110 continue      returnc forward fourier transformc scramble modes kx = 0, nx/2  120 nry = nxhy/ny      do 180 l = 1, jblok      if ((l+ks).gt.0) go to 150      do 140 k = 2, nyh      if (kxpi.eq.1) then         do 130 jj = 1, 3         s = cmplx(aimag(g(jj,ny2-k,1,l)),real(g(jj,ny2-k,1,l)))         g(jj,ny2-k,1,l) = conjg(g(jj,k,1,l) - s)         g(jj,k,1,l) = g(jj,k,1,l) + s  130    continue      endif  140 continuec bit-reverse array elements in y  150 do 170 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 170      do 160 j = kxpi, kxpt      t1 = g(1,k1,j,l)      t2 = g(2,k1,j,l)      t3 = g(3,k1,j,l)      g(1,k1,j,l) = g(1,k,j,l)      g(2,k1,j,l) = g(2,k,j,l)      g(3,k1,j,l) = g(3,k,j,l)      g(1,k,j,l) = t1      g(2,k,j,l) = t2      g(3,k,j,l) = t3  160 continue  170 continue  180 continuec first transform in y      nry = nxy/ny      do 230 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 220 l = 1, jblok      do 210 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 200 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 190 i = kxpi, kxpt      t1 = s*g(1,j2,i,l)      t2 = s*g(2,j2,i,l)      t3 = s*g(3,j2,i,l)      g(1,j2,i,l) = g(1,j1,i,l) - t1      g(2,j2,i,l) = g(2,j1,i,l) - t2      g(3,j2,i,l) = g(3,j1,i,l) - t3      g(1,j1,i,l) = g(1,j1,i,l) + t1      g(2,j1,i,l) = g(2,j1,i,l) + t2      g(3,j1,i,l) = g(3,j1,i,l) + t3  190 continue  200 continue  210 continue  220 continue  230 continue      return      end