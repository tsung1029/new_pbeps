!-----------------------------------------------------------------------!      module pfield2d!! Fortran90 interface to 2d parallel PIC Fortran77 library pfield2lib.f! written by viktor k. decyk, ucla! copyright 2000, regents of the university of california! update: may 23, 2005!      use globals, only: LINEAR, QUADRATIC      implicit none      private      public :: LINEAR, QUADRATIC      public :: PSCGUARD2, PSGUARD2, PSCGUARD2L, PSGUARD2L      public :: PACGUARD2X, PAGUARD2X, PACGUARD2XL, PAGUARD2XL      public :: cguard, bguard, sguard, aguard, zguard      public :: pois_init, pois, pois3, cuperp, bpois      public :: ibpois, maxwel, emfield, avpot, gtmodes, ptmodes      public :: fft_init, fft, fftn, fftc_init      public :: ipdivf2, ipgradf2, ipcurlf2!! define interface to original Fortran77 procedures!      interface         subroutine PCGUARD2X(fxy,nyp,nx,nxe,nypmx,nblok)         implicit none         integer nx, nxe, nypmx, nblok         real, dimension(2,nxe,nypmx,nblok) :: fxy         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PDGUARD2X(q,nyp,nx,nxe,nypmx,nblok)         implicit none         integer :: nx, nxe, nypmx, nblok         real, dimension(nxe,nypmx,nblok) :: q         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PBGUARD2X(bxy,nyp,nx,nxe,nypmx,nblok)         implicit none         integer nx, nxe, nypmx, nblok         real, dimension(3,nxe,nypmx,nblok) :: bxy         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PSCGUARD2(cu,nyp,xj0,yj0,zj0,nx,nxe,nypmx,nblok)         implicit none         real :: xj0, yj0, zj0         integer nx, nxe, nypmx, nblok         real, dimension(3,nxe,nypmx,nblok) :: cu         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PSCGUARD22(cu,nyp,xj0,yj0,nx,nxe,nypmx,nblok)         implicit none         real :: xj0, yj0         integer nx, nxe, nypmx, nblok         real, dimension(2,nxe,nypmx,nblok) :: cu         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PSGUARD2(q,nyp,qi0,nx,nxe,nypmx,nblok)         implicit none         real :: qi0         integer nx, nxe, nypmx, nblok         real, dimension(nxe,nypmx,nblok) :: q         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PACGUARD2X(cu,nyp,nx,nxe,nypmx,nblok)         implicit none         integer nx, nxe, nypmx, nblok         real, dimension(3,nxe,nypmx,nblok) :: cu         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PACGUARD22X(cu,nyp,nx,nxe,nypmx,nblok)         implicit none         integer nx, nxe, nypmx, nblok         real, dimension(2,nxe,nypmx,nblok) :: cu         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PAGUARD2X(q,nyp,nx,nxe,nypmx,nblok)         implicit none         integer nx, nxe, nypmx, nblok         real, dimension(nxe,nypmx,nblok) :: q         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PZGUARD2(q,nyp,nx,nxe,nypmx,nblok)         implicit none         integer nx, nxe, nypmx, nblok         real, dimension(nxe,nypmx,nblok) :: q         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PCGUARD2XL(fxy,nyp,nx,nxe,nypmx,nblok)         implicit none         integer nx, nxe, nypmx, nblok         real, dimension(2,nxe,nypmx,nblok) :: fxy         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PDGUARD2XL(q,nyp,nx,nxe,nypmx,nblok)         implicit none         integer :: nx, nxe, nypmx, nblok         real, dimension(nxe,nypmx,nblok) :: q         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PBGUARD2XL(bxy,nyp,nx,nxe,nypmx,nblok)         implicit none         integer nx, nxe, nypmx, nblok         real, dimension(3,nxe,nypmx,nblok) :: bxy         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PSCGUARD2L(cu,nyp,xj0,yj0,zj0,nx,nxe,nypmx,nblok)         implicit none         real :: xj0, yj0, zj0         integer nx, nxe, nypmx, nblok         real, dimension(3,nxe,nypmx,nblok) :: cu         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PSCGUARD22L(cu,nyp,xj0,yj0,nx,nxe,nypmx,nblok)         implicit none         real :: xj0, yj0         integer nx, nxe, nypmx, nblok         real, dimension(2,nxe,nypmx,nblok) :: cu         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PSGUARD2L(q,nyp,qi0,nx,nxe,nypmx,nblok)         implicit none         real :: qi0         integer nx, nxe, nypmx, nblok         real, dimension(nxe,nypmx,nblok) :: q         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PACGUARD2XL(cu,nyp,nx,nxe,nypmx,nblok)         implicit none         integer nx, nxe, nypmx, nblok         real, dimension(3,nxe,nypmx,nblok) :: cu         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PACGUARD22XL(cu,nyp,nx,nxe,nypmx,nblok)         implicit none         integer nx, nxe, nypmx, nblok         real, dimension(2,nxe,nypmx,nblok) :: cu         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PAGUARD2XL(q,nyp,nx,nxe,nypmx,nblok)         implicit none         integer nx, nxe, nypmx, nblok         real, dimension(nxe,nypmx,nblok) :: q         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PZGUARD2L(q,nyp,nx,nxe,nypmx,nblok)         implicit none         integer nx, nxe, nypmx, nblok         real, dimension(nxe,nypmx,nblok) :: q         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PPOISP2(q,fx,fy,isign,ffc,ax,ay,affp,we,nx,ny,kstrt,&     &nyv,kxp,jblok,nyhd)         implicit none         real :: ax, ay, affp, we         integer :: isign, nx, ny, kstrt, nyv, kxp, jblok, nyhd         complex, dimension(nyv,kxp,jblok) :: q, fx, fy         complex, dimension(nyhd,kxp,jblok) :: ffc         end subroutine      end interface      interface         subroutine PPOIS22(q,fxy,isign,ffc,ax,ay,affp,we,nx,ny,kstrt,ny&     &v,kxp,jblok,nyhd)         implicit none         real :: ax, ay, affp, we         integer :: isign, nx, ny, kstrt, nyv, kxp, jblok, nyhd         complex, dimension(nyv,kxp,jblok) :: q         complex, dimension(2,nyv,kxp,jblok) :: fxy         complex, dimension(nyhd,kxp,jblok) :: ffc         end subroutine      end interface      interface         subroutine PPOIS23(q,fxy,isign,ffc,ax,ay,affp,we,nx,ny,kstrt,ny&     &v,kxp,jblok,nyhd)         implicit none         real :: ax, ay, affp, we         integer :: isign, nx, ny, kstrt, nyv, kxp, jblok, nyhd         complex, dimension(nyv,kxp,jblok) :: q         complex, dimension(2,nyv,kxp,jblok) :: fxy         complex, dimension(nyhd,kxp,jblok) :: ffc         end subroutine      end interface      interface         subroutine PDIVF2(f,df,nx,ny,kstrt,ndim,nyv,kxp,jblok)         implicit none         integer :: nx, ny, kstrt, ndim, nyv, kxp, jblok         complex, dimension(3,nyv,kxp,jblok) :: f         complex, dimension(nyv,kxp,jblok) :: df         end subroutine      end interface      interface         subroutine PGRADF2(df,f,nx,ny,kstrt,ndim,nyv,kxp,jblok)         implicit none         integer :: nx, ny, kstrt, ndim, nyv, kxp, jblok         complex, dimension(nyv,kxp,jblok) :: df         complex, dimension(3,nyv,kxp,jblok) :: f         end subroutine      end interface      interface         subroutine PCURLF2(f,g,nx,ny,kstrt,nyv,kxp,jblok)         implicit none         integer :: nx, ny, kstrt, nyv, kxp, jblok         complex, dimension(3,nyv,kxp,jblok) :: f, g         end subroutine      end interface      interface         subroutine PCURLF22(f,g,nx,ny,kstrt,nyv,kxp,jblok)         implicit none         integer :: nx, ny, kstrt, nyv, kxp, jblok         complex, dimension(2,nyv,kxp,jblok) :: f         complex, dimension(nyv,kxp,jblok) :: g         end subroutine      end interface      interface         subroutine PCUPERP2(cu,nx,ny,kstrt,nyv,kxp,jblok)         implicit none         integer :: nx, ny, kstrt, nyv, kxp, jblok         complex, dimension(3,nyv,kxp,jblok) :: cu         end subroutine      end interface      interface         subroutine PCUPERP22(cu,nx,ny,kstrt,nyv,kxp,jblok)         implicit none         integer :: nx, ny, kstrt, nyv, kxp, jblok         complex, dimension(2,nyv,kxp,jblok) :: cu         end subroutine      end interface      interface         subroutine PBPOISP23(cu,bxy,isign,ffc,ax,ay,affp,ci,wm,nx,ny,ks&     &trt,nyv,kxp,jblok,nyhd)         implicit none         real :: ax, ay, affp, ci, wm         integer :: isign, nx, ny, kstrt, nyv, kxp, jblok, nyhd         complex, dimension(3,nyv,kxp,jblok) :: cu         complex, dimension(3,nyv,kxp,jblok) :: bxy         complex, dimension(nyhd,kxp,jblok) :: ffc         end subroutine      end interface      interface         subroutine PBPOISP22(cu,bxy,bz,isign,ffc,ax,ay,affp,ci,wm,nx,ny&     &,kstrt,nyv,kxp,jblok,nyhd)         implicit none         real :: ax, ay, affp, ci, wm         integer :: isign, nx, ny, kstrt, nyv, kxp, jblok, nyhd         complex, dimension(2,nyv,kxp,jblok) :: cu         complex, dimension(2,nyv,kxp,jblok) :: bxy         complex, dimension(nyv,kxp,jblok) :: bz         complex, dimension(nyhd,kxp,jblok) :: ffc         end subroutine      end interface      interface         subroutine IPBPOISP23(cu,bxy,ffc,ci,wm,nx,ny,kstrt,nyv,kxp,jblo&     &k,nyhd)         implicit none         real :: ci, wm         integer :: nx, ny, kstrt, nyv, kxp, jblok, nyhd         complex, dimension(3,nyv,kxp,jblok) :: cu         complex, dimension(3,nyv,kxp,jblok) :: bxy         complex, dimension(nyhd,kxp,jblok) :: ffc         end subroutine      end interface      interface         subroutine PMAXWEL2(exy,bxy,cu,ffc,affp,ci,dt,wf,wm,nx,ny,kstrt&     &,nyv,kxp,jblok,nyhd)         implicit none         real :: affp, ci, dt, wf, wm         integer :: nx, ny, kstrt, nyv, kxp, jblok, nyhd         complex, dimension(3,nyv,kxp,jblok) :: exy, bxy, cu         complex, dimension(nyhd,kxp,jblok) :: ffc         end subroutine      end interface      interface         subroutine PEMFIELD2(fxy,exy,ffc,isign,nx,ny,kstrt,nyv,kxp,jblo&     &k,nyhd)         implicit none         integer :: isign, nx, ny, kstrt, nyv, kxp, jblok, nyhd         complex, dimension(3,nyv,kxp,jblok) :: fxy, exy         complex, dimension(nyhd,kxp,jblok) :: ffc         end subroutine      end interface      interface         subroutine PAVPOT23(bxy,axy,nx,ny,kstrt,nyv,kxp,jblok)         implicit none         integer :: nx, ny, kstrt, nyv, kxp, jblok         complex, dimension(3,nyv,kxp,jblok) :: bxy, axy         end subroutine      end interface      interface         subroutine PGTMODES2(pot,pott,nx,ny,it,modesx,modesy,kstrt,nyv,&     &kxp,jblok,nt,modesxpd,modesyd)         implicit none         integer :: nx, ny, it, modesx, modesy, kstrt, nyv, kxp, jblok         integer :: nt, modesxpd, modesyd         complex, dimension(nyv,kxp,jblok) :: pot         complex, dimension(nt,modesyd,modesxpd,jblok) :: pott         end subroutine      end interface      interface         subroutine PPTMODES2(pot,pott,nx,ny,it,modesx,modesy,kstrt,nyv,&     &kxp,jblok,nt,modesxpd,modesyd)         implicit none         integer :: nx, ny, it, modesx, modesy, kstrt, nyv, kxp, jblok         integer :: nt, modesxpd, modesyd         complex, dimension(nyv,kxp,jblok) :: pot         complex, dimension(nt,modesyd,modesxpd,jblok) :: pott         end subroutine      end interface      interface         subroutine PFFT2R(f,g,bs,br,isign,ntpose,mixup,sct,indx,indy,ks&     &trt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         implicit none         integer :: isign, ntpose, indx, indy, kstrt, nxvh, nyv         integer :: kxp, kyp, kypd, jblok, kblok, nxhyd, nxyhd         real :: f         complex, dimension(nyv,kxp,jblok) :: g         complex, dimension(kxp,kyp,kblok) :: bs         complex, dimension(kxp,kyp,jblok) :: br         integer, dimension(nxhyd) :: mixup         complex, dimension(nxyhd) :: sct         end subroutine      end interface      interface         subroutine PFFT2R2(f,g,bs,br,isign,ntpose,mixup,sct,indx,indy,k&     &strt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         implicit none         integer :: isign, ntpose, indx, indy, kstrt, nxvh, nyv         integer :: kxp, kyp, kypd, jblok, kblok, nxhyd, nxyhd         real :: f         complex, dimension(2,nyv,kxp,jblok) :: g         complex, dimension(2,kxp,kyp,kblok) :: bs         complex, dimension(2,kxp,kyp,jblok) :: br         integer, dimension(nxhyd) :: mixup         complex, dimension(nxyhd) :: sct         end subroutine      end interface      interface         subroutine PFFT2R3(f,g,bs,br,isign,ntpose,mixup,sct,indx,indy,k&     &strt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         implicit none         integer :: isign, ntpose, indx, indy, kstrt, nxvh, nyv         integer :: kxp, kyp, kypd, jblok, kblok, nxhyd, nxyhd         real :: f         complex, dimension(3,nyv,kxp,jblok) :: g         complex, dimension(3,kxp,kyp,kblok) :: bs         complex, dimension(3,kxp,kyp,jblok) :: br         integer, dimension(nxhyd) :: mixup         complex, dimension(nxyhd) :: sct         end subroutine      end interface      interface         subroutine PFFT2RX(f,g,isign,ntpose,mixup,sct,indx,indy,kstrt,n&     &xvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         implicit none         integer :: isign, ntpose, indx, indy, kstrt, nxvh, nyv         integer :: kxp, kyp, kypd, jblok, kblok, nxhyd, nxyhd         real :: f         complex, dimension(nyv,kxp,jblok) :: g         integer, dimension(nxhyd) :: mixup         complex, dimension(nxyhd) :: sct         end subroutine      end interface      interface         subroutine PFFT2RX2(f,g,isign,ntpose,mixup,sct,indx,indy,kstrt,&     &nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         implicit none         integer :: isign, ntpose, indx, indy, kstrt, nxvh, nyv         integer :: kxp, kyp, kypd, jblok, kblok, nxhyd, nxyhd         real :: f         complex, dimension(2,nyv,kxp,jblok) :: g         integer, dimension(nxhyd) :: mixup         complex, dimension(nxyhd) :: sct         end subroutine      end interface      interface         subroutine PFFT2RX3(f,g,isign,ntpose,mixup,sct,indx,indy,kstrt,&     &nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         implicit none         integer :: isign, ntpose, indx, indy, kstrt, nxvh, nyv         integer :: kxp, kyp, kypd, jblok, kblok, nxhyd, nxyhd         real :: f         complex, dimension(3,nyv,kxp,jblok) :: g         integer, dimension(nxhyd) :: mixup         complex, dimension(nxyhd) :: sct         end subroutine      end interface      interface         subroutine PFFT2C(f,g,bs,br,isign,ntpose,mixup,sct,indx,indy,ks&     &trt,nxv,nyv,kxp,kyp,kypd,jblok,kblok,nxyd,nxyhd)         implicit none         integer :: isign, ntpose, indx, indy, kstrt, nxv, nyv, kxp, kyp         integer :: kypd, jblok, kblok, nxyd, nxyhd!        complex, dimension(*) :: f         complex :: f         complex, dimension(nyv,kxp,jblok) :: g         complex, dimension (kxp,kyp,kblok) :: bs         complex, dimension (kxp,kyp,jblok) :: br         integer, dimension(nxyd) :: mixup         complex, dimension(nxyhd) :: sct         end subroutine      end interface      interface         subroutine WPFFT2RN(f,g,bs,br,ss,isign,ntpose,mixup,sct,indx,in&     &dy,kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,ndim,nxhyd,nxyhd)         implicit none         integer :: isign, ntpose, indx, indy, kstrt, nxvh, nyv         integer :: kxp, kyp, kypd, jblok, kblok, ndim, nxhyd, nxyhd         real :: f         complex, dimension(ndim,nyv,kxp,jblok) :: g         complex, dimension(ndim,kxp,kyp,kblok) :: bs         complex, dimension(ndim,kxp,kyp,jblok) :: br         integer, dimension(nxhyd) :: mixup         complex, dimension(nxyhd) :: sct         complex, dimension(ndim,nxvh) :: ss         end subroutine      end interface      interface         subroutine WPFFT2RXN(f,g,ss,isign,ntpose,mixup,sct,indx,indy,ks&     &trt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,ndim,nxhyd,nxyhd)         implicit none         integer :: isign, ntpose, indx, indy, kstrt, nxvh, nyv         integer :: kxp, kyp, kypd, jblok, kblok, ndim, nxhyd, nxyhd         real :: f         complex, dimension(ndim,nyv,kxp,jblok) :: g         integer, dimension(nxhyd) :: mixup         complex, dimension(nxyhd) :: sct         complex, dimension(ndim,nxvh) :: ss         end subroutine      end interface!! define generic interfaces to Fortran90 library!      interface cguard         module procedure ipcguard2x         module procedure ipdguard2x      end interface!      interface bguard         module procedure ipbguard2x      end interface!      interface sguard         module procedure ipscguard2         module procedure ipsguard2      end interface!            interface aguard         module procedure ipacguard2x         module procedure ipaguard2x      end interface!      interface zguard         module procedure ipzguard2      end interface!       interface pois_init         module procedure ippois22init      end interface!       interface pois         module procedure ippois2         module procedure ipspois2         module procedure ippois22      end interface!      interface pois3         module procedure ippois23      end interface!      interface cuperp         module procedure ipcuperp2      end interface!      interface bpois         module procedure jpbpois23      end interface!      interface ibpois         module procedure jipbpois23      end interface!      interface maxwel         module procedure ipmaxwel2      end interface!      interface emfield         module procedure ipemfield2      end interface!      interface avpot         module procedure ipavpot23      end interface!      interface gtmodes         module procedure ipgtmodes2      end interface!      interface ptmodes         module procedure ipptmodes2      end interface!      interface fft_init         module procedure ipfft2rinit!        module procedure ipfft2rxinit      end interface!      interface fft!        module procedure ipfft2r!        module procedure ipfft2r2!        module procedure ipfft2r3         module procedure ipfft2rx         module procedure ipfft2rx2         module procedure ipfft2rx3         module procedure ipfft2c      end interface!      interface fftn!        module procedure ipfft2rn         module procedure ipfft2rxn      end interface!      interface fftc_init         module procedure ipfft2cinit      end interface!! define Fortran90 interface functions to Fortran77 library!      contains!         subroutine ipcguard2x(fxy,nyp,nx,inorder)! copy guard cells in x for non-uniform, periodic 2d vector data         implicit none         integer :: nx         integer, optional :: inorder         real, dimension(:,:,:,:), pointer :: fxy         integer, dimension(:), pointer :: nyp         integer :: nxe, nypmx, nblok, order         nxe = size(fxy,2); nypmx = size(fxy,3); nblok = size(fxy,4)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PCGUARD2XL(fxy,nyp,nx,nxe,nypmx,nblok)         else            call PCGUARD2X(fxy,nyp,nx,nxe,nypmx,nblok)         endif         end subroutine ipcguard2x!         subroutine ipdguard2x(q,nyp,nx,inorder)! copy guard cells in x for non-uniform, periodic 2d scalar data         implicit none         integer :: nx         integer, optional :: inorder         real, dimension(:,:,:), pointer :: q         integer, dimension(:), pointer :: nyp         integer :: nxe, nypmx, nblok, order         nxe = size(q,1); nypmx = size(q,2); nblok = size(q,3)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PDGUARD2XL(q,nyp,nx,nxe,nypmx,nblok)         else            call PDGUARD2X(q,nyp,nx,nxe,nypmx,nblok)         endif         end subroutine ipdguard2x!         subroutine ipbguard2x(bxy,nyp,nx,inorder)! copy guard cells in x for non-uniform, periodic 2d vector data         implicit none         integer :: nx         integer, optional :: inorder         real, dimension(:,:,:,:), pointer :: bxy         integer, dimension(:), pointer :: nyp         integer :: nxe, nypmx, nblok, order         nxe = size(bxy,2); nypmx = size(bxy,3); nblok = size(bxy,4)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PBGUARD2XL(bxy,nyp,nx,nxe,nypmx,nblok)         else            call PBGUARD2X(bxy,nyp,nx,nxe,nypmx,nblok)         endif         end subroutine ipbguard2x!         subroutine ipscguard2(cu,nyp,xj0,yj0,zj0,nx,inorder)! initialize periodic 2d vector field         implicit none         integer :: nx         integer, optional :: inorder         real :: xj0, yj0, zj0         real, dimension(:,:,:,:), pointer :: cu         integer, dimension(:), pointer :: nyp         integer :: nxe, nypmx, nblok, order         nxe = size(cu,2); nypmx = size(cu,3); nblok = size(cu,4)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PSCGUARD2L(cu,nyp,xj0,yj0,zj0,nx,nxe,nypmx,nblok)         else            call PSCGUARD2(cu,nyp,xj0,yj0,zj0,nx,nxe,nypmx,nblok)         endif         end subroutine ipscguard2!         subroutine ipsguard2(q,nyp,qi0,nx,inorder)! initialize periodic 2d scalar field         implicit none         integer :: nx         integer, optional :: inorder         real :: qi0         real, dimension(:,:,:), pointer :: q         integer, dimension(:), pointer :: nyp         integer :: nxe, nypmx, nblok, order         nxe = size(q,1); nypmx = size(q,2); nblok = size(q,3)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PSGUARD2L(q,nyp,qi0,nx,nxe,nypmx,nblok)         else            call PSGUARD2(q,nyp,qi0,nx,nxe,nypmx,nblok)         endif         end subroutine ipsguard2!         subroutine ipacguard2x(cu,nyp,nx,inorder)! add guard cells in x for non-uniform, periodic 2d vector data         implicit none         integer :: nx         integer, optional :: inorder         real, dimension(:,:,:,:), pointer :: cu         integer, dimension(:), pointer :: nyp         integer :: nxe, nypmx, nblok, order         nxe = size(cu,2); nypmx = size(cu,3); nblok = size(cu,4)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PACGUARD2XL(cu,nyp,nx,nxe,nypmx,nblok)         else            call PACGUARD2X(cu,nyp,nx,nxe,nypmx,nblok)         endif         end subroutine ipacguard2x!         subroutine ipaguard2x(q,nyp,nx,inorder)! add guard cells in x for non-uniform, periodic 2d scalar data         implicit none         integer :: nx         integer, optional :: inorder         real, dimension(:,:,:), pointer :: q         integer, dimension(:), pointer :: nyp         integer :: nxe, nypmx, nblok, order         nxe = size(q,1); nypmx = size(q,2); nblok = size(q,3)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PAGUARD2XL(q,nyp,nx,nxe,nypmx,nblok)         else            call PAGUARD2X(q,nyp,nx,nxe,nypmx,nblok)         endif         end subroutine ipaguard2x!         subroutine ipzguard2(q,nyp,nx,inorder)! zero out guard cells in periodic 2d scalar field         implicit none         integer :: nx         integer, optional :: inorder         real, dimension(:,:,:), pointer :: q         integer, dimension(:), pointer :: nyp         integer :: nxe, nypmx, nblok, order         nxe = size(q,1); nypmx = size(q,2); nblok = size(q,3)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PZGUARD2L(q,nyp,nx,nxe,nypmx,nblok)         else            call PZGUARD2(q,nyp,nx,nxe,nypmx,nblok)         endif         end subroutine ipzguard2!         subroutine ippois2init(ffc,ax,ay,affp,nx,ny,kstrt)! initialize 2d periodic poisson solver         implicit none         integer :: nx, ny, kstrt         real :: ax, ay, affp         complex, dimension(:,:,:), pointer :: ffc         integer :: isign = 0, nyv, kxp, jblok, nyhd         real :: we         complex, dimension(1,1,1) :: q, fx, fy         nyv = size(q,1)         nyhd = size(ffc,1); kxp = size(ffc,2); jblok = size(ffc,3)         call PPOISP2(q,fx,fy,isign,ffc,ax,ay,affp,we,nx,ny,kstrt,nyv,kx&     &p,jblok,nyhd)         end subroutine ippois2init!         subroutine ippois2(q,fx,ffc,we,nx,ny,kstrt)! poisson solver for periodic 2d potential         implicit none         integer :: nx, ny, kstrt         real :: we         complex, dimension(:,:,:), pointer :: q, fx, ffc         integer :: isign = 1, nyv, kxp, jblok, nyhd         real :: ax, ay, affp         complex, dimension(1,1,1) :: fy         nyv = size(q,1)         nyhd = size(ffc,1); kxp = size(ffc,2); jblok = size(ffc,3)         call PPOISP2(q,fx,fy,isign,ffc,ax,ay,affp,we,nx,ny,kstrt,nyv,kx&     &p,jblok,nyhd)         end subroutine ippois2!         subroutine ipspois2(q,fy,ffc,nx,ny,kstrt)! smoother for periodic 2d scalar field         implicit none         integer :: nx, ny, kstrt         complex, dimension(:,:,:), pointer :: q, fy, ffc         integer :: isign = 2, nyv, kxp, jblok, nyhd         real :: ax, ay, affp, we         complex, dimension(1,1,1) :: fx         nyv = size(q,1)         nyhd = size(ffc,1); kxp = size(ffc,2); jblok = size(ffc,3)         call PPOISP2(q,fx,fy,isign,ffc,ax,ay,affp,we,nx,ny,kstrt,nyv,kx&     &p,jblok,nyhd)         end subroutine ipspois2!         subroutine ippois22init(ffc,ax,ay,affp,nx,ny,kstrt)! initialize 2d periodic electric field solver         implicit none         integer :: nx, ny, kstrt         real :: ax, ay, affp         complex, dimension(:,:,:), pointer :: ffc         integer :: isign = 0, nyv, kxp, jblok, nyhd         real :: we         complex, dimension(1,1,1) :: q         complex, dimension(2,1,1,1) :: fxy         nyv = size(q,1)         nyhd = size(ffc,1); kxp = size(ffc,2); jblok = size(ffc,3)         call PPOIS22(q,fxy,isign,ffc,ax,ay,affp,we,nx,ny,kstrt,nyv,kxp,&     &jblok,nyhd)         end subroutine ippois22init!         subroutine ippois22(q,fxy,ffc,we,nx,ny,kstrt)! poisson solver for periodic 2d electric field         implicit none         integer :: nx, ny, kstrt         real :: we         complex, dimension(:,:,:), pointer :: q, ffc         complex, dimension(:,:,:,:), pointer :: fxy         integer :: isign = -1, nyv, kxp, jblok, nyhd         real :: ax, ay, affp         nyv = size(q,1)         nyhd = size(ffc,1); kxp = size(ffc,2); jblok = size(ffc,3)         call PPOIS22(q,fxy,isign,ffc,ax,ay,affp,we,nx,ny,kstrt,nyv,kxp,&     &jblok,nyhd)         end subroutine ippois22!         subroutine ippois23(q,fxy,ffc,we,nx,ny,kstrt)! poisson solver for periodic 2-1/2d electric field         implicit none         integer :: nx, ny, kstrt         real :: we         complex, dimension(:,:,:), pointer :: q, ffc         complex, dimension(:,:,:,:), pointer :: fxy         integer :: isign = -1, nyv, kxp, jblok, nyhd         real :: ax, ay, affp         nyv = size(q,1)         nyhd = size(ffc,1); kxp = size(ffc,2); jblok = size(ffc,3)         call PPOIS23(q,fxy,isign,ffc,ax,ay,affp,we,nx,ny,kstrt,nyv,kxp,&     &jblok,nyhd)         end subroutine ippois23!         subroutine ipdivf2(f,df,nx,ny,kstrt)! calculates the divergence of periodic 2d vector field         implicit none         integer :: nx, ny, kstrt         complex, dimension(:,:,:,:), pointer :: f         complex, dimension(:,:,:), pointer :: df         integer :: ndim, nyv, kxp, jblok         ndim = size(f,1)         nyv = size(f,2); kxp = size(f,3); jblok = size(f,4)         call PDIVF2(f,df,nx,ny,kstrt,ndim,nyv,kxp,jblok)         end subroutine ipdivf2!         subroutine ipgradf2(df,f,nx,ny,kstrt)! calculates the gradient of periodic 2d scalar field         implicit none         integer :: nx, ny, kstrt         complex, dimension(:,:,:), pointer :: df         complex, dimension(:,:,:,:), pointer :: f         integer :: ndim, nyv, kxp, jblok         ndim = size(f,1)         nyv = size(df,1); kxp = size(df,2); jblok = size(df,3)         call PGRADF2(df,f,nx,ny,kstrt,ndim,nyv,kxp,jblok)         end subroutine ipgradf2!         subroutine ipcurlf2(f,g,nx,ny,kstrt)! calculates the curl of periodic 2d vector field         implicit none         integer :: nx, ny, kstrt         complex, dimension(:,:,:,:), pointer :: f, g         integer :: nyv, kxp, jblok         nyv = size(f,2); kxp = size(f,3); jblok = size(f,4)         call PCURLF2(f,g,nx,ny,kstrt,nyv,kxp,jblok)         end subroutine ipcurlf2!         subroutine ipcuperp2(cu,nx,ny,kstrt)! calculates the transverse part of periodic 2d vector field         implicit none         integer :: nx, ny, kstrt         complex, dimension(:,:,:,:), pointer :: cu         integer :: nyv, kxp, jblok         nyv = size(cu,2); kxp = size(cu,3); jblok = size(cu,4)         call PCUPERP2(cu,nx,ny,kstrt,nyv,kxp,jblok)         end subroutine ipcuperp2!         subroutine jpbpois23(cu,bxy,ffc,ci,wm,nx,ny,kstrt)! calculates static vector potential for periodic 2d vector field         implicit none         integer :: nx, ny, kstrt         real :: ci, wm         complex, dimension(:,:,:), pointer :: ffc         complex, dimension(:,:,:,:), pointer :: cu, bxy         integer :: isign = 1, nyv, kxp, jblok, nyhd         real :: ax, ay, affp         nyv = size(cu,2)         nyhd = size(ffc,1); kxp = size(ffc,2); jblok = size(ffc,3)         call PBPOISP23(cu,bxy,isign,ffc,ax,ay,affp,ci,wm,nx,ny,kstrt,ny&     &v,kxp,jblok,nyhd)         end subroutine jpbpois23!         subroutine jipbpois23(cu,bxy,ffc,ci,wm,nx,ny,kstrt)! calculates static magnetic field for periodic 2d vector field         implicit none         integer :: nx, ny, kstrt         real :: ci, wm         complex, dimension(:,:,:), pointer :: ffc         complex, dimension(:,:,:,:), pointer :: cu, bxy         integer :: nyv, kxp, jblok, nyhd         nyv = size(cu,2)         nyhd = size(ffc,1); kxp = size(ffc,2); jblok = size(ffc,3)         call IPBPOISP23(cu,bxy,ffc,ci,wm,nx,ny,kstrt,nyv,kxp,jblok,nyhd&     &)         end subroutine jipbpois23!         subroutine ipmaxwel2(exy,bxy,cu,ffc,affp,ci,dt,wf,wm,nx,ny,kstr&     &t)! calculates maxwell's equation for periodic 2d vector field         implicit none         integer :: nx, ny, kstrt         real :: affp, ci, dt, wf, wm         complex, dimension(:,:,:), pointer :: ffc         complex, dimension(:,:,:,:), pointer :: exy, bxy, cu         integer :: nyv, kxp, jblok, nyhd         nyv = size(cu,2)         nyhd = size(ffc,1); kxp = size(ffc,2); jblok = size(ffc,3)         call PMAXWEL2(exy,bxy,cu,ffc,affp,ci,dt,wf,wm,nx,ny,kstrt,nyv,k&     &xp,jblok,nyhd)         end subroutine ipmaxwel2!         subroutine ipemfield2(fxy,exy,ffc,isign,nx,ny,kstrt)! combines and smooths periodic 2d vector fields         implicit none         integer :: isign, nx, ny, kstrt, nyhd         complex, dimension(:,:,:,:), pointer :: fxy, exy         complex, dimension(:,:,:), pointer :: ffc         integer :: nyv, kxp, jblok         nyv = size(fxy,2); kxp = size(fxy,3); jblok = size(fxy,4)         nyhd = size(ffc,1)          call PEMFIELD2(fxy,exy,ffc,isign,nx,ny,kstrt,nyv,kxp,jblok,nyhd&     &)         end subroutine ipemfield2 !         subroutine ipavpot23(bxy,axy,nx,ny,kstrt)! calculates periodic 2d vector potential from magnetic field         implicit none         integer :: nx, ny, kstrt         complex, dimension(:,:,:,:), pointer :: bxy, axy         integer :: nyv, kxp, jblok         nyv = size(bxy,2); kxp = size(bxy,3); jblok = size(bxy,4)         call PAVPOT23(bxy,axy,nx,ny,kstrt,nyv,kxp,jblok)         end subroutine ipavpot23!         subroutine ipgtmodes2(pot,pott,nx,ny,modesx,modesy,kstrt)! extracts lowest order modes from periodic 2d scalar field         implicit none         integer :: nx, ny, modesx, modesy, kstrt         complex, dimension(:,:,:), pointer :: pot         complex, dimension(:,:,:), pointer :: pott         integer :: it, nyv, kxp, jblok, nt, modesxpd, modesyd         it = 1; nt = 1         nyv = size(pot,1); kxp = size(pot,2); jblok = size(pot,3)         modesyd = size(pott,1); modesxpd = size(pott,2)         call PGTMODES2(pot,pott,nx,ny,it,modesx,modesy,kstrt,nyv,kxp,jb&     &lok,nt,modesxpd,modesyd)         end subroutine ipgtmodes2!         subroutine ipptmodes2(pot,pott,nx,ny,modesx,modesy,kstrt)! extracts lowest order modes to periodic 2d scalar field         implicit none         integer :: nx, ny, modesx, modesy, kstrt         complex, dimension(:,:,:), pointer :: pot         complex, dimension(:,:,:), pointer :: pott         integer :: it, nyv, kxp, jblok, nt, modesxpd, modesyd         it = 1; nt = 1         nyv = size(pot,1); kxp = size(pot,2); jblok = size(pot,3)         modesyd = size(pott,1); modesxpd = size(pott,2)         call PPTMODES2(pot,pott,nx,ny,it,modesx,modesy,kstrt,nyv,kxp,jb&     &lok,nt,modesxpd,modesyd)         end subroutine ipptmodes2!         subroutine ipfft2rinit(mixup,sct,indx,indy)! initialize 2d real to complex fft         implicit none         integer :: indx, indy         integer, dimension(:), pointer :: mixup         complex, dimension(:), pointer :: sct         integer :: isign = 0, ntpose = 1, kstrt = 1, nxvh = 1, nyv = 1         integer :: kxp = 1, kyp = 1, kypd = 1, jblok = 1, kblok = 1         integer :: nxhyd, nxyhd         real :: f         complex, dimension(1,1,1) :: g, bs, br         nxhyd = size(mixup); nxyhd = size(sct)         call PFFT2R(f,g,bs,br,isign,ntpose,mixup,sct,indx,indy,kstrt,nx&     &vh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         end subroutine ipfft2rinit!         subroutine ipfft2r(f,g,isign,mixup,sct,indx,indy,kstrt,kyp,inor&     &der)! perform 2d scalar real to complex fft         implicit none         integer :: isign, indx, indy, kstrt, kyp         integer, optional :: inorder         real, dimension(:,:,:), pointer :: f         complex, dimension(:,:,:), pointer :: g         integer, dimension(:), pointer :: mixup         complex, dimension(:), pointer :: sct         integer :: ntpose = 1, nxvh, nyv         integer :: kxp, kypd, jblok, kblok, nxhyd, nxyhd, order         complex, dimension(size(g,2),kyp,size(f,3)) :: bs         complex, dimension(size(g,2),kyp,size(g,3)) :: br         nxvh = size(f,1)/2; kypd = size(f,2); kblok = size(f,3)         nyv = size(g,1); kxp = size(g,2); jblok = size(g,3)         nxhyd = size(mixup); nxyhd = size(sct)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PFFT2R(f(1,1,1),g,bs,br,isign,ntpose,mixup,sct,indx,ind&     &y,kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         else            call PFFT2R(f(2,2,1),g,bs,br,isign,ntpose,mixup,sct,indx,ind&     &y,kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         endif         end subroutine ipfft2r!         subroutine ipfft2r2(f,g,mixup,sct,indx,indy,kstrt,kyp,inorder)! perform 2d vector real to complex fft for 2 component vectors         implicit none         integer :: indx, indy, kstrt, kyp         integer, optional :: inorder         real, dimension(:,:,:,:), pointer :: f         complex, dimension(:,:,:,:), pointer :: g         complex, dimension(2,size(g,3),kyp,size(f,4)) :: bs         complex, dimension(2,size(g,3),kyp,size(g,4)) :: br         integer, dimension(:), pointer :: mixup         complex, dimension(:), pointer :: sct         integer :: isign = 1, ntpose = 1, nxvh, nyv         integer :: kxp, kypd, jblok, kblok, nxhyd, nxyhd, order         nxvh = size(f,2)/2; kypd = size(f,3); kblok = size(f,4)         nyv = size(g,2); kxp = size(g,3); jblok = size(g,4)         nxhyd = size(mixup); nxyhd = size(sct)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PFFT2R2(f(1,1,1,1),g,bs,br,isign,ntpose,mixup,sct,indx,&     &indy,kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         else            call PFFT2R2(f(1,2,2,1),g,bs,br,isign,ntpose,mixup,sct,indx,&     &indy,kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         endif         end subroutine ipfft2r2!         subroutine ipfft2r3(f,g,isign,mixup,sct,indx,indy,kstrt,kyp,ino&     &rder)! perform 2d vector real to complex fft for 3 component vectors         implicit none         integer :: isign, indx, indy, kstrt, kyp         integer, optional :: inorder         real, dimension(:,:,:,:), pointer :: f         complex, dimension(:,:,:,:), pointer :: g         complex, dimension(3,size(g,3),kyp,size(f,4)) :: bs         complex, dimension(3,size(g,3),kyp,size(g,4)) :: br         integer, dimension(:), pointer :: mixup         complex, dimension(:), pointer :: sct         integer :: ntpose = 1, nxvh, nyv         integer :: kxp, kypd, jblok, kblok, nxhyd, nxyhd, order         nxvh = size(f,2)/2; kypd = size(f,3); kblok = size(f,4)         nyv = size(g,2); kxp = size(g,3); jblok = size(g,4)         nxhyd = size(mixup); nxyhd = size(sct)         order = QUADRATIC         if (present(inorder)) order = inorder         if (size(f,1)==2) then            if (order==LINEAR) then               call PFFT2R2(f(1,1,1,1),g,bs,br,isign,ntpose,mixup,sct,in&     &dx,indy,kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)            else               call PFFT2R2(f(1,2,2,1),g,bs,br,isign,ntpose,mixup,sct,in&     &dx,indy,kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)            endif         else if (size(f,1)==3) then            if (order==LINEAR) then               call PFFT2R3(f(1,1,1,1),g,bs,br,isign,ntpose,mixup,sct,in&     &dx,indy,kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)            else               call PFFT2R3(f(1,2,2,1),g,bs,br,isign,ntpose,mixup,sct,in&     &dx,indy,kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)            endif         endif         end subroutine ipfft2r3!         subroutine ipfft2rxinit(mixup,sct,indx,indy)! initialize optimized 2d real to complex fft         implicit none         integer :: indx, indy         integer, dimension(:), pointer :: mixup         complex, dimension(:), pointer :: sct         integer :: isign = 0, ntpose = 1, kstrt = 1, nxvh = 1, nyv = 1         integer :: kxp = 1, kyp = 1, kypd = 1         integer :: jblok = 1, kblok = 1         integer :: nxhyd, nxyhd         real :: f         complex, dimension(1,1,1) :: g         nxhyd = size(mixup); nxyhd = size(sct)         call PFFT2RX(f,g,isign,ntpose,mixup,sct,indx,indy,kstrt,nxvh,ny&     &v,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         end subroutine ipfft2rxinit!         subroutine ipfft2rx(f,g,isign,mixup,sct,indx,indy,kstrt,kyp,ino&     &rder)! perform optimized 2d scalar real to complex fft         implicit none         integer :: isign, indx, indy, kstrt, kyp         integer, optional :: inorder         real, dimension(:,:,:), pointer :: f         complex, dimension(:,:,:), pointer :: g         integer, dimension(:), pointer :: mixup         complex, dimension(:), pointer :: sct         integer :: ntpose = 1, nxvh, nyv, kxp, kypd         integer :: jblok, kblok, nxhyd, nxyhd, order         nxvh = size(f,1)/2; kypd = size(f,2); kblok = size(f,3)         nyv = size(g,1); kxp = size(g,2); jblok = size(g,3)         nxhyd = size(mixup); nxyhd = size(sct)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PFFT2RX(f(1,1,1),g,isign,ntpose,mixup,sct,indx,indy,kst&     &rt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         else            call PFFT2RX(f(2,2,1),g,isign,ntpose,mixup,sct,indx,indy,kst&     &rt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         endif         end subroutine ipfft2rx!         subroutine ipfft2rx2(f,g,mixup,sct,indx,indy,kstrt,kyp,inorder)! perform optimized 2d vector real to complex fft for 2 component vector         implicit none         integer :: indx, indy, kstrt, kyp         integer, optional :: inorder         real, dimension(:,:,:,:), pointer :: f         complex, dimension(:,:,:,:), pointer :: g         integer, dimension(:), pointer :: mixup         complex, dimension(:), pointer :: sct         integer :: isign = 1, ntpose = 1, nxvh, nyv, kxp         integer :: kypd, jblok, kblok, nxhyd, nxyhd, order         nxvh = size(f,2)/2; kypd = size(f,3); kblok = size(f,4)         nyv = size(g,2); kxp = size(g,3); jblok = size(g,4)         nxhyd = size(mixup); nxyhd = size(sct)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PFFT2RX2(f(1,1,1,1),g,isign,ntpose,mixup,sct,indx,indy,&     &kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         else            call PFFT2RX2(f(1,2,2,1),g,isign,ntpose,mixup,sct,indx,indy,&     &kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         endif         end subroutine ipfft2rx2!         subroutine ipfft2rx3(f,g,isign,mixup,sct,indx,indy,kstrt,kyp,in&     &order)! perform optimized 2d vector real to complex fft for 3 component vector         implicit none         integer :: isign, indx, indy, kstrt, kyp         integer, optional :: inorder         real, dimension(:,:,:,:), pointer :: f         complex, dimension(:,:,:,:), pointer :: g         integer, dimension(:), pointer :: mixup         complex, dimension(:), pointer :: sct         integer :: ntpose = 1, nxvh, nyv, kxp         integer :: kypd, jblok, kblok, nxhyd, nxyhd, order         nxvh = size(f,2)/2; kypd = size(f,3); kblok = size(f,4)         nyv = size(g,2); kxp = size(g,3); jblok = size(g,4)         nxhyd = size(mixup); nxyhd = size(sct)         order = QUADRATIC         if (present(inorder)) order = inorder         if (size(f,1)==2) then            if (order==LINEAR) then               call PFFT2RX2(f(1,1,1,1),g,isign,ntpose,mixup,sct,indx,in&     &dy,kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)            else               call PFFT2RX2(f(1,2,2,1),g,isign,ntpose,mixup,sct,indx,in&     &dy,kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)            endif         else if (size(f,1)==3) then            if (order==LINEAR) then               call PFFT2RX3(f(1,1,1,1),g,isign,ntpose,mixup,sct,indx,in&     &dy,kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)            else               call PFFT2RX3(f(1,2,2,1),g,isign,ntpose,mixup,sct,indx,in&     &dy,kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)            endif         endif         end subroutine ipfft2rx3!         subroutine ipfft2rn(f,g,isign,mixup,sct,indx,indy,kstrt,kyp,ino&     &rder)! perform 2d vector real to complex fft for n component vectors         implicit none         integer :: isign, indx, indy, kstrt, kyp         integer, optional :: inorder         real, dimension(:,:,:,:), pointer :: f         complex, dimension(:,:,:,:), pointer :: g         complex, dimension(3,size(g,3),kyp,size(f,4)) :: bs         complex, dimension(3,size(g,3),kyp,size(g,4)) :: br         integer, dimension(:), pointer :: mixup         complex, dimension(:), pointer :: sct         complex, dimension(size(f,1),size(f,2)/2) :: ss         integer :: ntpose = 1, ndim, nxvh, nyv         integer :: kxp, kypd, jblok, kblok, nxhyd, nxyhd, order         ndim = size(f,1); nxvh = size(f,2)/2; kypd = size(f,3)         kblok = size(f,4)         nyv = size(g,2); kxp = size(g,3); jblok = size(g,4)         nxhyd = size(mixup); nxyhd = size(sct)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call WPFFT2RN(f(1,1,1,1),g,bs,br,ss,isign,ntpose,mixup,sct,i&     &ndx,indy,kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,ndim,nxhyd,nxyhd)         else            call WPFFT2RN(f(1,2,2,1),g,bs,br,ss,isign,ntpose,mixup,sct,i&     &ndx,indy,kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,ndim,nxhyd,nxyhd)         endif         end subroutine ipfft2rn!         subroutine ipfft2rxn(f,g,isign,mixup,sct,indx,indy,kstrt,kyp,in&     &order)! perform optimized 2d vector real to complex fft for n component vector         implicit none         integer :: isign, indx, indy, kstrt, kyp         integer, optional :: inorder         real, dimension(:,:,:,:), pointer :: f         complex, dimension(:,:,:,:), pointer :: g         integer, dimension(:), pointer :: mixup         complex, dimension(:), pointer :: sct         complex, dimension(size(f,1),size(f,2)/2) :: ss         integer :: ntpose = 1, ndim, nxvh, nyv, kxp         integer :: kypd, jblok, kblok, nxhyd, nxyhd, order         ndim = size(f,1); nxvh = size(f,2)/2; kypd = size(f,3)         kblok = size(f,4)         nyv = size(g,2); kxp = size(g,3); jblok = size(g,4)         nxhyd = size(mixup); nxyhd = size(sct)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call WPFFT2RXN(f(1,1,1,1),g,ss,isign,ntpose,mixup,sct,indx,i&     &ndy,kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,ndim,nxhyd,nxyhd)         else            call WPFFT2RXN(f(1,2,2,1),g,ss,isign,ntpose,mixup,sct,indx,i&     &ndy,kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,ndim,nxhyd,nxyhd)         endif         end subroutine ipfft2rxn!         subroutine ipfft2c(f,g,isign,mixup,sct,indx,indy,kstrt,kyp,inor&     &der)! perform 2d scalar complex to complex fft         implicit none         integer :: isign, indx, indy, kstrt, kyp         integer, optional :: inorder         complex, dimension(:,:,:), pointer :: f, g         integer, dimension(:), pointer :: mixup         complex, dimension(:), pointer :: sct         integer :: ntpose = 1, nxv, nyv         integer :: kxp, kypd, jblok, kblok, nxyd, nxyhd, order         complex, dimension(size(g,2),kyp,size(f,3)) :: bs         complex, dimension(size(g,2),kyp,size(g,3)) :: br         nxv = size(f,1); kypd = size(f,2); kblok = size(f,3)         nyv = size(g,1); kxp = size(g,2); jblok = size(g,3)         nxyd = size(mixup); nxyhd = size(sct)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PFFT2C(f(1,1,1),g,bs,br,isign,ntpose,mixup,sct,indx,ind&     &y,kstrt,nxv,nyv,kxp,kyp,kypd,jblok,kblok,nxyd,nxyhd)         else            call PFFT2C(f(2,2,1),g,bs,br,isign,ntpose,mixup,sct,indx,ind&     &y,kstrt,nxv,nyv,kxp,kyp,kypd,jblok,kblok,nxyd,nxyhd)         endif         end subroutine ipfft2c!         subroutine ipfft2cinit(mixup,sct,indx,indy)! initialize 2d complex to complex fft         implicit none         integer :: indx, indy         integer, dimension(:), pointer :: mixup         complex, dimension(:), pointer :: sct         integer :: isign = 0, ntpose = 1, kstrt = 1, nxv = 1, nyv = 1         integer :: kxp = 1, kyp = 1, kypd = 1         integer :: jblok = 1, kblok = 1         integer :: nxyd, nxyhd         complex :: f         complex, dimension(1,1,1) :: g, bs, br         nxyd = size(mixup); nxyhd = size(sct)         call PFFT2C(f,g,bs,br,isign,ntpose,mixup,sct,indx,indy,kstrt,nx&     &v,nyv,kxp,kyp,kypd,jblok,kblok,nxyd,nxyhd)         end subroutine ipfft2cinit!      end module pfield2d