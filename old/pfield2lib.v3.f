c 2d parallel PIC library for solving field equationsc written by viktor k. decyk, uclac copyright 1995, regents of the university of californiac update: february 26, 2003c-----------------------------------------------------------------------      subroutine PCGUARD2X(fxy,nyp,nx,nxe,nypmx,nblok)c replicate extended periodic fieldc quadratic interpolation, for distributed data      implicit none      real fxy      integer nyp, nx, nxe, nypmx, nblok      dimension fxy(2,nxe,nypmx,nblok), nyp(nblok)      integer i, k, l, nyp3      do 30 l = 1, nblok      nyp3 = nyp(l) + 3      do 20 k = 1, nyp3      do 10 i = 1, 2      fxy(i,1,k,l) = fxy(i,nx+1,k,l)      fxy(i,nx+2,k,l) = fxy(i,2,k,l)      fxy(i,nx+3,k,l) = fxy(i,3,k,l)   10 continue   20 continue   30 continue      return      endc-----------------------------------------------------------------------      subroutine PDGUARD2X(q,nyp,nx,nxe,nypmx,nblok)c replicate extended periodic scalar fieldc quadratic interpolation, for distributed data      implicit none      real q      integer nyp, nx, nxe, nypmx, nblok      dimension q(nxe,nypmx,nblok), nyp(nblok)      integer k, l, nyp3      do 20 l = 1, nblok      nyp3 = nyp(l) + 3      do 10 k = 1, nyp3      q(1,k,l) = q(nx+1,k,l)      q(nx+2,k,l) = q(2,k,l)      q(nx+3,k,l) = q(3,k,l)   10 continue   20 continue      return      endc-----------------------------------------------------------------------      subroutine PBGUARD2X(bxy,nyp,nx,nxe,nypmx,nblok)c replicate extended periodic vector fieldc quadratic interpolation, for distributed data      implicit none      real bxy      integer nyp, nx, nxe, nypmx, nblok      dimension bxy(3,nxe,nypmx,nblok), nyp(nblok)      integer i, k, l, nyp3      do 30 l = 1, nblok      nyp3 = nyp(l) + 3      do 20 k = 1, nyp3      do 10 i = 1, 3      bxy(i,1,k,l) = bxy(i,nx+1,k,l)      bxy(i,nx+2,k,l) = bxy(i,2,k,l)      bxy(i,nx+3,k,l) = bxy(i,3,k,l)   10 continue   20 continue   30 continue      return      endc-----------------------------------------------------------------------      subroutine PSCGUARD2(cu,nyp,xj0,yj0,zj0,nx,nxe,nypmx,nblok)c initialize extended periodic fieldc quadratic interpolation, for distributed data      implicit none      real cu, xj0, yj0, zj0      integer nyp, nx, nxe, nypmx, nblok      dimension cu(3,nxe,nypmx,nblok), nyp(nblok)      integer i, j, k, l, nyp3, nx3c initialize extended field, with zero in the edges      nx3 = nx + 3      do 60 l = 1, nblok      nyp3 = nyp(l) + 3      do 30 k = 1, nyp(l)      do 10 j = 1, nx      cu(1,j+1,k+1,l) = xj0      cu(2,j+1,k+1,l) = yj0      cu(3,j+1,k+1,l) = zj0   10 continue      do 20 i = 1, 3      cu(i,1,k+1,l) = 0.      cu(i,nx+2,k+1,l) = 0.      cu(i,nx+3,k+1,l) = 0.   20 continue   30 continue      do 50 j = 1, nx3      do 40 i = 1, 3      cu(i,j,1,l) = 0.      cu(i,j,nyp3-1,l) = 0.      cu(i,j,nyp3,l) = 0.   40 continue   50 continue   60 continue      return      endc-----------------------------------------------------------------------      subroutine PSCGUARD22(cu,nyp,xj0,yj0,nx,nxe,nypmx,nblok)c initialize extended periodic fieldc quadratic interpolation, for distributed data      implicit none      real cu, xj0, yj0      integer nyp, nx, nxe, nypmx, nblok      dimension cu(2,nxe,nypmx,nblok), nyp(nblok)      integer i, j, k, l, nyp3, nx3c initialize extended field, with zero in the edges      nx3 = nx + 3      do 60 l = 1, nblok      nyp3 = nyp(l) + 3      do 30 k = 1, nyp(l)      do 10 j = 1, nx      cu(1,j+1,k+1,l) = xj0      cu(2,j+1,k+1,l) = yj0   10 continue      do 20 i = 1, 2      cu(i,1,k+1,l) = 0.      cu(i,nx+2,k+1,l) = 0.      cu(i,nx+3,k+1,l) = 0.   20 continue   30 continue      do 50 j = 1, nx3      do 40 i = 1, 2      cu(i,j,1,l) = 0.      cu(i,j,nyp3-1,l) = 0.      cu(i,j,nyp3,l) = 0.   40 continue   50 continue   60 continue      return      endc-----------------------------------------------------------------------      subroutine PSGUARD2(q,nyp,qi0,nx,nxe,nypmx,nblok)c initialize extended periodic scalar fieldc quadratic interpolation, for distributed data      implicit none      real q, qi0      integer nyp, nx, nxe, nypmx, nblok      dimension q(nxe,nypmx,nblok), nyp(nblok)      integer j, k, l, nyp3, nx3c initialize extended field, with zero in the edges      nx3 = nx + 3      do 40 l = 1, nblok      nyp3 = nyp(l) + 3      do 20 k = 1, nyp(l)      do 10 j = 1, nx      q(j+1,k+1,l) = qi0   10 continue      q(1,k+1,l) = 0.      q(nx+2,k+1,l) = 0.      q(nx+3,k+1,l) = 0.   20 continue      do 30 j = 1, nx3      q(j,1,l) = 0.      q(j,nyp3-1,l) = 0.      q(j,nyp3,l) = 0.   30 continue   40 continue      return      endc-----------------------------------------------------------------------      subroutine PACGUARD2X(cu,nyp,nx,nxe,nypmx,nblok)c accumulate extended periodic fieldc quadratic interpolation, for distributed data      implicit none      real cu      integer nyp, nx, nxe, nypmx, nblok      dimension cu(3,nxe,nypmx,nblok), nyp(nblok)      integer i, k, l, nyp3c accumulate edges of extended field      do 30 l = 1, nblok      nyp3 = nyp(l) + 3      do 20 k = 1, nyp3      do 10 i = 1, 3      cu(i,2,k,l) = cu(i,2,k,l) + cu(i,nx+2,k,l)      cu(i,3,k,l) = cu(i,3,k,l) + cu(i,nx+3,k,l)      cu(i,nx+1,k,l) = cu(i,nx+1,k,l) + cu(i,1,k,l)   10 continue   20 continue   30 continue      return      endc-----------------------------------------------------------------------      subroutine PACGUARD22X(cu,nyp,nx,nxe,nypmx,nblok)c accumulate extended periodic fieldc quadratic interpolation, for distributed data      implicit none      real cu      integer nyp, nx, nxe, nypmx, nblok      dimension cu(2,nxe,nypmx,nblok), nyp(nblok)      integer i, k, l, nyp3c accumulate edges of extended field      do 30 l = 1, nblok      nyp3 = nyp(l) + 3      do 20 k = 1, nyp3      do 10 i = 1, 2      cu(i,2,k,l) = cu(i,2,k,l) + cu(i,nx+2,k,l)      cu(i,3,k,l) = cu(i,3,k,l) + cu(i,nx+3,k,l)      cu(i,nx+1,k,l) = cu(i,nx+1,k,l) + cu(i,1,k,l)   10 continue   20 continue   30 continue      return      endc-----------------------------------------------------------------------      subroutine PAGUARD2X(q,nyp,nx,nxe,nypmx,nblok)c accumulate extended periodic scalar fieldc quadratic interpolation, for distributed data      implicit none      real q      integer nyp, nx, nxe, nypmx, nblok      dimension q(nxe,nypmx,nblok), nyp(nblok)      integer k, l, nyp3c accumulate edges of extended field      do 20 l = 1, nblok      nyp3 = nyp(l) + 3      do 10 k = 1, nyp3      q(2,k,l) = q(2,k,l) + q(nx+2,k,l)      q(3,k,l) = q(3,k,l) + q(nx+3,k,l)      q(nx+1,k,l) = q(nx+1,k,l) + q(1,k,l)   10 continue   20 continue      return      endc-----------------------------------------------------------------------      subroutine PCGUARD2XL(fxy,nyp,nx,nxe,nypmx,nblok)c replicate extended periodic fieldc linear interpolation, for distributed data      implicit none      real fxy      integer nyp, nx, nxe, nypmx, nblok      dimension fxy(2,nxe,nypmx,nblok), nyp(nblok)      integer k, l, nyp1      do 20 l = 1, nblok      nyp1 = nyp(l) + 1      do 10 k = 1, nyp1      fxy(1,nx+1,k,l) = fxy(1,1,k,l)      fxy(2,nx+1,k,l) = fxy(2,1,k,l)   10 continue   20 continue      return      endc-----------------------------------------------------------------------      subroutine PDGUARD2XL(q,nyp,nx,nxe,nypmx,nblok)c replicate extended periodic scalar fieldc linear interpolation, for distributed data      implicit none      real q      integer nyp, nx, nxe, nypmx, nblok      dimension q(nxe,nypmx,nblok), nyp(nblok)      integer k, l, nyp1      do 20 l = 1, nblok      nyp1 = nyp(l) + 1      do 10 k = 1, nyp1      q(nx+1,k,l) = q(1,k,l)   10 continue   20 continue      return      endc-----------------------------------------------------------------------      subroutine PBGUARD2XL(bxy,nyp,nx,nxe,nypmx,nblok)c replicate extended periodic vector fieldc linear interpolation, for distributed data      implicit none      real bxy      integer nyp, nx, nxe, nypmx, nblok      dimension bxy(3,nxe,nypmx,nblok), nyp(nblok)      integer k, l, nyp1      do 20 l = 1, nblok      nyp1 = nyp(l) + 1      do 10 k = 1, nyp1      bxy(1,nx+1,k,l) = bxy(1,1,k,l)      bxy(2,nx+1,k,l) = bxy(2,1,k,l)      bxy(3,nx+1,k,l) = bxy(3,1,k,l)   10 continue   20 continue      return      endc-----------------------------------------------------------------------      subroutine PSCGUARD2L(cu,nyp,xj0,yj0,zj0,nx,nxe,nypmx,nblok)c initialize extended periodic fieldc linear interpolation, for distributed data      implicit none      real cu, xj0, yj0, zj0      integer nyp, nx, nxe, nypmx, nblok      dimension cu(3,nxe,nypmx,nblok), nyp(nblok)      integer i, j, k, l, nyp1, nx1c initialize extended field, with zero in the edges      nx1 = nx + 1      do 60 l = 1, nblok      nyp1 = nyp(l) + 1      do 30 k = 1, nyp(l)      do 10 j = 1, nx      cu(1,j,k,l) = xj0      cu(2,j,k,l) = yj0      cu(3,j,k,l) = zj0   10 continue      do 20 i = 1, 3      cu(i,nx+1,k,l) = 0.   20 continue   30 continue      do 50 j = 1, nx1      do 40 i = 1, 3      cu(i,j,nyp1,l) = 0.   40 continue   50 continue   60 continue      return      endc-----------------------------------------------------------------------      subroutine PSCGUARD22L(cu,nyp,xj0,yj0,nx,nxe,nypmx,nblok)c initialize extended periodic fieldc linear interpolation, for distributed data      implicit none      real cu, xj0, yj0      integer nyp, nx, nxe, nypmx, nblok      dimension cu(2,nxe,nypmx,nblok), nyp(nblok)      integer i, j, k, l, nyp1, nx1c initialize extended field, with zero in the edges      nx1 = nx + 1      do 60 l = 1, nblok      nyp1 = nyp(l) + 1      do 30 k = 1, nyp(l)      do 10 j = 1, nx      cu(1,j,k,l) = xj0      cu(2,j,k,l) = yj0   10 continue      do 20 i = 1, 2      cu(i,nx+1,k,l) = 0.   20 continue   30 continue      do 50 j = 1, nx1      do 40 i = 1, 2      cu(i,j,nyp1,l) = 0.   40 continue   50 continue   60 continue      return      endc-----------------------------------------------------------------------      subroutine PSGUARD2L(q,nyp,qi0,nx,nxe,nypmx,nblok)c initialize extended periodic scalar fieldc linear interpolation, for distributed data      implicit none      real q, qi0      integer nyp, nx, nxe, nypmx, nblok      dimension q(nxe,nypmx,nblok), nyp(nblok)      integer j, k, l, nyp1, nx1c initialize extended field, with zero in the edges      nx1 = nx + 1      do 40 l = 1, nblok      nyp1 = nyp(l) + 1      do 20 k = 1, nyp(l)      do 10 j = 1, nx      q(j,k,l) = qi0   10 continue      q(nx+1,k,l) = 0.   20 continue      do 30 j = 1, nx1      q(j,nyp1,l) = 0.   30 continue   40 continue      return      endc-----------------------------------------------------------------------      subroutine PACGUARD2XL(cu,nyp,nx,nxe,nypmx,nblok)c accumulate extended periodic fieldc linear interpolation, for distributed data      implicit none      real cu      integer nyp, nx, nxe, nypmx, nblok      dimension cu(3,nxe,nypmx,nblok), nyp(nblok)      integer i, k, l, nyp1c accumulate edges of extended field      do 30 l = 1, nblok      nyp1 = nyp(l) + 1      do 20 k = 1, nyp1      do 10 i = 1, 3      cu(i,1,k,l) = cu(i,1,k,l) + cu(i,nx+1,k,l)   10 continue   20 continue   30 continue      return      endc-----------------------------------------------------------------------      subroutine PACGUARD22XL(cu,nyp,nx,nxe,nypmx,nblok)c accumulate extended periodic fieldc linear interpolation, for distributed data      implicit none      real cu      integer nyp, nx, nxe, nypmx, nblok      dimension cu(2,nxe,nypmx,nblok), nyp(nblok)      integer i, k, l, nyp1c accumulate edges of extended field      do 30 l = 1, nblok      nyp1 = nyp(l) + 1      do 20 k = 1, nyp1      do 10 i = 1, 2      cu(i,1,k,l) = cu(i,1,k,l) + cu(i,nx+1,k,l)   10 continue   20 continue   30 continue      return      endc-----------------------------------------------------------------------      subroutine PAGUARD2XL(q,nyp,nx,nxe,nypmx,nblok)c accumulate extended periodic scalar fieldc linear interpolation, for distributed data      implicit none      real q      integer nyp, nx, nxe, nypmx, nblok      dimension q(nxe,nypmx,nblok), nyp(nblok)      integer k, l, nyp1c accumulate edges of extended field      do 20 l = 1, nblok      nyp1 = nyp(l) + 1      do 10 k = 1, nyp1      q(1,k,l) = q(1,k,l) + q(nx+1,k,l)   10 continue   20 continue      return      endc-----------------------------------------------------------------------      subroutine PPOISP2(q,fx,fy,isign,ffc,ax,ay,affp,we,nx,ny,kstrt,nyv     1,kxp,jblok,nyhd)c this subroutine solves 2d poisson's equation in fourier space forc force/charge (or convolution of electric field over particle shape)c or for potential, or provides a smoothing function,c with periodic boundary conditions for distributed data.c for isign = 0, input: isign,ax,ay,affp,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: ffcc for isign = -1, input: q,ffc,isign,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: fx,fy,wec approximate flop count is: 33*nxc*nyc + 15*(nxc + nyc)c for isign = 1, input: q,ffc,isign,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: fx,wec approximate flop count is: 21*nxc*nyc + 11*(nxc + nyc)c for isign = 2, input: q,ffc,isign,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: fyc approximate flop count is: 4*nxc*nyc + 2*(nxc + nyc)c where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc if isign < 0, force/charge is calculated using the equations:c fx(kx,ky) = -sqrt(-1)*kx*g(kx,ky)*q(kx,ky)*s(kx,ky),c fy(kx,ky) = -sqrt(-1)*ky*g(kx,ky)*q(kx,ky)*s(kx,ky),c where kx = 2pi*j/nx, ky = 2pi*k/ny, and j,k = fourier mode numbers,c g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky),c s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2), except forc fx(kx=pi) = fy(kx=pi) = fx(ky=pi) = fy(ky=pi) = 0, andc fx(kx=0,ky=0) = fy(kx=0,ky=0) = 0.c if isign = 1, potential is calculated using the equation:c fx(kx,ky) = g(kx,ky)*q(kx,ky)c if isign = 2, smoothing is calculated using the equation:c fy(kx,ky) = q(kx,ky)*s(kx,ky)c q(k,j,l) = complex charge density for fourier mode (jj-1,k-1)c fx(k,j,l) = x component of complex force/charge,c fy(k,j,l) = y component of complex force/charge,c for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c jblok = number of data blocksc kxp = number of data values per blockc kstrt = starting data block numberc if isign = 0, form factor array is preparedc aimag(ffc(k,j,l)) = finite-size particle shape factor sc real(ffc(k,j,l)) = potential green's function gc for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c ax/ay = half-width of particle in x/y directionc affp = normalization constant = nx*ny/np, where np=number of particlesc electric field energy is also calculated, usingc we = nx*ny*sum((affp/(kx**2+ky**2))*|q(kx,ky)*s(kx,ky)|**2)c nx/ny = system length in x/y directionc nyv = first dimension of field arrays, must be >= nyc nyhd = first dimension of form factor array, must be >= nyh      double precision wp      complex q, fx, fy, ffc, zero      dimension q(nyv,kxp,jblok)      dimension fx(nyv,kxp,jblok), fy(nyv,kxp,jblok)      dimension ffc(nyhd,kxp,jblok)      nxh = nx/2      nyh = ny/2      ny2 = ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx)      dny = 6.28318530717959/float(ny)      zero = cmplx(0.,0.)      if (isign.ne.0) go to 40      if (kstrt.gt.nxh) returnc prepare form factor array      do 30 l = 1, jblok      joff = kxp*(l + ks) - 1      do 20 j = 1, kxp      dkx = dnx*float(j + joff)      at1 = dkx*dkx      at2 = (dkx*ax)**2      do 10 k = 1, nyh      dky = dny*float(k - 1)      at3 = dky*dky + at1      at4 = exp(-.5*((dky*ay)**2 + at2))      if (at3.eq.0.) then         ffc(k,j,l) = cmplx(affp,1.)      else         ffc(k,j,l) = cmplx(affp*at4/at3,at4)      endif   10 continue   20 continue   30 continue      return   40 if (isign.gt.0) go to 100c calculate force/charge and sum field energy      wp = 0.0d0      if (kstrt.gt.nxh) go to 90      do 80 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 60 j = 1, kxp      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 50 k = 2, nyh         k1 = ny2 - k         at1 = real(ffc(k,j,l))*aimag(ffc(k,j,l))         at2 = dkx*at1         at3 = dny*float(k - 1)*at1         fx(k,j,l) = at2*cmplx(aimag(q(k,j,l)),-real(q(k,j,l)))         fx(k1,j,l) = at2*cmplx(aimag(q(k1,j,l)),-real(q(k1,j,l)))         fy(k,j,l) = at3*cmplx(aimag(q(k,j,l)),-real(q(k,j,l)))         fy(k1,j,l) = at3*cmplx(-aimag(q(k1,j,l)),real(q(k1,j,l)))         wp = wp + at1*(q(k,j,l)*conjg(q(k,j,l)) + q(k1,j,l)*conjg(q(k1,     1j,l)))   50    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         at1 = real(ffc(1,j,l))*aimag(ffc(1,j,l))         fx(1,j,l) = dkx*at1*cmplx(aimag(q(1,j,l)),-real(q(1,j,l)))         fx(k1,j,l) = zero         fy(1,j,l) = zero         fy(k1,j,l) = zero         wp = wp + at1*(q(1,j,l)*conjg(q(1,j,l)))      endif   60 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 70 k = 2, nyh         k1 = ny2 - k         at1 = real(ffc(k,1,l))*aimag(ffc(k,1,l))         fx(k,1,l) = zero         fx(k1,1,l) = zero         fy(k,1,l) = dny*float(k - 1)*at1*cmplx(aimag(q(k,1,l)),-real(q(     1k,1,l)))         fy(k1,1,l) = zero         wp = wp + at1*(q(k,1,l)*conjg(q(k,1,l)))   70    continue         k1 = nyh + 1         fx(1,1,l) = zero         fx(k1,1,l) = zero         fy(1,1,l) = zero         fy(k1,1,l) = zero      endif   80 continue   90 continue      we = float(nx*ny)*wp      returnc calculate potential and sum field energy  100 if (isign.gt.1) go to 160      wp = 0.0d0      if (kstrt.gt.nxh) go to 150      do 140 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 120 j = 1, kxp      if ((j+joff).gt.0) then         do 110 k = 2, nyh         k1 = ny2 - k         at2 = real(ffc(k,j,l))         at1 = at2*aimag(ffc(k,j,l))         fx(k,j,l) = at2*q(k,j,l)         fx(k1,j,l) = at2*q(k1,j,l)         wp = wp + at1*(q(k,j,l)*conjg(q(k,j,l)) + q(k1,j,l)*conjg(q(k1,     1j,l)))  110    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         at2 = real(ffc(1,j,l))         at1 = at2*aimag(ffc(1,j,l))         fx(1,j,l) = at2*q(1,j,l)         fx(k1,j,l) = zero         wp = wp + at1*(q(1,j,l)*conjg(q(1,j,l)))      endif  120 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 130 k = 2, nyh         k1 = ny2 - k         at2 = real(ffc(k,1,l))         at1 = at2*aimag(ffc(k,1,l))         fx(k,1,l) = at2*q(k,1,l)         fx(k1,1,l) = zero         wp = wp + at1*(q(k,1,l)*conjg(q(k,1,l)))  130    continue         k1 = nyh + 1         fx(1,1,l) = zero         fx(k1,1,l) = zero      endif  140 continue  150 continue      we = float(nx*ny)*wp      returnc calculate smoothing  160 if (kstrt.gt.nxh) go to 210      do 200 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 180 j = 1, kxp      if ((j+joff).gt.0) then         do 170 k = 2, nyh         k1 = ny2 - k         at1 = aimag(ffc(k,j,l))         fy(k,j,l) = at1*q(k,j,l)         fy(k1,j,l) = at1*q(k1,j,l)  170    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         at1 = aimag(ffc(1,j,l))         fy(1,j,l) = at1*q(1,j,l)         fy(k1,j,l) = zero      endif  180 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 190 k = 2, nyh         k1 = ny2 - k         at1 = aimag(ffc(k,1,l))         fy(k,1,l) = at1*q(k,1,l)         fy(k1,1,l) = zero  190    continue         k1 = nyh + 1         fy(1,1,l) = cmplx(aimag(ffc(1,1,l))*real(q(1,1,l)),0.)         fy(k1,1,l) = zero      endif  200 continue  210 continue      return      endc-----------------------------------------------------------------------      subroutine PPOIS22(q,fxy,isign,ffc,ax,ay,affp,we,nx,ny,kstrt,nyv,k     1xp,jblok,nyhd)c this subroutine solves 2d poisson's equation in fourier space forc force/charge (or convolution of electric field over particle shape)c with periodic boundary conditions, for distributed data.c for isign = 0, input: isign,ax,ay,affp,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: ffcc for isign /= 0, input: q,ffc,isign,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: fxy,wec approximate flop count is: 33*nxc*nyc + 15*(nxc + nyc)c where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc the equation used is:c fx(kx,ky) = -sqrt(-1)*kx*g(kx,ky)*s(kx,ky)*q(kx,ky),c fy(kx,ky) = -sqrt(-1)*ky*g(kx,ky)*s(kx,ky)*q(kx,ky),c where kx = 2pi*j/nx, ky = 2pi*k/ny, and j,k = fourier mode numbers,c g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky),c s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2), except forc fx(kx=pi) = fy(kx=pi) = fx(ky=pi) = fy(ky=pi) = 0, andc fx(kx=0,ky=0) = fy(kx=0,ky=0) = 0.c q(k,j,l) = complex charge density for fourier mode (jj-1,k-1)c fxy(1,k,j,l) = x component of complex force/charge,c fxy(2,k,j,l) = y component of complex force/charge,c for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c jblok = number of data blocksc kxp = number of data values per blockc kstrt = starting data block numberc if isign = 0, form factor array is preparedc if isign is not equal to 0, force/charge is calculated.c aimag(ffc(k,j,l)) = finite-size particle shape factor sc real(ffc(k,j,l)) = potential green's function gc for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c ax/ay = half-width of particle in x/y directionc affp = normalization constant = nx*ny/np, where np=number of particlesc electric field energy is also calculated, usingc we = nx*ny*sum((affp/(kx**2+ky**2))*|q(kx,ky)*s(kx,ky)|**2)c nx/ny = system length in x/y directionc nyv = first dimension of field arrays, must be >= nyc nyhd = first dimension of form factor array, must be >= nyh      double precision wp      complex q, fxy, ffc, zero, zt1, zt2      dimension q(nyv,kxp,jblok), fxy(2,nyv,kxp,jblok)      dimension ffc(nyhd,kxp,jblok)      nxh = nx/2      nyh = ny/2      ny2 = ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx)      dny = 6.28318530717959/float(ny)      zero = cmplx(0.,0.)      if (isign.ne.0) go to 40      if (kstrt.gt.nxh) returnc prepare form factor array      do 30 l = 1, jblok      joff = kxp*(l + ks) - 1      do 20 j = 1, kxp      dkx = dnx*float(j + joff)      at1 = dkx*dkx      at2 = (dkx*ax)**2      do 10 k = 1, nyh      dky = dny*float(k - 1)      at3 = dky*dky + at1      at4 = exp(-.5*((dky*ay)**2 + at2))      if (at3.eq.0.) then         ffc(k,j,l) = cmplx(affp,1.)      else         ffc(k,j,l) = cmplx(affp*at4/at3,at4)      endif   10 continue   20 continue   30 continue      returnc calculate force/charge and sum field energy   40 wp = 0.0d0      if (kstrt.gt.nxh) go to 90      do 80 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 60 j = 1, kxp      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 50 k = 2, nyh         k1 = ny2 - k         at1 = real(ffc(k,j,l))*aimag(ffc(k,j,l))         at2 = dkx*at1         at3 = dny*float(k - 1)*at1         zt1 = cmplx(aimag(q(k,j,l)),-real(q(k,j,l)))         zt2 = cmplx(aimag(q(k1,j,l)),-real(q(k1,j,l)))         fxy(1,k,j,l) = at2*zt1         fxy(2,k,j,l) = at3*zt1         fxy(1,k1,j,l) = at2*zt2         fxy(2,k1,j,l) = -at3*zt2         wp = wp + at1*(q(k,j,l)*conjg(q(k,j,l)) + q(k1,j,l)*conjg(q(k1,     1j,l)))   50    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         at1 = real(ffc(1,j,l))*aimag(ffc(1,j,l))         at3 = dkx*at1         zt1 = cmplx(aimag(q(1,j,l)),-real(q(1,j,l)))         fxy(1,1,j,l) = at3*zt1         fxy(2,1,j,l) = zero         fxy(1,k1,j,l) = zero         fxy(2,k1,j,l) = zero         wp = wp + at1*(q(1,j,l)*conjg(q(1,j,l)))      endif   60 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 70 k = 2, nyh         k1 = ny2 - k         at1 = real(ffc(k,1,l))*aimag(ffc(k,1,l))         at2 = dny*float(k - 1)*at1         zt1 = cmplx(aimag(q(k,1,l)),-real(q(k,1,l)))         fxy(1,k,1,l) = zero         fxy(2,k,1,l) = at2*zt1         fxy(1,k1,1,l) = zero         fxy(2,k1,1,l) = zero         wp = wp + at1*(q(k,1,l)*conjg(q(k,1,l)))   70    continue         k1 = nyh + 1         fxy(1,1,1,l) = zero         fxy(2,1,1,l) = zero         fxy(1,k1,1,l) = zero         fxy(2,k1,1,l) = zero      endif   80 continue   90 continue      we = float(nx*ny)*wp      return      endc-----------------------------------------------------------------------      subroutine PPOIS23(q,fxy,isign,ffc,ax,ay,affp,we,nx,ny,kstrt,nyv,k     1xp,jblok,nyhd)c this subroutine solves 2d poisson's equation in fourier space forc force/charge (or convolution of electric field over particle shape)c with periodic boundary conditions.  Zeros out z component.c for distributed data.c for isign = 0, input: isign,ax,ay,affp,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: ffcc for isign /= 0, input: q,ffc,isign,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: fxy,wec approximate flop count is: 33*nxc*nyc + 15*(nxc + nyc)c where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc the equation used is:c fx(kx,ky) = -sqrt(-1)*kx*g(kx,ky)*s(kx,ky)*q(kx,ky),c fy(kx,ky) = -sqrt(-1)*ky*g(kx,ky)*s(kx,ky)*q(kx,ky),c fz(kx,ky) = zero,c where kx = 2pi*j/nx, ky = 2pi*k/ny, and j,k = fourier mode numbers,c g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky),c s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2), except forc fx(kx=pi) = fy(kx=pi) = fx(ky=pi) = fy(ky=pi) = 0, andc fx(kx=0,ky=0) = fy(kx=0,ky=0) = 0.c q(k,j,l) = complex charge density for fourier mode (jj-1,k-1)c fxy(1,k,j,l) = x component of complex force/charge,c fxy(2,k,j,l) = y component of complex force/charge,c fxy(3,k,j,l) = zero,c for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c jblok = number of data blocksc kxp = number of data values per blockc kstrt = starting data block numberc if isign = 0, form factor array is preparedc if isign is not equal to 0, force/charge is calculated.c aimag(ffc(k,j,l)) = finite-size particle shape factor sc real(ffc(k,j,l)) = potential green's function gc for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c ax/ay = half-width of particle in x/y directionc affp = normalization constant = nx*ny/np, where np=number of particlesc electric field energy is also calculated, usingc we = nx*ny*sum((affp/(kx**2+ky**2))*|q(kx,ky)*s(kx,ky)|**2)c nx/ny = system length in x/y directionc nyv = first dimension of field arrays, must be >= nyc nyhd = first dimension of form factor array, must be >= nyh      double precision wp      complex q, fxy, ffc, zero, zt1, zt2      dimension q(nyv,kxp,jblok), fxy(3,nyv,kxp,jblok)      dimension ffc(nyhd,kxp,jblok)      nxh = nx/2      nyh = ny/2      ny2 = ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx)      dny = 6.28318530717959/float(ny)      zero = cmplx(0.,0.)      if (isign.ne.0) go to 40      if (kstrt.gt.nxh) returnc prepare form factor array      do 30 l = 1, jblok      joff = kxp*(l + ks) - 1      do 20 j = 1, kxp      dkx = dnx*float(j + joff)      at1 = dkx*dkx      at2 = (dkx*ax)**2      do 10 k = 1, nyh      dky = dny*float(k - 1)      at3 = dky*dky + at1      at4 = exp(-.5*((dky*ay)**2 + at2))      if (at3.eq.0.) then         ffc(k,j,l) = cmplx(affp,1.)      else         ffc(k,j,l) = cmplx(affp*at4/at3,at4)      endif   10 continue   20 continue   30 continue      returnc calculate force/charge and sum field energy   40 wp = 0.0d0      if (kstrt.gt.nxh) go to 90      do 80 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 60 j = 1, kxp      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 50 k = 2, nyh         k1 = ny2 - k         at1 = real(ffc(k,j,l))*aimag(ffc(k,j,l))         at2 = dkx*at1         at3 = dny*float(k - 1)*at1         zt1 = cmplx(aimag(q(k,j,l)),-real(q(k,j,l)))         zt2 = cmplx(aimag(q(k1,j,l)),-real(q(k1,j,l)))         fxy(1,k,j,l) = at2*zt1         fxy(2,k,j,l) = at3*zt1         fxy(3,k,j,l) = zero         fxy(1,k1,j,l) = at2*zt2         fxy(2,k1,j,l) = -at3*zt2         fxy(3,k1,j,l) = zero         wp = wp + at1*(q(k,j,l)*conjg(q(k,j,l)) + q(k1,j,l)*conjg(q(k1,     1j,l)))   50    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         at1 = real(ffc(1,j,l))*aimag(ffc(1,j,l))         at3 = dkx*at1         zt1 = cmplx(aimag(q(1,j,l)),-real(q(1,j,l)))         fxy(1,1,j,l) = at3*zt1         fxy(2,1,j,l) = zero         fxy(3,1,j,l) = zero         fxy(1,k1,j,l) = zero         fxy(2,k1,j,l) = zero         fxy(3,k1,j,l) = zero         wp = wp + at1*(q(1,j,l)*conjg(q(1,j,l)))      endif   60 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 70 k = 2, nyh         k1 = ny2 - k         at1 = real(ffc(k,1,l))*aimag(ffc(k,1,l))         at2 = dny*float(k - 1)*at1         zt1 = cmplx(aimag(q(k,1,l)),-real(q(k,1,l)))         fxy(1,k,1,l) = zero         fxy(2,k,1,l) = at2*zt1         fxy(3,k,1,l) = zero         fxy(1,k1,1,l) = zero         fxy(2,k1,1,l) = zero         fxy(3,k1,1,l) = zero         wp = wp + at1*(q(k,1,l)*conjg(q(k,1,l)))   70    continue         k1 = nyh + 1         fxy(1,1,1,l) = zero         fxy(2,1,1,l) = zero         fxy(3,1,1,l) = zero         fxy(1,k1,1,l) = zero         fxy(2,k1,1,l) = zero         fxy(3,k1,1,l) = zero      endif   80 continue   90 continue      we = float(nx*ny)*wp      return      endc-----------------------------------------------------------------------      subroutine PDIVF2(f,df,nx,ny,kstrt,ndim,nyv,kxp,jblok)c this subroutine calculates the divergence in fourier spacec input: all except df, output: dfc approximate flop count is: 16*nxc*nyc + 5*(nxc + nyc)c where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc the divergence is calculated using the equation:c df(kx,ky) = sqrt(-1)*(kx*fx(kx,ky)+ky*fy(kx,ky))c where kx = 2pi*j/nx, ky = 2pi*k/ny, and j,k = fourier mode numbers,c except for df(kx=pi) = df(ky=pi) = df(kx=0,ky=0) = 0.c nx/ny = system length in x/y directionc ndim = number of field arrays, must be >= 2c kstrt = starting data block numberc nyv = first dimension of field arrays, must be >= nyc kxp = number of data values per blockc jblok = number of data blocks      complex f, df, zero, zt1      dimension f(ndim,nyv,kxp,jblok), df(nyv,kxp,jblok)      if (ndim.lt.2) return      nxh = nx/2      nyh = ny/2      ny2 = ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx)      dny = 6.28318530717959/float(ny)      zero = cmplx(0.,0.)c calculate the divergence      if (kstrt.gt.nxh) return      do 40 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 20 j = 1, kxp      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 10 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         zt1 = dkx*f(1,k,j,l) + dky*f(2,k,j,l)         df(k,j,l) = cmplx(-aimag(zt1),real(zt1))         zt1 = dkx*f(1,k1,j,l) - dky*f(2,k1,j,l)         df(k1,j,l) = cmplx(-aimag(zt1),real(zt1))   10    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         df(1,j,l) = dkx*cmplx(-aimag(f(1,1,j,l)),real(f(1,1,j,l)))         df(k1,j,l) = zero      endif   20 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 30 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         df(k,1,l) = dky*cmplx(-aimag(f(2,k,1,l)),real(f(2,k,1,l)))         df(k1,1,l) = zero   30    continue         k1 = nyh + 1         df(1,1,l) = zero         df(k1,1,l) = zero      endif   40 continue      return      endc-----------------------------------------------------------------------      subroutine PGRADF2(df,f,nx,ny,kstrt,ndim,nyv,kxp,jblok)c this subroutine calculates the gradient in fourier spacec input: all except f, output: fc approximate flop count is: 12*nxc*nyc + 4*(nxc + nyc)c where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc the gradient is calculated using the equations:c fx(kx,ky) = sqrt(-1)*kx*df(kx,ky)c fy(kx,ky) = sqrt(-1)*ky*df(kx,ky)c where kx = 2pi*j/nx, ky = 2pi*k/ny, and j,k = fourier mode numbers,c except for fx(kx=pi) = fy(kx=pi) = 0, fx(ky=pi) = fy(ky=pi) = 0,c and fx(kx=0,ky=0) = fy(kx=0,ky=0) = 0.c nx/ny = system length in x/y directionc ndim = number of field arrays, must be >= 2c kstrt = starting data block numberc nyv = first dimension of field arrays, must be >= nyc kxp = number of data values per blockc jblok = number of data blocks      complex df, f, zero, zt1      dimension df(nyv,kxp,jblok), f(ndim,nyv,kxp,jblok)      nxh = nx/2      nyh = ny/2      ny2 = ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx)      dny = 6.28318530717959/float(ny)      zero = cmplx(0.,0.)c calculate the gradient      if (kstrt.gt.nxh) return      do 40 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 20 j = 1, kxp      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 10 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         zt1 = cmplx(-aimag(df(k,j,l)),real(df(k,j,l)))         f(1,k,j,l) = dkx*zt1         f(2,k,j,l) = dky*zt1         zt1 = cmplx(-aimag(df(k1,j,l)),real(df(k1,j,l)))         f(1,k1,j,l) = dkx*zt1         f(2,k1,j,l) = -dky*zt1   10    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         f(1,1,j,l) = dkx*cmplx(-aimag(df(1,j,l)),real(df(1,j,l)))         f(2,1,j,l) = zero         f(1,k1,j,l) = zero         f(2,k1,j,l) = zero      endif   20 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 30 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         f(1,k,1,l) = zero         f(2,k,1,l) = dky*cmplx(-aimag(df(k,1,l)),real(df(k,1,l)))         f(1,k1,1,l) = zero         f(2,k1,1,l) = zero   30    continue         k1 = nyh + 1         f(1,1,1,l) = zero         f(2,1,1,l) = zero         f(1,k1,1,l) = zero         f(2,k1,1,l) = zero      endif   40 continue      return      endc-----------------------------------------------------------------------      subroutine PCURLF2(f,g,nx,ny,kstrt,nyv,kxp,jblok)c this subroutine calculates the curl in fourier spacec input: all except g, output: gc approximate flop count is: 32*nxc*nyc + 10*(nxc + nyc)c where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc the curl is calculated using the equations:c gx(kx,ky) = sqrt(-1)*ky*fz(kx,ky)c gy(kx,ky) = -sqrt(-1)*kx*fz(kx,ky)c gz(kx,ky) = sqrt(-1)*(kx*fy(kx,ky)-ky*fx(kx,ky))c where kx = 2pi*j/nx, ky = 2pi*k/ny, and j,k = fourier mode numbers,c except for gx(kx=pi) = gy(kx=pi) = 0, gx(ky=pi) = gy(ky=pi) = 0,c and gx(kx=0,ky=0) = gy(kx=0,ky=0) = 0.c nx/ny = system length in x/y directionc kstrt = starting data block numberc nyv = first dimension of field arrays, must be >= nyc kxp = number of data values per blockc jblok = number of data blocks      complex f, g, zero, zt1, zt2, zt3      dimension f(3,nyv,kxp,jblok), g(3,nyv,kxp,jblok)      nxh = nx/2      nyh = ny/2      ny2 = ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx)      dny = 6.28318530717959/float(ny)      zero = cmplx(0.,0.)c calculate the curl      if (kstrt.gt.nxh) return      do 40 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 20 j = 1, kxp      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 10 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         zt1 = cmplx(-aimag(f(3,k,j,l)),real(f(3,k,j,l)))         zt2 = cmplx(-aimag(f(2,k,j,l)),real(f(2,k,j,l)))         zt3 = cmplx(-aimag(f(1,k,j,l)),real(f(1,k,j,l)))         g(1,k,j,l) = dky*zt1         g(2,k,j,l) = -dkx*zt1         g(3,k,j,l) = dkx*zt2 - dky*zt3         zt1 = cmplx(-aimag(f(3,k1,j,l)),real(f(3,k1,j,l)))         zt2 = cmplx(-aimag(f(2,k1,j,l)),real(f(2,k1,j,l)))         zt3 = cmplx(-aimag(f(1,k1,j,l)),real(f(1,k1,j,l)))         g(1,k1,j,l) = -dky*zt1         g(2,k1,j,l) = -dkx*zt1         g(3,k1,j,l) = dkx*zt2 + dky*zt3   10    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         zt1 = cmplx(-aimag(f(3,1,j,l)),real(f(3,1,j,l)))         zt2 = cmplx(-aimag(f(2,1,j,l)),real(f(2,1,j,l)))         g(1,1,j,l) = zero         g(2,1,j,l) = -dkx*zt1         g(3,1,j,l) = dkx*zt2         g(1,k1,j,l) = zero         g(2,k1,j,l) = zero         g(3,k1,j,l) = zero      endif   20 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 30 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         zt1 = cmplx(-aimag(f(3,k,1,l)),real(f(3,k,1,l)))         zt2 = cmplx(-aimag(f(1,k,1,l)),real(f(1,k,1,l)))         g(1,k,1,l) = dky*zt1         g(2,k,1,l) = zero         g(3,k,1,l) = -dky*zt2         g(1,k1,1,l) = zero         g(2,k1,1,l) = zero         g(3,k1,1,l) = zero   30    continue         k1 = nyh + 1         g(1,1,1,l) = zero         g(2,1,1,l) = zero         g(3,1,1,l) = zero         g(1,k1,1,l) = zero         g(2,k1,1,l) = zero         g(2,k1,1,l) = zero      endif   40 continue      return      endc-----------------------------------------------------------------------      subroutine PCUPERP2(cu,nx,ny,kstrt,nyv,kxp,jblok)c this subroutine calculates the transverse current in fourier spacec input: all, output: cuc approximate flop count is: 36*nxc*nycc and nxc*nyc dividesc where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc the transverse current is calculated using the equation:c cux(kx,ky) = cux(kx,ky)-kx*(kx*cux(kx,ky)+ky*cuy(kx,ky))/(kx*kx+ky*ky)c cuy(kx,ky) = cuy(kx,ky)-ky*(kx*cux(kx,ky)+ky*cuy(kx,ky))/(kx*kx+ky*ky)c where kx = 2pi*j/nx, ky = 2pi*k/ny, and j,k = fourier mode numbers,c except for cux(kx=pi) = cuy(kx=pi) = 0, cux(ky=pi) = cuy(ky=pi) = 0,c and cux(kx=0,ky=0) = cuy(kx=0,ky=0) = 0.c cu(i,k,j,l) = i-th component of complex current density andc for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c nx/ny = system length in x/y directionc kstrt = starting data block numberc nyv = first dimension of field arrays, must be >= nyc kxp = number of data values per blockc jblok = number of data blocks      complex cu, zero, zt1      dimension cu(3,nyv,kxp,jblok)      nxh = nx/2      nyh = ny/2      ny2 = ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx)      dny = 6.28318530717959/float(ny)      zero = cmplx(0.,0.)c calculate transverse part of current      if (kstrt.gt.nxh) return      do 40 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 20 j = 1, kxp      dkx = dnx*float(j + joff)      dkx2 = dkx*dkx      if ((j+joff).gt.0) then         do 10 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         at1 = 1./(dky*dky + dkx2)         zt1 = at1*(dkx*cu(1,k,j,l) + dky*cu(2,k,j,l))         cu(1,k,j,l) = cu(1,k,j,l) - dkx*zt1         cu(2,k,j,l) = cu(2,k,j,l) - dky*zt1         zt1 = at1*(dkx*cu(1,k1,j,l) - dky*cu(2,k1,j,l))         cu(1,k1,j,l) = cu(1,k1,j,l) - dkx*zt1         cu(2,k1,j,l) = cu(2,k1,j,l) + dky*zt1   10    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         cu(1,1,j,l) = zero         cu(1,k1,j,l) = zero         cu(2,k1,j,l) = zero      endif   20 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 30 k = 2, nyh         k1 = ny2 - k         cu(2,k,1,l) = zero         cu(1,k1,1,l) = zero         cu(2,k1,1,l) = zero   30    continue         k1 = nyh + 1         cu(1,1,1,l) = zero         cu(2,1,1,l) = zero         cu(1,k1,1,l) = zero         cu(2,k1,1,l) = zero      endif   40 continue      return      endc-----------------------------------------------------------------------      subroutine PCUPERP22(cu,nx,ny,kstrt,nyv,kxp,jblok)c this subroutine calculates the transverse current in fourier spacec input: all, output: cuc approximate flop count is: 36*nxc*nycc and nxc*nyc dividesc where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc the transverse current is calculated using the equation:c cux(kx,ky) = cux(kx,ky)-kx*(kx*cux(kx,ky)+ky*cuy(kx,ky))/(kx*kx+ky*ky)c cuy(kx,ky) = cuy(kx,ky)-ky*(kx*cux(kx,ky)+ky*cuy(kx,ky))/(kx*kx+ky*ky)c where kx = 2pi*j/nx, ky = 2pi*k/ny, and j,k = fourier mode numbers,c except for cux(kx=pi) = cuy(kx=pi) = 0, cux(ky=pi) = cuy(ky=pi) = 0,c and cux(kx=0,ky=0) = cuy(kx=0,ky=0) = 0.c cu(i,k,j,l) = i-th component of complex current density andc for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c nx/ny = system length in x/y directionc kstrt = starting data block numberc nyv = first dimension of field arrays, must be >= nyc kxp = number of data values per blockc jblok = number of data blocks      complex cu, zero, zt1      dimension cu(2,nyv,kxp,jblok)      nxh = nx/2      nyh = ny/2      ny2 = ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx)      dny = 6.28318530717959/float(ny)      zero = cmplx(0.,0.)c calculate transverse part of current      if (kstrt.gt.nxh) return      do 40 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 20 j = 1, kxp      dkx = dnx*float(j + joff)      dkx2 = dkx*dkx      if ((j+joff).gt.0) then         do 10 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         at1 = 1./(dky*dky + dkx2)         zt1 = at1*(dkx*cu(1,k,j,l) + dky*cu(2,k,j,l))         cu(1,k,j,l) = cu(1,k,j,l) - dkx*zt1         cu(2,k,j,l) = cu(2,k,j,l) - dky*zt1         zt1 = at1*(dkx*cu(1,k1,j,l) - dky*cu(2,k1,j,l))         cu(1,k1,j,l) = cu(1,k1,j,l) - dkx*zt1         cu(2,k1,j,l) = cu(2,k1,j,l) + dky*zt1   10    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         cu(1,1,j,l) = zero         cu(1,k1,j,l) = zero         cu(2,k1,j,l) = zero      endif   20 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 30 k = 2, nyh         k1 = ny2 - k         cu(2,k,1,l) = zero         cu(1,k1,1,l) = zero         cu(2,k1,1,l) = zero   30    continue         k1 = nyh + 1         cu(1,1,1,l) = zero         cu(2,1,1,l) = zero         cu(1,k1,1,l) = zero         cu(2,k1,1,l) = zero      endif   40 continue      return      endc-----------------------------------------------------------------------      subroutine PBPOISP23(cu,bxy,isign,ffc,ax,ay,affp,ci,wm,nx,ny,kstrt     1,nyv,kxp,jblok,nyhd)c this subroutine solves 2d poisson's equation in fourier space forc magnetic field (or convolution of magnetic field over particle shape)c or for vector potential, or provides a smoothing function,c with periodic boundary conditions for distributed data.c for isign = 0, input: isign,ax,ay,affp,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: ffcc for isign = -1, input: cu,ffc,isign,ci,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: bxy,wmc approximate flop count is: 85*nxc*nyc + 36*(nxc + nyc)c for isign = 1, input: cu,ffc,isign,ci,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: bxy,wmc approximate flop count is: 63*nxc*nyc + 33*(nxc + nyc)c for isign = 2, input: cu,ffc,isign,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: bxyc approximate flop count is: 12*nxc*nyc + 6*(nxc + nyc)c where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc if isign = 0, form factor array is preparedc if isign < 0, magnetic field is calculated using the equations:c bx(kx,ky) = ci*ci*sqrt(-1)*g(kx,ky)*ky*cuz(kx,ky)*s(kx,ky),c by(kx,ky) = -ci*ci*sqrt(-1)*g(kx,ky)*kx*cuz(kx,ky)*s(kx,ky),c bz(kx,ky) = ci*ci*sqrt(-1)*g(kx,ky)*(kx*cuy(kx,ky)-ky*cux(kx,ky))*c             s(kx,ky),c where kx = 2pi*j/nx, ky = 2pi*k/ny, and j,k = fourier mode numbers,c g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky),c s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2), except forc bx(kx=pi) = by(kx=pi) = bz(kx=pi) = 0,c bx(ky=pi) = by(ky=pi) = bz(ky=pi) = 0,c bx(kx=0,ky=0) = by(kx=0,ky=0) = bz(kx=0,ky=0) = 0.c if isign = 1, vector potential is calculated using the equation:c bx(kx,ky) = ci*ci*g(kx,ky)*cux(kx,ky)c by(kx,ky) = ci*ci*g(kx,ky)*cuy(kx,ky)c bz(kx,ky) = ci*ci*g(kx,ky)*cuz(kx,ky)c if isign = 2, smoothing is calculated using the equation:c bx(kx,ky) = cux(kx,ky)*s(kx,ky)c by(kx,ky) = cuy(kx,ky)*s(kx,ky)c bz(kx,ky) = cuz(kx,ky)*s(kx,ky)c cu(i,k,j,l) = i-th component of complex current density andc bxy(i,k,j,l) = i-th component of complex magnetic field,c for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c jblok = number of data blocksc kxp = number of data values per blockc kstrt = starting data block numberc aimag(ffc(k,j,l)) = finite-size particle shape factor sc real(ffc(k,j,l)) = potential green's function gc for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c ax/ay = half-width of particle in x/y directionc affp = normalization constant = nx*ny/np, where np=number of particlesc ci = reciprical of velocity of lightc magnetic field energy is also calculated, usingc wm = nx*ny*nz*sum((affp/(kx**2+ky**2+kz**2))*ci*cic    |cu(kx,ky,kz)*s(kx,ky,kz)|**2)c this expression is valid only if the current is divergence-freec nx/ny = system length in x/y directionc nyv = first dimension of field arrays, must be >= nyc nyhd = first dimension of form factor array, must be >= nyh      double precision wp      complex cu, bxy, ffc, zero, zt1, zt2, zt3      dimension cu(3,nyv,kxp,jblok)      dimension bxy(3,nyv,kxp,jblok)      dimension ffc(nyhd,kxp,jblok)      nxh = nx/2      nyh = ny/2      ny2 = ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx)      dny = 6.28318530717959/float(ny)      zero = cmplx(0.,0.)      ci2 = ci*ci      if (isign.ne.0) go to 40      if (kstrt.gt.nxh) returnc prepare form factor array      do 30 l = 1, jblok      joff = kxp*(l + ks) - 1      do 20 j = 1, kxp      dkx = dnx*float(j + joff)      at1 = dkx*dkx      at2 = (dkx*ax)**2      do 10 k = 1, nyh      dky = dny*float(k - 1)      at3 = dky*dky + at1      at4 = exp(-.5*((dky*ay)**2 + at2))      if (at3.eq.0.) then         ffc(k,j,l) = cmplx(affp,1.)      else         ffc(k,j,l) = cmplx(affp*at4/at3,at4)      endif   10 continue   20 continue   30 continue      return   40 if (isign.gt.0) go to 100c calculate magnetic field and sum field energy      wp = 0.0d0      if (kstrt.gt.nxh) go to 90      do 80 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 60 j = 1, kxp      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 50 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         at1 = ci2*real(ffc(k,j,l))*aimag(ffc(k,j,l))         at2 = dky*at1         at3 = dkx*at1         zt1 = cmplx(-aimag(cu(3,k,j,l)),real(cu(3,k,j,l)))         zt2 = cmplx(-aimag(cu(2,k,j,l)),real(cu(2,k,j,l)))         zt3 = cmplx(-aimag(cu(1,k,j,l)),real(cu(1,k,j,l)))         bxy(1,k,j,l) = at2*zt1         bxy(2,k,j,l) = -at3*zt1         bxy(3,k,j,l) = at3*zt2 - at2*zt3         zt1 = cmplx(-aimag(cu(3,k1,j,l)),real(cu(3,k1,j,l)))         zt2 = cmplx(-aimag(cu(2,k1,j,l)),real(cu(2,k1,j,l)))         zt3 = cmplx(-aimag(cu(1,k1,j,l)),real(cu(1,k1,j,l)))         bxy(1,k1,j,l) = -at2*zt1         bxy(2,k1,j,l) = -at3*zt1         bxy(3,k1,j,l) = at3*zt2 + at2*zt3         wp = wp + at1*(cu(1,k,j,l)*conjg(cu(1,k,j,l)) + cu(2,k,j,l)*con     1jg(cu(2,k,j,l)) + cu(3,k,j,l)*conjg(cu(3,k,j,l)) + cu(1,k1,j,l)*co     2njg(cu(1,k1,j,l)) + cu(2,k1,j,l)*conjg(cu(2,k1,j,l)) + cu(3,k1,j,l     3)*conjg(cu(3,k1,j,l)))   50    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         at1 = ci2*real(ffc(1,j,l))*aimag(ffc(1,j,l))         at2 = dkx*at1         zt1 = cmplx(-aimag(cu(3,1,j,l)),real(cu(3,1,j,l)))         zt2 = cmplx(-aimag(cu(2,1,j,l)),real(cu(2,1,j,l)))         bxy(1,1,j,l) = zero         bxy(2,1,j,l) = -at2*zt1         bxy(3,1,j,l) = at2*zt2         bxy(1,k1,j,l) = zero         bxy(2,k1,j,l) = zero         bxy(3,k1,j,l) = zero         wp = wp + at1*(cu(1,1,j,l)*conjg(cu(1,1,j,l)) + cu(2,1,j,l)*con     1jg(cu(2,1,j,l)) + cu(3,1,j,l)*conjg(cu(3,1,j,l)))      endif   60 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 70 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         at1 = ci2*real(ffc(k,1,l))*aimag(ffc(k,1,l))         at2 = dky*at1         zt1 = cmplx(-aimag(cu(3,k,1,l)),real(cu(3,k,1,l)))         zt2 = cmplx(-aimag(cu(1,k,1,l)),real(cu(1,k,1,l)))         bxy(1,k,1,l) = at2*zt1         bxy(2,k,1,l) = zero         bxy(3,k,1,l) = -at2*zt2         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero         bxy(3,k1,1,l) = zero         wp = wp + at1*(cu(1,k,1,l)*conjg(cu(1,k,1,l)) + cu(2,k,1,l)*con     1jg(cu(2,k,1,l)) + cu(3,k,1,l)*conjg(cu(3,k,1,l)))   70    continue         k1 = nyh + 1         bxy(1,1,1,l) = zero         bxy(2,1,1,l) = zero         bxy(3,1,1,l) = zero         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero         bxy(3,k1,1,l) = zero      endif   80 continue   90 continue      wm = float(nx*ny)*wp      returnc calculate vector potential and sum field energy  100 if (isign.gt.1) go to 160      wp = 0.0d0      if (kstrt.gt.nxh) go to 150      do 140 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 120 j = 1, kxp      if ((j+joff).gt.0) then         do 110 k = 2, nyh         k1 = ny2 - k         at2 = ci2*real(ffc(k,j,l))         at1 = at2*aimag(ffc(k,j,l))         bxy(1,k,j,l) = at2*cu(1,k,j,l)         bxy(2,k,j,l) = at2*cu(2,k,j,l)         bxy(3,k,j,l) = at2*cu(3,k,j,l)         bxy(1,k1,j,l) = at2*cu(1,k1,j,l)         bxy(2,k1,j,l) = at2*cu(2,k1,j,l)         bxy(3,k1,j,l) = at2*cu(3,k1,j,l)         wp = wp + at1*(cu(1,k,j,l)*conjg(cu(1,k,j,l)) + cu(2,k,j,l)*con     1jg(cu(2,k,j,l)) + cu(3,k,j,l)*conjg(cu(3,k,j,l)) + cu(1,k1,j,l)*co     2njg(cu(1,k1,j,l)) + cu(2,k1,j,l)*conjg(cu(2,k1,j,l)) + cu(3,k1,j,l     3)*conjg(cu(3,k1,j,l)))  110    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         at2 = ci2*real(ffc(1,j,l))         at1 = at2*aimag(ffc(1,j,l))         bxy(1,1,j,l) = at2*cu(1,1,j,l)         bxy(2,1,j,l) = at2*cu(2,1,j,l)         bxy(3,1,j,l) = at2*cu(3,1,j,l)         bxy(1,k1,j,l) = zero         bxy(2,k1,j,l) = zero         bxy(3,k1,j,l) = zero         wp = wp + at1*(cu(1,1,j,l)*conjg(cu(1,1,j,l)) + cu(2,1,j,l)*con     1jg(cu(2,1,j,l)) + cu(3,1,j,l)*conjg(cu(3,1,j,l)))      endif  120 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 130 k = 2, nyh         k1 = ny2 - k         at2 = ci2*real(ffc(k,1,l))         at1 = at2*aimag(ffc(k,1,l))         bxy(1,k,1,l) = at2*cu(1,k,1,l)         bxy(2,k,1,l) = at2*cu(2,k,1,l)         bxy(3,k,1,l) = at2*cu(3,k,1,l)         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero         bxy(3,k1,1,l) = zero         wp = wp + at1*(cu(1,k,1,l)*conjg(cu(1,k,1,l)) + cu(2,k,1,l)*con     1jg(cu(2,k,1,l)) + cu(3,k,1,l)*conjg(cu(3,k,1,l)))  130    continue         k1 = nyh + 1         bxy(1,1,1,l) = zero         bxy(2,1,1,l) = zero         bxy(3,1,1,l) = zero         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero         bxy(3,k1,1,l) = zero      endif  140 continue  150 continue      wm = float(nx*ny)*wp      returnc calculate smoothing  160 if (kstrt.gt.nxh) go to 210      do 200 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 180 j = 1, kxp      if ((j+joff).gt.0) then         do 170 k = 2, nyh         k1 = ny2 - k         at1 = aimag(ffc(k,j,l))         bxy(1,k,j,l) = at1*cu(1,k,j,l)         bxy(2,k,j,l) = at1*cu(2,k,j,l)         bxy(3,k,j,l) = at1*cu(3,k,j,l)         bxy(1,k1,j,l) = at1*cu(1,k1,j,l)         bxy(2,k1,j,l) = at1*cu(2,k1,j,l)         bxy(3,k1,j,l) = at1*cu(3,k1,j,l)  170    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         at1 = aimag(ffc(1,j,l))         bxy(1,1,j,l) = at1*cu(1,1,j,l)         bxy(2,1,j,l) = at1*cu(2,1,j,l)         bxy(3,1,j,l) = at1*cu(3,1,j,l)         bxy(1,k1,j,l) = zero         bxy(2,k1,j,l) = zero         bxy(3,k1,j,l) = zero      endif  180 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 190 k = 2, nyh         k1 = ny2 - k         at1 = aimag(ffc(k,1,l))         bxy(1,k,1,l) = at1*cu(1,k,1,l)         bxy(2,k,1,l) = at1*cu(2,k,1,l)         bxy(3,k,1,l) = at1*cu(3,k,1,l)         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero         bxy(3,k1,1,l) = zero  190    continue         k1 = nyh + 1         at1 = aimag(ffc(1,1,l))         bxy(1,1,1,l) = cmplx(at1*real(cu(1,1,1,l)),0.)         bxy(2,1,1,l) = cmplx(at1*real(cu(2,1,1,l)),0.)         bxy(3,1,1,l) = cmplx(at1*real(cu(3,1,1,l)),0.)         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero         bxy(3,k1,1,l) = zero      endif  200 continue  210 continue      return      endc-----------------------------------------------------------------------      subroutine PBPOISP22(cu,bxy,bz,isign,ffc,ax,ay,affp,ci,wm,nx,ny,ks     1trt,nyv,kxp,jblok,nyhd)c this subroutine solves 2d poisson's equation in fourier space forc magnetic field (or convolution of magnetic field over particle shape)c or for vector potential, or provides a smoothing function,c with periodic boundary conditions for distributed data.c for isign = 0, input: isign,ax,ay,affp,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: ffcc for isign = -1, input: cu,ffc,isign,ci,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: bz,wmc approximate flop count is: 55*nxc*nyc + 24*(nxc + nyc)c for isign = 1, input: cu,ffc,isign,ci,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: bxy,wmc approximate flop count is: 45*nxc*nyc + 24*(nxc + nyc)c for isign = 2, input: cu,ffc,isign,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: bxyc approximate flop count is: 8*nxc*nyc + 4*(nxc + nyc)c where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc if isign = 0, form factor array is preparedc if isign < 0, magnetic field is calculated using the equations:c bz(kx,ky) = ci*ci*sqrt(-1)*g(kx,ky)*(kx*cuy(kx,ky)-ky*cux(kx,ky))*c             s(kx,ky),c where kx = 2pi*j/nx, ky = 2pi*k/ny, and j,k = fourier mode numbers,c g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky),c s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2), except forc bz(kx=pi) = 0, bz(ky=pi) = 0, bz(kx=0,ky=0) = 0.c if isign = 1, vector potential is calculated using the equation:c bx(kx,ky) = ci*ci*g(kx,ky)*cux(kx,ky)c by(kx,ky) = ci*ci*g(kx,ky)*cuy(kx,ky)c if isign = 2, smoothing is calculated using the equation:c bx(kx,ky) = cux(kx,ky)*s(kx,ky)c by(kx,ky) = cuy(kx,ky)*s(kx,ky)c cu(i,k,j,l) = i-th component of complex current density andc bxy(i,k,j,l) = i-th component of complex vector potential,c bz(k,j,l) = z component of complex magnetic field,c for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c jblok = number of data blocksc kxp = number of data values per blockc kstrt = starting data block numberc aimag(ffc(k,j,l)) = finite-size particle shape factor sc real(ffc(k,j,l)) = potential green's function gc for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c ax/ay = half-width of particle in x/y directionc affp = normalization constant = nx*ny/np, where np=number of particlesc ci = reciprical of velocity of lightc magnetic field energy is also calculated, usingc wm = nx*ny*nz*sum((affp/(kx**2+ky**2+kz**2))*ci*cic    |cu(kx,ky,kz)*s(kx,ky,kz)|**2)c this expression is valid only if the current is divergence-freec nx/ny = system length in x/y directionc nyv = first dimension of field arrays, must be >= nyc nyhd = first dimension of form factor array, must be >= nyh      double precision wp      complex cu, bxy, bz, ffc, zero, zt2, zt3      dimension cu(2,nyv,kxp,jblok)      dimension bxy(2,nyv,kxp,jblok), bz(nyv,kxp,jblok)      dimension ffc(nyhd,kxp,jblok)      nxh = nx/2      nyh = ny/2      ny2 = ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx)      dny = 6.28318530717959/float(ny)      zero = cmplx(0.,0.)      ci2 = ci*ci      if (isign.ne.0) go to 40      if (kstrt.gt.nxh) returnc prepare form factor array      do 30 l = 1, jblok      joff = kxp*(l + ks) - 1      do 20 j = 1, kxp      dkx = dnx*float(j + joff)      at1 = dkx*dkx      at2 = (dkx*ax)**2      do 10 k = 1, nyh      dky = dny*float(k - 1)      at3 = dky*dky + at1      at4 = exp(-.5*((dky*ay)**2 + at2))      if (at3.eq.0.) then         ffc(k,j,l) = cmplx(affp,1.)      else         ffc(k,j,l) = cmplx(affp*at4/at3,at4)      endif   10 continue   20 continue   30 continue      return   40 if (isign.gt.0) go to 100c calculate magnetic field and sum field energy      wp = 0.0d0      if (kstrt.gt.nxh) go to 90      do 80 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 60 j = 1, kxp      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 50 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         at1 = ci2*real(ffc(k,j,l))*aimag(ffc(k,j,l))         at2 = dky*at1         at3 = dkx*at1         zt2 = cmplx(-aimag(cu(2,k,j,l)),real(cu(2,k,j,l)))         zt3 = cmplx(-aimag(cu(1,k,j,l)),real(cu(1,k,j,l)))         bz(k,j,l) = at3*zt2 - at2*zt3         zt2 = cmplx(-aimag(cu(2,k1,j,l)),real(cu(2,k1,j,l)))         zt3 = cmplx(-aimag(cu(1,k1,j,l)),real(cu(1,k1,j,l)))         bz(k1,j,l) = at3*zt2 + at2*zt3         wp = wp + at1*(cu(1,k,j,l)*conjg(cu(1,k,j,l)) + cu(2,k,j,l)*con     1jg(cu(2,k,j,l)) + cu(1,k1,j,l)*conjg(cu(1,k1,j,l)) + cu(2,k1,j,l)*     2conjg(cu(2,k1,j,l)))   50    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         at1 = ci2*real(ffc(1,j,l))*aimag(ffc(1,j,l))         at2 = dkx*at1         zt2 = cmplx(-aimag(cu(2,1,j,l)),real(cu(2,1,j,l)))         bz(1,j,l) = at2*zt2         bz(k1,j,l) = zero         wp = wp + at1*(cu(1,1,j,l)*conjg(cu(1,1,j,l)) + cu(2,1,j,l)*con     1jg(cu(2,1,j,l)))      endif   60 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 70 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         at1 = ci2*real(ffc(k,1,l))*aimag(ffc(k,1,l))         at2 = dky*at1         zt2 = cmplx(-aimag(cu(1,k,1,l)),real(cu(1,k,1,l)))         bz(k,1,l) = -at2*zt2         bz(k1,1,l) = zero         wp = wp + at1*(cu(1,k,1,l)*conjg(cu(1,k,1,l)) + cu(2,k,1,l)*con     1jg(cu(2,k,1,l)))   70    continue         k1 = nyh + 1         bz(1,1,l) = zero         bz(k1,1,l) = zero      endif   80 continue   90 continue      wm = float(nx*ny)*wp      returnc calculate vector potential and sum field energy  100 if (isign.gt.1) go to 160      wp = 0.0d0      if (kstrt.gt.nxh) go to 150      do 140 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 120 j = 1, kxp      if ((j+joff).gt.0) then         do 110 k = 2, nyh         k1 = ny2 - k         at2 = ci2*real(ffc(k,j,l))         at1 = at2*aimag(ffc(k,j,l))         bxy(1,k,j,l) = at2*cu(1,k,j,l)         bxy(2,k,j,l) = at2*cu(2,k,j,l)         bxy(1,k1,j,l) = at2*cu(1,k1,j,l)         bxy(2,k1,j,l) = at2*cu(2,k1,j,l)         wp = wp + at1*(cu(1,k,j,l)*conjg(cu(1,k,j,l)) + cu(2,k,j,l)*con     1jg(cu(2,k,j,l)) + cu(1,k1,j,l)*conjg(cu(1,k1,j,l)) + cu(2,k1,j,l)*     2conjg(cu(2,k1,j,l)))  110    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         at2 = ci2*real(ffc(1,j,l))         at1 = at2*aimag(ffc(1,j,l))         bxy(1,1,j,l) = at2*cu(1,1,j,l)         bxy(2,1,j,l) = at2*cu(2,1,j,l)         bxy(1,k1,j,l) = zero         bxy(2,k1,j,l) = zero         wp = wp + at1*(cu(1,1,j,l)*conjg(cu(1,1,j,l)) + cu(2,1,j,l)*con     1jg(cu(2,1,j,l)))      endif  120 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 130 k = 2, nyh         k1 = ny2 - k         at2 = ci2*real(ffc(k,1,l))         at1 = at2*aimag(ffc(k,1,l))         bxy(1,k,1,l) = at2*cu(1,k,1,l)         bxy(2,k,1,l) = at2*cu(2,k,1,l)         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero         wp = wp + at1*(cu(1,k,1,l)*conjg(cu(1,k,1,l)) + cu(2,k,1,l)*con     1jg(cu(2,k,1,l)))  130    continue         k1 = nyh + 1         bxy(1,1,1,l) = zero         bxy(2,1,1,l) = zero         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero      endif  140 continue  150 continue      wm = float(nx*ny)*wp      returnc calculate smoothing  160 if (kstrt.gt.nxh) go to 210      do 200 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 180 j = 1, kxp      if ((j+joff).gt.0) then         do 170 k = 2, nyh         k1 = ny2 - k         at1 = aimag(ffc(k,j,l))         bxy(1,k,j,l) = at1*cu(1,k,j,l)         bxy(2,k,j,l) = at1*cu(2,k,j,l)         bxy(1,k1,j,l) = at1*cu(1,k1,j,l)         bxy(2,k1,j,l) = at1*cu(2,k1,j,l)  170    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         at1 = aimag(ffc(1,j,l))         bxy(1,1,j,l) = at1*cu(1,1,j,l)         bxy(2,1,j,l) = at1*cu(2,1,j,l)         bxy(1,k1,j,l) = zero         bxy(2,k1,j,l) = zero      endif  180 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 190 k = 2, nyh         k1 = ny2 - k         at1 = aimag(ffc(k,1,l))         bxy(1,k,1,l) = at1*cu(1,k,1,l)         bxy(2,k,1,l) = at1*cu(2,k,1,l)         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero  190    continue         k1 = nyh + 1         at1 = aimag(ffc(1,1,l))         bxy(1,1,1,l) = cmplx(at1*real(cu(1,1,1,l)),0.)         bxy(2,1,1,l) = cmplx(at1*real(cu(2,1,1,l)),0.)         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero      endif  200 continue  210 continue      return      endc-----------------------------------------------------------------------      subroutine PMAXWEL2(exy,bxy,cu,ffc,affp,ci,dt,wf,wm,nx,ny,kstrt,ny     1v,kxp,jblok,nyhd)c this subroutine solves 2d maxwell's equation in fourier space forc transverse electric and magnetic fields with periodic boundaryc conditions.c input: all, output: wf, wm, exy, bxyc approximate flop count is: 286*nxc*nyc + 84*(nxc + nyc)c plus nxc*nyc dividesc where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc the magnetic field is first updated half a step using the equations:c bx(kx,ky) = bx(kx,ky) - .5*dt*sqrt(-1)*ky*ez(kx,ky)c by(kx,ky) = by(kx,ky) + .5*dt*sqrt(-1)*kx*ez(kx,ky)c bz(kx,ky) = bz(kx,ky) - .5*dt*sqrt(-1)*(kx*ey(kx,ky)-ky*ex(kx,ky))c the electric field is then updated a whole step using the equations:c ex(kx,ky) = ex(kx,ky) + c2*dt*sqrt(-1)*ky*bz(kx,ky)c                       - affp*dt*cux(kx,ky)*s(kx,ky)c ey(kx,ky) = ey(kx,ky) - c2*dt*sqrt(-1)*kx*bz(kx,ky)c                       - affp*dt*cuy(kx,ky)*s(kx,ky)c ez(kx,ky) = ez(kx,ky) + c2*dt*sqrt(-1)*(kx*by(kx,ky)-ky*bx(kx,ky))c                       - affp*dt*cuz(kx,ky)*s(kx,ky)c the magnetic field is finally updated the remaining half step withc the new electric field and the previous magnetic field equations.c where kx = 2pi*j/nx, ky = 2pi*k/ny, c2 = 1./(ci*ci)c and s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)c j,k = fourier mode numbers, except forc ex(kx=pi) = ey(kx=pi) = ez(kx=pi) = 0,c ex(ky=pi) = ey(ky=pi) = ez(ky=pi) = 0,c ex(kx=0,ky=0) = ey(kx=0,ky=0) = ez(kx=0,ky=0) = 0.c and similarly for bx, by, bz.c cu(i,k,j,l) = i-th component of complex current density andc exy(i,k,j,l) = i-th component of complex electric field,c bxy(i,k,j,l) = i-th component of complex magnetic field,c for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c aimag(ffc(k,j,l)) = finite-size particle shape factor sc s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)c for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c affp = normalization constant = nx*ny/np, where np=number of particlesc ci = reciprical of velocity of lightc dt = time interval between successive calculationsc transverse electric field energy is also calculated, usingc wf = nx*ny*nz**sum((1/affp)*|exyz(kx,ky,kz)|**2)c magnetic field energy is also calculated, usingc wm = nx*ny*nz**sum((c2/affp)*|bxyz(kx,ky,kz)|**2)c nx/ny = system length in x/y directionc jblok = number of data blocksc kxp = number of data values per blockc kstrt = starting data block numberc nyv = first dimension of field arrays, must be >= nyc nyhd = first dimension of form factor array, must be >= nyh      double precision wp, ws      complex exy, bxy, cu, ffc      complex zero, zt1, zt2, zt3, zt4, zt5, zt6, zt7, zt8, zt9      dimension exy(3,nyv,kxp,jblok), bxy(3,nyv,kxp,jblok)      dimension cu(3,nyv,kxp,jblok)      dimension ffc(nyhd,kxp,jblok)      if (ci.le.0.) return      nxh = nx/2      nyh = ny/2      ny2 = ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx)      dny = 6.28318530717959/float(ny)      dth = .5*dt      c2 = 1./(ci*ci)      cdt = c2*dt      adt = affp*dt      zero = cmplx(0.,0.)      anorm = 1.0/affpc update electromagnetic field and sum field energies      ws = 0.0d0      wp = 0.0d0      if (kstrt.gt.nxh) go to 50c calculate the electromagnetic fields      do 40 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 20 j = 1, kxp      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 10 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         at1 = aimag(ffc(k,j,l))**2         afdt = adt*at1         at1 = anorm/at1c update magnetic field half time step, ky > 0         zt1 = cmplx(-aimag(exy(3,k,j,l)),real(exy(3,k,j,l)))         zt2 = cmplx(-aimag(exy(2,k,j,l)),real(exy(2,k,j,l)))         zt3 = cmplx(-aimag(exy(1,k,j,l)),real(exy(1,k,j,l)))         zt4 = bxy(1,k,j,l) - dth*(dky*zt1)         zt5 = bxy(2,k,j,l) + dth*(dkx*zt1)         zt6 = bxy(3,k,j,l) - dth*(dkx*zt2 - dky*zt3)c update electric field whole time step         zt1 = cmplx(-aimag(zt6),real(zt6))         zt2 = cmplx(-aimag(zt5),real(zt5))         zt3 = cmplx(-aimag(zt4),real(zt4))         zt7 = exy(1,k,j,l) + cdt*(dky*zt1) - afdt*cu(1,k,j,l)         zt8 = exy(2,k,j,l) - cdt*(dkx*zt1) - afdt*cu(2,k,j,l)         zt9 = exy(3,k,j,l) + cdt*(dkx*zt2 - dky*zt3) - afdt*cu(3,k,j,l)c update magnetic field half time step and store electric field         zt1 = cmplx(-aimag(zt9),real(zt9))         zt2 = cmplx(-aimag(zt8),real(zt8))         zt3 = cmplx(-aimag(zt7),real(zt7))         exy(1,k,j,l) = zt7         exy(2,k,j,l) = zt8         exy(3,k,j,l) = zt9         ws = ws + at1*(zt7*conjg(zt7) + zt8*conjg(zt8) + zt9*conjg(zt9)     1)         zt4 = zt4 - dth*(dky*zt1)         zt5 = zt5 + dth*(dkx*zt1)         zt6 = zt6 - dth*(dkx*zt2 - dky*zt3)         bxy(1,k,j,l) = zt4         bxy(2,k,j,l) = zt5         bxy(3,k,j,l) = zt6         wp = wp + at1*(zt4*conjg(zt4) + zt5*conjg(zt5) + zt6*conjg(zt6)     1)c update magnetic field half time step, ky < 0         zt1 = cmplx(-aimag(exy(3,k1,j,l)),real(exy(3,k1,j,l)))         zt2 = cmplx(-aimag(exy(2,k1,j,l)),real(exy(2,k1,j,l)))         zt3 = cmplx(-aimag(exy(1,k1,j,l)),real(exy(1,k1,j,l)))         zt4 = bxy(1,k1,j,l) + dth*(dky*zt1)         zt5 = bxy(2,k1,j,l) + dth*(dkx*zt1)         zt6 = bxy(3,k1,j,l) - dth*(dkx*zt2 + dky*zt3)c update electric field whole time step         zt1 = cmplx(-aimag(zt6),real(zt6))         zt2 = cmplx(-aimag(zt5),real(zt5))         zt3 = cmplx(-aimag(zt4),real(zt4))         zt7 = exy(1,k1,j,l) - cdt*(dky*zt1) - afdt*cu(1,k1,j,l)         zt8 = exy(2,k1,j,l) - cdt*(dkx*zt1) - afdt*cu(2,k1,j,l)         zt9 = exy(3,k1,j,l) + cdt*(dkx*zt2 + dky*zt3) - afdt*cu(3,k1,j,     1l)c update magnetic field half time step and store electric field         zt1 = cmplx(-aimag(zt9),real(zt9))         zt2 = cmplx(-aimag(zt8),real(zt8))         zt3 = cmplx(-aimag(zt7),real(zt7))         exy(1,k1,j,l) = zt7         exy(2,k1,j,l) = zt8         exy(3,k1,j,l) = zt9         ws = ws + at1*(zt7*conjg(zt7) + zt8*conjg(zt8) + zt9*conjg(zt9)     1)         zt4 = zt4 + dth*(dky*zt1)         zt5 = zt5 + dth*(dkx*zt1)         zt6 = zt6 - dth*(dkx*zt2 + dky*zt3)         bxy(1,k1,j,l) = zt4         bxy(2,k1,j,l) = zt5         bxy(3,k1,j,l) = zt6         wp = wp + at1*(zt4*conjg(zt4) + zt5*conjg(zt5) + zt6*conjg(zt6)     1)   10    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         at1 = aimag(ffc(1,j,l))**2         afdt = adt*at1         at1 = anorm/at1c update magnetic field half time step         zt1 = cmplx(-aimag(exy(3,1,j,l)),real(exy(3,1,j,l)))         zt2 = cmplx(-aimag(exy(2,1,j,l)),real(exy(2,1,j,l)))         zt5 = bxy(2,1,j,l) + dth*(dkx*zt1)         zt6 = bxy(3,1,j,l) - dth*(dkx*zt2)c update electric field whole time step         zt1 = cmplx(-aimag(zt6),real(zt6))         zt2 = cmplx(-aimag(zt5),real(zt5))         zt8 = exy(2,1,j,l) - cdt*(dkx*zt1) - afdt*cu(2,1,j,l)         zt9 = exy(3,1,j,l) + cdt*(dkx*zt2) - afdt*cu(3,1,j,l)c update magnetic field half time step and store electric field         zt1 = cmplx(-aimag(zt9),real(zt9))         zt2 = cmplx(-aimag(zt8),real(zt8))         exy(1,1,j,l) = zero         exy(2,1,j,l) = zt8         exy(3,1,j,l) = zt9         ws = ws + at1*(zt8*conjg(zt8) + zt9*conjg(zt9))         zt5 = zt5 + dth*(dkx*zt1)         zt6 = zt6 - dth*(dkx*zt2)         bxy(1,1,j,l) = zero         bxy(2,1,j,l) = zt5         bxy(3,1,j,l) = zt6         wp = wp + at1*(zt5*conjg(zt5) + zt6*conjg(zt6))         bxy(1,k1,j,l) = zero         bxy(2,k1,j,l) = zero         bxy(3,k1,j,l) = zero         exy(1,k1,j,l) = zero         exy(2,k1,j,l) = zero         exy(3,k1,j,l) = zero      endif   20 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 30 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         at1 = aimag(ffc(k,1,l))**2         afdt = adt*at1         at1 = anorm/at1c update magnetic field half time step         zt1 = cmplx(-aimag(exy(3,k,1,l)),real(exy(3,k,1,l)))         zt3 = cmplx(-aimag(exy(1,k,1,l)),real(exy(1,k,1,l)))         zt4 = bxy(1,k,1,l) - dth*(dky*zt1)         zt6 = bxy(3,k,1,l) + dth*(dky*zt3)c update electric field whole time step         zt1 = cmplx(-aimag(zt6),real(zt6))         zt3 = cmplx(-aimag(zt4),real(zt4))         zt7 = exy(1,k,1,l) + cdt*(dky*zt1) - afdt*cu(1,k,1,l)         zt9 = exy(3,k,1,l) - cdt*(dky*zt3) - afdt*cu(3,k,1,l)c update magnetic field half time step and store electric field         zt1 = cmplx(-aimag(zt9),real(zt9))         zt3 = cmplx(-aimag(zt7),real(zt7))         exy(1,k,1,l) = zt7         exy(2,k,1,l) = zero         exy(3,k,1,l) = zt9         ws = ws + at1*(zt7*conjg(zt7) + zt9*conjg(zt9))         zt4 = zt4 - dth*(dky*zt1)         zt6 = zt6 + dth*(dky*zt3)         bxy(1,k,1,l) = zt4         bxy(2,k,1,l) = zero         bxy(3,k,1,l) = zt6         wp = wp + at1*(zt4*conjg(zt4) + zt6*conjg(zt6))         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero         bxy(3,k1,1,l) = zero         exy(1,k1,1,l) = zero         exy(2,k1,1,l) = zero         exy(3,k1,1,l) = zero   30    continue         k1 = nyh + 1         bxy(1,1,1,l) = zero         bxy(2,1,1,l) = zero         bxy(3,1,1,l) = zero         exy(1,1,1,l) = zero         exy(2,1,1,l) = zero         exy(3,1,1,l) = zero         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero         bxy(3,k1,1,l) = zero         exy(1,k1,1,l) = zero         exy(2,k1,1,l) = zero         exy(3,k1,1,l) = zero      endif   40 continue   50 continue      wf = float(nx*ny)*ws      wm = float(nx*ny)*c2*wp      return      endc-----------------------------------------------------------------------      subroutine PEMFIELD2(fxy,exy,isign,nx,ny,kstrt,nyv,kxp,jblok)c this subroutine either adds complex vector fields if isign > 0c or copies complex vector fields if isign < 0      implicit none      integer isign, nx, ny, kstrt, nyv, kxp, jblok      complex fxy, exy      dimension fxy(3,nyv,kxp,jblok), exy(3,nyv,kxp,jblok)      integer i, j, k, l, nxh      nxh = nx/2      if (kstrt.gt.nxh) returnc add the fields      if (isign.gt.0) then         do 40 l = 1, jblok         do 30 j = 1, kxp         do 20 k = 1, ny         do 10 i = 1, 3         fxy(i,k,j,l) = fxy(i,k,j,l) + exy(i,k,j,l)   10    continue   20    continue   30    continue   40    continuec copy the fields      else if (isign.lt.0) then         do 80 l = 1, jblok         do 70 j = 1, kxp         do 60 k = 1, ny         do 50 i = 1, 3         fxy(i,k,j,l) = exy(i,k,j,l)   50    continue   60    continue   70    continue   80    continue      endif      return      endc-----------------------------------------------------------------------      subroutine PFFT2R(f,g,bs,br,isign,ntpose,mixup,sct,indx,indy,kstrt     1,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)c this subroutine performs a two dimensional real to complex fastc fourier transform and its inverse, using complex arithmetic,c for data which is distributed in blocksc for isign = 0, input: isign, indx, indy, kstrt, nxhyd, nxyhdc output: mixup, sctc for isign = (-1,1), input: all, output: f, g, bs, brc for isign = -1, approximate flop count: N*(5*log2(N) + 10)/nvpc for isign = 1,  approximate flop count: N*(5*log2(N) + 8)/nvpc where N = (nx/2)*ny, and nvp = number of procsc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc ntpose = (0,1) = (no,yes) input, output data are transposedc if isign = 0, the fft tables are preparedc if isign = -1, an inverse fourier transform is performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(n,m,l) = (1/nx*ny)*sum(f(j,k,i)*c       exp(-sqrt(-1)*2pi*n*j/nx)*exp(-sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, f is the input and g is the outputc g(m,n,l) = (1/nx*ny)*sum(f(j,k,i)*c       exp(-sqrt(-1)*2pi*nn*j/nx)*exp(-sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c if isign = 1, a forward fourier transform is performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(j,k,i) = sum(f(n,m,l)*exp(sqrt(-1)*2pi*n*j/nx)*c       exp(sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, g is the input and f is the outputc f(j,k,i) = sum(g(m,n,l)*exp(sqrt(-1)*2pi*nn*j/nx)*c       exp(sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c bs, br = scratch arraysc kstrt = starting data block numberc nxvh/nyv = first dimension of f/gc kypd = second dimension of fc kxp/kyp = number of data values per block in x/yc jblok/kblok = number of data blocks in x/yc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxhyd = maximum of (nx/2,ny)c nxyhd = one half of maximum of (nx,ny)c the real data is stored in a complex array of length nx/2, nyc with the odd/even x points stored in the real/imaginary parts.c in complex notation, fourier coefficients are stored as follows:c if ntpose = 0,c f(j,k,i) = mode j-1,kk-1, where kk = k + kyp*(i - 1)c 1 <= j <= nx/2 and 1 <= kk <= ny, except forc f(1,k,i) = mode nx/2,kk-1, where ny/2+2 <= kk <= ny, andc imaginary part of f(1,1,1) = real part of mode nx/2,0 andc imaginary part of f(1,1,(ny/2)/kyp+1) = real part of mode nx/2,ny/2c if ntpose = 1,c g(k,j,i) = mode jj-1,k-1, where jj = j + kxp*(i - 1)c 1 <= jj <= nx/2 and 1 <= k <= ny, except forc g(k,1,1) = mode nx/2,k-1, where ny/2+2 <= k <= ny, andc imaginary part of g(1,1,1) = real part of mode nx/2,0 andc imaginary part of g(ny/2+1,1,1) = real part of mode nx/2,ny/2c written by viktor k. decyk, uclac parallel version      implicit none      integer isign, ntpose, indx, indy, kstrt, nxvh, nyv, kxp, kyp      integer kypd, jblok, kblok, nxhyd, nxyhd, mixup      complex f, g, bs, br, sct      dimension f(nxvh,kypd,kblok), g(nyv,kxp,jblok)      dimension bs(kxp,kyp,kblok), br(kxp,kyp,jblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, nxh, nxhh, nxh2, ny, nyh, ny2, nxy      integer nxhy, ks, j, k, lb, ll, jb, it, nxyh, nrx, nry, l, i, m      integer ns, ns2, km, kmr, k1, k2, j1, j2      real dnxy, arg, ani      complex s, t, t1      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nxh2 = nxh + 2      ny = 2**indy      nyh = ny/2      ny2 = ny + 2      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      if (isign) 50, 10, 300c prepare fft tablesc bit-reverse index table: mixup(j) = 1 + reversed bits of (j - 1)   10 do 30 j = 1, nxhy      lb = j - 1      ll = 0      do 20 k = 1, indx1y      jb = lb/2      it = lb - 2*jb      lb = jb      ll = 2*ll + it   20 continue      mixup(j) = ll + 1   30 continuec sine/cosine table for the angles 2*n*pi/nxy      nxyh = nxy/2      dnxy = 6.28318530717959/float(nxy)      do 40 j = 1, nxyh      arg = dnxy*float(j - 1)      sct(j) = cmplx(cos(arg),-sin(arg))   40 continue      returnc inverse fourier transform   50 if (kstrt.gt.ny) go to 180      nrx = nxhy/nxh      do 80 l = 1, kblokc bit-reverse array elements in x      do 70 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 70      do 60 k = 1, kyp      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = t   60 continue   70 continue   80 continuec first transform in x      nrx = nxy/nxh      do 130 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 120 l = 1, kblok      do 110 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 100 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 90 i = 1, kyp      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t   90 continue  100 continue  110 continue  120 continue  130 continuec unscramble coefficients and normalize      kmr = nxy/nx      ani = 1./float(2*nx*ny)      do 170 l = 1, kblok      do 150 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),-real(sct(1+kmr*(j-1))))      do 140 k = 1, kyp      t = conjg(f(nxh2-j,k,l))      s = f(j,k,l) + t      t = (f(j,k,l) - t)*t1      f(j,k,l) = ani*(s + t)      f(nxh2-j,k,l) = ani*conjg(s - t)  140 continue  150 continue      do 160 k = 1, kyp      f(nxhh+1,k,l) = 2.*ani*conjg(f(nxhh+1,k,l))      f(1,k,l) = 2.*ani*cmplx(real(f(1,k,l)) + aimag(f(1,k,l)),real(f(1,     1k,l)) - aimag(f(1,k,l)))  160 continue  170 continuec transpose f array to g  180 call PTPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kypd,jblok     1,kblok)      if (kstrt.gt.nxh) go to 290      nry = nxhy/ny      do 210 l = 1, jblokc bit-reverse array elements in y      do 200 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 200      do 190 j = 1, kxp      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = t  190 continue  200 continue  210 continuec then transform in y      nry = nxy/ny      do 260 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 250 l = 1, jblok      do 240 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 230 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 220 i = 1, kxp      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t  220 continue  230 continue  240 continue  250 continue  260 continuec unscramble modes kx = 0, nx/2      do 280 l = 1, jblok      if ((l+ks).gt.0) go to 280      do 270 k = 2, nyh      s = g(ny2-k,1,l)      g(ny2-k,1,l) = .5*cmplx(aimag(g(k,1,l) + s),real(g(k,1,l) - s))      g(k,1,l) = .5*cmplx(real(g(k,1,l) + s),aimag(g(k,1,l) - s))  270 continue  280 continuec transpose g array to f  290 if (ntpose.eq.0) call PTPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,kyp,k     1xp,kypd,kxp,kblok,jblok)      returnc forward fourier transformc transpose f array to g  300 if (ntpose.eq.0) call PTPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,kxp,k     1yp,kxp,kypd,jblok,kblok)      if (kstrt.gt.nxh) go to 410      nry = nxhy/ny      do 350 l = 1, jblokc scramble modes kx = 0, nx/2      if ((l+ks).gt.0) go to 320      do 310 k = 2, nyh      s = cmplx(aimag(g(ny2-k,1,l)),real(g(ny2-k,1,l)))      g(ny2-k,1,l) = conjg(g(k,1,l) - s)      g(k,1,l) = g(k,1,l) + s  310 continuec bit-reverse array elements in y  320 do 340 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 340      do 330 j = 1, kxp      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = t  330 continue  340 continue  350 continuec first transform in y      nry = nxy/ny      do 400 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 390 l = 1, jblok      do 380 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 370 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 360 i = 1, kxp      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t  360 continue  370 continue  380 continue  390 continue  400 continuec transpose g array to f  410 call PTPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kxp,kblok     1,jblok)      if (kstrt.gt.ny) return      nrx = nxhy/nxh      kmr = nxy/nx      do 470 l = 1, kblokc scramble coefficients      do 430 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),real(sct(1+kmr*(j-1))))      do 420 k = 1, kyp      t = conjg(f(nxh2-j,k,l))      s = f(j,k,l) + t      t = (f(j,k,l) - t)*t1      f(j,k,l) = s + t      f(nxh2-j,k,l) = conjg(s - t)  420 continue  430 continue      do 440 k = 1, kyp      f(nxhh+1,k,l) = 2.*conjg(f(nxhh+1,k,l))      f(1,k,l) = cmplx(real(f(1,k,l)) + aimag(f(1,k,l)),real(f(1,k,l)) -     1 aimag(f(1,k,l)))  440 continuec bit-reverse array elements in x      do 460 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 460      do 450 k = 1, kyp      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = t  450 continue  460 continue  470 continuec then transform in x      nrx = nxy/nxh      do 520 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 510 l = 1, kblok      do 500 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 490 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 480 i = 1, kyp      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t  480 continue  490 continue  500 continue  510 continue  520 continue      return      endc-----------------------------------------------------------------------      subroutine PFFT2R2(f,g,bs,br,isign,ntpose,mixup,sct,indx,indy,kstr     1t,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)c this subroutine performs 2 two dimensional complex to real fastc fourier transforms, using complex arithmetic,c for data which is distributed in blocksc for isign = 0, input: isign, indx, indy, kstrt, nxhyd, nxyhdc output: mixup, sctc for isign = (-1,1), input: all, output: f, g, bs, brc for isign = -1, approximate flop count: N*(5*log2(N) + 10)/nvpc for isign = 1,  approximate flop count: N*(5*log2(N) + 8)/nvpc where N = (nx/2)*ny, and nvp = number of procsc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc ntpose = (0,1) = (no,yes) input, output data are transposedc if isign = 0, the fft tables are preparedc if isign = -1, two inverse fourier transforms are performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(1:2,n,m,l) = (1/nx*ny)*sum(f(1:2,j,k,i)*c       exp(-sqrt(-1)*2pi*n*j/nx)*exp(-sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, f is the input and g is the outputc g(1:2,m,n,l) = (1/nx*ny)*sum(f(1:2,j,k,i)*c       exp(-sqrt(-1)*2pi*nn*j/nx)*exp(-sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c if isign = 1, two forward fourier transforms are performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(1:2,j,k,i) = sum(f(1:2,n,m,l)*exp(sqrt(-1)*2pi*n*j/nx)*c       exp(sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, g is the input and f is the outputc f(1:2,j,k,i) = sum(g(1:2,m,n,l)*exp(sqrt(-1)*2pi*nn*j/nx)*c       exp(sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c bs, br = scratch arraysc kstrt = starting data block numberc nxvh/nyv = second dimension of f/gc kypd = third dimension of fc kxp/kyp = number of data values per block in x/yc jblok/kblok = number of data blocks in x/yc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxhyd = maximum of (nx/2,ny)c nxyhd = one half of maximum of (nx,ny)c the real data is stored in a complex array of length nx/2, nyc with the odd/even x points stored in the real/imaginary parts.c in complex notation, fourier coefficients are stored as follows:c if ntpose = 0,c f(j,k,i) = mode j-1,kk-1, where kk = k + kyp*(i - 1)c 1 <= j <= nx/2 and 1 <= kk <= ny, except forc f(1,k,i) = mode nx/2,kk-1, where ny/2+2 <= kk <= ny, andc imaginary part of f(1,1,1) = real part of mode nx/2,0 andc imaginary part of f(1,1,(ny/2)/kyp+1) = real part of mode nx/2,ny/2c if ntpose = 1,c g(k,j,i) = mode jj-1,k-1, where jj = j + kxp*(i - 1)c 1 <= jj <= nx/2 and 1 <= k <= ny, except forc g(k,1,1) = mode nx/2,k-1, where ny/2+2 <= k <= ny, andc imaginary part of g(1,1,1) = real part of mode nx/2,0 andc imaginary part of g(ny/2+1,1,1) = real part of mode nx/2,ny/2c written by viktor k. decyk, uclac parallel version      implicit none      integer isign, ntpose, indx, indy, kstrt, nxvh, nyv, kxp, kyp      integer kypd, jblok, kblok, nxhyd, nxyhd, mixup      complex f, g, bs, br, sct      dimension f(2,nxvh,kypd,kblok), g(2,nyv,kxp,jblok)      dimension bs(2,kxp,kyp,kblok), br(2,kxp,kyp,jblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, nxh, nxhh, nxh2, ny, nyh, ny2, nxy      integer nxhy, ks, j, k, lb, ll, jb, it, nxyh, nrx, nry, l, i, m      integer ns, ns2, km, kmr, k1, k2, j1, j2, jj      real dnxy, arg, ani, at1      complex s, t, t1, t2      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nxh2 = nxh + 2      ny = 2**indy      nyh = ny/2      ny2 = ny + 2      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      if (isign) 50, 10, 360c prepare fft tablesc bit-reverse index table: mixup(j) = 1 + reversed bits of (j - 1)   10 do 30 j = 1, nxhy      lb = j - 1      ll = 0      do 20 k = 1, indx1y      jb = lb/2      it = lb - 2*jb      lb = jb      ll = 2*ll + it   20 continue      mixup(j) = ll + 1   30 continuec sine/cosine table for the angles 2*n*pi/nxy      nxyh = nxy/2      dnxy = 6.28318530717959/float(nxy)      do 40 j = 1, nxyh      arg = dnxy*float(j - 1)      sct(j) = cmplx(cos(arg),-sin(arg))   40 continue      returnc inverse fourier transform   50 if (kstrt.gt.ny) go to 230c swap complex components      do 80 l = 1, kblok      do 70 k = 1, kyp      do 60 j = 1, nxh      at1 = aimag(f(1,j,k,l))      f(1,j,k,l) = cmplx(real(f(1,j,k,l)),real(f(2,j,k,l)))      f(2,j,k,l) = cmplx(at1,aimag(f(2,j,k,l)))   60 continue   70 continue   80 continue      nrx = nxhy/nxh      do 110 l = 1, kblokc bit-reverse array elements in x      do 100 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 100      do 90 k = 1, kyp      t1 = f(1,j1,k,l)      t2 = f(2,j1,k,l)      f(1,j1,k,l) = f(1,j,k,l)      f(2,j1,k,l) = f(2,j,k,l)      f(1,j,k,l) = t1      f(2,j,k,l) = t2   90 continue  100 continue  110 continuec first transform in x      nrx = nxy/nxh      do 160 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 150 l = 1, kblok      do 140 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 130 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 120 i = 1, kyp      t1 = s*f(1,j2,i,l)      t2 = s*f(2,j2,i,l)      f(1,j2,i,l) = f(1,j1,i,l) - t1      f(2,j2,i,l) = f(2,j1,i,l) - t2      f(1,j1,i,l) = f(1,j1,i,l) + t1      f(2,j1,i,l) = f(2,j1,i,l) + t2  120 continue  130 continue  140 continue  150 continue  160 continuec unscramble coefficients and normalize      kmr = nxy/nx      ani = 1./float(2*nx*ny)      do 220 l = 1, kblok      do 190 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),-real(sct(1+kmr*(j-1))))      do 180 k = 1, kyp      do 170 jj = 1, 2      t = conjg(f(jj,nxh2-j,k,l))      s = f(jj,j,k,l) + t      t = (f(jj,j,k,l) - t)*t1      f(jj,j,k,l) = ani*(s + t)      f(jj,nxh2-j,k,l) = ani*conjg(s - t)  170 continue  180 continue  190 continue      do 210 k = 1, kyp      do 200 jj = 1, 2      f(jj,nxhh+1,k,l) = 2.*ani*conjg(f(jj,nxhh+1,k,l))      f(jj,1,k,l) = 2.*ani*cmplx(real(f(jj,1,k,l)) + aimag(f(jj,1,k,l)),     1real(f(jj,1,k,l)) - aimag(f(jj,1,k,l)))  200 continue  210 continue  220 continuec transpose f array to g  230 call P2TPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kypd,jblo     1k,kblok)      if (kstrt.gt.nxh) go to 350      nry = nxhy/ny      do 260 l = 1, jblokc bit-reverse array elements in y      do 250 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 250      do 240 j = 1, kxp      t1 = g(1,k1,j,l)      t2 = g(2,k1,j,l)      g(1,k1,j,l) = g(1,k,j,l)      g(2,k1,j,l) = g(2,k,j,l)      g(1,k,j,l) = t1      g(2,k,j,l) = t2  240 continue  250 continue  260 continuec then transform in y      nry = nxy/ny      do 310 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 300 l = 1, jblok      do 290 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 280 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 270 i = 1, kxp      t1 = s*g(1,j2,i,l)      t2 = s*g(2,j2,i,l)      g(1,j2,i,l) = g(1,j1,i,l) - t1      g(2,j2,i,l) = g(2,j1,i,l) - t2      g(1,j1,i,l) = g(1,j1,i,l) + t1      g(2,j1,i,l) = g(2,j1,i,l) + t2  270 continue  280 continue  290 continue  300 continue  310 continuec unscramble modes kx = 0, nx/2      do 340 l = 1, jblok      if ((l+ks).gt.0) go to 340      do 330 k = 2, nyh      do 320 jj = 1, 2      s = g(jj,ny2-k,1,l)      g(jj,ny2-k,1,l) = .5*cmplx(aimag(g(jj,k,1,l) + s),real(g(jj,k,1,l)     1- s))      g(jj,k,1,l) = .5*cmplx(real(g(jj,k,1,l) + s),aimag(g(jj,k,1,l) - s     1))  320 continue  330 continue  340 continuec transpose g array to f  350 if (ntpose.eq.0) call P2TPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,kyp,     1kxp,kypd,kxp,kblok,jblok)      returnc forward fourier transformc transpose f array to g  360 if (ntpose.eq.0) call P2TPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,kxp,     1kyp,kxp,kypd,jblok,kblok)      if (kstrt.gt.nxh) go to 480      nry = nxhy/ny      do 420 l = 1, jblokc scramble modes kx = 0, nx/2      if ((l+ks).gt.0) go to 390      do 380 k = 2, nyh      do 370 jj = 1, 2      s = cmplx(aimag(g(jj,ny2-k,1,l)),real(g(jj,ny2-k,1,l)))      g(jj,ny2-k,1,l) = conjg(g(jj,k,1,l) - s)      g(jj,k,1,l) = g(jj,k,1,l) + s  370 continue  380 continuec bit-reverse array elements in y  390 do 410 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 410      do 400 j = 1, kxp      t1 = g(1,k1,j,l)      t2 = g(2,k1,j,l)      g(1,k1,j,l) = g(1,k,j,l)      g(2,k1,j,l) = g(2,k,j,l)      g(1,k,j,l) = t1      g(2,k,j,l) = t2  400 continue  410 continue  420 continuec first transform in y      nry = nxy/ny      do 470 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 460 l = 1, jblok      do 450 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 440 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 430 i = 1, kxp      t1 = s*g(1,j2,i,l)      t2 = s*g(2,j2,i,l)      g(1,j2,i,l) = g(1,j1,i,l) - t1      g(2,j2,i,l) = g(2,j1,i,l) - t2      g(1,j1,i,l) = g(1,j1,i,l) + t1      g(2,j1,i,l) = g(2,j1,i,l) + t2  430 continue  440 continue  450 continue  460 continue  470 continuec transpose g array to f  480 call P2TPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kxp,kblo     1k,jblok)      if (kstrt.gt.ny) return      nrx = nxhy/nxh      kmr = nxy/nx      do 560 l = 1, kblokc scramble coefficients      do 510 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),real(sct(1+kmr*(j-1))))      do 500 k = 1, kyp      do 490 jj = 1, 2      t = conjg(f(jj,nxh2-j,k,l))      s = f(jj,j,k,l) + t      t = (f(jj,j,k,l) - t)*t1      f(jj,j,k,l) = s + t      f(jj,nxh2-j,k,l) = conjg(s - t)  490 continue  500 continue  510 continue      do 530 k = 1, kyp      do 520 jj = 1, 2      f(jj,nxhh+1,k,l) = 2.*conjg(f(jj,nxhh+1,k,l))      f(jj,1,k,l) = cmplx(real(f(jj,1,k,l)) + aimag(f(jj,1,k,l)),real(f(     1jj,1,k,l)) - aimag(f(jj,1,k,l)))  520 continue  530 continuec bit-reverse array elements in x      do 550 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 550      do 540 k = 1, kyp      t1 = f(1,j1,k,l)      t2 = f(2,j1,k,l)      f(1,j1,k,l) = f(1,j,k,l)      f(2,j1,k,l) = f(2,j,k,l)      f(1,j,k,l) = t1      f(2,j,k,l) = t2  540 continue  550 continue  560 continuec then transform in x      nrx = nxy/nxh      do 610 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 600 l = 1, kblok      do 590 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 580 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 570 i = 1, kyp      t1 = s*f(1,j2,i,l)      t2 = s*f(2,j2,i,l)      f(1,j2,i,l) = f(1,j1,i,l) - t1      f(2,j2,i,l) = f(2,j1,i,l) - t2      f(1,j1,i,l) = f(1,j1,i,l) + t1      f(2,j1,i,l) = f(2,j1,i,l) + t2  570 continue  580 continue  590 continue  600 continue  610 continuec swap complex components      do 640 l = 1, kblok      do 630 k = 1, kyp      do 620 j = 1, nxh      at1 = aimag(f(1,j,k,l))      f(1,j,k,l) = cmplx(real(f(1,j,k,l)),real(f(2,j,k,l)))      f(2,j,k,l) = cmplx(at1,aimag(f(2,j,k,l)))  620 continue  630 continue  640 continue      return      endc-----------------------------------------------------------------------      subroutine PFFT2R3(f,g,bs,br,isign,ntpose,mixup,sct,indx,indy,kstr     1t,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)c this subroutine performs 3 two dimensional complex to real fastc fourier transforms, using complex arithmetic,c for data which is distributed in blocksc for isign = 0, input: isign, indx, indy, kstrt, nxhyd, nxyhdc output: mixup, sctc for isign = (-1,1), input: all, output: f, g, bs, brc for isign = -1, approximate flop count: N*(5*log2(N) + 10)/nvpc for isign = 1,  approximate flop count: N*(5*log2(N) + 8)/nvpc where N = (nx/2)*ny, and nvp = number of procsc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc ntpose = (0,1) = (no,yes) input, output data are transposedc if isign = 0, the fft tables are preparedc if isign = -1, three inverse fourier transforms are performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(1:3,n,m,l) = (1/nx*ny)*sum(f(1:3,j,k,i)*c       exp(-sqrt(-1)*2pi*n*j/nx)*exp(-sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, f is the input and g is the outputc g(1:3,m,n,l) = (1/nx*ny)*sum(f(1:3,j,k,i)*c       exp(-sqrt(-1)*2pi*nn*j/nx)*exp(-sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c if isign = 1, three forward fourier transforms are performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(1:3,j,k,i) = sum(f(1:3,n,m,l)*exp(sqrt(-1)*2pi*n*j/nx)*c       exp(sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, g is the input and f is the outputc f(1:3,j,k,i) = sum(g(1:3,m,n,l)*exp(sqrt(-1)*2pi*nn*j/nx)*c       exp(sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c bs, br = scratch arraysc kstrt = starting data block numberc nxvh/nyv = second dimension of f/gc kypd = third dimension of fc kxp/kyp = number of data values per block in x/yc jblok/kblok = number of data blocks in x/yc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxhyd = maximum of (nx/2,ny)c nxyhd = one half of maximum of (nx,ny)c the real data is stored in a complex array of length nx/2, nyc with the odd/even x points stored in the real/imaginary parts.c in complex notation, fourier coefficients are stored as follows:c if ntpose = 0,c f(j,k,i) = mode j-1,kk-1, where kk = k + kyp*(i - 1)c 1 <= j <= nx/2 and 1 <= kk <= ny, except forc f(1,k,i) = mode nx/2,kk-1, where ny/2+2 <= kk <= ny, andc imaginary part of f(1,1,1) = real part of mode nx/2,0 andc imaginary part of f(1,1,(ny/2)/kyp+1) = real part of mode nx/2,ny/2c if ntpose = 1,c g(k,j,i) = mode jj-1,k-1, where jj = j + kxp*(i - 1)c 1 <= jj <= nx/2 and 1 <= k <= ny, except forc g(k,1,1) = mode nx/2,k-1, where ny/2+2 <= k <= ny, andc imaginary part of g(1,1,1) = real part of mode nx/2,0 andc imaginary part of g(ny/2+1,1,1) = real part of mode nx/2,ny/2c written by viktor k. decyk, uclac parallel version      implicit none      integer isign, ntpose, indx, indy, kstrt, nxvh, nyv, kxp, kyp      integer kypd, jblok, kblok, nxhyd, nxyhd, mixup      complex f, g, bs, br, sct      dimension f(3,nxvh,kypd,kblok), g(3,nyv,kxp,jblok)      dimension bs(3,kxp,kyp,kblok), br(3,kxp,kyp,jblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, nxh, nxhh, nxh2, ny, nyh, ny2, nxy      integer nxhy, ks, j, k, lb, ll, jb, it, nxyh, nrx, nry, l, i, m      integer ns, ns2, km, kmr, k1, k2, j1, j2, jj      real dnxy, arg, ani, at1, at2      complex s, t, t1, t2, t3      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nxh2 = nxh + 2      ny = 2**indy      nyh = ny/2      ny2 = ny + 2      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      if (isign) 50, 10, 360c prepare fft tablesc bit-reverse index table: mixup(j) = 1 + reversed bits of (j - 1)   10 do 30 j = 1, nxhy      lb = j - 1      ll = 0      do 20 k = 1, indx1y      jb = lb/2      it = lb - 2*jb      lb = jb      ll = 2*ll + it   20 continue      mixup(j) = ll + 1   30 continuec sine/cosine table for the angles 2*n*pi/nxy      nxyh = nxy/2      dnxy = 6.28318530717959/float(nxy)      do 40 j = 1, nxyh      arg = dnxy*float(j - 1)      sct(j) = cmplx(cos(arg),-sin(arg))   40 continue      returnc inverse fourier transform   50 if (kstrt.gt.ny) go to 230c swap complex components      do 80 l = 1, kblok      do 70 i = 1, kyp      do 60 j = 1, nxh      at1 = real(f(3,j,i,l))      f(3,j,i,l) = cmplx(real(f(2,j,i,l)),aimag(f(3,j,i,l)))      at2 = aimag(f(2,j,i,l))      f(2,j,i,l) = cmplx(aimag(f(1,j,i,l)),at1)      f(1,j,i,l) = cmplx(real(f(1,j,i,l)),at2)   60 continue   70 continue   80 continue      nrx = nxhy/nxh      do 110 l = 1, kblokc bit-reverse array elements in x      do 100 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 100      do 90 k = 1, kyp      t1 = f(1,j1,k,l)      t2 = f(2,j1,k,l)      t3 = f(3,j1,k,l)      f(1,j1,k,l) = f(1,j,k,l)      f(2,j1,k,l) = f(2,j,k,l)      f(3,j1,k,l) = f(3,j,k,l)      f(1,j,k,l) = t1      f(2,j,k,l) = t2      f(3,j,k,l) = t3   90 continue  100 continue  110 continuec first transform in x      nrx = nxy/nxh      do 160 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 150 l = 1, kblok      do 140 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 130 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 120 i = 1, kyp      t1 = s*f(1,j2,i,l)      t2 = s*f(2,j2,i,l)      t3 = s*f(3,j2,i,l)      f(1,j2,i,l) = f(1,j1,i,l) - t1      f(2,j2,i,l) = f(2,j1,i,l) - t2      f(3,j2,i,l) = f(3,j1,i,l) - t3      f(1,j1,i,l) = f(1,j1,i,l) + t1      f(2,j1,i,l) = f(2,j1,i,l) + t2      f(3,j1,i,l) = f(3,j1,i,l) + t3  120 continue  130 continue  140 continue  150 continue  160 continuec unscramble coefficients and normalize      kmr = nxy/nx      ani = 1./float(2*nx*ny)      do 220 l = 1, kblok      do 190 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),-real(sct(1+kmr*(j-1))))      do 180 k = 1, kyp      do 170 jj = 1, 3      t = conjg(f(jj,nxh2-j,k,l))      s = f(jj,j,k,l) + t      t = (f(jj,j,k,l) - t)*t1      f(jj,j,k,l) = ani*(s + t)      f(jj,nxh2-j,k,l) = ani*conjg(s - t)  170 continue  180 continue  190 continue      do 210 k = 1, kyp      do 200 jj = 1, 3      f(jj,nxhh+1,k,l) = 2.*ani*conjg(f(jj,nxhh+1,k,l))      f(jj,1,k,l) = 2.*ani*cmplx(real(f(jj,1,k,l)) + aimag(f(jj,1,k,l)),     1real(f(jj,1,k,l)) - aimag(f(jj,1,k,l)))  200 continue  210 continue  220 continuec transpose f array to g  230 call P3TPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kypd,jblo     1k,kblok)      if (kstrt.gt.nxh) go to 350      nry = nxhy/ny      do 260 l = 1, jblokc bit-reverse array elements in y      do 250 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 250      do 240 j = 1, kxp      t1 = g(1,k1,j,l)      t2 = g(2,k1,j,l)      t3 = g(3,k1,j,l)      g(1,k1,j,l) = g(1,k,j,l)      g(2,k1,j,l) = g(2,k,j,l)      g(3,k1,j,l) = g(3,k,j,l)      g(1,k,j,l) = t1      g(2,k,j,l) = t2      g(3,k,j,l) = t3  240 continue  250 continue  260 continuec then transform in y      nry = nxy/ny      do 310 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 300 l = 1, jblok      do 290 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 280 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 270 i = 1, kxp      t1 = s*g(1,j2,i,l)      t2 = s*g(2,j2,i,l)      t3 = s*g(3,j2,i,l)      g(1,j2,i,l) = g(1,j1,i,l) - t1      g(2,j2,i,l) = g(2,j1,i,l) - t2      g(3,j2,i,l) = g(3,j1,i,l) - t3      g(1,j1,i,l) = g(1,j1,i,l) + t1      g(2,j1,i,l) = g(2,j1,i,l) + t2      g(3,j1,i,l) = g(3,j1,i,l) + t3  270 continue  280 continue  290 continue  300 continue  310 continuec unscramble modes kx = 0, nx/2      do 340 l = 1, jblok      if ((l+ks).gt.0) go to 340      do 330 k = 2, nyh      do 320 jj = 1, 3      s = g(jj,ny2-k,1,l)      g(jj,ny2-k,1,l) = .5*cmplx(aimag(g(jj,k,1,l) + s),real(g(jj,k,1,l)     1- s))      g(jj,k,1,l) = .5*cmplx(real(g(jj,k,1,l) + s),aimag(g(jj,k,1,l) - s     1))  320 continue  330 continue  340 continuec transpose g array to f  350 if (ntpose.eq.0) call P3TPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,kyp,     1kxp,kypd,kxp,kblok,jblok)      returnc forward fourier transformc transpose f array to g  360 if (ntpose.eq.0) call P3TPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,kxp,     1kyp,kxp,kypd,jblok,kblok)      if (kstrt.gt.nxh) go to 480      nry = nxhy/ny      do 420 l = 1, jblokc scramble modes kx = 0, nx/2      if ((l+ks).gt.0) go to 390      do 380 k = 2, nyh      do 370 jj = 1, 3      s = cmplx(aimag(g(jj,ny2-k,1,l)),real(g(jj,ny2-k,1,l)))      g(jj,ny2-k,1,l) = conjg(g(jj,k,1,l) - s)      g(jj,k,1,l) = g(jj,k,1,l) + s  370 continue  380 continuec bit-reverse array elements in y  390 do 410 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 410      do 400 j = 1, kxp      t1 = g(1,k1,j,l)      t2 = g(2,k1,j,l)      t3 = g(3,k1,j,l)      g(1,k1,j,l) = g(1,k,j,l)      g(2,k1,j,l) = g(2,k,j,l)      g(3,k1,j,l) = g(3,k,j,l)      g(1,k,j,l) = t1      g(2,k,j,l) = t2      g(3,k,j,l) = t3  400 continue  410 continue  420 continuec first transform in y      nry = nxy/ny      do 470 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 460 l = 1, jblok      do 450 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 440 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 430 i = 1, kxp      t1 = s*g(1,j2,i,l)      t2 = s*g(2,j2,i,l)      t3 = s*g(3,j2,i,l)      g(1,j2,i,l) = g(1,j1,i,l) - t1      g(2,j2,i,l) = g(2,j1,i,l) - t2      g(3,j2,i,l) = g(3,j1,i,l) - t3      g(1,j1,i,l) = g(1,j1,i,l) + t1      g(2,j1,i,l) = g(2,j1,i,l) + t2      g(3,j1,i,l) = g(3,j1,i,l) + t3  430 continue  440 continue  450 continue  460 continue  470 continuec transpose g array to f  480 call P3TPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kxp,kblo     1k,jblok)      if (kstrt.gt.ny) return      nrx = nxhy/nxh      kmr = nxy/nx      do 560 l = 1, kblokc scramble coefficients      do 510 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),real(sct(1+kmr*(j-1))))      do 500 k = 1, kyp      do 490 jj = 1, 3      t = conjg(f(jj,nxh2-j,k,l))      s = f(jj,j,k,l) + t      t = (f(jj,j,k,l) - t)*t1      f(jj,j,k,l) = s + t      f(jj,nxh2-j,k,l) = conjg(s - t)  490 continue  500 continue  510 continue      do 530 k = 1, kyp      do 520 jj = 1, 3      f(jj,nxhh+1,k,l) = 2.*conjg(f(jj,nxhh+1,k,l))      f(jj,1,k,l) = cmplx(real(f(jj,1,k,l)) + aimag(f(jj,1,k,l)),real(f(     1jj,1,k,l)) - aimag(f(jj,1,k,l)))  520 continue  530 continuec bit-reverse array elements in x      do 550 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 550      do 540 k = 1, kyp      t1 = f(1,j1,k,l)      t2 = f(2,j1,k,l)      t3 = f(3,j1,k,l)      f(1,j1,k,l) = f(1,j,k,l)      f(2,j1,k,l) = f(2,j,k,l)      f(3,j1,k,l) = f(3,j,k,l)      f(1,j,k,l) = t1      f(2,j,k,l) = t2      f(3,j,k,l) = t3  540 continue  550 continue  560 continuec then transform in x      nrx = nxy/nxh      do 610 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 600 l = 1, kblok      do 590 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 580 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 570 i = 1, kyp      t1 = s*f(1,j2,i,l)      t2 = s*f(2,j2,i,l)      t3 = s*f(3,j2,i,l)      f(1,j2,i,l) = f(1,j1,i,l) - t1      f(2,j2,i,l) = f(2,j1,i,l) - t2      f(3,j2,i,l) = f(3,j1,i,l) - t3      f(1,j1,i,l) = f(1,j1,i,l) + t1      f(2,j1,i,l) = f(2,j1,i,l) + t2      f(3,j1,i,l) = f(3,j1,i,l) + t3  570 continue  580 continue  590 continue  600 continue  610 continuec swap complex components      do 640 l = 1, kblok      do 630 i = 1, kyp      do 620 j = 1, nxh      at1 = real(f(3,j,i,l))      f(3,j,i,l) = cmplx(aimag(f(2,j,i,l)),aimag(f(3,j,i,l)))      at2 = real(f(2,j,i,l))      f(2,j,i,l) = cmplx(at1,aimag(f(1,j,i,l)))      f(1,j,i,l) = cmplx(real(f(1,j,i,l)),at2)  620 continue  630 continue  640 continue      return      endc-----------------------------------------------------------------------      subroutine PFFT2RX(f,g,isign,ntpose,mixup,sct,indx,indy,kstrt,nxvh     1,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)c this subroutine performs a two dimensional real to complex fastc fourier transform and its inverse, using complex arithmetic,c for data which is distributed in blocksc for isign = 0, input: isign, indx, indy, kstrt, nxhyd, nxyhdc output: mixup, sctc for isign = (-1,1), input: all, output: f, gc for isign = -1, approximate flop count: N*(5*log2(N) + 10)/nvpc for isign = 1,  approximate flop count: N*(5*log2(N) + 8)/nvpc where N = (nx/2)*ny, and nvp = number of procsc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc ntpose = (0,1) = (no,yes) input, output data are transposedc if isign = 0, the fft tables are preparedc if isign = -1, an inverse fourier transform is performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(n,m,l) = (1/nx*ny)*sum(f(j,k,i)*c       exp(-sqrt(-1)*2pi*n*j/nx)*exp(-sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, f is the input and g is the outputc g(m,n,l) = (1/nx*ny)*sum(f(j,k,i)*c       exp(-sqrt(-1)*2pi*nn*j/nx)*exp(-sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c if isign = 1, a forward fourier transform is performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(j,k,i) = sum(f(n,m,l)*exp(sqrt(-1)*2pi*n*j/nx)*c       exp(sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, g is the input and f is the outputc f(j,k,i) = sum(g(m,n,l)*exp(sqrt(-1)*2pi*nn*j/nx)*c       exp(sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c kstrt = starting data block numberc nxvh/nyv = first dimension of f/gc kypd = second dimension of fc kxp/kyp = number of data values per block in x/yc jblok/kblok = number of data blocks in x/yc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxhyd = maximum of (nx/2,ny)c nxyhd = one half of maximum of (nx,ny)c the real data is stored in a complex array of length nx/2, nyc with the odd/even x points stored in the real/imaginary parts.c in complex notation, fourier coefficients are stored as follows:c if ntpose = 0,c f(j,k,i) = mode j-1,kk-1, where kk = k + kyp*(i - 1)c 1 <= j <= nx/2 and 1 <= kk <= ny, except forc f(1,k,i) = mode nx/2,kk-1, where ny/2+2 <= kk <= ny, andc imaginary part of f(1,1,1) = real part of mode nx/2,0 andc imaginary part of f(1,1,(ny/2)/kyp+1) = real part of mode nx/2,ny/2c if ntpose = 1,c g(k,j,i) = mode jj-1,k-1, where jj = j + kxp*(i - 1)c 1 <= jj <= nx/2 and 1 <= k <= ny, except forc g(k,1,1) = mode nx/2,k-1, where ny/2+2 <= k <= ny, andc imaginary part of g(1,1,1) = real part of mode nx/2,0 andc imaginary part of g(ny/2+1,1,1) = real part of mode nx/2,ny/2c written by viktor k. decyk, uclac parallel, RISC optimized version      implicit none      integer isign, ntpose, mixup, indx, indy, kstrt, nxvh      integer nyv, kxp, kyp, kypd, jblok, kblok, nxhyd, nxyhd      complex f, g, sct      dimension f(nxvh,kypd,kblok), g(nyv,kxp,jblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, nxh, nxhh, nxh2, ny, nyh, ny2, nxy      integer nxhy, ks, j, k, lb, ll, jb, it, nxyh, nrx, nry, l, i, m      integer ns, ns2, km, kmr, k1, k2, j1, j2      real dnxy, arg, ani      complex s, t, t1      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nxh2 = nxh + 2      ny = 2**indy      nyh = ny/2      ny2 = ny + 2      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      if (isign) 50, 10, 300c prepare fft tablesc bit-reverse index table: mixup(j) = 1 + reversed bits of (j - 1)   10 do 30 j = 1, nxhy      lb = j - 1      ll = 0      do 20 k = 1, indx1y      jb = lb/2      it = lb - 2*jb      lb = jb      ll = 2*ll + it   20 continue      mixup(j) = ll + 1   30 continuec sine/cosine table for the angles 2*n*pi/nxy      nxyh = nxy/2      dnxy = 6.28318530717959/float(nxy)      do 40 j = 1, nxyh      arg = dnxy*float(j - 1)      sct(j) = cmplx(cos(arg),-sin(arg))   40 continue      returnc inverse fourier transform   50 if (kstrt.gt.ny) go to 180      nrx = nxhy/nxh      do 80 l = 1, kblokc bit-reverse array elements in x      do 70 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 70      do 60 k = 1, kyp      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = t   60 continue   70 continue   80 continuec first transform in x      nrx = nxy/nxh      do 130 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 120 l = 1, kblok      do 110 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 100 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 90 i = 1, kyp      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t   90 continue  100 continue  110 continue  120 continue  130 continuec unscramble coefficients and normalize      kmr = nxy/nx      ani = 1./float(2*nx*ny)      do 170 l = 1, kblok      do 150 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),-real(sct(1+kmr*(j-1))))      do 140 k = 1, kyp      t = conjg(f(nxh2-j,k,l))      s = f(j,k,l) + t      t = (f(j,k,l) - t)*t1      f(j,k,l) = ani*(s + t)      f(nxh2-j,k,l) = ani*conjg(s - t)  140 continue  150 continue      do 160 k = 1, kyp      f(nxhh+1,k,l) = 2.*ani*conjg(f(nxhh+1,k,l))      f(1,k,l) = 2.*ani*cmplx(real(f(1,k,l)) + aimag(f(1,k,l)),real(f(1,     1k,l)) - aimag(f(1,k,l)))  160 continue  170 continuec transpose f array to g  180 call PTPOSEX(f,g,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kypd,jblok,kblo     1k)      if (kstrt.gt.nxh) go to 290      nry = nxhy/ny      do 210 l = 1, jblokc bit-reverse array elements in y      do 200 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 200      do 190 j = 1, kxp      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = t  190 continue  200 continue  210 continuec then transform in y      nry = nxy/ny      do 260 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 250 l = 1, jblok      do 240 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 230 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 220 i = 1, kxp      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t  220 continue  230 continue  240 continue  250 continue  260 continuec unscramble modes kx = 0, nx/2      do 280 l = 1, jblok      if ((l+ks).gt.0) go to 280      do 270 k = 2, nyh      s = g(ny2-k,1,l)      g(ny2-k,1,l) = .5*cmplx(aimag(g(k,1,l) + s),real(g(k,1,l) - s))      g(k,1,l) = .5*cmplx(real(g(k,1,l) + s),aimag(g(k,1,l) - s))  270 continue  280 continuec transpose g array to f  290 if (ntpose.eq.0) call PTPOSEX(g,f,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,ky     1pd,kxp,kblok,jblok)      returnc forward fourier transformc transpose f array to g  300 if (ntpose.eq.0) call PTPOSEX(f,g,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kx     1p,kypd,jblok,kblok)      if (kstrt.gt.nxh) go to 410      nry = nxhy/ny      do 350 l = 1, jblokc scramble modes kx = 0, nx/2      if ((l+ks).gt.0) go to 320      do 310 k = 2, nyh      s = cmplx(aimag(g(ny2-k,1,l)),real(g(ny2-k,1,l)))      g(ny2-k,1,l) = conjg(g(k,1,l) - s)      g(k,1,l) = g(k,1,l) + s  310 continuec bit-reverse array elements in y  320 do 340 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 340      do 330 j = 1, kxp      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = t  330 continue  340 continue  350 continuec first transform in y      nry = nxy/ny      do 400 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 390 l = 1, jblok      do 380 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 370 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 360 i = 1, kxp      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t  360 continue  370 continue  380 continue  390 continue  400 continuec transpose g array to f  410 call PTPOSEX(g,f,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kxp,kblok,jblo     1k)      if (kstrt.gt.ny) return      nrx = nxhy/nxh      kmr = nxy/nx      do 470 l = 1, kblokc scramble coefficients      do 430 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),real(sct(1+kmr*(j-1))))      do 420 k = 1, kyp      t = conjg(f(nxh2-j,k,l))      s = f(j,k,l) + t      t = (f(j,k,l) - t)*t1      f(j,k,l) = s + t      f(nxh2-j,k,l) = conjg(s - t)  420 continue  430 continue      do 440 k = 1, kyp      f(nxhh+1,k,l) = 2.*conjg(f(nxhh+1,k,l))      f(1,k,l) = cmplx(real(f(1,k,l)) + aimag(f(1,k,l)),real(f(1,k,l)) -     1 aimag(f(1,k,l)))  440 continuec bit-reverse array elements in x      do 460 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 460      do 450 k = 1, kyp      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = t  450 continue  460 continue  470 continuec then transform in x      nrx = nxy/nxh      do 520 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 510 l = 1, kblok      do 500 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 490 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 480 i = 1, kyp      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t  480 continue  490 continue  500 continue  510 continue  520 continue      return      endc-----------------------------------------------------------------------      subroutine PFFT2RX2(f,g,isign,ntpose,mixup,sct,indx,indy,kstrt,nxv     1h,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)c this subroutine performs 2 two dimensional complex to real fastc fourier transforms, using complex arithmetic,c for data which is distributed in blocksc for isign = 0, input: isign, indx, indy, kstrt, nxhyd, nxyhdc output: mixup, sctc for isign = (-1,1), input: all, output: f, gc for isign = -1, approximate flop count: N*(5*log2(N) + 10)/nvpc for isign = 1,  approximate flop count: N*(5*log2(N) + 8)/nvpc where N = (nx/2)*ny, and nvp = number of procsc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc ntpose = (0,1) = (no,yes) input, output data are transposedc if isign = 0, the fft tables are preparedc if isign = -1, two inverse fourier transforms are performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(1:2,n,m,l) = (1/nx*ny)*sum(f(1:2,j,k,i)*c       exp(-sqrt(-1)*2pi*n*j/nx)*exp(-sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, f is the input and g is the outputc g(1:2,m,n,l) = (1/nx*ny)*sum(f(1:2,j,k,i)*c       exp(-sqrt(-1)*2pi*nn*j/nx)*exp(-sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c if isign = 1, two forward fourier transforms are performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(1:2,j,k,i) = sum(f(1:2,n,m,l)*exp(sqrt(-1)*2pi*n*j/nx)*c       exp(sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, g is the input and f is the outputc f(1:2,j,k,i) = sum(g(1:2,m,n,l)*exp(sqrt(-1)*2pi*nn*j/nx)*c       exp(sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c kstrt = starting data block numberc nxvh/nyv = second dimension of f/gc kypd = third dimension of fc kxp/kyp = number of data values per block in x/yc jblok/kblok = number of data blocks in x/yc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxhyd = maximum of (nx/2,ny)c nxyhd = one half of maximum of (nx,ny)c the real data is stored in a complex array of length nx/2, nyc with the odd/even x points stored in the real/imaginary parts.c in complex notation, fourier coefficients are stored as follows:c if ntpose = 0,c f(j,k,i) = mode j-1,kk-1, where kk = k + kyp*(i - 1)c 1 <= j <= nx/2 and 1 <= kk <= ny, except forc f(1,k,i) = mode nx/2,kk-1, where ny/2+2 <= kk <= ny, andc imaginary part of f(1,1,1) = real part of mode nx/2,0 andc imaginary part of f(1,1,(ny/2)/kyp+1) = real part of mode nx/2,ny/2c if ntpose = 1,c g(k,j,i) = mode jj-1,k-1, where jj = j + kxp*(i - 1)c 1 <= jj <= nx/2 and 1 <= k <= ny, except forc g(k,1,1) = mode nx/2,k-1, where ny/2+2 <= k <= ny, andc imaginary part of g(1,1,1) = real part of mode nx/2,0 andc imaginary part of g(ny/2+1,1,1) = real part of mode nx/2,ny/2c written by viktor k. decyk, uclac parallel, optimized version      implicit none      integer isign, ntpose, mixup, indx, indy, kstrt, nxvh      integer nyv, kxp, kyp, kypd, jblok, kblok, nxhyd, nxyhd      complex f, g, sct      dimension f(2,nxvh,kypd,kblok), g(2,nyv,kxp,jblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, nxh, nxhh, nxh2, ny, nyh, ny2, nxy      integer nxhy, ks, j, k, lb, ll, jb, it, nxyh, nrx, nry, l, i, m      integer ns, ns2, km, kmr, k1, k2, j1, j2, jj      real dnxy, arg, ani, at1      complex s, t, t1, t2      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nxh2 = nxh + 2      ny = 2**indy      nyh = ny/2      ny2 = ny + 2      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      if (isign) 50, 10, 360c prepare fft tablesc bit-reverse index table: mixup(j) = 1 + reversed bits of (j - 1)   10 do 30 j = 1, nxhy      lb = j - 1      ll = 0      do 20 k = 1, indx1y      jb = lb/2      it = lb - 2*jb      lb = jb      ll = 2*ll + it   20 continue      mixup(j) = ll + 1   30 continuec sine/cosine table for the angles 2*n*pi/nxy      nxyh = nxy/2      dnxy = 6.28318530717959/float(nxy)      do 40 j = 1, nxyh      arg = dnxy*float(j - 1)      sct(j) = cmplx(cos(arg),-sin(arg))   40 continue      returnc inverse fourier transform   50 if (kstrt.gt.ny) go to 230c swap complex components      do 80 l = 1, kblok      do 70 k = 1, kyp      do 60 j = 1, nxh      at1 = aimag(f(1,j,k,l))      f(1,j,k,l) = cmplx(real(f(1,j,k,l)),real(f(2,j,k,l)))      f(2,j,k,l) = cmplx(at1,aimag(f(2,j,k,l)))   60 continue   70 continue   80 continue      nrx = nxhy/nxh      do 110 l = 1, kblokc bit-reverse array elements in x      do 100 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 100      do 90 k = 1, kyp      t1 = f(1,j1,k,l)      t2 = f(2,j1,k,l)      f(1,j1,k,l) = f(1,j,k,l)      f(2,j1,k,l) = f(2,j,k,l)      f(1,j,k,l) = t1      f(2,j,k,l) = t2   90 continue  100 continue  110 continuec first transform in x      nrx = nxy/nxh      do 160 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 150 l = 1, kblok      do 140 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 130 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 120 i = 1, kyp      t1 = s*f(1,j2,i,l)      t2 = s*f(2,j2,i,l)      f(1,j2,i,l) = f(1,j1,i,l) - t1      f(2,j2,i,l) = f(2,j1,i,l) - t2      f(1,j1,i,l) = f(1,j1,i,l) + t1      f(2,j1,i,l) = f(2,j1,i,l) + t2  120 continue  130 continue  140 continue  150 continue  160 continuec unscramble coefficients and normalize      kmr = nxy/nx      ani = 1./float(2*nx*ny)      do 220 l = 1, kblok      do 190 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),-real(sct(1+kmr*(j-1))))      do 180 k = 1, kyp      do 170 jj = 1, 2      t = conjg(f(jj,nxh2-j,k,l))      s = f(jj,j,k,l) + t      t = (f(jj,j,k,l) - t)*t1      f(jj,j,k,l) = ani*(s + t)      f(jj,nxh2-j,k,l) = ani*conjg(s - t)  170 continue  180 continue  190 continue      do 210 k = 1, kyp      do 200 jj = 1, 2      f(jj,nxhh+1,k,l) = 2.*ani*conjg(f(jj,nxhh+1,k,l))      f(jj,1,k,l) = 2.*ani*cmplx(real(f(jj,1,k,l)) + aimag(f(jj,1,k,l)),     1real(f(jj,1,k,l)) - aimag(f(jj,1,k,l)))  200 continue  210 continue  220 continuec transpose f array to g  230 call P2TPOSEX(f,g,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kypd,jblok,kbl     1ok)      if (kstrt.gt.nxh) go to 350      nry = nxhy/ny      do 260 l = 1, jblokc bit-reverse array elements in y      do 250 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 250      do 240 j = 1, kxp      t1 = g(1,k1,j,l)      t2 = g(2,k1,j,l)      g(1,k1,j,l) = g(1,k,j,l)      g(2,k1,j,l) = g(2,k,j,l)      g(1,k,j,l) = t1      g(2,k,j,l) = t2  240 continue  250 continue  260 continuec then transform in y      nry = nxy/ny      do 310 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 300 l = 1, jblok      do 290 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 280 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 270 i = 1, kxp      t1 = s*g(1,j2,i,l)      t2 = s*g(2,j2,i,l)      g(1,j2,i,l) = g(1,j1,i,l) - t1      g(2,j2,i,l) = g(2,j1,i,l) - t2      g(1,j1,i,l) = g(1,j1,i,l) + t1      g(2,j1,i,l) = g(2,j1,i,l) + t2  270 continue  280 continue  290 continue  300 continue  310 continuec unscramble modes kx = 0, nx/2      do 340 l = 1, jblok      if ((l+ks).gt.0) go to 340      do 330 k = 2, nyh      do 320 jj = 1, 2      s = g(jj,ny2-k,1,l)      g(jj,ny2-k,1,l) = .5*cmplx(aimag(g(jj,k,1,l) + s),real(g(jj,k,1,l)     1- s))      g(jj,k,1,l) = .5*cmplx(real(g(jj,k,1,l) + s),aimag(g(jj,k,1,l) - s     1))  320 continue  330 continue  340 continuec transpose g array to f  350 if (ntpose.eq.0) call P2TPOSEX(g,f,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,k     1ypd,kxp,kblok,jblok)      returnc forward fourier transformc transpose f array to g  360 if (ntpose.eq.0) call P2TPOSEX(f,g,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,k     1xp,kypd,jblok,kblok)      if (kstrt.gt.nxh) go to 480      nry = nxhy/ny      do 420 l = 1, jblokc scramble modes kx = 0, nx/2      if ((l+ks).gt.0) go to 390      do 380 k = 2, nyh      do 370 jj = 1, 2      s = cmplx(aimag(g(jj,ny2-k,1,l)),real(g(jj,ny2-k,1,l)))      g(jj,ny2-k,1,l) = conjg(g(jj,k,1,l) - s)      g(jj,k,1,l) = g(jj,k,1,l) + s  370 continue  380 continuec bit-reverse array elements in y  390 do 410 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 410      do 400 j = 1, kxp      t1 = g(1,k1,j,l)      t2 = g(2,k1,j,l)      g(1,k1,j,l) = g(1,k,j,l)      g(2,k1,j,l) = g(2,k,j,l)      g(1,k,j,l) = t1      g(2,k,j,l) = t2  400 continue  410 continue  420 continuec first transform in y      nry = nxy/ny      do 470 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 460 l = 1, jblok      do 450 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 440 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 430 i = 1, kxp      t1 = s*g(1,j2,i,l)      t2 = s*g(2,j2,i,l)      g(1,j2,i,l) = g(1,j1,i,l) - t1      g(2,j2,i,l) = g(2,j1,i,l) - t2      g(1,j1,i,l) = g(1,j1,i,l) + t1      g(2,j1,i,l) = g(2,j1,i,l) + t2  430 continue  440 continue  450 continue  460 continue  470 continuec transpose g array to f  480 call P2TPOSEX(g,f,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kxp,kblok,jbl     1ok)      if (kstrt.gt.ny) return      nrx = nxhy/nxh      kmr = nxy/nx      do 560 l = 1, kblokc scramble coefficients      do 510 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),real(sct(1+kmr*(j-1))))      do 500 k = 1, kyp      do 490 jj = 1, 2      t = conjg(f(jj,nxh2-j,k,l))      s = f(jj,j,k,l) + t      t = (f(jj,j,k,l) - t)*t1      f(jj,j,k,l) = s + t      f(jj,nxh2-j,k,l) = conjg(s - t)  490 continue  500 continue  510 continue      do 530 k = 1, kyp      do 520 jj = 1, 2      f(jj,nxhh+1,k,l) = 2.*conjg(f(jj,nxhh+1,k,l))      f(jj,1,k,l) = cmplx(real(f(jj,1,k,l)) + aimag(f(jj,1,k,l)),real(f(     1jj,1,k,l)) - aimag(f(jj,1,k,l)))  520 continue  530 continuec bit-reverse array elements in x      do 550 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 550      do 540 k = 1, kyp      t1 = f(1,j1,k,l)      t2 = f(2,j1,k,l)      f(1,j1,k,l) = f(1,j,k,l)      f(2,j1,k,l) = f(2,j,k,l)      f(1,j,k,l) = t1      f(2,j,k,l) = t2  540 continue  550 continue  560 continuec then transform in x      nrx = nxy/nxh      do 610 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 600 l = 1, kblok      do 590 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 580 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 570 i = 1, kyp      t1 = s*f(1,j2,i,l)      t2 = s*f(2,j2,i,l)      f(1,j2,i,l) = f(1,j1,i,l) - t1      f(2,j2,i,l) = f(2,j1,i,l) - t2      f(1,j1,i,l) = f(1,j1,i,l) + t1      f(2,j1,i,l) = f(2,j1,i,l) + t2  570 continue  580 continue  590 continue  600 continue  610 continuec swap complex components      do 640 l = 1, kblok      do 630 k = 1, kyp      do 620 j = 1, nxh      at1 = aimag(f(1,j,k,l))      f(1,j,k,l) = cmplx(real(f(1,j,k,l)),real(f(2,j,k,l)))      f(2,j,k,l) = cmplx(at1,aimag(f(2,j,k,l)))  620 continue  630 continue  640 continue      return      endc-----------------------------------------------------------------------      subroutine PFFT2RX3(f,g,isign,ntpose,mixup,sct,indx,indy,kstrt,nxv     1h,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)c this subroutine performs 3 two dimensional complex to real fastc fourier transforms, using complex arithmetic,c for data which is distributed in blocksc for isign = 0, input: isign, indx, indy, kstrt, nxhyd, nxyhdc output: mixup, sctc for isign = (-1,1), input: all, output: f, gc for isign = -1, approximate flop count: N*(5*log2(N) + 10)/nvpc for isign = 1,  approximate flop count: N*(5*log2(N) + 8)/nvpc where N = (nx/2)*ny, and nvp = number of procsc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc ntpose = (0,1) = (no,yes) input, output data are transposedc if isign = 0, the fft tables are preparedc if isign = -1, three inverse fourier transforms are performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(1:3,n,m,l) = (1/nx*ny)*sum(f(1:3,j,k,i)*c       exp(-sqrt(-1)*2pi*n*j/nx)*exp(-sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, f is the input and g is the outputc g(1:3,m,n,l) = (1/nx*ny)*sum(f(1:3,j,k,i)*c       exp(-sqrt(-1)*2pi*nn*j/nx)*exp(-sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c if isign = 1, three forward fourier transforms are performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(1:3,j,k,i) = sum(f(1:3,n,m,l)*exp(sqrt(-1)*2pi*n*j/nx)*c       exp(sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, g is the input and f is the outputc f(1:3,j,k,i) = sum(g(1:3,m,n,l)*exp(sqrt(-1)*2pi*nn*j/nx)*c       exp(sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c kstrt = starting data block numberc nxvh/nyv = second dimension of f/gc kypd = third dimension of fc kxp/kyp = number of data values per block in x/yc jblok/kblok = number of data blocks in x/yc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxhyd = maximum of (nx/2,ny)c nxyhd = one half of maximum of (nx,ny)c the real data is stored in a complex array of length nx/2, nyc with the odd/even x points stored in the real/imaginary parts.c in complex notation, fourier coefficients are stored as follows:c if ntpose = 0,c f(j,k,i) = mode j-1,kk-1, where kk = k + kyp*(i - 1)c 1 <= j <= nx/2 and 1 <= kk <= ny, except forc f(1,k,i) = mode nx/2,kk-1, where ny/2+2 <= kk <= ny, andc imaginary part of f(1,1,1) = real part of mode nx/2,0 andc imaginary part of f(1,1,(ny/2)/kyp+1) = real part of mode nx/2,ny/2c if ntpose = 1,c g(k,j,i) = mode jj-1,k-1, where jj = j + kxp*(i - 1)c 1 <= jj <= nx/2 and 1 <= k <= ny, except forc g(k,1,1) = mode nx/2,k-1, where ny/2+2 <= k <= ny, andc imaginary part of g(1,1,1) = real part of mode nx/2,0 andc imaginary part of g(ny/2+1,1,1) = real part of mode nx/2,ny/2c written by viktor k. decyk, uclac parallel, optimized version      implicit none      integer isign, ntpose, indx, indy, kstrt, nxvh, nyv, kxp, kyp      integer kypd, jblok, kblok, nxhyd, nxyhd, mixup      complex f, g, sct      dimension f(3,nxvh,kypd,kblok), g(3,nyv,kxp,jblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, nxh, nxhh, nxh2, ny, nyh, ny2, nxy      integer nxhy, ks, j, k, lb, ll, jb, it, nxyh, nrx, nry, l, i, m      integer ns, ns2, km, kmr, k1, k2, j1, j2, jj      real dnxy, arg, ani, at1, at2      complex s, t, t1, t2, t3      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nxh2 = nxh + 2      ny = 2**indy      nyh = ny/2      ny2 = ny + 2      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      if (isign) 50, 10, 360c prepare fft tablesc bit-reverse index table: mixup(j) = 1 + reversed bits of (j - 1)   10 do 30 j = 1, nxhy      lb = j - 1      ll = 0      do 20 k = 1, indx1y      jb = lb/2      it = lb - 2*jb      lb = jb      ll = 2*ll + it   20 continue      mixup(j) = ll + 1   30 continuec sine/cosine table for the angles 2*n*pi/nxy      nxyh = nxy/2      dnxy = 6.28318530717959/float(nxy)      do 40 j = 1, nxyh      arg = dnxy*float(j - 1)      sct(j) = cmplx(cos(arg),-sin(arg))   40 continue      returnc inverse fourier transform   50 if (kstrt.gt.ny) go to 230c swap complex components      do 80 l = 1, kblok      do 70 i = 1, kyp      do 60 j = 1, nxh      at1 = real(f(3,j,i,l))      f(3,j,i,l) = cmplx(real(f(2,j,i,l)),aimag(f(3,j,i,l)))      at2 = aimag(f(2,j,i,l))      f(2,j,i,l) = cmplx(aimag(f(1,j,i,l)),at1)      f(1,j,i,l) = cmplx(real(f(1,j,i,l)),at2)   60 continue   70 continue   80 continue      nrx = nxhy/nxh      do 110 l = 1, kblokc bit-reverse array elements in x      do 100 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 100      do 90 k = 1, kyp      t1 = f(1,j1,k,l)      t2 = f(2,j1,k,l)      t3 = f(3,j1,k,l)      f(1,j1,k,l) = f(1,j,k,l)      f(2,j1,k,l) = f(2,j,k,l)      f(3,j1,k,l) = f(3,j,k,l)      f(1,j,k,l) = t1      f(2,j,k,l) = t2      f(3,j,k,l) = t3   90 continue  100 continue  110 continuec first transform in x      nrx = nxy/nxh      do 160 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 150 l = 1, kblok      do 140 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 130 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 120 i = 1, kyp      t1 = s*f(1,j2,i,l)      t2 = s*f(2,j2,i,l)      t3 = s*f(3,j2,i,l)      f(1,j2,i,l) = f(1,j1,i,l) - t1      f(2,j2,i,l) = f(2,j1,i,l) - t2      f(3,j2,i,l) = f(3,j1,i,l) - t3      f(1,j1,i,l) = f(1,j1,i,l) + t1      f(2,j1,i,l) = f(2,j1,i,l) + t2      f(3,j1,i,l) = f(3,j1,i,l) + t3  120 continue  130 continue  140 continue  150 continue  160 continuec unscramble coefficients and normalize      kmr = nxy/nx      ani = 1./float(2*nx*ny)      do 220 l = 1, kblok      do 190 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),-real(sct(1+kmr*(j-1))))      do 180 k = 1, kyp      do 170 jj = 1, 3      t = conjg(f(jj,nxh2-j,k,l))      s = f(jj,j,k,l) + t      t = (f(jj,j,k,l) - t)*t1      f(jj,j,k,l) = ani*(s + t)      f(jj,nxh2-j,k,l) = ani*conjg(s - t)  170 continue  180 continue  190 continue      do 210 k = 1, kyp      do 200 jj = 1, 3      f(jj,nxhh+1,k,l) = 2.*ani*conjg(f(jj,nxhh+1,k,l))      f(jj,1,k,l) = 2.*ani*cmplx(real(f(jj,1,k,l)) + aimag(f(jj,1,k,l)),     1real(f(jj,1,k,l)) - aimag(f(jj,1,k,l)))  200 continue  210 continue  220 continuec transpose f array to g  230 call P3TPOSEX(f,g,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kypd,jblok,kbl     1ok)      if (kstrt.gt.nxh) go to 350      nry = nxhy/ny      do 260 l = 1, jblokc bit-reverse array elements in y      do 250 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 250      do 240 j = 1, kxp      t1 = g(1,k1,j,l)      t2 = g(2,k1,j,l)      t3 = g(3,k1,j,l)      g(1,k1,j,l) = g(1,k,j,l)      g(2,k1,j,l) = g(2,k,j,l)      g(3,k1,j,l) = g(3,k,j,l)      g(1,k,j,l) = t1      g(2,k,j,l) = t2      g(3,k,j,l) = t3  240 continue  250 continue  260 continuec then transform in y      nry = nxy/ny      do 310 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 300 l = 1, jblok      do 290 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 280 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 270 i = 1, kxp      t1 = s*g(1,j2,i,l)      t2 = s*g(2,j2,i,l)      t3 = s*g(3,j2,i,l)      g(1,j2,i,l) = g(1,j1,i,l) - t1      g(2,j2,i,l) = g(2,j1,i,l) - t2      g(3,j2,i,l) = g(3,j1,i,l) - t3      g(1,j1,i,l) = g(1,j1,i,l) + t1      g(2,j1,i,l) = g(2,j1,i,l) + t2      g(3,j1,i,l) = g(3,j1,i,l) + t3  270 continue  280 continue  290 continue  300 continue  310 continuec unscramble modes kx = 0, nx/2      do 340 l = 1, jblok      if ((l+ks).gt.0) go to 340      do 330 k = 2, nyh      do 320 jj = 1, 3      s = g(jj,ny2-k,1,l)      g(jj,ny2-k,1,l) = .5*cmplx(aimag(g(jj,k,1,l) + s),real(g(jj,k,1,l)     1- s))      g(jj,k,1,l) = .5*cmplx(real(g(jj,k,1,l) + s),aimag(g(jj,k,1,l) - s     1))  320 continue  330 continue  340 continuec transpose g array to f  350 if (ntpose.eq.0) call P3TPOSEX(g,f,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,k     1ypd,kxp,kblok,jblok)      returnc forward fourier transformc transpose f array to g  360 if (ntpose.eq.0) call P3TPOSEX(f,g,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,k     1xp,kypd,jblok,kblok)      if (kstrt.gt.nxh) go to 480      nry = nxhy/ny      do 420 l = 1, jblokc scramble modes kx = 0, nx/2      if ((l+ks).gt.0) go to 390      do 380 k = 2, nyh      do 370 jj = 1, 3      s = cmplx(aimag(g(jj,ny2-k,1,l)),real(g(jj,ny2-k,1,l)))      g(jj,ny2-k,1,l) = conjg(g(jj,k,1,l) - s)      g(jj,k,1,l) = g(jj,k,1,l) + s  370 continue  380 continuec bit-reverse array elements in y  390 do 410 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 410      do 400 j = 1, kxp      t1 = g(1,k1,j,l)      t2 = g(2,k1,j,l)      t3 = g(3,k1,j,l)      g(1,k1,j,l) = g(1,k,j,l)      g(2,k1,j,l) = g(2,k,j,l)      g(3,k1,j,l) = g(3,k,j,l)      g(1,k,j,l) = t1      g(2,k,j,l) = t2      g(3,k,j,l) = t3  400 continue  410 continue  420 continuec first transform in y      nry = nxy/ny      do 470 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 460 l = 1, jblok      do 450 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 440 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 430 i = 1, kxp      t1 = s*g(1,j2,i,l)      t2 = s*g(2,j2,i,l)      t3 = s*g(3,j2,i,l)      g(1,j2,i,l) = g(1,j1,i,l) - t1      g(2,j2,i,l) = g(2,j1,i,l) - t2      g(3,j2,i,l) = g(3,j1,i,l) - t3      g(1,j1,i,l) = g(1,j1,i,l) + t1      g(2,j1,i,l) = g(2,j1,i,l) + t2      g(3,j1,i,l) = g(3,j1,i,l) + t3  430 continue  440 continue  450 continue  460 continue  470 continuec transpose g array to f  480 call P3TPOSEX(g,f,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kxp,kblok,jbl     1ok)      if (kstrt.gt.ny) return      nrx = nxhy/nxh      kmr = nxy/nx      do 560 l = 1, kblokc scramble coefficients      do 510 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),real(sct(1+kmr*(j-1))))      do 500 k = 1, kyp      do 490 jj = 1, 3      t = conjg(f(jj,nxh2-j,k,l))      s = f(jj,j,k,l) + t      t = (f(jj,j,k,l) - t)*t1      f(jj,j,k,l) = s + t      f(jj,nxh2-j,k,l) = conjg(s - t)  490 continue  500 continue  510 continue      do 530 k = 1, kyp      do 520 jj = 1, 3      f(jj,nxhh+1,k,l) = 2.*conjg(f(jj,nxhh+1,k,l))      f(jj,1,k,l) = cmplx(real(f(jj,1,k,l)) + aimag(f(jj,1,k,l)),real(f(     1jj,1,k,l)) - aimag(f(jj,1,k,l)))  520 continue  530 continuec bit-reverse array elements in x      do 550 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 550      do 540 k = 1, kyp      t1 = f(1,j1,k,l)      t2 = f(2,j1,k,l)      t3 = f(3,j1,k,l)      f(1,j1,k,l) = f(1,j,k,l)      f(2,j1,k,l) = f(2,j,k,l)      f(3,j1,k,l) = f(3,j,k,l)      f(1,j,k,l) = t1      f(2,j,k,l) = t2      f(3,j,k,l) = t3  540 continue  550 continue  560 continuec then transform in x      nrx = nxy/nxh      do 610 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 600 l = 1, kblok      do 590 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 580 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 570 i = 1, kyp      t1 = s*f(1,j2,i,l)      t2 = s*f(2,j2,i,l)      t3 = s*f(3,j2,i,l)      f(1,j2,i,l) = f(1,j1,i,l) - t1      f(2,j2,i,l) = f(2,j1,i,l) - t2      f(3,j2,i,l) = f(3,j1,i,l) - t3      f(1,j1,i,l) = f(1,j1,i,l) + t1      f(2,j1,i,l) = f(2,j1,i,l) + t2      f(3,j1,i,l) = f(3,j1,i,l) + t3  570 continue  580 continue  590 continue  600 continue  610 continuec swap complex components      do 640 l = 1, kblok      do 630 i = 1, kyp      do 620 j = 1, nxh      at1 = real(f(3,j,i,l))      f(3,j,i,l) = cmplx(aimag(f(2,j,i,l)),aimag(f(3,j,i,l)))      at2 = real(f(2,j,i,l))      f(2,j,i,l) = cmplx(at1,aimag(f(1,j,i,l)))      f(1,j,i,l) = cmplx(real(f(1,j,i,l)),at2)  620 continue  630 continue  640 continue      return      endc-----------------------------------------------------------------------      subroutine PFFT2C(f,g,bs,br,isign,ntpose,mixup,sct,indx,indy,kstrt     1,nxv,nyv,kxp,kyp,kypd,jblok,kblok,nxyd,nxyhd)c this subroutine performs a two dimensional complex to complex fastc fourier transform and its inverse, using complex arithmetic,c for data which is distributed in blocksc for isign = 0, input: isign, indx, indy, kstrt, nxyd, nxyhdc output: mixup, sctc for isign = (-1,1), input: all, output: f, g, bs, brc approximate flop count: 5*N*log2(N)/nvpc where N = nx*ny, and nvp = number of procsc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc ntpose = (0,1) = (no,yes) input, output data are transposedc if isign = 0, the fft tables are preparedc if isign = -1, an inverse fourier transform is performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(n,m,l) = (1/nx*ny)*sum(f(j,k,i)*c       exp(-sqrt(-1)*2pi*n*j/nx)*exp(-sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, f is the input and g is the outputc g(m,n,l) = (1/nx*ny)*sum(f(j,k,i)*c       exp(-sqrt(-1)*2pi*nn*j/nx)*exp(-sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c if isign = 1, a forward fourier transform is performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(j,k,i) = sum(f(n,m,l)*exp(sqrt(-1)*2pi*n*j/nx)*c       exp(sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, g is the input and f is the outputc f(j,k,i) = sum(g(m,n,l)*exp(sqrt(-1)*2pi*nn*j/nx)*c       exp(sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c bs, br = scratch arraysc kstrt = starting data block numberc nxv/nyv = first dimension of f/gc kypd = second dimension of f c kxp/kyp = number of data values per block in x/yc jblok/kblok = number of data blocks in x/yc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxy = maximum of (nx,ny)c nxyh = one half of maximum of (nx,ny)c written by viktor k. decyk, uclac parallel version      implicit none      integer isign, ntpose, indx, indy, kstrt, nxv, nyv, kxp, kyp      integer kypd, jblok, kblok, nxyd, nxyhd, mixup      complex f, g, bs, br, sct      dimension f(nxv,kypd,kblok), g(nyv,kxp,jblok)      dimension bs(kxp,kyp,kblok), br(kxp,kyp,jblok)      dimension mixup(nxyd), sct(nxyhd)c local data      integer indxy, nx, nxh, ny, nyh, nxy, j, k, lb, ll, jb, it, nxyh      integer nrx, nry, l, i, m, ns, ns2, km, kmr, k1, k2, j1, j2      real dnxy, arg, ani      complex s, t      indxy = max0(indx,indy)      nx = 2**indx      nxh = nx/2      ny = 2**indy      nyh = ny/2      nxy = 2**indxy      if (isign) 50, 10, 270c prepare fft tablesc bit-reverse index table: mixup(j) = 1 + reversed bits of (j - 1)   10 do 30 j = 1, nxy      lb = j - 1      ll = 0      do 20 k = 1, indxy      jb = lb/2      it = lb - 2*jb      lb = jb      ll = 2*ll + it   20 continue      mixup(j) = ll + 1   30 continuec sine/cosine table for the angles 2*n*pi/nxy      nxyh = nxy/2      dnxy = 6.28318530717959/float(nxy)      do 40 j = 1, nxyh      arg = dnxy*float(j - 1)      sct(j) = cmplx(cos(arg),-sin(arg))   40 continue      returnc inverse fourier transform   50 if (kstrt.gt.ny) go to 140      nrx = nxy/nx      do 80 l = 1, kblokc bit-reverse array elements in x      do 70 j = 1, nx      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 70      do 60 k = 1, kyp      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = t   60 continue   70 continue   80 continuec first transform in x      do 130 m = 1, indx      ns = 2**(m - 1)      ns2 = ns + ns      km = nxh/ns      kmr = km*nrx      do 120 l = 1, kblok      do 110 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 100 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 90 i = 1, kyp      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t   90 continue  100 continue  110 continue  120 continue  130 continuec transpose f array to g  140 call PTPOSE(f,g,bs,br,nx,ny,kstrt,nxv,nyv,kxp,kyp,kxp,kypd,jblok,k     1blok)      if (kstrt.gt.nx) go to 260      nry = nxy/ny      do 170 l = 1, jblokc bit-reverse array elements in y      do 160 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 160      do 150 j = 1, kxp      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = t  150 continue  160 continue  170 continuec then transform in y      do 220 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 210 l = 1, jblok      do 200 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 190 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 180 i = 1, kxp      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t  180 continue  190 continue  200 continue  210 continue  220 continuec normalize result      ani = 1./float(nx*ny)      do 250 l = 1, jblok      do 240 j = 1, kxp      do 230 k = 1, ny      g(k,j,l) = g(k,j,l)*ani  230 continue  240 continue  250 continuec transpose g array to f  260 if (ntpose.eq.0) call PTPOSE(g,f,br,bs,ny,nx,kstrt,nyv,nxv,kyp,kxp     1,kypd,kxp,kblok,jblok)      returnc forward fourier transformc transpose f array to g  270 if (ntpose.eq.0) call PTPOSE(f,g,bs,br,nx,ny,kstrt,nxv,nyv,kxp,kyp     1,kxp,kypd,jblok,kblok)      if (kstrt.gt.nx) go to 360      nry = nxy/ny      do 300 l = 1, jblokc bit-reverse array elements in y      do 290 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 290      do 280 j = 1, kxp      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = t  280 continue  290 continue  300 continuec first transform in y      do 350 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 340 l = 1, jblok      do 330 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 320 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 310 i = 1, kxp      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t  310 continue  320 continue  330 continue  340 continue  350 continuec transpose g array to f  360 call PTPOSE(g,f,br,bs,ny,nx,kstrt,nyv,nxv,kyp,kxp,kypd,kxp,kblok,j     1blok)      if (kstrt.gt.ny) return      nrx = nxy/nx      do 390 l = 1, kblokc bit-reverse array elements in x      do 380 j = 1, nx      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 380      do 370 k = 1, kyp      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = t  370 continue  380 continue  390 continuec then transform in x      do 440 m = 1, indx      ns = 2**(m - 1)      ns2 = ns + ns      km = nxh/ns      kmr = km*nrx      do 430 l = 1, kblok      do 420 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 410 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 400 i = 1, kyp      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t  400 continue  410 continue  420 continue  430 continue  440 continue      return      end