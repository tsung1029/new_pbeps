c-----------------------------------------------------------------------      program pfft2tst      implicit none      integer indx, indy, indnvp, mshare, nx, ny, nxh, nvp, kyp, kxp      integer kyb, kxb, jkmx, kxyb, kbmin, kblok, jbmin, jblok      integer nmx, nxy, nmxh, nxhy, nxv, nyv, nxvh, nxyhc indnvp = exponent which determines number of virtual processorsc mshare = (0,1) = (no,yes) architecture is shared memory      parameter( indx =   7, indy =   8, indnvp =   2, mshare =   0)      parameter(nx=2**indx,ny=2**indy,nxh=nx/2)      parameter(nvp=2**indnvp,kyp=(ny-1)/nvp+1,kxp=(nxh-1)/nvp+1)      parameter(kyb=ny/kyp,kxb=nxh/kxp,jkmx=kxb*(kyb/kxb)+kyb*(kxb/kyb))      parameter(kxyb=jkmx/(2-kxb/jkmx-kyb/jkmx))      parameter(kbmin=kxyb/kxb,kblok=kbmin+mshare*(ny/kyp-kbmin))      parameter(jbmin=kxyb/kyb,jblok=jbmin+mshare*(nxh/kxp-jbmin))      parameter(nmx=nx*(ny/nx)+ny*(nx/ny),nxy=nmx/(2-nx/nmx-ny/nmx))      parameter(nmxh=nxh*(ny/nxh)+ny*(nxh/ny))      parameter(nxhy=nmxh/(2-nxh/nmxh-ny/nmxh))      parameter(nxv=nx+2,nyv=ny+2,nxvh=nxv/2,nxyh=nxy/2)      integer mixup, msid, mrid, i, j, k, l, kk, k1, ntpose, isign      integer idproc, kstrt, ks, koff      real f, g, h, time, sum1, eps, work1      complex sct, bs, br      double precision dtime      double precision ranorm      dimension f(nxv,kyp,kblok), g(2*nyv,kxp,jblok)      dimension h(nxv,ny)      dimension time(2)c mixup, sct = arrays for fft      dimension mixup(nxhy), sct(nxyh), msid(kxb), mrid(kyb)      dimension bs(kxp,kyp,kblok), br(kxp,kyp,jblok)c ntpose = (0,1) = (no,yes) input, output data are transposed in pfft2r      data ntpose /1/c initialize for parallel processing      call PPINIT(idproc,nvp)      kstrt = idproc + 1      ks = kstrt - 2c prepare fft tables      isign = 0      call PFFT2R(f,g,bs,br,isign,ntpose,mixup,sct,indx,indy,kstrt,nxvh,     1nyv,kxp,kyp,kyp,jblok,kblok,nxhy,nxyh)c     call PFFT2RX(f,g,isign,ntpose,mixup,sct,indx,indy,kstrt,nxvh,nyv,kc    1xp,kyp,kyp,jblok,kblok,nxhy,nxyh)c     call PFFT2RY(f,g,msid,mrid,isign,ntpose,mixup,sct,indx,indy,kstrt,c    1nxvh,nyv,kxp,kyp,kxb,kyb,kyp,jblok,kblok,nxhy,nxyh)c create test function      do 30 k = 1, ny      kk = (k - 1)/kyp      k1 = k - kyp*kk      do 20 j = 1, nx      h(j,k) = ranorm()      do 10 l = 1, kblok      if (kk.eq.(l+ks)) f(j,k1,l) = h(j,k)   10 continue   20 continue   30 continue      call PTIMERA(-1,time,dtime)      do 40 i = 1, 10c transform to fourier space      isign = -1      call PFFT2R(f,g,bs,br,isign,ntpose,mixup,sct,indx,indy,kstrt,nxvh,     1nyv,kxp,kyp,kyp,jblok,kblok,nxhy,nxyh)c     call PFFT2RX(f,g,isign,ntpose,mixup,sct,indx,indy,kstrt,nxvh,nyv,kc    1xp,kyp,kyp,jblok,kblok,nxhy,nxyh)c     call PFFT2RY(f,g,msid,mrid,isign,ntpose,mixup,sct,indx,indy,kstrt,c    1nxvh,nyv,kxp,kyp,kxb,kyb,kyp,jblok,kblok,nxhy,nxyh)c     call PTPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kyp,jblok,c    1kblok)c     call PTPOSEX(f,g,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kyp,jblok,kblokc    1)c     call PTPOSEY(f,g,msid,mrid,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxb,kyb,kc    1xp,kyp,jblok,kblok)c transform to real space      isign = 1      call PFFT2R(f,g,bs,br,isign,ntpose,mixup,sct,indx,indy,kstrt,nxvh,     1nyv,kxp,kyp,kyp,jblok,kblok,nxhy,nxyh)c     call PFFT2RX(f,g,isign,ntpose,mixup,sct,indx,indy,kstrt,nxvh,nyv,kc    1xp,kyp,kyp,jblok,kblok,nxhy,nxyh)c     call PFFT2RY(f,g,msid,mrid,isign,ntpose,mixup,sct,indx,indy,kstrt,c    1nxvh,nyv,kxp,kyp,kxb,kyb,kyp,jblok,kblok,nxhy,nxyh)c     call PTPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kyp,kxp,kblok,c    1jblok)c     call PTPOSEX(g,f,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kyp,kxp,kblok,jblokc    1)c     call PTPOSEY(g,f,mrid,msid,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kyb,kxb,kc    1yp,kxp,kblok,jblok)   40 continue      call PTIMERA(1,time,dtime)      sum1 = 0.      if (kstrt.gt.ny) go to 80      do 70 l = 1, kblok      koff = kyp*(l + ks)      do 60 k = 1, kyp      k1 = k + koff      do 50 j = 1, nx      eps = abs(f(j,k,l) - h(j,k1))c     if (eps.gt..000001) thenc        write (6,*) j,k1,h(j,k1)c     endif      sum1 = sum1 + eps   50 continue   60 continue   70 continue   80 continue      call PSUM(sum1,work1,1,1)      call PPEXIT      if (kstrt.eq.1) then         write (6,*) 'pfft2rx max/min real time=',time(1),time(2),'sec'         write (6,*) 'error=',sum1         pause      endif      stop      endc-----------------------------------------------------------------------      function ranorm()c this program calculates a random number y from a gaussian distributionc with zero mean and unit variance, according to the method ofc mueller and box:c    y(k) = (-2*ln(x(k)))**1/2*sin(2*pi*x(k+1))c    y(k+1) = (-2*ln(x(k)))**1/2*cos(2*pi*x(k+1)),c where x is a random number uniformly distributed on (0,1).c written for the ibm by viktor k. decyk, ucla      integer r1,r2,r4,r5      double precision ranorm,h1l,h1u,h2l,r0,r3,asc,bsc,temp      save iflg,r1,r2,r4,r5,h1l,h1u,h2l,r0      data r1,r2,r4,r5 /885098780,1824280461,1396483093,55318673/      data h1l,h1u,h2l /65531.0d0,32767.0d0,65525.0d0/      data iflg,r0 /0,0.0d0/      if (iflg.eq.0) go to 10      ranorm = r0      r0 = 0.0d0      iflg = 0      return   10 isc = 65536      asc = dfloat(isc)      bsc = asc*asc      i1 = r1 - (r1/isc)*isc      r3 = h1l*dfloat(r1) + asc*h1u*dfloat(i1)      i1 = r3/bsc      r3 = r3 - dfloat(i1)*bsc      bsc = 0.5d0*bsc      i1 = r2/isc      isc = r2 - i1*isc      r0 = h1l*dfloat(r2) + asc*h1u*dfloat(isc)      asc = 1.0d0/bsc      isc = r0*asc      r2 = r0 - dfloat(isc)*bsc      r3 = r3 + (dfloat(isc) + 2.0d0*h1u*dfloat(i1))      isc = r3*asc      r1 = r3 - dfloat(isc)*bsc      temp = dsqrt(-2.0d0*dlog((dfloat(r1) + dfloat(r2)*asc)*asc))      isc = 65536      asc = dfloat(isc)      bsc = asc*asc      i1 = r4 - (r4/isc)*isc      r3 = h2l*dfloat(r4) + asc*h1u*dfloat(i1)      i1 = r3/bsc      r3 = r3 - dfloat(i1)*bsc      bsc = 0.5d0*bsc      i1 = r5/isc      isc = r5 - i1*isc      r0 = h2l*dfloat(r5) + asc*h1u*dfloat(isc)      asc = 1.0d0/bsc      isc = r0*asc      r5 = r0 - dfloat(isc)*bsc      r3 = r3 + (dfloat(isc) + 2.0d0*h1u*dfloat(i1))      isc = r3*asc      r4 = r3 - dfloat(isc)*bsc      r0 = 6.28318530717959d0*((dfloat(r4) + dfloat(r5)*asc)*asc)      ranorm = temp*dsin(r0)      r0 = temp*dcos(r0)      iflg = 1      return      endc-----------------------------------------------------------------------      subroutine PFFT2R(f,g,bs,br,isign,ntpose,mixup,sct,indx,indy,kstrt     1,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)c this subroutine performs a two dimensional real to complex fastc fourier transform and its inverse, using complex arithmetic,c for data which is distributed in blocksc for isign = 0, input: isign, indx, indy, kstrt, nxhyd, nxyhdc output: mixup, sctc for isign = (-1,1), input: all, output: f, g, bs, brc for isign = -1, approximate flop count: N*(5*log2(N) + 10)/nvpc for isign = 1,  approximate flop count: N*(5*log2(N) + 8)/nvpc where N = (nx/2)*ny, and nvp = number of procsc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc ntpose = (0,1) = (no,yes) input, output data are transposedc if isign = 0, the fft tables are preparedc if isign = -1, an inverse fourier transform is performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(n,m,l) = (1/nx*ny)*sum(f(j,k,i)*c       exp(-sqrt(-1)*2pi*n*j/nx)*exp(-sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, f is the input and g is the outputc g(m,n,l) = (1/nx*ny)*sum(f(j,k,i)*c       exp(-sqrt(-1)*2pi*nn*j/nx)*exp(-sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c if isign = 1, a forward fourier transform is performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(j,k,i) = sum(f(n,m,l)*exp(sqrt(-1)*2pi*n*j/nx)*c       exp(sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, g is the input and f is the outputc f(j,k,i) = sum(g(m,n,l)*exp(sqrt(-1)*2pi*nn*j/nx)*c       exp(sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c bs, br = scratch arraysc kstrt = starting data block numberc nxvh/nyv = first dimension of f/gc kypd = second dimension of fc kxp/kyp = number of data values per block in x/yc jblok/kblok = number of data blocks in x/yc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxhyd = maximum of (nx/2,ny)c nxyhd = one half of maximum of (nx,ny)c the real data is stored in a complex array of length nx/2, nyc with the odd/even x points stored in the real/imaginary parts.c in complex notation, fourier coefficients are stored as follows:c if ntpose = 0,c f(j,k,i) = mode j-1,kk-1, where kk = k + kyp*(i - 1)c 1 <= j <= nx/2 and 1 <= kk <= ny, except forc f(1,k,i) = mode nx/2,kk-1, where ny/2+2 <= kk <= ny, andc imaginary part of f(1,1,1) = real part of mode nx/2,0 andc imaginary part of f(1,1,(ny/2)/kyp+1) = real part of mode nx/2,ny/2c if ntpose = 1,c g(k,j,i) = mode jj-1,k-1, where jj = j + kxp*(i - 1)c 1 <= jj <= nx/2 and 1 <= k <= ny, except forc g(k,1,1) = mode nx/2,k-1, where ny/2+2 <= k <= ny, andc imaginary part of g(1,1,1) = real part of mode nx/2,0 andc imaginary part of g(ny/2+1,1,1) = real part of mode nx/2,ny/2c written by viktor k. decyk, uclac parallel version      implicit none      integer isign, ntpose, indx, indy, kstrt, nxvh, nyv, kxp, kyp      integer kypd, jblok, kblok, nxhyd, nxyhd, mixup      complex f, g, bs, br, sct      dimension f(nxvh,kypd,kblok), g(nyv,kxp,jblok)      dimension bs(kxp,kyp,kblok), br(kxp,kyp,jblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, nxh, nxhh, nxh2, ny, nyh, ny2, nxy      integer nxhy, ks, j, k, lb, ll, jb, it, nxyh, nrx, nry, l, i, m      integer ns, ns2, km, kmr, k1, k2, j1, j2      real dnxy, arg, ani      complex s, t, t1      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nxh2 = nxh + 2      ny = 2**indy      nyh = ny/2      ny2 = ny + 2      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      if (isign) 50, 10, 300c prepare fft tablesc bit-reverse index table: mixup(j) = 1 + reversed bits of (j - 1)   10 do 30 j = 1, nxhy      lb = j - 1      ll = 0      do 20 k = 1, indx1y      jb = lb/2      it = lb - 2*jb      lb = jb      ll = 2*ll + it   20 continue      mixup(j) = ll + 1   30 continuec sine/cosine table for the angles 2*n*pi/nxy      nxyh = nxy/2      dnxy = 6.28318530717959/float(nxy)      do 40 j = 1, nxyh      arg = dnxy*float(j - 1)      sct(j) = cmplx(cos(arg),-sin(arg))   40 continue      returnc inverse fourier transform   50 if (kstrt.gt.ny) go to 180      nrx = nxhy/nxh      do 80 l = 1, kblokc bit-reverse array elements in x      do 70 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 70      do 60 k = 1, kyp      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = t   60 continue   70 continue   80 continuec first transform in x      nrx = nxy/nxh      do 130 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 120 l = 1, kblok      do 110 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 100 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 90 i = 1, kyp      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t   90 continue  100 continue  110 continue  120 continue  130 continuec unscramble coefficients and normalize      kmr = nxy/nx      ani = 1./float(2*nx*ny)      do 170 l = 1, kblok      do 150 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),-real(sct(1+kmr*(j-1))))      do 140 k = 1, kyp      t = conjg(f(nxh2-j,k,l))      s = f(j,k,l) + t      t = (f(j,k,l) - t)*t1      f(j,k,l) = ani*(s + t)      f(nxh2-j,k,l) = ani*conjg(s - t)  140 continue  150 continue      do 160 k = 1, kyp      f(nxhh+1,k,l) = 2.*ani*conjg(f(nxhh+1,k,l))      f(1,k,l) = 2.*ani*cmplx(real(f(1,k,l)) + aimag(f(1,k,l)),real(f(1,     1k,l)) - aimag(f(1,k,l)))  160 continue  170 continuec transpose f array to g  180 call PTPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kypd,jblok     1,kblok)      if (kstrt.gt.nxh) go to 290      nry = nxhy/ny      do 210 l = 1, jblokc bit-reverse array elements in y      do 200 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 200      do 190 j = 1, kxp      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = t  190 continue  200 continue  210 continuec then transform in y      nry = nxy/ny      do 260 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 250 l = 1, jblok      do 240 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 230 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 220 i = 1, kxp      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t  220 continue  230 continue  240 continue  250 continue  260 continuec unscramble modes kx = 0, nx/2      do 280 l = 1, jblok      if ((l+ks).gt.0) go to 280      do 270 k = 2, nyh      s = g(ny2-k,1,l)      g(ny2-k,1,l) = .5*cmplx(aimag(g(k,1,l) + s),real(g(k,1,l) - s))      g(k,1,l) = .5*cmplx(real(g(k,1,l) + s),aimag(g(k,1,l) - s))  270 continue  280 continuec transpose g array to f  290 if (ntpose.eq.0) call PTPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,kyp,k     1xp,kypd,kxp,kblok,jblok)      returnc forward fourier transformc transpose f array to g  300 if (ntpose.eq.0) call PTPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,kxp,k     1yp,kxp,kypd,jblok,kblok)      if (kstrt.gt.nxh) go to 410      nry = nxhy/ny      do 350 l = 1, jblokc scramble modes kx = 0, nx/2      if ((l+ks).gt.0) go to 320      do 310 k = 2, nyh      s = cmplx(aimag(g(ny2-k,1,l)),real(g(ny2-k,1,l)))      g(ny2-k,1,l) = conjg(g(k,1,l) - s)      g(k,1,l) = g(k,1,l) + s  310 continuec bit-reverse array elements in y  320 do 340 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 340      do 330 j = 1, kxp      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = t  330 continue  340 continue  350 continuec first transform in y      nry = nxy/ny      do 400 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 390 l = 1, jblok      do 380 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 370 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 360 i = 1, kxp      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t  360 continue  370 continue  380 continue  390 continue  400 continuec transpose g array to f  410 call PTPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kxp,kblok     1,jblok)      if (kstrt.gt.ny) return      nrx = nxhy/nxh      kmr = nxy/nx      do 470 l = 1, kblokc scramble coefficients      do 430 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),real(sct(1+kmr*(j-1))))      do 420 k = 1, kyp      t = conjg(f(nxh2-j,k,l))      s = f(j,k,l) + t      t = (f(j,k,l) - t)*t1      f(j,k,l) = s + t      f(nxh2-j,k,l) = conjg(s - t)  420 continue  430 continue      do 440 k = 1, kyp      f(nxhh+1,k,l) = 2.*conjg(f(nxhh+1,k,l))      f(1,k,l) = cmplx(real(f(1,k,l)) + aimag(f(1,k,l)),real(f(1,k,l)) -     1 aimag(f(1,k,l)))  440 continuec bit-reverse array elements in x      do 460 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 460      do 450 k = 1, kyp      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = t  450 continue  460 continue  470 continuec then transform in x      nrx = nxy/nxh      do 520 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 510 l = 1, kblok      do 500 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 490 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 480 i = 1, kyp      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t  480 continue  490 continue  500 continue  510 continue  520 continue      return      endc-----------------------------------------------------------------------      subroutine PFFT2RX(f,g,isign,ntpose,mixup,sct,indx,indy,kstrt,nxvh     1,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)c this subroutine performs a two dimensional real to complex fastc fourier transform and its inverse, using complex arithmetic,c for data which is distributed in blocksc for isign = 0, input: isign, indx, indy, kstrt, nxhyd, nxyhdc output: mixup, sctc for isign = (-1,1), input: all, output: f, gc for isign = -1, approximate flop count: N*(5*log2(N) + 10)/nvpc for isign = 1,  approximate flop count: N*(5*log2(N) + 8)/nvpc where N = (nx/2)*ny, and nvp = number of procsc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc ntpose = (0,1) = (no,yes) input, output data are transposedc if isign = 0, the fft tables are preparedc if isign = -1, an inverse fourier transform is performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(n,m,l) = (1/nx*ny)*sum(f(j,k,i)*c       exp(-sqrt(-1)*2pi*n*j/nx)*exp(-sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, f is the input and g is the outputc g(m,n,l) = (1/nx*ny)*sum(f(j,k,i)*c       exp(-sqrt(-1)*2pi*nn*j/nx)*exp(-sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c if isign = 1, a forward fourier transform is performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(j,k,i) = sum(f(n,m,l)*exp(sqrt(-1)*2pi*n*j/nx)*c       exp(sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, g is the input and f is the outputc f(j,k,i) = sum(g(m,n,l)*exp(sqrt(-1)*2pi*nn*j/nx)*c       exp(sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c kstrt = starting data block numberc nxvh/nyv = first dimension of f/gc kypd = second dimension of fc kxp/kyp = number of data values per block in x/yc jblok/kblok = number of data blocks in x/yc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxhyd = maximum of (nx/2,ny)c nxyhd = one half of maximum of (nx,ny)c the real data is stored in a complex array of length nx/2, nyc with the odd/even x points stored in the real/imaginary parts.c in complex notation, fourier coefficients are stored as follows:c if ntpose = 0,c f(j,k,i) = mode j-1,kk-1, where kk = k + kyp*(i - 1)c 1 <= j <= nx/2 and 1 <= kk <= ny, except forc f(1,k,i) = mode nx/2,kk-1, where ny/2+2 <= kk <= ny, andc imaginary part of f(1,1,1) = real part of mode nx/2,0 andc imaginary part of f(1,1,(ny/2)/kyp+1) = real part of mode nx/2,ny/2c if ntpose = 1,c g(k,j,i) = mode jj-1,k-1, where jj = j + kxp*(i - 1)c 1 <= jj <= nx/2 and 1 <= k <= ny, except forc g(k,1,1) = mode nx/2,k-1, where ny/2+2 <= k <= ny, andc imaginary part of g(1,1,1) = real part of mode nx/2,0 andc imaginary part of g(ny/2+1,1,1) = real part of mode nx/2,ny/2c written by viktor k. decyk, uclac parallel, RISC optimized version      implicit none      integer isign, ntpose, mixup, indx, indy, kstrt, nxvh      integer nyv, kxp, kyp, kypd, jblok, kblok, nxhyd, nxyhd      complex f, g, sct      dimension f(nxvh,kypd,kblok), g(nyv,kxp,jblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, nxh, nxhh, nxh2, ny, nyh, ny2, nxy      integer nxhy, ks, j, k, lb, ll, jb, it, nxyh, nrx, nry, l, i, m      integer ns, ns2, km, kmr, k1, k2, j1, j2      real dnxy, arg, ani      complex s, t, t1      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nxh2 = nxh + 2      ny = 2**indy      nyh = ny/2      ny2 = ny + 2      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      if (isign) 50, 10, 300c prepare fft tablesc bit-reverse index table: mixup(j) = 1 + reversed bits of (j - 1)   10 do 30 j = 1, nxhy      lb = j - 1      ll = 0      do 20 k = 1, indx1y      jb = lb/2      it = lb - 2*jb      lb = jb      ll = 2*ll + it   20 continue      mixup(j) = ll + 1   30 continuec sine/cosine table for the angles 2*n*pi/nxy      nxyh = nxy/2      dnxy = 6.28318530717959/float(nxy)      do 40 j = 1, nxyh      arg = dnxy*float(j - 1)      sct(j) = cmplx(cos(arg),-sin(arg))   40 continue      returnc inverse fourier transform   50 if (kstrt.gt.ny) go to 180      nrx = nxhy/nxh      do 80 l = 1, kblokc bit-reverse array elements in x      do 70 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 70      do 60 k = 1, kyp      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = t   60 continue   70 continue   80 continuec first transform in x      nrx = nxy/nxh      do 130 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 120 l = 1, kblok      do 110 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 100 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 90 i = 1, kyp      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t   90 continue  100 continue  110 continue  120 continue  130 continuec unscramble coefficients and normalize      kmr = nxy/nx      ani = 1./float(2*nx*ny)      do 170 l = 1, kblok      do 150 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),-real(sct(1+kmr*(j-1))))      do 140 k = 1, kyp      t = conjg(f(nxh2-j,k,l))      s = f(j,k,l) + t      t = (f(j,k,l) - t)*t1      f(j,k,l) = ani*(s + t)      f(nxh2-j,k,l) = ani*conjg(s - t)  140 continue  150 continue      do 160 k = 1, kyp      f(nxhh+1,k,l) = 2.*ani*conjg(f(nxhh+1,k,l))      f(1,k,l) = 2.*ani*cmplx(real(f(1,k,l)) + aimag(f(1,k,l)),real(f(1,     1k,l)) - aimag(f(1,k,l)))  160 continue  170 continuec transpose f array to g  180 call PTPOSEX(f,g,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kypd,jblok,kblo     1k)      if (kstrt.gt.nxh) go to 290      nry = nxhy/ny      do 210 l = 1, jblokc bit-reverse array elements in y      do 200 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 200      do 190 j = 1, kxp      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = t  190 continue  200 continue  210 continuec then transform in y      nry = nxy/ny      do 260 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 250 l = 1, jblok      do 240 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 230 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 220 i = 1, kxp      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t  220 continue  230 continue  240 continue  250 continue  260 continuec unscramble modes kx = 0, nx/2      do 280 l = 1, jblok      if ((l+ks).gt.0) go to 280      do 270 k = 2, nyh      s = g(ny2-k,1,l)      g(ny2-k,1,l) = .5*cmplx(aimag(g(k,1,l) + s),real(g(k,1,l) - s))      g(k,1,l) = .5*cmplx(real(g(k,1,l) + s),aimag(g(k,1,l) - s))  270 continue  280 continuec transpose g array to f  290 if (ntpose.eq.0) call PTPOSEX(g,f,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,ky     1pd,kxp,kblok,jblok)      returnc forward fourier transformc transpose f array to g  300 if (ntpose.eq.0) call PTPOSEX(f,g,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kx     1p,kypd,jblok,kblok)      if (kstrt.gt.nxh) go to 410      nry = nxhy/ny      do 350 l = 1, jblokc scramble modes kx = 0, nx/2      if ((l+ks).gt.0) go to 320      do 310 k = 2, nyh      s = cmplx(aimag(g(ny2-k,1,l)),real(g(ny2-k,1,l)))      g(ny2-k,1,l) = conjg(g(k,1,l) - s)      g(k,1,l) = g(k,1,l) + s  310 continuec bit-reverse array elements in y  320 do 340 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 340      do 330 j = 1, kxp      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = t  330 continue  340 continue  350 continuec first transform in y      nry = nxy/ny      do 400 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 390 l = 1, jblok      do 380 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 370 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 360 i = 1, kxp      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t  360 continue  370 continue  380 continue  390 continue  400 continuec transpose g array to f  410 call PTPOSEX(g,f,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kxp,kblok,jblo     1k)      if (kstrt.gt.ny) return      nrx = nxhy/nxh      kmr = nxy/nx      do 470 l = 1, kblokc scramble coefficients      do 430 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),real(sct(1+kmr*(j-1))))      do 420 k = 1, kyp      t = conjg(f(nxh2-j,k,l))      s = f(j,k,l) + t      t = (f(j,k,l) - t)*t1      f(j,k,l) = s + t      f(nxh2-j,k,l) = conjg(s - t)  420 continue  430 continue      do 440 k = 1, kyp      f(nxhh+1,k,l) = 2.*conjg(f(nxhh+1,k,l))      f(1,k,l) = cmplx(real(f(1,k,l)) + aimag(f(1,k,l)),real(f(1,k,l)) -     1 aimag(f(1,k,l)))  440 continuec bit-reverse array elements in x      do 460 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 460      do 450 k = 1, kyp      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = t  450 continue  460 continue  470 continuec then transform in x      nrx = nxy/nxh      do 520 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 510 l = 1, kblok      do 500 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 490 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 480 i = 1, kyp      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t  480 continue  490 continue  500 continue  510 continue  520 continue      return      endc-----------------------------------------------------------------------      subroutine PFFT2RY(f,g,msid,mrid,isign,ntpose,mixup,sct,indx,indy,     1kstrt,nxvh,nyv,kxp,kyp,kxb,kyb,kypd,jblok,kblok,nxhyd,nxyhd)c this subroutine performs a two dimensional real to complex fastc fourier transform and its inverse, using complex arithmetic,c for data which is distributed in blocksc for isign = 0, input: isign, indx, indy, kstrt, nxhyd, nxyhdc output: mixup, sctc for isign = (-1,1), input: all, output: f, gc for isign = -1, approximate flop count: N*(5*log2(N) + 10)/nvpc for isign = 1,  approximate flop count: N*(5*log2(N) + 8)/nvpc where N = (nx/2)*ny, and nvp = number of procsc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc ntpose = (0,1) = (no,yes) input, output data are transposedc if isign = 0, the fft tables are preparedc if isign = -1, an inverse fourier transform is performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(n,m,l) = (1/nx*ny)*sum(f(j,k,i)*c       exp(-sqrt(-1)*2pi*n*j/nx)*exp(-sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, f is the input and g is the outputc g(m,n,l) = (1/nx*ny)*sum(f(j,k,i)*c       exp(-sqrt(-1)*2pi*nn*j/nx)*exp(-sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c if isign = 1, a forward fourier transform is performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(j,k,i) = sum(f(n,m,l)*exp(sqrt(-1)*2pi*n*j/nx)*c       exp(sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, g is the input and f is the outputc f(j,k,i) = sum(g(m,n,l)*exp(sqrt(-1)*2pi*nn*j/nx)*c       exp(sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c msid, mrid = scratch arrays for identifying asynchronous messagesc kstrt = starting data block numberc nxvh/nyv = first dimension of f/gc kypd = second dimension of fc kxp/kyp = number of data values per block in x/yc kxb/kyb = number of processors in x/yc jblok/kblok = number of data blocks in x/yc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxhyd = maximum of (nx/2,ny)c nxyhd = one half of maximum of (nx,ny)c the real data is stored in a complex array of length nx/2, nyc with the odd/even x points stored in the real/imaginary parts.c in complex notation, fourier coefficients are stored as follows:c if ntpose = 0,c f(j,k,i) = mode j-1,kk-1, where kk = k + kyp*(i - 1)c 1 <= j <= nx/2 and 1 <= kk <= ny, except forc f(1,k,i) = mode nx/2,kk-1, where ny/2+2 <= kk <= ny, andc imaginary part of f(1,1,1) = real part of mode nx/2,0 andc imaginary part of f(1,1,(ny/2)/kyp+1) = real part of mode nx/2,ny/2c if ntpose = 1,c g(k,j,i) = mode jj-1,k-1, where jj = j + kxp*(i - 1)c 1 <= jj <= nx/2 and 1 <= k <= ny, except forc g(k,1,1) = mode nx/2,k-1, where ny/2+2 <= k <= ny, andc imaginary part of g(1,1,1) = real part of mode nx/2,0 andc imaginary part of g(ny/2+1,1,1) = real part of mode nx/2,ny/2c written by viktor k. decyk, uclac parallel, RISC optimized version      implicit none      integer msid, mrid, isign, ntpose, mixup, indx, indy, kstrt, nxvh      integer nyv, kxp, kyp, kxb, kyb, kypd, jblok, kblok, nxhyd, nxyhd      complex f, g, sct      dimension f(nxvh,kypd,kblok), g(nyv,kxp,jblok)      dimension msid(kxb), mrid(kyb)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, nxh, nxhh, nxh2, ny, nyh, ny2, nxy      integer nxhy, ks, j, k, lb, ll, jb, it, nxyh, nrx, nry, l, i, m      integer ns, ns2, km, kmr, k1, k2, j1, j2      real dnxy, arg, ani      complex s, t, t1      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nxh2 = nxh + 2      ny = 2**indy      nyh = ny/2      ny2 = ny + 2      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      if (isign) 50, 10, 300c prepare fft tablesc bit-reverse index table: mixup(j) = 1 + reversed bits of (j - 1)   10 do 30 j = 1, nxhy      lb = j - 1      ll = 0      do 20 k = 1, indx1y      jb = lb/2      it = lb - 2*jb      lb = jb      ll = 2*ll + it   20 continue      mixup(j) = ll + 1   30 continuec sine/cosine table for the angles 2*n*pi/nxy      nxyh = nxy/2      dnxy = 6.28318530717959/float(nxy)      do 40 j = 1, nxyh      arg = dnxy*float(j - 1)      sct(j) = cmplx(cos(arg),-sin(arg))   40 continue      returnc inverse fourier transform   50 if (kstrt.gt.ny) go to 180      nrx = nxhy/nxh      do 80 l = 1, kblokc bit-reverse array elements in x      do 70 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 70      do 60 k = 1, kyp      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = t   60 continue   70 continue   80 continuec first transform in x      nrx = nxy/nxh      do 130 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 120 l = 1, kblok      do 110 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 100 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 90 i = 1, kyp      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t   90 continue  100 continue  110 continue  120 continue  130 continuec unscramble coefficients and normalize      kmr = nxy/nx      ani = 1./float(2*nx*ny)      do 170 l = 1, kblok      do 150 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),-real(sct(1+kmr*(j-1))))      do 140 k = 1, kyp      t = conjg(f(nxh2-j,k,l))      s = f(j,k,l) + t      t = (f(j,k,l) - t)*t1      f(j,k,l) = ani*(s + t)      f(nxh2-j,k,l) = ani*conjg(s - t)  140 continue  150 continue      do 160 k = 1, kyp      f(nxhh+1,k,l) = 2.*ani*conjg(f(nxhh+1,k,l))      f(1,k,l) = 2.*ani*cmplx(real(f(1,k,l)) + aimag(f(1,k,l)),real(f(1,     1k,l)) - aimag(f(1,k,l)))  160 continue  170 continuec transpose f array to g  180 call PTPOSEY(f,g,msid,mrid,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxb,kyb,k     1xp,kypd,jblok,kblok)      if (kstrt.gt.nxh) go to 290      nry = nxhy/ny      do 210 l = 1, jblokc bit-reverse array elements in y      do 200 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 200      do 190 j = 1, kxp      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = t  190 continue  200 continue  210 continuec then transform in y      nry = nxy/ny      do 260 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 250 l = 1, jblok      do 240 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 230 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 220 i = 1, kxp      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t  220 continue  230 continue  240 continue  250 continue  260 continuec unscramble modes kx = 0, nx/2      do 280 l = 1, jblok      if ((l+ks).gt.0) go to 280      do 270 k = 2, nyh      s = g(ny2-k,1,l)      g(ny2-k,1,l) = .5*cmplx(aimag(g(k,1,l) + s),real(g(k,1,l) - s))      g(k,1,l) = .5*cmplx(real(g(k,1,l) + s),aimag(g(k,1,l) - s))  270 continue  280 continuec transpose g array to f  290 if (ntpose.eq.0) call PTPOSEY(g,f,mrid,msid,ny,nxh,kstrt,nyv,nxvh,     1kyp,kxp,kyb,kxb,kypd,kxp,kblok,jblok)      returnc forward fourier transformc transpose f array to g  300 if (ntpose.eq.0) call PTPOSEY(f,g,msid,mrid,nxh,ny,kstrt,nxvh,nyv,     1kxp,kyp,kxb,kyb,kxp,kypd,jblok,kblok)      if (kstrt.gt.nxh) go to 410      nry = nxhy/ny      do 350 l = 1, jblokc scramble modes kx = 0, nx/2      if ((l+ks).gt.0) go to 320      do 310 k = 2, nyh      s = cmplx(aimag(g(ny2-k,1,l)),real(g(ny2-k,1,l)))      g(ny2-k,1,l) = conjg(g(k,1,l) - s)      g(k,1,l) = g(k,1,l) + s  310 continuec bit-reverse array elements in y  320 do 340 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 340      do 330 j = 1, kxp      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = t  330 continue  340 continue  350 continuec first transform in y      nry = nxy/ny      do 400 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 390 l = 1, jblok      do 380 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 370 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 360 i = 1, kxp      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t  360 continue  370 continue  380 continue  390 continue  400 continuec transpose g array to f  410 call PTPOSEY(g,f,mrid,msid,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kyb,kxb,k     1ypd,kxp,kblok,jblok)      if (kstrt.gt.ny) return      nrx = nxhy/nxh      kmr = nxy/nx      do 470 l = 1, kblokc scramble coefficients      do 430 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),real(sct(1+kmr*(j-1))))      do 420 k = 1, kyp      t = conjg(f(nxh2-j,k,l))      s = f(j,k,l) + t      t = (f(j,k,l) - t)*t1      f(j,k,l) = s + t      f(nxh2-j,k,l) = conjg(s - t)  420 continue  430 continue      do 440 k = 1, kyp      f(nxhh+1,k,l) = 2.*conjg(f(nxhh+1,k,l))      f(1,k,l) = cmplx(real(f(1,k,l)) + aimag(f(1,k,l)),real(f(1,k,l)) -     1 aimag(f(1,k,l)))  440 continuec bit-reverse array elements in x      do 460 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 460      do 450 k = 1, kyp      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = t  450 continue  460 continue  470 continuec then transform in x      nrx = nxy/nxh      do 520 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 510 l = 1, kblok      do 500 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 490 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 480 i = 1, kyp      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t  480 continue  490 continue  500 continue  510 continue  520 continue      return      endc-----------------------------------------------------------------------      subroutine PPINIT(idproc,nvp)c this subroutine initializes parallel processingc input: nvp, output: idprocc idproc = processor idc nvp = number of real or virtual processors requested      implicit none      integer idproc, nvpc get definition of MPI constants      include 'mpif.h'c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplxc lstat = length of status array      parameter(lstat=8)c nproc = number of real or virtual processors obtainedc lgrp = current communicatorc mreal = default datatype for realsc mint = default datatype for integersc mcplx = default datatype for complex type      common /pparms/ nproc, lgrp, mreal, mint, mcplxc local data      integer ierror, ndprec      save /pparms/c ndprec = (0,1) = (no,yes) use (normal,autodouble) precision      data ndprec /1/c this segment is used for shared memory computersc     nproc = nvpc     idproc = 0c this segment is used for mpi computers      if (MPI_STATUS_SIZE.gt.lstat) then         write (2,*) ' status size too small, actual/required = ', lstat     1, MPI_STATUS_SIZE         stop      endifc initialize the MPI execution environment      call MPI_INIT(ierror)      if (ierror.ne.0) stop      lgrp = MPI_COMM_WORLDc determine the rank of the calling process in the communicator      call MPI_COMM_RANK(lgrp,idproc,ierror)c determine the size of the group associated with a communicator      call MPI_COMM_SIZE(lgrp,nproc,ierror)c set default datatypes         mint = MPI_INTEGERc single precision      if (ndprec.eq.0) then         mreal = MPI_REAL         mcplx = MPI_COMPLEXc double precision      else         mreal = MPI_DOUBLE_PRECISION         mcplx = MPI_DOUBLE_COMPLEX      endifc requested number of processors not obtained      if (nproc.ne.nvp) then         write (2,*) ' processor number error: nvp, nproc=', nvp, nproc         call PPEXIT         stop      endif      return      endc-----------------------------------------------------------------------      subroutine PPEXITc this subroutine terminates parallel processing      implicit nonec common block for parallel processing      integer nproc, lgrp, mreal, mint, mcplxc lgrp = current communicator      common /pparms/ nproc, lgrp, mreal, mint, mcplx      integer ierrorc synchronize processes      call MPI_BARRIER(lgrp,ierror)c terminate MPI execution environment      call MPI_FINALIZE(ierror)      return      endc-----------------------------------------------------------------------      subroutine PTPOSE(f,g,s,t,nx,ny,kstrt,nxv,nyv,kxp,kyp,kxpd,kypd,jb     1lok,kblok)c this subroutine performs a transpose of a matrix f, distributed in y,c to a matrix g, distributed in x, that is,c g(k+kyp*(m-1),j,l) = f(j+kxp*(l-1),k,m), wherec 1 <= j <= kxp, 1 <= k <= kyp, 1 <= l <= nx/kxp, 1 <= m <= ny/kypc and where indices l and m can be distributed across processors.c this subroutine sends and receives one message at a time, eitherc synchronously or asynchronously. it uses a minimum of system resourcesc f = complex input arrayc g = complex output arrayc s, t = complex scratch arraysc nx/ny = number of points in x/yc kstrt = starting data block numberc nxv/nyv = first dimension of f/gc kypd/kxpd = second dimension of f/gc kxp/kyp = number of data values per block in x/yc jblok/kblok = number of data blocks in x/y      implicit none      integer nx, ny, kstrt, nxv, nyv, kxp, kyp, kxpd, kypd      integer jblok, kblok      complex f, g, s, t      dimension f(nxv,kypd,kblok), g(nyv,kxpd,jblok)      dimension s(kxp,kyp,kblok), t(kxp,kyp,jblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplxc lstat = length of status array      parameter(lstat=8)c lgrp = current communicatorc mcplx = default datatype for complex      common /pparms/ nproc, lgrp, mreal, mint, mcplxc local data      integer ks, kxb, kyb      integer jkblok, kxym, mtr, ntr, mntr      integer l, i, joff, koff, k, j      integer ir0, is0, ii, ir, is, ierr, msid, istatus      dimension istatus(lstat)      ks = kstrt - 2      kxb = nx/kxp      kyb = ny/kypc this segment is used for shared memory computersc     if (kstrt.gt.nx) returnc     do 40 l = 1, jblokc     joff = kxp*(l + ks)c     do 30 i = 1, kybc     koff = kyp*(i - 1)c     do 20 k = 1, kypc     do 10 j = 1, kxpc     g(k+koff,j,l) = f(j+joff,k,i)c  10 continuec  20 continuec  30 continuec  40 continuec this segment is used for mpi computers      jkblok = max0(jblok,kblok)      kxym = min0(kxb,kyb)      mtr = kyb/kxym      ntr = kxb/kxym      mntr = max0(mtr,ntr)      do 70 l = 1, jkblok      do 60 i = 1, kxym      ir0 = iand(kxym-1,ieor(l+ks,i-1)) + 1      is0 = ir0      do 50 ii = 1, mntrc post receive      if ((kstrt.le.nx).and.(ii.le.mtr)) then         ir = ir0 + kxym*(ii - 1)         call MPI_IRECV(t(1,1,l),kxp*kyp,mcplx,ir-1,ir+kxym+1,lgrp,msid,     1ierr)      endifc send data      if ((kstrt.le.ny).and.(ii.le.ntr)) then         is = is0 + kxym*(ii - 1)         joff = kxp*(is - 1)         do 20 k = 1, kyp         do 10 j = 1, kxp         s(j,k,l) = f(j+joff,k,l)   10    continue   20    continue         call MPI_SEND(s(1,1,l),kxp*kyp,mcplx,is-1,l+ks+kxym+2,lgrp,ierr     1)      endifc receive data      if ((kstrt.le.nx).and.(ii.le.mtr)) then         koff = kyp*(ir - 1)         call MPI_WAIT(msid,istatus,ierr)         do 40 k = 1, kyp         do 30 j = 1, kxp         g(k+koff,j,l) = t(j,k,l)   30    continue   40    continue      endif   50 continue   60 continue   70 continue      return      endc-----------------------------------------------------------------------      subroutine PTPOSEX(f,g,nx,ny,kstrt,nxv,nyv,kxp,kyp,kxpd,kypd,jblok     1,kblok)c this subroutine performs a transpose of a matrix f, distributed in y,c to a matrix g, distributed in x, that is,c g(k+kyp*(m-1),j,l) = f(j+kxp*(l-1),k,m), wherec 1 <= j <= kxp, 1 <= k <= kyp, 1 <= l <= nx/kxp, 1 <= m <= ny/kypc and where indices l and m can be distributed across processors.c this subroutine sends and receives multiple asynchronous messages.c f = complex input arrayc g = complex output arrayc nx/ny = number of points in x/yc kstrt = starting data block numberc nxv/nyv = first dimension of f/gc kxp/kyp = number of data values per block in x/yc kypd/kxpd = second dimension of f/gc jblok/kblok = number of data blocks in x/yc optimized version      implicit none      integer nx, ny, kstrt, nxv, nyv, kxp, kyp      integer kxpd, kypd, jblok, kblok      complex f, g      dimension f(nxv*kypd*kblok), g(nyv*kxpd*jblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplxc lstat = length of status array      parameter(lstat=8)c lgrp = current communicatorc mcplx = default datatype for complex      common /pparms/ nproc, lgrp, mreal, mint, mcplxc local data      integer ks, kxb, kyb, l, i, joff, koff, k, j      integer jkblok, kxym, mtr, ntr, mntr, msid      integer ir0, is0, ii, ir, is, ioff, ierr, istatus      dimension istatus(lstat)      ks = kstrt - 2      kxb = nx/kxp      kyb = ny/kypc this segment is used for shared memory computersc     if (kstrt.gt.nx) returnc     do 40 l = 1, jblokc     joff = kxp*(l + ks)c     do 30 i = 1, kybc     koff = kyp*(i - 1)c     do 20 k = 1, kypc     do 10 j = 1, kxpc     g(k+koff+nyv*(j-1+kxpd*(l-1))) = f(j+joff+nxv*(k-1+kypd*(i-1)))c  10 continuec  20 continuec  30 continuec  40 continuec this segment is used for mpi computers      jkblok = max0(jblok,kblok)      kxym = min0(kxb,kyb)      mtr = kyb/kxym      ntr = kxb/kxym      mntr = max0(mtr,ntr)c transpose local data      do 50 l = 1, jkblok      ioff = kxb*(l - 1) - 1      koff = kypd*(l - 1) - 1      do 40 i = 1, kxym      is0 = iand(kxym-1,ieor(l+ks,i-1)) + 1      do 30 ii = 1, ntr      if (kstrt.le.ny) then         is = is0 + kxym*(ii - 1)         joff = kxp*(is - 1)         is = kyp*(is + ioff) - 1         do 20 k = 1, kyp         do 10 j = 1, kxp         g(j+kxp*(k+is)) = f(j+joff+nxv*(k+koff))   10    continue   20    continue      endif   30 continue   40 continue   50 continuec exchange data      do 80 l = 1, jkblok      ioff = kxb*(l - 1) - 1      koff = kyb*(l - 1) - 1      do 70 i = 1, kxym      ir0 = iand(kxym-1,ieor(l+ks,i-1)) + 1      is0 = ir0      do 60 ii = 1, mntrc post receive      if ((kstrt.le.nx).and.(ii.le.mtr)) then         ir = ir0 + kxym*(ii - 1)         call MPI_IRECV(f(1+kxp*kyp*(ir+koff)),kxp*kyp,mcplx,ir-1,ir+kxy     1m+1,lgrp,msid,ierr)      endifc send data      if ((kstrt.le.ny).and.(ii.le.ntr)) then         is = is0 + kxym*(ii - 1)         call MPI_SEND(g(1+kxp*kyp*(is+ioff)),kxp*kyp,mcplx,is-1,l+ks+kx     1ym+2,lgrp,ierr)      endifc receive data      if ((kstrt.le.nx).and.(ii.le.mtr)) then         call MPI_WAIT(msid,istatus,ierr)      endif   60 continue   70 continue   80 continuec transpose local data      do 130 l = 1, jkblok      ioff = kyb*(l - 1) - 1      joff = kxpd*(l - 1) - 1      do 120 i = 1, kxym      ir0 = iand(kxym-1,ieor(l+ks,i-1)) + 1      do 110 ii = 1, mtr      if (kstrt.le.nx) then         ir = ir0 + kxym*(ii - 1)         koff = kyp*(ir - 1)         ir = kyp*(ir + ioff) - 1         do 100 k = 1, kyp         do 90 j = 1, kxp         g(k+koff+nyv*(j+joff)) = f(j+kxp*(k+ir))   90    continue  100    continue      endif  110 continue  120 continue  130 continue      return      endc-----------------------------------------------------------------------      subroutine PTPOSEY(f,g,msid,mrid,nx,ny,kstrt,nxv,nyv,kxp,kyp,kxb,k     1yb,kxpd,kypd,jblok,kblok)c this subroutine performs a transpose of a matrix f, distributed in y,c to a matrix g, distributed in x, that is,c g(k+kyp*(m-1),j,l) = f(j+kxp*(l-1),k,m), wherec 1 <= j <= kxp, 1 <= k <= kyp, 1 <= l <= nx/kxp, 1 <= m <= ny/kypc and where indices l and m can be distributed across processors.c this subroutine sends and receives multiple asynchronous messages.c f = complex input arrayc g = complex output arrayc msid, mrid = scratch arrays for identifying asynchronous messagesc nx/ny = number of points in x/yc kstrt = starting data block numberc nxv/nyv = first dimension of f/gc kxp/kyp = number of data values per block in x/yc kxb/kyb = number of processors in x/yc kypd/kxpd = second dimension of f/gc jblok/kblok = number of data blocks in x/yc optimized version      implicit none      integer msid, mrid, nx, ny, kstrt, nxv, nyv, kxp, kyp, kxb, kyb      integer kxpd, kypd, jblok, kblok      complex f, g      dimension f(nxv*kypd*kblok), g(nyv*kxpd*jblok)      dimension msid(kxb), mrid(kyb)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplxc lstat = length of status array      parameter(lstat=8)c lgrp = current communicatorc mcplx = default datatype for complex      common /pparms/ nproc, lgrp, mreal, mint, mcplxc local data      integer ks, l, i, joff, koff, k, j      integer jkblok, kxym, mtr, ntr, mntr      integer ir0, is0, ii, ir, is, ioff, ierr, istatus      dimension istatus(lstat)      ks = kstrt - 2c this segment is used for shared memory computersc     if (kstrt.gt.nx) returnc     do 40 l = 1, jblokc     joff = kxp*(l + ks)c     do 30 i = 1, kybc     koff = kyp*(i - 1)c     do 20 k = 1, kypc     do 10 j = 1, kxpc     g(k+koff+nyv*(j-1+kxpd*(l-1))) = f(j+joff+nxv*(k-1+kypd*(i-1)))c  10 continuec  20 continuec  30 continuec  40 continuec this segment is used for mpi computers      jkblok = max0(jblok,kblok)      kxym = min0(kxb,kyb)      mtr = kyb/kxym      ntr = kxb/kxym      mntr = max0(mtr,ntr)c transpose local data      do 50 l = 1, jkblok      ioff = kxb*(l - 1) - 1      koff = kypd*(l - 1) - 1      do 40 i = 1, kxym      is0 = iand(kxym-1,ieor(l+ks,i-1)) + 1      do 30 ii = 1, ntr      if (kstrt.le.ny) then         is = is0 + kxym*(ii - 1)         joff = kxp*(is - 1)         is = kyp*(is + ioff) - 1         do 20 k = 1, kyp         do 10 j = 1, kxp         g(j+kxp*(k+is)) = f(j+joff+nxv*(k+koff))   10    continue   20    continue      endif   30 continue   40 continue   50 continuec post all receives      do 80 l = 1, jkblok      ioff = kyb*(l - 1) - 1      do 70 i = 1, kxym      ir0 = iand(kxym-1,ieor(l+ks,i-1)) + 1      do 60 ii = 1, mtr      if (kstrt.le.nx) then         ir = ir0 + kxym*(ii - 1)         call MPI_IRECV(f(1+kxp*kyp*(ir+ioff)),kxp*kyp,mcplx,ir-1,ir+kxy     1m+1,lgrp,mrid(ir),ierr)      endif   60 continue   70 continue   80 continuec post all sends      do 110 l = 1, jkblok      ioff = kxb*(l - 1) - 1      do 100 i = 1, kxym      is0 = iand(kxym-1,ieor(l+ks,i-1)) + 1      do 90 ii = 1, ntr      if (kstrt.le.ny) then         is = is0 + kxym*(ii - 1)         call MPI_ISEND(g(1+kxp*kyp*(is+ioff)),kxp*kyp,mcplx,is-1,l+ks+k     1xym+2,lgrp,msid(is),ierr)      endif   90 continue  100 continue  110 continuec wait for all messages      do 140 l = 1, jkblok      do 130 i = 1, kxym      ir0 = iand(kxym-1,ieor(l+ks,i-1)) + 1      is0 = ir0      do 120 ii = 1, mntrc wait for data to arrive      if ((kstrt.le.nx).and.(ii.le.mtr)) then         ir = ir0 + kxym*(ii - 1)         call MPI_WAIT(mrid(ir),istatus,ierr)      endifc make sure data was successfully sent      if ((kstrt.le.ny).and.(ii.le.ntr)) then         is = is0 + kxym*(ii - 1)         call MPI_WAIT(msid(is),istatus,ierr)      endif  120 continue  130 continue  140 continuec transpose local data      do 190 l = 1, jkblok      ioff = kyb*(l - 1) - 1      joff = kxpd*(l - 1) - 1      do 180 i = 1, kxym      ir0 = iand(kxym-1,ieor(l+ks,i-1)) + 1      do 170 ii = 1, mtr      if (kstrt.le.nx) then         ir = ir0 + kxym*(ii - 1)         koff = kyp*(ir - 1)         ir = kyp*(ir + ioff) - 1         do 160 k = 1, kyp         do 150 j = 1, kxp         g(k+koff+nyv*(j+joff)) = f(j+kxp*(k+ir))  150    continue  160    continue      endif  170 continue  180 continue  190 continue      return      endc-----------------------------------------------------------------------      subroutine PTIMERA(icntrl,time,dtime)c this subroutine performs parallel wall clock timingc input: icntrl, dtimec icntrl = (-1,0,1) = (initialize,ignore,read) clockc clock should be initialized before it is read!c time = maximum/minimum elapsed time in secondsc dtime = current timec written for mpi      implicit none      integer icntrl      real time      double precision dtime      dimension time(2)c get definition of MPI constants      include 'mpif.h'c common block for parallel processing      integer nproc, lgrp, mreal, mint, mcplxc lgrp = current communicatorc mreal = default datatype for reals      common /pparms/ nproc, lgrp, mreal, mint, mcplxc local data      integer ierr      real nclock      double precision jclockc initialize clock      if (icntrl.eq.(-1)) then         call MPI_BARRIER(lgrp,ierr)         dtime = MPI_WTIME()c read clock and write time difference from last clock initialization      else if (icntrl.eq.1) then         jclock = dtime         dtime = MPI_WTIME()         nclock = real(dtime - jclock)         call MPI_ALLREDUCE(nclock,time(2),1,mreal,MPI_MIN,lgrp,ierr)         call MPI_ALLREDUCE(nclock,time(1),1,mreal,MPI_MAX,lgrp,ierr)      endif      return      endc-----------------------------------------------------------------------      subroutine PSUM(f,g,nxp,nblok)c this subroutine performs a parallel sum of a vector, that is:c f(j,k) = sum over k of f(j,k)c assumes the number of processors nproc is a power of two.c the algorithm performs partial sums in binary pairs, as follows:c first, adjacent processors exchange vectors and sum them.  next,c processors separated by 2 exchange the new vectors and sum them, thenc those separated by 4, up to processors separated by nproc/2.  at thec end, all processors contain the same summation.c f = input and output datac g = scratch arrayc nxp = number of data values in vectorc nblok = number of data blocksc written by viktor k. decyk, ucla      implicit none      real f, g      integer nxp, nblok      dimension f(nxp,nblok), g(nxp,nblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplxc lstat = length of status array      parameter(lstat=8)c nproc = number of real or virtual processors obtainedc lgrp = current communicatorc mreal = default datatype for reals      common /pparms/ nproc, lgrp, mreal, mint, mcplxc local data      integer istatus, ierr, msid      integer idproc, kstrt, ks, l, kxs, k, kb, lb, j      dimension istatus(lstat)c find processor idc this line is used for shared memory computersc     idproc = 0c this line is used for mpi computers      call MPI_COMM_RANK(lgrp,idproc,ierr)      kstrt = idproc + 1      if (kstrt.gt.nproc) return      ks = kstrt - 2      l = 1      kxs = 1c main iteration loop   10 if (kxs.ge.nproc) go to 60c shift data      do 30 k = 1, nblok      kb = k + ks      lb = kb/kxs      kb = kb + 1      lb = lb - 2*(lb/2)c this loop is used for shared memory computersc     do 20 j = 1, nxpc     if (lb.eq.0) thenc        g(j,k) = f(j,kb+kxs)c     elsec        g(j,k) = f(j,kb-kxs)c     endifc  20 continuec this segment is used for mpi computers      if (lb.eq.0) then         call MPI_IRECV(g,nxp,mreal,kb+kxs-1,l+nxp,lgrp,msid,ierr)         call MPI_SEND(f,nxp,mreal,kb+kxs-1,l+nxp,lgrp,ierr)      else         call MPI_IRECV(g,nxp,mreal,kb-kxs-1,l+nxp,lgrp,msid,ierr)         call MPI_SEND(f,nxp,mreal,kb-kxs-1,l+nxp,lgrp,ierr)      endif      call MPI_WAIT(msid,istatus,ierr)   30 continuec perform sum      do 50 k = 1, nblok      do 40 j = 1, nxp      f(j,k) = f(j,k) + g(j,k)   40 continue   50 continue      l = l + 1      kxs = kxs + kxs      go to 10   60 return      end