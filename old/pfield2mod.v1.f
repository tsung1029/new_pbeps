!-----------------------------------------------------------------------!      module pfield2d!! Fortran90 interface to 2d parallel PIC Fortran77 library pfield2lib.f! written by viktor k. decyk, ucla! copyright 2000, regents of the university of california! update: june 24, 2002!      use globals, only: LINEAR, QUADRATIC      implicit none      private      public :: LINEAR, QUADRATIC      public :: cguard, bguard, sguard, aguard, sguardp, aguardp      public :: pois_init, pois, cuperp, bpois, fft_init, fft, fftc_init      public :: ipdivf2, ipgradf2, ipcurlf2      public :: lcguard, lbguard, poisd_init, poisd!! define interface to original Fortran77 procedures      interface         subroutine PCGUARD2X(fxy,nyp,nx,nxe,nypmx,nblok)         implicit none         integer nx, nxe, nypmx, nblok         real, dimension(2,nxe,nypmx,nblok) :: fxy         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PDGUARD2X(q,nyp,nx,nxe,nypmx,nblok)         implicit none         integer :: nx, nxe, nypmx, nblok         real, dimension(nxe,nypmx,nblok) :: q         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PBGUARD2X(bxy,nyp,nx,nxe,nypmx,nblok)         implicit none         integer nx, nxe, nypmx, nblok         real, dimension(3,nxe,nypmx,nblok) :: bxy         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PSCGUARD2(cu,nyp,xj0,yj0,zj0,nx,nxe,nypmx,nblok)         implicit none         real :: xj0, yj0, zj0         integer nx, nxe, nypmx, nblok         real, dimension(3,nxe,nypmx,nblok) :: cu         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PSGUARD2(q,nyp,qi0,nx,nxe,nypmx,nblok)         implicit none         real :: qi0         integer nx, nxe, nypmx, nblok         real, dimension(nxe,nypmx,nblok) :: q         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PACGUARD2X(cu,nyp,nx,nxe,nypmx,nblok)         implicit none         integer nx, nxe, nypmx, nblok         real, dimension(3,nxe,nypmx,nblok) :: cu         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PAGUARD2X(q,nyp,nx,nxe,nypmx,nblok)         implicit none         integer nx, nxe, nypmx, nblok         real, dimension(nxe,nypmx,nblok) :: q         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PCGUARD2XL(fxy,nyp,nx,nxe,nypmx,nblok)         implicit none         integer nx, nxe, nypmx, nblok         real, dimension(2,nxe,nypmx,nblok) :: fxy         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PDGUARD2XL(q,nyp,nx,nxe,nypmx,nblok)         implicit none         integer :: nx, nxe, nypmx, nblok         real, dimension(nxe,nypmx,nblok) :: q         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PBGUARD2XL(bxy,nyp,nx,nxe,nypmx,nblok)         implicit none         integer nx, nxe, nypmx, nblok         real, dimension(3,nxe,nypmx,nblok) :: bxy         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PSCGUARD2L(cu,nyp,xj0,yj0,zj0,nx,nxe,nypmx,nblok)         implicit none         real :: xj0, yj0, zj0         integer nx, nxe, nypmx, nblok         real, dimension(3,nxe,nypmx,nblok) :: cu         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PSGUARD2L(q,nyp,qi0,nx,nxe,nypmx,nblok)         implicit none         real :: qi0         integer nx, nxe, nypmx, nblok         real, dimension(nxe,nypmx,nblok) :: q         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PACGUARD2XL(cu,nyp,nx,nxe,nypmx,nblok)         implicit none         integer nx, nxe, nypmx, nblok         real, dimension(3,nxe,nypmx,nblok) :: cu         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PAGUARD2XL(q,nyp,nx,nxe,nypmx,nblok)         implicit none         integer nx, nxe, nypmx, nblok         real, dimension(nxe,nypmx,nblok) :: q         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PPOISP2(q,fx,fy,isign,ffc,ax,ay,affp,we,nx,ny,kstrt,&     &nyv,kxp,jblok,nyhd)         implicit none         real :: ax, ay, affp, we         integer :: isign, nx, ny, kstrt, nyv, kxp, jblok, nyhd         complex, dimension(nyv,kxp,jblok) :: q, fx, fy         complex, dimension(nyhd,kxp,jblok) :: ffc         end subroutine      end interface      interface         subroutine PPOIS22(q,fxy,isign,ffc,ax,ay,affp,we,nx,ny,kstrt,ny&     &v,kxp,jblok,nyhd)         implicit none         real :: ax, ay, affp, we         integer :: isign, nx, ny, kstrt, nyv, kxp, jblok, nyhd         complex, dimension(nyv,kxp,jblok) :: q         complex, dimension(2,nyv,kxp,jblok) :: fxy         complex, dimension(nyhd,kxp,jblok) :: ffc         end subroutine      end interface      interface         subroutine PDIVF2(f,df,nx,ny,kstrt,ndim,nyv,kxp,jblok)         implicit none         integer :: nx, ny, kstrt, ndim, nyv, kxp, jblok         complex, dimension(3,nyv,kxp,jblok) :: f         complex, dimension(nyv,kxp,jblok) :: df         end subroutine      end interface      interface         subroutine PGRADF2(df,f,nx,ny,kstrt,ndim,nyv,kxp,jblok)         implicit none         integer :: nx, ny, kstrt, ndim, nyv, kxp, jblok         complex, dimension(nyv,kxp,jblok) :: df         complex, dimension(3,nyv,kxp,jblok) :: f         end subroutine      end interface      interface         subroutine PCURLF2(f,g,nx,ny,kstrt,nyv,kxp,jblok)         implicit none         integer :: nx, ny, kstrt, nyv, kxp, jblok         complex, dimension(3,nyv,kxp,jblok) :: f, g         end subroutine      end interface      interface         subroutine PCUPERP2(cu,nx,ny,kstrt,nyv,kxp,jblok)         implicit none         integer :: nx, ny, kstrt, nyv, kxp, jblok         complex, dimension(3,nyv,kxp,jblok) :: cu         end subroutine      end interface      interface         subroutine PBPOISP23(cu,bxy,isign,ffc,ax,ay,affp,ci,wm,nx,ny,ks&     &trt,nyv,kxp,jblok,nyhd)         implicit none         real :: ax, ay, affp, ci, wm         integer :: isign, nx, ny, kstrt, nyv, kxp, jblok, nyhd         complex, dimension(3,nyv,kxp,jblok) :: cu         complex, dimension(3,nyv,kxp,jblok) :: bxy         complex, dimension(nyhd,kxp,jblok) :: ffc         end subroutine      end interface      interface         subroutine PLCGUARD2X(fxy,nyp,nx,nxe,nypmx,nblok)         implicit none         integer :: nx, nxe, nypmx, nblok         real, dimension(2,nxe,nypmx,nblok) :: fxy         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PLDGUARD2X(q,nyp,nx,nxe,nypmx,nblok)         implicit none         integer :: nx, nxe, nypmx, nblok         real, dimension(nxe,nypmx,nblok) :: q         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PLBGUARD2X(bxy,nyp,nx,nxe,nypmx,nblok)         implicit none         integer :: nx, nxe, nypmx, nblok         real, dimension(3,nxe,nypmx,nblok) :: bxy         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PLSCGUARD2(cu,kstrt,nvp,nyp,xj0,yj0,zj0,nx,ngx,ngy,n&     &xe,nypmx,nblok)         implicit none         real :: xj0, yj0, zj0         integer :: kstrt, nvp, nx, ngx, ngy, nxe, nypmx, nblok         real, dimension(3,nxe,nypmx,nblok) :: cu         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PLSGUARD2(q,kstrt,nvp,nyp,qi0,nx,ngx,ngy,nxe,nypmx,n&     &blok)         implicit none         real :: qi0         integer :: kstrt, nvp, nx, ngx, ngy, nxe, nypmx, nblok         real, dimension(nxe,nypmx,nblok) :: q         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PLACGUARD2X(cu,nyp,nx,nxe,nypmx,nblok)         implicit none         integer :: nx, nxe, nypmx, nblok         real :: cu         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PLAGUARD2X(q,nyp,nx,nxe,nypmx,nblok)         implicit none         integer :: nx, nxe, nypmx, nblok         real :: q         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PLSCGUARD2L(cu,kstrt,nvp,nyp,xj0,yj0,zj0,nx,ngx,ngy,&     &nxe,nypmx,nblok)         implicit none         real :: xj0, yj0, zj0         integer :: kstrt, nvp, nx, ngx, ngy, nxe, nypmx, nblok         real, dimension(3,nxe,nypmx,nblok) :: cu         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PLSGUARD2L(q,kstrt,nvp,nyp,qi0,nx,ngx,ngy,nxe,nypmx,&     &nblok)         implicit none         real :: qi0         integer :: kstrt, nvp, nx, ngx, ngy, nxe, nypmx, nblok         real, dimension(nxe,nypmx,nblok) :: q         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PPOISD2(q,fx,fy,isign,ffd,ax,ay,affp,we,nx,ny,kstrt,&     &ny2d,kxp2,j2blok,nyd)         implicit none         real :: ax, ay, affp, we         integer :: isign, nx, ny, kstrt, ny2d, kxp2, j2blok, nyd         complex, dimension(ny2d,kxp2,j2blok) :: q, fx, fy         complex, dimension(nyd,kxp2,j2blok) :: ffd         end subroutine      end interface      interface         subroutine PPOISD22(q,fxy,isign,ffd,ax,ay,affp,we,nx,ny,kstrt,n&     &y2d,kxp2,j2blok,nyd)         implicit none         real :: ax, ay, affp, we         integer :: isign, nx, ny, kstrt, ny2d, kxp2, j2blok, nyd         complex, dimension(ny2d,kxp2,j2blok) :: q         complex, dimension(2,ny2d,kxp2,j2blok) :: fxy         complex, dimension(nyd,kxp2,j2blok) :: ffd         end subroutine      end interface      interface         subroutine PFFT2R(f,g,bs,br,isign,ntpose,mixup,sct,indx,indy,ks&     &trt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         implicit none         integer :: isign, ntpose, indx, indy, kstrt, nxvh, nyv         integer :: kxp, kyp, kypd, jblok, kblok, nxhyd, nxyhd         real :: f         complex, dimension(nyv,kxp,jblok) :: g         complex, dimension(kxp,kyp,kblok) :: bs         complex, dimension(kxp,kyp,jblok) :: br         integer, dimension(nxhyd) :: mixup         complex, dimension(nxyhd) :: sct         end subroutine      end interface      interface         subroutine PFFT2R2(f,g,bs,br,isign,ntpose,mixup,sct,indx,indy,k&     &strt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         implicit none         integer :: isign, ntpose, indx, indy, kstrt, nxvh, nyv         integer :: kxp, kyp, kypd, jblok, kblok, nxhyd, nxyhd         real :: f         complex, dimension(2,nyv,kxp,jblok) :: g         complex, dimension(2,kxp,kyp,kblok) :: bs         complex, dimension(2,kxp,kyp,jblok) :: br         integer, dimension(nxhyd) :: mixup         complex, dimension(nxyhd) :: sct         end subroutine      end interface      interface         subroutine PFFT2R3(f,g,bs,br,isign,ntpose,mixup,sct,indx,indy,k&     &strt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         implicit none         integer :: isign, ntpose, indx, indy, kstrt, nxvh, nyv         integer :: kxp, kyp, kypd, jblok, kblok, nxhyd, nxyhd         real :: f         complex, dimension(3,nyv,kxp,jblok) :: g         complex, dimension(3,kxp,kyp,kblok) :: bs         complex, dimension(3,kxp,kyp,jblok) :: br         integer, dimension(nxhyd) :: mixup         complex, dimension(nxyhd) :: sct         end subroutine      end interface      interface         subroutine PFFT2RX(f,g,isign,ntpose,mixup,sct,indx,indy,kstrt,n&     &xvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         implicit none         integer :: isign, ntpose, indx, indy, kstrt, nxvh, nyv         integer :: kxp, kyp, kypd, jblok, kblok, nxhyd, nxyhd         real :: f         complex, dimension(nyv,kxp,jblok) :: g         integer, dimension(nxhyd) :: mixup         complex, dimension(nxyhd) :: sct         end subroutine      end interface      interface         subroutine PFFT2RX2(f,g,isign,ntpose,mixup,sct,indx,indy,kstrt,&     &nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         implicit none         integer :: isign, ntpose, indx, indy, kstrt, nxvh, nyv         integer :: kxp, kyp, kypd, jblok, kblok, nxhyd, nxyhd         real :: f         complex, dimension(2,nyv,kxp,jblok) :: g         integer, dimension(nxhyd) :: mixup         complex, dimension(nxyhd) :: sct         end subroutine      end interface      interface         subroutine PFFT2RX3(f,g,isign,ntpose,mixup,sct,indx,indy,kstrt,&     &nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         implicit none         integer :: isign, ntpose, indx, indy, kstrt, nxvh, nyv         integer :: kxp, kyp, kypd, jblok, kblok, nxhyd, nxyhd         real :: f         complex, dimension(3,nyv,kxp,jblok) :: g         integer, dimension(nxhyd) :: mixup         complex, dimension(nxyhd) :: sct         end subroutine      end interface      interface         subroutine PFFT2C(f,g,bs,br,isign,ntpose,mixup,sct,indx,indy,ks&     &trt,nxv,nyv,kxp,kyp,kypd,jblok,kblok,nxyd,nxyhd)         implicit none         integer :: isign, ntpose, indx, indy, kstrt, nxv, nyv, kxp, kyp         integer :: kypd, jblok, kblok, nxyd, nxyhd!        complex, dimension(*) :: f         complex :: f         complex, dimension(nyv,kxp,jblok) :: g         complex, dimension (kxp,kyp,kblok) :: bs         complex, dimension (kxp,kyp,jblok) :: br         integer, dimension(nxyd) :: mixup         complex, dimension(nxyhd) :: sct         end subroutine      end interface!! define generic interfaces to Fortran90 library!      interface cguard         module procedure ipcguard2x         module procedure ipdguard2x      end interface!      interface bguard         module procedure ipbguard2x      end interface!      interface sguard         module procedure ipscguard2         module procedure ipsguard2      end interface!            interface aguard         module procedure ipacguard2x         module procedure ipaguard2x      end interface!      interface sguardp         module procedure ipscguard2p         module procedure ipsguard2p      end interface!            interface aguardp         module procedure ipacguard2xp         module procedure ipaguard2xp      end interface!       interface pois_init         module procedure ippois22init      end interface!       interface pois         module procedure ippois2         module procedure ippois22      end interface!      interface cuperp         module procedure ipcuperp2      end interface!      interface bpois         module procedure ipbpois23      end interface!      interface lcguard         module procedure iplcguard2x         module procedure ipldguard2x      end interface!      interface lbguard         module procedure iplbguard2x      end interface!      interface poisd_init         module procedure ippoisd22init      end interface!      interface poisd         module procedure ippoisd2         module procedure ippoisd22      end interface!      interface fft_init         module procedure ipfft2rinit!        module procedure ipfft2rxinit      end interface!      interface fft!        module procedure ipfft2r!        module procedure ipfft2r2!        module procedure ipfft2r3         module procedure ipfft2rx         module procedure ipfft2rx2         module procedure ipfft2rx3         module procedure ipfft2c      end interface!      interface fftc_init         module procedure ipfft2cinit      end interface!! define Fortran90 interface functions to Fortran77 library!      contains!         subroutine ipcguard2x(fxy,nyp,nx,inorder)         implicit none         integer :: nx         integer, optional :: inorder         real, dimension(:,:,:,:) :: fxy         integer, dimension(:) :: nyp         integer :: nxe, nypmx, nblok, order         nxe = size(fxy,2); nypmx = size(fxy,3); nblok = size(fxy,4)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PCGUARD2XL(fxy,nyp,nx,nxe,nypmx,nblok)         else            call PCGUARD2X(fxy,nyp,nx,nxe,nypmx,nblok)         endif         end subroutine ipcguard2x!         subroutine ipdguard2x(q,nyp,nx,inorder)         implicit none         integer :: nx         integer, optional :: inorder         real, dimension(:,:,:) :: q         integer, dimension(:) :: nyp         integer :: nxe, nypmx, nblok, order         nxe = size(q,1); nypmx = size(q,2); nblok = size(q,3)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PDGUARD2XL(q,nyp,nx,nxe,nypmx,nblok)         else            call PDGUARD2X(q,nyp,nx,nxe,nypmx,nblok)         endif         end subroutine ipdguard2x!         subroutine ipbguard2x(bxy,nyp,nx,inorder)         implicit none         integer :: nx         integer, optional :: inorder         real, dimension(:,:,:,:) :: bxy         integer, dimension(:) :: nyp         integer :: nxe, nypmx, nblok, order         nxe = size(bxy,2); nypmx = size(bxy,3); nblok = size(bxy,4)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PBGUARD2XL(bxy,nyp,nx,nxe,nypmx,nblok)         else            call PBGUARD2X(bxy,nyp,nx,nxe,nypmx,nblok)         endif         end subroutine ipbguard2x!         subroutine ipscguard2(cu,nyp,xj0,yj0,zj0,nx,inorder)         implicit none         integer :: nx         integer, optional :: inorder         real :: xj0, yj0, zj0         real, dimension(:,:,:,:) :: cu         integer, dimension(:) :: nyp         integer :: nxe, nypmx, nblok, order         nxe = size(cu,2); nypmx = size(cu,3); nblok = size(cu,4)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PSCGUARD2L(cu,nyp,xj0,yj0,zj0,nx,nxe,nypmx,nblok)         else            call PSCGUARD2(cu,nyp,xj0,yj0,zj0,nx,nxe,nypmx,nblok)         endif         end subroutine ipscguard2!         subroutine ipsguard2(q,nyp,qi0,nx,inorder)         implicit none         integer :: nx         integer, optional :: inorder         real :: qi0         real, dimension(:,:,:) :: q         integer, dimension(:) :: nyp         integer :: nxe, nypmx, nblok, order         nxe = size(q,1); nypmx = size(q,2); nblok = size(q,3)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PSGUARD2L(q,nyp,qi0,nx,nxe,nypmx,nblok)         else            call PSGUARD2(q,nyp,qi0,nx,nxe,nypmx,nblok)         endif         end subroutine ipsguard2!         subroutine ipacguard2x(cu,nyp,nx,inorder)         implicit none         integer :: nx         integer, optional :: inorder         real, dimension(:,:,:,:) :: cu         integer, dimension(:) :: nyp         integer :: nxe, nypmx, nblok, order         nxe = size(cu,2); nypmx = size(cu,3); nblok = size(cu,4)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PACGUARD2XL(cu,nyp,nx,nxe,nypmx,nblok)         else            call PACGUARD2X(cu,nyp,nx,nxe,nypmx,nblok)         endif         end subroutine ipacguard2x!         subroutine ipaguard2x(q,nyp,nx,inorder)         implicit none         integer :: nx         integer, optional :: inorder         real, dimension(:,:,:) :: q         integer, dimension(:) :: nyp         integer :: nxe, nypmx, nblok, order         nxe = size(q,1); nypmx = size(q,2); nblok = size(q,3)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PAGUARD2XL(q,nyp,nx,nxe,nypmx,nblok)         else            call PAGUARD2X(q,nyp,nx,nxe,nypmx,nblok)         endif         end subroutine ipaguard2x!         subroutine ipscguard2p(cu,kstrt,nvp,nyp,xj0,yj0,zj0,nx,ipbc,ino&     &rder)         implicit none         integer :: kstrt, nvp, nx, ipbc         integer, optional :: inorder         real :: xj0, yj0, zj0         real, dimension(:,:,:,:) :: cu         integer, dimension(:) :: nyp         integer :: ngx = 1, ngy = 1, nxe, nypmx, nblok, order         nxe = size(cu,2); nypmx = size(cu,3); nblok = size(cu,4)         order = QUADRATIC         if (present(inorder)) order = inorder         if (ipbc==1) then            if (order==LINEAR) then               call PSCGUARD2L(cu,nyp,xj0,yj0,zj0,nx,nxe,nypmx,nblok)            else               call PSCGUARD2(cu,nyp,xj0,yj0,zj0,nx,nxe,nypmx,nblok)            endif         else if (ipbc==2) then            if (order==LINEAR) then               call PLSCGUARD2L(cu,kstrt,nvp,nyp,xj0,yj0,zj0,nx,ngx,ngy,&     &nxe,nypmx,nblok)            else               call PLSCGUARD2(cu,kstrt,nvp,nyp,xj0,yj0,zj0,nx,ngx,ngy,n&     &xe,nypmx,nblok)            endif         endif         end subroutine ipscguard2p!         subroutine ipsguard2p(q,kstrt,nvp,nyp,qi0,nx,ipbc,inorder)         implicit none         integer :: kstrt, nvp, nx, ipbc         integer, optional :: inorder         real :: qi0         real, dimension(:,:,:) :: q         integer, dimension(:) :: nyp         integer :: ngx = 1, ngy = 1, nxe, nypmx, nblok, order         nxe = size(q,1); nypmx = size(q,2); nblok = size(q,3)         order = QUADRATIC         if (present(inorder)) order = inorder         if (ipbc==1) then            if (order==LINEAR) then               call PSGUARD2L(q,nyp,qi0,nx,nxe,nypmx,nblok)            else               call PSGUARD2(q,nyp,qi0,nx,nxe,nypmx,nblok)            endif         else if (ipbc==2) then            if (order==LINEAR) then               call PLSGUARD2L(q,kstrt,nvp,nyp,qi0,nx,ngx,ngy,nxe,nypmx,&     &nblok)            else               call PLSGUARD2(q,kstrt,nvp,nyp,qi0,nx,ngx,ngy,nxe,nypmx,n&     &blok)            endif         endif         end subroutine ipsguard2p!         subroutine ipacguard2xp(cu,nyp,nx,ipbc,inorder)         implicit none         integer :: nx, ipbc         integer, optional :: inorder         real, dimension(:,:,:,:) :: cu         integer, dimension(:) :: nyp         integer :: nxe, nypmx, nblok, order         nxe = size(cu,2); nypmx = size(cu,3); nblok = size(cu,4)         order = QUADRATIC         if (present(inorder)) order = inorder         if (ipbc==1) then            if (order==LINEAR) then               call PACGUARD2XL(cu,nyp,nx,nxe,nypmx,nblok)            else               call PACGUARD2X(cu,nyp,nx,nxe,nypmx,nblok)            endif         else if (ipbc==2) then            if (order==QUADRATIC) then               call PLACGUARD2X(cu(1,2,1,1),nyp,nx-2,nxe,nypmx,nblok)            endif         endif         end subroutine ipacguard2xp!         subroutine ipaguard2xp(q,nyp,nx,ipbc,inorder)         implicit none         integer :: nx, ipbc         integer, optional :: inorder         real, dimension(:,:,:) :: q         integer, dimension(:) :: nyp         integer :: nxe, nypmx, nblok, order         nxe = size(q,1); nypmx = size(q,2); nblok = size(q,3)         order = QUADRATIC         if (present(inorder)) order = inorder         if (ipbc==1) then            if (order==LINEAR) then               call PAGUARD2XL(q,nyp,nx,nxe,nypmx,nblok)            else               call PAGUARD2X(q,nyp,nx,nxe,nypmx,nblok)            endif         else if (ipbc==2) then            if (order==QUADRATIC) then               call PLAGUARD2X(q(2,1,1),nyp,nx-2,nxe,nypmx,nblok)            endif         endif         end subroutine ipaguard2xp!         subroutine ippois2init(ffc,ax,ay,affp,nx,ny,kstrt)         implicit none         integer :: nx, ny, kstrt         real :: ax, ay, affp         complex, dimension(:,:,:) :: ffc         integer :: isign = 0, nyv, kxp, jblok, nyhd         real :: we         complex, dimension(1,1,1) :: q, fx, fy         nyv = size(q,1)         nyhd = size(ffc,1); kxp = size(ffc,2); jblok = size(ffc,3)         call PPOISP2(q,fx,fy,isign,ffc,ax,ay,affp,we,nx,ny,kstrt,nyv,kx&     &p,jblok,nyhd)         end subroutine ippois2init!         subroutine ippois2(q,fx,ffc,we,nx,ny,kstrt)         implicit none         integer :: nx, ny, kstrt         real :: we         complex, dimension(:,:,:) :: q, fx, ffc         integer :: isign = 1, nyv, kxp, jblok, nyhd         real :: ax, ay, affp         complex, dimension(1,1,1) :: fy         nyv = size(q,1)         nyhd = size(ffc,1); kxp = size(ffc,2); jblok = size(ffc,3)         call PPOISP2(q,fx,fy,isign,ffc,ax,ay,affp,we,nx,ny,kstrt,nyv,kx&     &p,jblok,nyhd)         end subroutine ippois2!         subroutine ippois22init(ffc,ax,ay,affp,nx,ny,kstrt)         implicit none         integer :: nx, ny, kstrt         real :: ax, ay, affp         complex, dimension(:,:,:) :: ffc         integer :: isign = 0, nyv, kxp, jblok, nyhd         real :: we         complex, dimension(1,1,1) :: q         complex, dimension(2,1,1,1) :: fxy         nyv = size(q,1)         nyhd = size(ffc,1); kxp = size(ffc,2); jblok = size(ffc,3)         call PPOIS22(q,fxy,isign,ffc,ax,ay,affp,we,nx,ny,kstrt,nyv,kxp,&     &jblok,nyhd)         end subroutine ippois22init!         subroutine ippois22(q,fxy,ffc,we,nx,ny,kstrt)         implicit none         integer :: nx, ny, kstrt         real :: we         complex, dimension(:,:,:) :: q, ffc         complex, dimension(:,:,:,:) :: fxy         integer :: isign = -1, nyv, kxp, jblok, nyhd         real :: ax, ay, affp         nyv = size(q,1)         nyhd = size(ffc,1); kxp = size(ffc,2); jblok = size(ffc,3)         call PPOIS22(q,fxy,isign,ffc,ax,ay,affp,we,nx,ny,kstrt,nyv,kxp,&     &jblok,nyhd)         end subroutine ippois22!         subroutine ipdivf2(f,df,nx,ny,kstrt)         implicit none         integer :: nx, ny, kstrt         complex, dimension(:,:,:,:) :: f         complex, dimension(:,:,:) :: df         integer :: ndim, nyv, kxp, jblok         ndim = size(f,1)         nyv = size(f,2); kxp = size(f,3); jblok = size(f,4)         call PDIVF2(f,df,nx,ny,kstrt,ndim,nyv,kxp,jblok)         end subroutine ipdivf2!         subroutine ipgradf2(df,f,nx,ny,kstrt)         implicit none         integer :: nx, ny, kstrt         complex, dimension(:,:,:) :: df         complex, dimension(:,:,:,:) :: f         integer :: ndim, nyv, kxp, jblok         ndim = size(f,1)         nyv = size(df,1); kxp = size(df,2); jblok = size(df,3)         call PGRADF2(df,f,nx,ny,kstrt,ndim,nyv,kxp,jblok)         end subroutine ipgradf2!         subroutine ipcurlf2(f,g,nx,ny,kstrt)         implicit none         integer :: nx, ny, kstrt         complex, dimension(:,:,:,:) :: f, g         integer :: nyv, kxp, jblok         nyv = size(f,2); kxp = size(f,3); jblok = size(f,4)         call PCURLF2(f,g,nx,ny,kstrt,nyv,kxp,jblok)         end subroutine ipcurlf2!         subroutine ipcuperp2(cu,nx,ny,kstrt)         implicit none         integer :: nx, ny, kstrt         complex, dimension(:,:,:,:) :: cu         integer :: nyv, kxp, jblok         nyv = size(cu,2); kxp = size(cu,3); jblok = size(cu,4)         call PCUPERP2(cu,nx,ny,kstrt,nyv,kxp,jblok)         end subroutine ipcuperp2!         subroutine ipbpois23(cu,bxy,ffc,ci,wm,nx,ny,kstrt)         implicit none         integer :: nx, ny, kstrt         real :: ci, wm         complex, dimension(:,:,:) :: ffc         complex, dimension(:,:,:,:) :: cu, bxy         integer :: isign = -1, nyv, kxp, jblok, nyhd         real :: ax, ay, affp         nyv = size(cu,2)         nyhd = size(ffc,1); kxp = size(ffc,2); jblok = size(ffc,3)         call PBPOISP23(cu,bxy,isign,ffc,ax,ay,affp,ci,wm,nx,ny,kstrt,ny&     &v,kxp,jblok,nyhd)         end subroutine ipbpois23!         subroutine iplcguard2x(fxy,nyp,nx,inorder)         implicit none         integer :: nx         integer, optional :: inorder         real, dimension(:,:,:,:) :: fxy         integer, dimension(:) :: nyp         integer :: nxe, nypmx, nblok, order         nxe = size(fxy,2); nypmx = size(fxy,3); nblok = size(fxy,4)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==QUADRATIC) then            call PLCGUARD2X(fxy,nyp,nx,nxe,nypmx,nblok)         endif         end subroutine iplcguard2x!         subroutine ipldguard2x(q,nyp,nx,inorder)         implicit none         integer :: nx         integer, optional :: inorder         real, dimension(:,:,:) :: q         integer, dimension(:) :: nyp         integer :: nxe, nypmx, nblok, order         nxe = size(q,1); nypmx = size(q,2); nblok = size(q,3)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==QUADRATIC) then            call PLDGUARD2X(q,nyp,nx,nxe,nypmx,nblok)         endif         end subroutine ipldguard2x!         subroutine iplbguard2x(bxy,nyp,nx,inorder)         implicit none         integer :: nx         integer, optional :: inorder         real, dimension(:,:,:,:) :: bxy         integer, dimension(:) :: nyp         integer :: nxe, nypmx, nblok, order         nxe = size(bxy,2); nypmx = size(bxy,3); nblok = size(bxy,4)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==QUADRATIC) then            call PLBGUARD2X(bxy,nyp,nx,nxe,nypmx,nblok)         endif         end subroutine iplbguard2x!         subroutine ippoisd2(q,fx,ffd,we,nx,ny,kstrt)         implicit none         integer :: nx, ny, kstrt         real :: we         complex, dimension(:,:,:) :: q, fx, ffd         integer :: isign = 1, ny2d, kxp2, j2blok, nyd         real :: ax, ay, affp         complex, dimension(1,1,1) :: fy         ny2d = size(q,1)         nyd = size(ffd,1); kxp2 = size(ffd,2); j2blok = size(ffd,3)         call PPOISD2(q,fx,fy,isign,ffd,ax,ay,affp,we,nx,ny,kstrt,ny2d,k&     7xp2,j2blok,nyd)         end subroutine ippoisd2!         subroutine ippoisd22init(ffd,ax,ay,affp,nx,ny,kstrt)         implicit none         integer :: nx, ny, kstrt         real :: ax, ay, affp         complex, dimension(:,:,:) :: ffd         integer :: isign = 0, ny2d, kxp2, j2blok, nyd         real :: we         complex, dimension(1,1,1) :: q         complex, dimension(2,1,1,1) :: fxy         ny2d = size(q,1)         nyd = size(ffd,1); kxp2 = size(ffd,2); j2blok = size(ffd,3)         call PPOISD22(q,fxy,isign,ffd,ax,ay,affp,we,nx,ny,kstrt,ny2d,kx&     &p2,j2blok,nyd)         end subroutine ippoisd22init!         subroutine ippoisd22(q,fxy,ffd,we,nx,ny,kstrt)         implicit none         integer :: nx, ny, kstrt         real :: we         complex, dimension(:,:,:) :: q, ffd         complex, dimension(:,:,:,:) :: fxy         integer :: isign = -1, ny2d, kxp2, j2blok, nyd         real :: ax, ay, affp         ny2d = size(q,1)         nyd = size(ffd,1); kxp2 = size(ffd,2); j2blok = size(ffd,3)         call PPOISD22(q,fxy,isign,ffd,ax,ay,affp,we,nx,ny,kstrt,ny2d,kx&     &p2,j2blok,nyd)         end subroutine ippoisd22!         subroutine ipfft2rinit(mixup,sct,indx,indy)         implicit none         integer :: indx, indy         integer, dimension(:) :: mixup         complex, dimension(:) :: sct         integer :: isign = 0, ntpose = 1, kstrt = 1, nxvh = 1, nyv = 1         integer :: kxp = 1, kyp = 1, kypd = 1, jblok = 1, kblok = 1         integer :: nxhyd, nxyhd         real :: f         complex, dimension(1,1,1) :: g, bs, br         nxhyd = size(mixup); nxyhd = size(sct)         call PFFT2R(f,g,bs,br,isign,ntpose,mixup,sct,indx,indy,kstrt,nx&     &vh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         end subroutine ipfft2rinit!         subroutine ipfft2r(f,g,isign,mixup,sct,indx,indy,kstrt,kyp,inor&     &der)         implicit none         integer :: isign, indx, indy, kstrt, kyp         integer, optional :: inorder         real, dimension(:,:,:) :: f         complex, dimension(:,:,:) :: g         integer, dimension(:) :: mixup         complex, dimension(:) :: sct         integer :: ntpose = 1, nxvh, nyv         integer :: kxp, kypd, jblok, kblok, nxhyd, nxyhd, order         complex, dimension(size(g,2),kyp,size(f,3)) :: bs         complex, dimension(size(g,2),kyp,size(g,3)) :: br         nxvh = size(f,1)/2; kypd = size(f,2); kblok = size(f,3)         nyv = size(g,1); kxp = size(g,2); jblok = size(g,3)         nxhyd = size(mixup); nxyhd = size(sct)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PFFT2R(f(1,1,1),g,bs,br,isign,ntpose,mixup,sct,indx,ind&     &y,kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         else            call PFFT2R(f(2,2,1),g,bs,br,isign,ntpose,mixup,sct,indx,ind&     &y,kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         endif         end subroutine ipfft2r!         subroutine ipfft2r2(f,g,mixup,sct,indx,indy,kstrt,kyp,inorder)         implicit none         integer :: indx, indy, kstrt, kyp         integer, optional :: inorder         real, dimension(:,:,:,:) :: f         complex, dimension(:,:,:,:) :: g         complex, dimension(2,size(g,3),kyp,size(f,4)) :: bs         complex, dimension(2,size(g,3),kyp,size(g,4)) :: br         integer, dimension(:) :: mixup         complex, dimension(:) :: sct         integer :: isign = 1, ntpose = 1, nxvh, nyv         integer :: kxp, kypd, jblok, kblok, nxhyd, nxyhd, order         nxvh = size(f,2)/2; kypd = size(f,3); kblok = size(f,4)         nyv = size(g,2); kxp = size(g,3); jblok = size(g,4)         nxhyd = size(mixup); nxyhd = size(sct)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PFFT2R2(f(1,1,1,1),g,bs,br,isign,ntpose,mixup,sct,indx,&     &indy,kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         else            call PFFT2R2(f(1,2,2,1),g,bs,br,isign,ntpose,mixup,sct,indx,&     &indy,kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         endif         end subroutine ipfft2r2!         subroutine ipfft2r3(f,g,isign,mixup,sct,indx,indy,kstrt,kyp,ino&     &rder)         implicit none         integer :: isign, indx, indy, kstrt, kyp         integer, optional :: inorder         real, dimension(:,:,:,:) :: f         complex, dimension(:,:,:,:) :: g         complex, dimension(3,size(g,3),kyp,size(f,4)) :: bs         complex, dimension(3,size(g,3),kyp,size(g,4)) :: br         integer, dimension(:) :: mixup         complex, dimension(:) :: sct         integer :: ntpose = 1, nxvh, nyv         integer :: kxp, kypd, jblok, kblok, nxhyd, nxyhd, order         nxvh = size(f,2)/2; kypd = size(f,3); kblok = size(f,4)         nyv = size(g,2); kxp = size(g,3); jblok = size(g,4)         nxhyd = size(mixup); nxyhd = size(sct)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PFFT2R3(f(1,1,1,1),g,bs,br,isign,ntpose,mixup,sct,indx,&     &indy,kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         else            call PFFT2R3(f(1,2,2,1),g,bs,br,isign,ntpose,mixup,sct,indx,&     &indy,kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         endif         end subroutine ipfft2r3!         subroutine ipfft2rxinit(mixup,sct,indx,indy)         implicit none         integer :: indx, indy         integer, dimension(:) :: mixup         complex, dimension(:) :: sct         integer :: isign = 0, ntpose = 1, kstrt = 1, nxvh = 1, nyv = 1         integer :: kxp = 1, kyp = 1, kypd = 1         integer :: jblok = 1, kblok = 1         integer :: nxhyd, nxyhd         real :: f         complex, dimension(1,1,1) :: g         nxhyd = size(mixup); nxyhd = size(sct)         call PFFT2RX(f,g,isign,ntpose,mixup,sct,indx,indy,kstrt,nxvh,ny&     &v,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         end subroutine ipfft2rxinit!         subroutine ipfft2rx(f,g,isign,mixup,sct,indx,indy,kstrt,kyp,ino&     &rder)         implicit none         integer :: isign, indx, indy, kstrt, kyp         integer, optional :: inorder         real, dimension(:,:,:) :: f         complex, dimension(:,:,:) :: g         integer, dimension(:) :: mixup         complex, dimension(:) :: sct         integer :: ntpose = 1, nxvh, nyv, kxp, kypd         integer :: jblok, kblok, nxhyd, nxyhd, order         nxvh = size(f,1)/2; kypd = size(f,2); kblok = size(f,3)         nyv = size(g,1); kxp = size(g,2); jblok = size(g,3)         nxhyd = size(mixup); nxyhd = size(sct)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PFFT2RX(f(1,1,1),g,isign,ntpose,mixup,sct,indx,indy,kst&     &rt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         else            call PFFT2RX(f(2,2,1),g,isign,ntpose,mixup,sct,indx,indy,kst&     &rt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         endif         end subroutine ipfft2rx!         subroutine ipfft2rx2(f,g,mixup,sct,indx,indy,kstrt,kyp,inorder)         implicit none         integer :: indx, indy, kstrt, kyp         integer, optional :: inorder         real, dimension(:,:,:,:) :: f         complex, dimension(:,:,:,:) :: g         integer, dimension(:) :: mixup         complex, dimension(:) :: sct         integer :: isign = 1, ntpose = 1, nxvh, nyv, kxp         integer :: kypd, jblok, kblok, nxhyd, nxyhd, order         nxvh = size(f,2)/2; kypd = size(f,3); kblok = size(f,4)         nyv = size(g,2); kxp = size(g,3); jblok = size(g,4)         nxhyd = size(mixup); nxyhd = size(sct)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PFFT2RX2(f(1,1,1,1),g,isign,ntpose,mixup,sct,indx,indy,&     &kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         else            call PFFT2RX2(f(1,2,2,1),g,isign,ntpose,mixup,sct,indx,indy,&     &kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         endif         end subroutine ipfft2rx2!         subroutine ipfft2rx3(f,g,isign,mixup,sct,indx,indy,kstrt,kyp,in&     &order)         implicit none         integer :: isign, indx, indy, kstrt, kyp         integer, optional :: inorder         real, dimension(:,:,:,:) :: f         complex, dimension(:,:,:,:) :: g         integer, dimension(:) :: mixup         complex, dimension(:) :: sct         integer :: ntpose = 1, nxvh, nyv, kxp         integer :: kypd, jblok, kblok, nxhyd, nxyhd, order         nxvh = size(f,2)/2; kypd = size(f,3); kblok = size(f,4)         nyv = size(g,2); kxp = size(g,3); jblok = size(g,4)         nxhyd = size(mixup); nxyhd = size(sct)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PFFT2RX3(f(1,1,1,1),g,isign,ntpose,mixup,sct,indx,indy,&     &kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         else            call PFFT2RX3(f(1,2,2,1),g,isign,ntpose,mixup,sct,indx,indy,&     &kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         endif         end subroutine ipfft2rx3!         subroutine ipfft2c(f,g,isign,mixup,sct,indx,indy,kstrt,kyp,inor&     &der)         implicit none         integer :: isign, indx, indy, kstrt, kyp         integer, optional :: inorder         complex, dimension(:,:,:) :: f, g         integer, dimension(:) :: mixup         complex, dimension(:) :: sct         integer :: ntpose = 1, nxv, nyv         integer :: kxp, kypd, jblok, kblok, nxyd, nxyhd, order         complex, dimension(size(g,2),kyp,size(f,3)) :: bs         complex, dimension(size(g,2),kyp,size(g,3)) :: br         nxv = size(f,1); kypd = size(f,2); kblok = size(f,3)         nyv = size(g,1); kxp = size(g,2); jblok = size(g,3)         nxyd = size(mixup); nxyhd = size(sct)         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PFFT2C(f(1,1,1),g,bs,br,isign,ntpose,mixup,sct,indx,ind&     &y,kstrt,nxv,nyv,kxp,kyp,kypd,jblok,kblok,nxyd,nxyhd)         else            call PFFT2C(f(2,2,1),g,bs,br,isign,ntpose,mixup,sct,indx,ind&     &y,kstrt,nxv,nyv,kxp,kyp,kypd,jblok,kblok,nxyd,nxyhd)         endif         end subroutine ipfft2c!         subroutine ipfft2cinit(mixup,sct,indx,indy)         implicit none         integer :: indx, indy         integer, dimension(:) :: mixup         complex, dimension(:) :: sct         integer :: isign = 0, ntpose = 1, kstrt = 1, nxv = 1, nyv = 1         integer :: kxp = 1, kyp = 1, kypd = 1         integer :: jblok = 1, kblok = 1         integer :: nxyd, nxyhd         complex :: f         complex, dimension(1,1,1) :: g, bs, br         nxyd = size(mixup); nxyhd = size(sct)         call PFFT2C(f,g,bs,br,isign,ntpose,mixup,sct,indx,indy,kstrt,nx&     &v,nyv,kxp,kyp,kypd,jblok,kblok,nxyd,nxyhd)         end subroutine ipfft2cinit!      end module pfield2d