c 2d parallel PIC library for solving field equations with non-periodicc boundary conditionsc written by viktor k. decyk, uclac copyright 1995, regents of the university of californiac update: march 3, 2003c-----------------------------------------------------------------------      subroutine PLCGUARD2X(fxy,nyp,nx,nxe,nypmx,nblok)c this subroutine replicates field so as to disablec quadratic interpolation within a half a cell of the edges,c and reduce it to linear interpolation in the x directionc for distributed data      implicit none      real fxy      integer nyp, nx, nxe, nypmx, nblok      dimension fxy(2,nxe,nypmx,nblok), nyp(nblok)c local data      integer k, l, nyp3      do 20 l = 1, nblok      nyp3 = nyp(l) + 3      do 10 k = 1, nyp3      fxy(1,1,k,l) = 2.*fxy(1,2,k,l) - fxy(1,3,k,l)      fxy(2,1,k,l) = 2.*fxy(2,2,k,l) - fxy(2,3,k,l)      fxy(1,nx+3,k,l) = 2.*fxy(1,nx+2,k,l) - fxy(1,nx+1,k,l)      fxy(2,nx+3,k,l) = 2.*fxy(2,nx+2,k,l) - fxy(2,nx+1,k,l)   10 continue   20 continue      return      endc-----------------------------------------------------------------------      subroutine PLDGUARD2X(q,nyp,nx,nxe,nypmx,nblok)c this subroutine replicates scalar field so as to disablec quadratic interpolation within a half a cell of the edges,c and reduce it to linear interpolation in the x directionc for distributed data      implicit none      real q      integer nyp, nx, nxe, nypmx, nblok      dimension q(nxe,nypmx,nblok), nyp(nblok)c local data      integer k, l, nyp3      do 20 l = 1, nblok      nyp3 = nyp(l) + 3      do 10 k = 1, nyp3      q(1,k,l) = 2.*q(2,k,l) - q(3,k,l)      q(nx+3,k,l) = 2.*q(nx+2,k,l) - q(nx+1,k,l)   10 continue   20 continue      return      endc-----------------------------------------------------------------------      subroutine PLBGUARD2X(bxy,nyp,nx,nxe,nypmx,nblok)c this subroutine replicates field so as to disablec quadratic interpolation within a half a cell of the edges,c and reduce it to linear interpolation in the x directionc for distributed data      implicit none      real bxy      integer nyp, nx, nxe, nypmx, nblok      dimension bxy(3,nxe,nypmx,nblok), nyp(nblok)c local data      integer k, l, nyp3      do 20 l = 1, nblok      nyp3 = nyp(l) + 3      do 10 k = 1, nyp3      bxy(1,1,k,l) = 2.*bxy(1,2,k,l) - bxy(1,3,k,l)      bxy(2,1,k,l) = 2.*bxy(2,2,k,l) - bxy(2,3,k,l)      bxy(3,1,k,l) = 2.*bxy(3,2,k,l) - bxy(3,3,k,l)      bxy(1,nx+3,k,l) = 2.*bxy(1,nx+2,k,l) - bxy(1,nx+1,k,l)      bxy(2,nx+3,k,l) = 2.*bxy(2,nx+2,k,l) - bxy(2,nx+1,k,l)      bxy(3,nx+3,k,l) = 2.*bxy(3,nx+2,k,l) - bxy(3,nx+1,k,l)   10 continue   20 continue      return      endc-----------------------------------------------------------------------      subroutine PLSCGUARD2(cu,kstrt,nvp,nyp,xj0,yj0,zj0,nx,ngx,ngy,nxe,     1nypmx,nblok)c initialize extended non-periodic fieldc ngx/ngy = (0,1) number of grid cells away from edgec quadratic interpolation, for distributed data      implicit none      real cu, xj0, yj0, zj0      integer kstrt, nvp, nyp, nx, ngx, ngy, nxe, nypmx, nblok      dimension cu(3,nxe,nypmx,nblok), nyp(nblok)      integer i, j, k, l, ks, nyp3, nxg, nx3      real chx, chy, chz      if ((ngx.lt.0).or.(ngx.gt.1).or.(ngy.lt.0).or.(ngy.gt.1)) returnc initialize extended field, with zero in the edges      nxg = nx - 2*ngx      nx3 = nx + 3      ks = kstrt - 2      chx = .5*xj0      chy = .5*yj0      chz = .5*zj0      do 120 l = 1, nblok      nyp3 = nyp(l) + 3      do 30 k = 1, nyp(l)      do 10 j = 2, nxg      cu(1,j+ngx+1,k+1,l) = xj0      cu(2,j+ngx+1,k+1,l) = yj0      cu(3,j+ngx+1,k+1,l) = zj0   10 continue      do 20 i = 1, 3      cu(i,1,k+1,l) = 0.      cu(i,2,k+1,l) = 0.      cu(i,nx+2,k+1,l) = 0.      cu(i,nx+3,k+1,l) = 0.   20 continue      cu(1,ngx+2,k+1,l) = chx      cu(2,ngx+2,k+1,l) = chy      cu(3,ngx+2,k+1,l) = chz      cu(1,nx-ngx+2,k+1,l) = chx      cu(2,nx-ngx+2,k+1,l) = chy      cu(3,nx-ngx+2,k+1,l) = chz   30 continue      do 50 j = 1, nx3      do 40 i = 1, 3      cu(i,j,1,l) = 0.      cu(i,j,nyp3-1,l) = 0.      cu(i,j,nyp3,l) = 0.   40 continue   50 continue      if ((l+ks).eq.0) thenc fix previous deposit when grid is only one wide.         if ((ngy+4).gt.nyp3) then            chx = -chx            chy = -chy            chz = -chz         endifc handle first grid point in y         do 70 j = 1, nx3         do 60 i = 1, 3         cu(i,j,2,l) = 0.   60    continue   70    continue         do 80 j = 2, nxg         cu(1,j+ngx+1,ngy+2,l) = chx         cu(2,j+ngx+1,ngy+2,l) = chy         cu(3,j+ngx+1,ngy+2,l) = chz   80    continue         do 90 i = 1, 3         cu(i,1,ngy+2,l) = 0.         cu(i,2,ngy+2,l) = 0.         cu(i,nx+2,ngy+2,l) = 0.         cu(i,nx+3,ngy+2,l) = 0.   90    continue         cu(1,ngx+2,ngy+2,l) = .5*chx         cu(2,ngx+2,ngy+2,l) = .5*chy         cu(3,ngx+2,ngy+2,l) = .5*chz         cu(1,nx-ngx+2,ngy+2,l) = .5*chx         cu(2,nx-ngx+2,ngy+2,l) = .5*chy         cu(3,nx-ngx+2,ngy+2,l) = .5*chz         chx = .5*xj0         chy = .5*yj0         chz = .5*zj0      endif      if ((l+ks).eq.(nvp-1)) thenc handle last grid point in y         do 100 j = 2, nxg         cu(1,j+ngx+1,nyp3-ngy-1,l) = chx         cu(2,j+ngx+1,nyp3-ngy-1,l) = chy         cu(3,j+ngx+1,nyp3-ngy-1,l) = chz  100    continue         do 110 i = 1, 3         cu(i,1,nyp3-ngy-1,l) = 0.         cu(i,2,nyp3-ngy-1,l) = 0.         cu(i,nx+2,nyp3-ngy-1,l) = 0.         cu(i,nx+3,nyp3-ngy-1,l) = 0.  110    continue         cu(1,ngx+2,nyp3-ngy-1,l) = .5*chx         cu(2,ngx+2,nyp3-ngy-1,l) = .5*chy         cu(3,ngx+2,nyp3-ngy-1,l) = .5*chz         cu(1,nx-ngx+2,nyp3-ngy-1,l) = .5*chx         cu(2,nx-ngx+2,nyp3-ngy-1,l) = .5*chy         cu(3,nx-ngx+2,nyp3-ngy-1,l) = .5*chz      endif  120 continue      return      endc-----------------------------------------------------------------------      subroutine PLSCGUARD22(cu,kstrt,nvp,nyp,xj0,yj0,nx,ngx,ngy,nxe,nyp     1mx,nblok)c initialize extended non-periodic fieldc ngx/ngy = (0,1) number of grid cells away from edgec quadratic interpolation, for distributed data      implicit none      real cu, xj0, yj0      integer kstrt, nvp, nyp, nx, ngx, ngy, nxe, nypmx, nblok      dimension cu(2,nxe,nypmx,nblok), nyp(nblok)      integer i, j, k, l, ks, nyp3, nxg, nx3      real chx, chy      if ((ngx.lt.0).or.(ngx.gt.1).or.(ngy.lt.0).or.(ngy.gt.1)) returnc initialize extended field, with zero in the edges      nxg = nx - 2*ngx      nx3 = nx + 3      ks = kstrt - 2      chx = .5*xj0      chy = .5*yj0      do 120 l = 1, nblok      nyp3 = nyp(l) + 3      do 30 k = 1, nyp(l)      do 10 j = 2, nxg      cu(1,j+ngx+1,k+1,l) = xj0      cu(2,j+ngx+1,k+1,l) = yj0   10 continue      do 20 i = 1, 2      cu(i,1,k+1,l) = 0.      cu(i,2,k+1,l) = 0.      cu(i,nx+2,k+1,l) = 0.      cu(i,nx+3,k+1,l) = 0.   20 continue      cu(1,ngx+2,k+1,l) = chx      cu(2,ngx+2,k+1,l) = chy      cu(1,nx-ngx+2,k+1,l) = chx      cu(2,nx-ngx+2,k+1,l) = chy   30 continue      do 50 j = 1, nx3      do 40 i = 1, 2      cu(i,j,1,l) = 0.      cu(i,j,nyp3-1,l) = 0.      cu(i,j,nyp3,l) = 0.   40 continue   50 continue      if ((l+ks).eq.0) thenc fix previous deposit when grid is only one wide.         if ((ngy+4).gt.nyp3) then            chx = -chx            chy = -chy         endifc handle first grid point in y         do 70 j = 1, nx3         do 60 i = 1, 2         cu(i,j,2,l) = 0.   60    continue   70    continue         do 80 j = 2, nxg         cu(1,j+ngx+1,ngy+2,l) = chx         cu(2,j+ngx+1,ngy+2,l) = chy   80    continue         do 90 i = 1, 2         cu(i,1,ngy+2,l) = 0.         cu(i,2,ngy+2,l) = 0.         cu(i,nx+2,ngy+2,l) = 0.         cu(i,nx+3,ngy+2,l) = 0.   90    continue         cu(1,ngx+2,ngy+2,l) = .5*chx         cu(2,ngx+2,ngy+2,l) = .5*chy         cu(1,nx-ngx+2,ngy+2,l) = .5*chx         cu(2,nx-ngx+2,ngy+2,l) = .5*chy         chx = .5*xj0         chy = .5*yj0      endif      if ((l+ks).eq.(nvp-1)) thenc handle last grid point in y         do 100 j = 2, nxg         cu(1,j+ngx+1,nyp3-ngy-1,l) = chx         cu(2,j+ngx+1,nyp3-ngy-1,l) = chy  100    continue         do 110 i = 1, 2         cu(i,1,nyp3-ngy-1,l) = 0.         cu(i,2,nyp3-ngy-1,l) = 0.         cu(i,nx+2,nyp3-ngy-1,l) = 0.         cu(i,nx+3,nyp3-ngy-1,l) = 0.  110    continue         cu(1,ngx+2,nyp3-ngy-1,l) = .5*chx         cu(2,ngx+2,nyp3-ngy-1,l) = .5*chy         cu(1,nx-ngx+2,nyp3-ngy-1,l) = .5*chx         cu(2,nx-ngx+2,nyp3-ngy-1,l) = .5*chy      endif  120 continue      return      endc-----------------------------------------------------------------------      subroutine PLSGUARD2(q,kstrt,nvp,nyp,qi0,nx,ngx,ngy,nxe,nypmx,nblo     1k)c initialize extended non-periodic scalar fieldc ngx/ngy = (0,1) number of grid cells away from edgec quadratic interpolation, for distributed data      implicit none      real q, qi0      integer kstrt, nvp, nyp, nx, ngx, ngy, nxe, nypmx, nblok      dimension q(nxe,nypmx,nblok), nyp(nblok)      integer j, k, l, ks, nyp3, nxg, nx3      real qh      if ((ngx.lt.0).or.(ngx.gt.1).or.(ngy.lt.0).or.(ngy.gt.1)) returnc initialize extended field, with zero in the edges      nxg = nx - 2*ngx      nx3 = nx + 3      ks = kstrt - 2      qh = .5*qi0      do 70 l = 1, nblok      nyp3 = nyp(l) + 3      do 20 k = 1, nyp(l)      do 10 j = 2, nxg      q(j+ngx+1,k+1,l) = qi0   10 continue      q(1,k+1,l) = 0.      q(2,k+1,l) = 0.      q(nx+2,k+1,l) = 0.      q(nx+3,k+1,l) = 0.      q(ngx+2,k+1,l) = qh      q(nx-ngx+2,k+1,l) = qh   20 continue      do 30 j = 1, nx3      q(j,1,l) = 0.      q(j,nyp3-1,l) = 0.      q(j,nyp3,l) = 0.   30 continue      if ((l+ks).eq.0) thenc fix previous deposit when grid is only one wide.         if ((ngy+4).gt.nyp3) qh = -qhc handle first grid point in y         do 40 j = 1, nx3         q(j,2,l) = 0.   40    continue         do 50 j = 2, nxg         q(j+ngx+1,ngy+2,l) = qh   50    continue         q(1,ngy+2,l) = 0.         q(2,ngy+2,l) = 0.         q(nx+2,ngy+2,l) = 0.         q(nx+3,ngy+2,l) = 0.         q(ngx+2,ngy+2,l) = .5*qh         q(nx-ngx+2,ngy+2,l) = .5*qh         qh = .5*qi0      endif      if ((l+ks).eq.(nvp-1)) thenc handle last grid point in y         do 60 j = 2, nxg         q(j+ngx+1,nyp3-ngy-1,l) = qh   60    continue         q(1,nyp3-ngy-1,l) = 0.         q(2,nyp3-ngy-1,l) = 0.         q(nx+2,nyp3-ngy-1,l) = 0.         q(nx+3,nyp3-ngy-1,l) = 0.         q(ngx+2,nyp3-ngy-1,l) = .5*qh         q(nx-ngx+2,nyp3-ngy-1,l) = .5*qh      endif   70 continue      return      endc-----------------------------------------------------------------------      subroutine PLACGUARD2X(cu,nyp,nx,nxe,nypmx,nblok)c this subroutine adds adds up guard cells so as to disablec quadratic interpolation within a half a cell of the edges,c and reduce it to linear interpolation in the x directionc for distributed data      implicit none      real cu      integer nyp, nx, nxe, nypmx, nblok      dimension cu(3,nxe,nypmx,nblok), nyp(nblok)c local data      integer i, k, l, nyp3c add up guard cells      do 30 l = 1, nblok      nyp3 = nyp(l) + 3      do 20 k = 1, nyp3      do 10 i = 1, 3      cu(i,2,k,l) = cu(i,2,k,l) + 2.*cu(i,1,k,l)      cu(i,3,k,l) = cu(i,3,k,l) - cu(i,1,k,l)      cu(i,nx+1,k,l) = cu(i,nx+1,k,l) - cu(i,nx+3,k,l)      cu(i,nx+2,k,l) = cu(i,nx+2,k,l) + 2.*cu(i,nx+3,k,l)      cu(i,1,k,l) = 0.      cu(i,nx+3,k,l) = 0.   10 continue   20 continue   30 continue      return      endc-----------------------------------------------------------------------      subroutine PLACGUARD22X(cu,nyp,nx,nxe,nypmx,nblok)c this subroutine adds adds up guard cells so as to disablec quadratic interpolation within a half a cell of the edges,c and reduce it to linear interpolation in the x directionc for distributed data      implicit none      real cu      integer nyp, nx, nxe, nypmx, nblok      dimension cu(2,nxe,nypmx,nblok), nyp(nblok)c local data      integer i, k, l, nyp3c add up guard cells      do 30 l = 1, nblok      nyp3 = nyp(l) + 3      do 20 k = 1, nyp3      do 10 i = 1, 2      cu(i,2,k,l) = cu(i,2,k,l) + 2.*cu(i,1,k,l)      cu(i,3,k,l) = cu(i,3,k,l) - cu(i,1,k,l)      cu(i,nx+1,k,l) = cu(i,nx+1,k,l) - cu(i,nx+3,k,l)      cu(i,nx+2,k,l) = cu(i,nx+2,k,l) + 2.*cu(i,nx+3,k,l)      cu(i,1,k,l) = 0.      cu(i,nx+3,k,l) = 0.   10 continue   20 continue   30 continue      return      endc-----------------------------------------------------------------------      subroutine PLAGUARD2X(q,nyp,nx,nxe,nypmx,nblok)c this subroutine adds adds up guard cells so as to disablec quadratic interpolation within a half a cell of the edges,c and reduce it to linear interpolation in the x directionc for distributed scalar data      implicit none      real q      integer nyp, nx, nxe, nypmx, nblok      dimension q(nxe,nypmx,nblok), nyp(nblok)c local data      integer k, l, nyp3c add up guard cells      do 20 l = 1, nblok      nyp3 = nyp(l) + 3      do 10 k = 1, nyp3      q(2,k,l) = q(2,k,l) + 2.*q(1,k,l)      q(3,k,l) = q(3,k,l) - q(1,k,l)      q(nx+1,k,l) = q(nx+1,k,l) - q(nx+3,k,l)      q(nx+2,k,l) = q(nx+2,k,l) + 2.*q(nx+3,k,l)      q(1,k,l) = 0.      q(nx+3,k,l) = 0.   10 continue   20 continue      return      endc-----------------------------------------------------------------------      subroutine PLSCGUARD2L(cu,kstrt,nvp,nyp,xj0,yj0,zj0,nx,ngx,ngy,nxe     1,nypmx,nblok)c initialize extended non-periodic fieldc ngx/ngy = (0,1) = number of grid cells away from edgec linear interpolation, for distributed data      implicit none      real cu, xj0, yj0, zj0      integer kstrt, nvp, nyp, nx, ngx, ngy, nxe, nypmx, nblok      dimension cu(3,nxe,nypmx,nblok), nyp(nblok)      integer i, j, k, l, ks, nyp1, nxg, nx1      real chx, chy, chz      if ((ngx.lt.0).or.(ngx.gt.1).or.(ngy.lt.0).or.(ngy.gt.1)) returnc initialize extended field, with zero in the edges      nxg = nx - 2*ngx      nx1 = nx + 1      ks = kstrt - 2      chx = .5*xj0      chy = .5*yj0      chz = .5*zj0      do 120 l = 1, nblok      nyp1 = nyp(l) + 1      do 30 k = 1, nyp(l)      do 10 j = 2, nxg      cu(1,j+ngx,k,l) = xj0      cu(2,j+ngx,k,l) = yj0      cu(3,j+ngx,k,l) = zj0   10 continue      do 20 i = 1, 3      cu(i,1,k,l) = 0.      cu(i,nx+1,k,l) = 0.   20 continue      cu(1,ngx+1,k,l) = chx      cu(2,ngx+1,k,l) = chy      cu(3,ngx+1,k,l) = chz      cu(1,nx-ngx+1,k,l) = chx      cu(2,nx-ngx+1,k,l) = chy      cu(3,nx-ngx+1,k,l) = chz   30 continue      do 50 j = 1, nx1      do 40 i = 1, 3      cu(i,j,nyp1,l) = 0.   40 continue   50 continue      if ((l+ks).eq.0) thenc fix previous deposit when grid is only one wide.         if ((ngy+2).gt.nyp1) then            chx = -chx            chy = -chy            chz = -chz         endifc handle first grid point in y         do 70 j = 1, nx1         do 60 i = 1, 3         cu(i,j,1,l) = 0.   60    continue   70    continue         do 80 j = 2, nxg         cu(1,j+ngx,ngy+1,l) = chx         cu(2,j+ngx,ngy+1,l) = chy         cu(3,j+ngx,ngy+1,l) = chz   80    continue         do 90 i = 1, 3         cu(i,1,ngy+1,l) = 0.         cu(i,nx+1,ngy+1,l) = 0.   90    continue         cu(1,ngx+1,ngy+1,l) = .5*chx         cu(2,ngx+1,ngy+1,l) = .5*chy         cu(3,ngx+1,ngy+1,l) = .5*chz         cu(1,nx-ngx+1,ngy+1,l) = .5*chx         cu(2,nx-ngx+1,ngy+1,l) = .5*chy         cu(3,nx-ngx+1,ngy+1,l) = .5*chz         chx = .5*xj0         chy = .5*yj0         chz = .5*zj0      endif      if ((l+ks).eq.(nvp-1)) thenc handle last grid point in y         do 100 j = 2, nxg         cu(1,j+ngx,nyp1-ngy,l) = chx         cu(2,j+ngx,nyp1-ngy,l) = chy         cu(3,j+ngx,nyp1-ngy,l) = chz  100    continue         do 110 i = 1, 3         cu(i,1,nyp1-ngy,l) = 0.         cu(i,nx+1,nyp1-ngy,l) = 0.  110    continue         cu(1,ngx+1,nyp1-ngy,l) = .5*chx         cu(2,ngx+1,nyp1-ngy,l) = .5*chy         cu(3,ngx+1,nyp1-ngy,l) = .5*chz         cu(1,nx-ngx+1,nyp1-ngy,l) = .5*chx         cu(2,nx-ngx+1,nyp1-ngy,l) = .5*chy         cu(3,nx-ngx+1,nyp1-ngy,l) = .5*chz      endif  120 continue      return      endc-----------------------------------------------------------------------      subroutine PLSCGUARD22L(cu,kstrt,nvp,nyp,xj0,yj0,nx,ngx,ngy,nxe,ny     1pmx,nblok)c initialize extended non-periodic fieldc ngx/ngy = (0,1) = number of grid cells away from edgec linear interpolation, for distributed data      implicit none      real cu, xj0, yj0      integer kstrt, nvp, nyp, nx, ngx, ngy, nxe, nypmx, nblok      dimension cu(2,nxe,nypmx,nblok), nyp(nblok)      integer i, j, k, l, ks, nyp1, nxg, nx1      real chx, chy      if ((ngx.lt.0).or.(ngx.gt.1).or.(ngy.lt.0).or.(ngy.gt.1)) returnc initialize extended field, with zero in the edges      nxg = nx - 2*ngx      nx1 = nx + 1      ks = kstrt - 2      chx = .5*xj0      chy = .5*yj0      do 120 l = 1, nblok      nyp1 = nyp(l) + 1      do 30 k = 1, nyp(l)      do 10 j = 2, nxg      cu(1,j+ngx,k,l) = xj0      cu(2,j+ngx,k,l) = yj0   10 continue      do 20 i = 1, 2      cu(i,1,k,l) = 0.      cu(i,nx+1,k,l) = 0.   20 continue      cu(1,ngx+1,k,l) = chx      cu(2,ngx+1,k,l) = chy      cu(1,nx-ngx+1,k,l) = chx      cu(2,nx-ngx+1,k,l) = chy   30 continue      do 50 j = 1, nx1      do 40 i = 1, 2      cu(i,j,nyp1,l) = 0.   40 continue   50 continue      if ((l+ks).eq.0) thenc fix previous deposit when grid is only one wide.         if ((ngy+2).gt.nyp1) then            chx = -chx            chy = -chy         endifc handle first grid point in y         do 70 j = 1, nx1         do 60 i = 1, 2         cu(i,j,1,l) = 0.   60    continue   70    continue         do 80 j = 2, nxg         cu(1,j+ngx,ngy+1,l) = chx         cu(2,j+ngx,ngy+1,l) = chy   80    continue         do 90 i = 1, 2         cu(i,1,ngy+1,l) = 0.         cu(i,nx+1,ngy+1,l) = 0.   90    continue         cu(1,ngx+1,ngy+1,l) = .5*chx         cu(2,ngx+1,ngy+1,l) = .5*chy         cu(1,nx-ngx+1,ngy+1,l) = .5*chx         cu(2,nx-ngx+1,ngy+1,l) = .5*chy         chx = .5*xj0         chy = .5*yj0      endif      if ((l+ks).eq.(nvp-1)) thenc handle last grid point in y         do 100 j = 2, nxg         cu(1,j+ngx,nyp1-ngy,l) = chx         cu(2,j+ngx,nyp1-ngy,l) = chy  100    continue         do 110 i = 1, 2         cu(i,1,nyp1-ngy,l) = 0.         cu(i,nx+1,nyp1-ngy,l) = 0.  110    continue         cu(1,ngx+1,nyp1-ngy,l) = .5*chx         cu(2,ngx+1,nyp1-ngy,l) = .5*chy         cu(1,nx-ngx+1,nyp1-ngy,l) = .5*chx         cu(2,nx-ngx+1,nyp1-ngy,l) = .5*chy      endif  120 continue      return      endc-----------------------------------------------------------------------      subroutine PLSGUARD2L(q,kstrt,nvp,nyp,qi0,nx,ngx,ngy,nxe,nypmx,nbl     1ok)c initialize extended non-periodic scalar fieldc ngx/ngy = (0,1) = number of grid cells away from edgec linear interpolation, for distributed data      implicit none      real q, qi0      integer kstrt, nvp, nyp, nx, ngx, ngy, nxe, nypmx, nblok      dimension q(nxe,nypmx,nblok), nyp(nblok)      integer j, k, l, ks, nyp1, nxg, nx1      real qh      if ((ngx.lt.0).or.(ngx.gt.1).or.(ngy.lt.0).or.(ngy.gt.1)) returnc initialize extended field, with zero in the edges      nxg = nx - 2*ngx      nx1 = nx + 1      ks = kstrt - 2      qh = .5*qi0      do 70 l = 1, nblok      nyp1 = nyp(l) + 1      do 20 k = 1, nyp(l)      do 10 j = 2, nxg      q(j+ngx,k,l) = qi0   10 continue      q(1,k,l) = 0.      q(nx+1,k,l) = 0.      q(ngx+1,k,l) = qh      q(nx-ngx+1,k,l) = qh   20 continue      do 30 j = 1, nx1      q(j,nyp1,l) = 0.   30 continue      if ((l+ks).eq.0) thenc fix previous deposit when grid is only one wide.         if ((ngy+2).gt.nyp1) qh = -qhc handle first grid point in y         do 40 j = 1, nx1         q(j,1,l) = 0.   40    continue         do 50 j = 2, nxg         q(j+ngx,ngy+1,l) = qh   50    continue         q(1,ngy+1,l) = 0.         q(nx+1,ngy+1,l) = 0.         q(ngx+1,ngy+1,l) = .5*qh         q(nx-ngx+1,ngy+1,l) = .5*qh         qh = .5*qi0      endif      if ((l+ks).eq.(nvp-1)) thenc handle last grid point in y         do 60 j = 2, nxg         q(j+ngx,nyp1-ngy,l) = qh   60    continue         q(1,nyp1-ngy,l) = 0.         q(nx+1,nyp1-ngy,l) = 0.         q(ngx+1,nyp1-ngy,l) = .5*qh         q(nx-ngx+1,nyp1-ngy,l) = .5*qh      endif   70 continue      return      endc-----------------------------------------------------------------------      subroutine PPOISD2(q,fx,fy,isign,ffd,ax,ay,affp,we,nx,ny,kstrt,ny2     1d,kxp2,j2blok,nyd)c this subroutine solves 2d poisson's equation in fourier space forc force/charge (or convolution of electric field over particle shape)c or for potential, or provides a smoothing function, with diricheletc boundary conditions (zero potential), for distributed data.c fourier coefficients are constructed so that a real to complex fftc will perform the appropriate sin-sin, sin-cos, or cos-sin transformc for isign = 0,input: isign,ax,ay,affp,nx,ny,kstrt,ny2d,kxp2,j2blok,nydc               output: ffdc for isign = -1, input: q,ffd,isign,nx,ny,kstrt,ny2d,kxp2,j2blok,nydc                output: fx,fy,wec approximate flop count is: 11*nx*nyc for isign = 1, input: q,ffd,isign,nx,ny,kstrt,ny2d,kxp2,j2blok,nydc                output: fx,wec approximate flop count is: 6*nc*nyc for isign = 2, input: q,ffd,isign,nx,ny,kstrt,ny2d,kxp2,j2blok,nydc                output: fyc approximate flop count is: 2*nx*nyc if isign < 0, force/charge is calculated using the equations:c fx(kx,ky) = -sqrt(-1)*kx*g(kx,ky)*s(kx,ky)*q(kx,ky),c fy(kx,ky) = -sqrt(-1)*ky*g(kx,ky)*s(kx,ky)*q(kx,ky),c where kx = pi*j/nx, ky = pi*k/ny, and j,k = fourier mode numbers,c g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky),c s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2), except forc if isign = 1, potential is calculated using the equation:c fx(kx,ky) = g(kx,ky)*q(kx,ky)*s(kx,ky)c if isign = 2, smoothing is calculated using the equation:c fy(kx,ky) = q(kx,ky)*s(kx,ky)c q(k,j,l) = complex charge density for fourier mode (jj-1,k-1)c fx(k,j,l) = x component of complex force/charge,c fy(k,j,l) = y component of complex force/charge,c all for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c if isign = 0, form factor array is preparedc ffd(k,2*j,l) = finite-size particle shape factor sc ffd(k,2*j-1,l) = potential green's function gc all for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c j2blok = number of data blocksc kxp2 = number of data values per blockc kstrt = starting data block numberc ax/ay = half-width of particle in x/y directionc affp = normalization constant = nx*ny/np, where np=number of particlesc electric field energy is also calculated, usingc we = 2*nx*ny*sum((affp/(kx**2+ky**2))*|q(kx,ky)*s(kx,ky)|**2)c nx/ny = system length in x/y directionc ny2d = first dimension of field arrays, must be >= 2*nyc nyd = first dimension of form factor array, must be >= ny      double precision wp      complex q, fx, fy, ffd, zero      dimension q(ny2d,kxp2,j2blok)      dimension fx(ny2d,kxp2,j2blok), fy(ny2d,kxp2,j2blok)      dimension ffd(nyd,kxp2,j2blok)      ny2 = 2*ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx + nx)      dny = 6.28318530717959/float(ny + ny)      zero = cmplx(0.,0.)      if (isign.ne.0) go to 40      if (kstrt.gt.nx) returnc prepare form factor array      do 30 l = 1, j2blok      joff = kxp2*(l + ks) - 1      do 20 j = 1, kxp2      dkx = dnx*float(j + joff)      at1 = dkx*dkx      at2 = (dkx*ax)**2      do 10 k = 1, ny      dky = dny*float(k - 1)      at3 = dky*dky + at1      at4 = exp(-.5*((dky*ay)**2 + at2))      if (at3.eq.0.) then         ffd(k,j,l) = cmplx(affp,1.)      else         ffd(k,j,l) = cmplx(affp*at4/at3,at4)      endif   10 continue   20 continue   30 continue      return   40 if (isign.gt.0) go to 100c calculate force/charge and sum field energy      wp = 0.0d0      if (kstrt.gt.nx) go to 90      do 80 l = 1, j2blokc mode numbers kx > 0 and 0 < ky < ny      joff = kxp2*(l + ks) - 1      do 60 j = 1, kxp2      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 50 k = 2, ny         k1 = ny2 - k         at1 = real(ffd(k,j,l))*aimag(ffd(k,j,l))         at3 = -at1*real(q(k,j,l))         at2 = dkx*at3         at3 = dny*float(k - 1)*at3         fx(k,j,l) = cmplx(0.,at2)         fx(k1,j,l) = cmplx(0.,-at2)         fy(k,j,l) = cmplx(0.,at3)         fy(k1,j,l) = cmplx(0.,at3)         wp = wp + at1*real(q(k,j,l))**2   50    continue      endifc mode numbers ky = 0, ny      fx(1,j,l) = zero      fx(ny+1,j,l) = zero      fy(1,j,l) = zero      fy(ny+1,j,l) = zero   60 continuec mode number kx = 0      if ((l+ks).eq.0) then         do 70 k = 2, ny         k1 = ny2 - k         fx(k,1,l) = zero         fx(k1,1,l) = zero         fy(k,1,l) = zero         fy(k1,1,l) = zero   70    continue      endif   80 continue   90 continue      we = 2.0*float(nx*ny)*wp      returnc calculate potential and sum field energy  100 if (isign.gt.1) go to 160      wp = 0.0d0      if (kstrt.gt.nx) go to 150      do 140 l = 1, j2blokc mode numbers kx > 0 and 0 < ky < ny      joff = kxp2*(l + ks) - 1      do 120 j = 1, kxp2      if ((j+joff).gt.0) then         do 110 k = 2, ny         k1 = ny2 - k         at2 = real(ffd(k,j,l))         at1 = at2*aimag(ffd(k,j,l))         at3 = at2*real(q(k,j,l))         fx(k,j,l) = cmplx(at3,0.)         fx(k1,j,l) = cmplx(-at3,0.)         wp = wp + at1*real(q(k,j,l))**2  110    continue      endifc mode numbers ky = 0, ny      at1 = real(ffd(1,j,l))*aimag(ffd(1,j,l))      fx(1,j,l) = zero      fx(ny+1,j,l) = zero      wp = wp + at1*real(q(1,j,l))**2  120 continuec mode number kx = 0      if ((l+ks).eq.0) then         do 130 k = 2, ny         k1 = ny2 - k         at1 = real(ffd(k,1,l))*aimag(ffd(k,1,l))         fx(k,1,l) = zero         fx(k1,1,l) = zero         wp = wp + at1*real(q(k,1,l))**2  130    continue      endif  140 continue  150 continue      we = 2.0*float(nx*ny)*wp      returnc calculate smoothing  160 if (kstrt.gt.nx) go to 210      do 200 l = 1, j2blokc mode numbers kx > 0 and 0 < ky < ny      joff = kxp2*(l + ks) - 1      do 180 j = 1, kxp2      if ((j+joff).gt.0) then         do 170 k = 2, ny         k1 = ny2 - k         at1 = aimag(ffd(k,j,l))         at2 = at1*real(q(k,j,l))         fy(k,j,l) = cmplx(at2,0.)         fy(k1,j,l) = cmplx(-at2,0.)  170    continue      endifc mode numbers ky = 0, ny      fy(1,j,l) = zero      fy(ny+1,j,l) = zero  180 continuec mode number kx = 0      if ((l+ks).eq.0) then         do 190 k = 2, ny         k1 = ny2 - k         fy(k,1,l) = zero         fy(k1,1,l) = zero  190    continue      endif  200 continue  210 continue      return      endc-----------------------------------------------------------------------      subroutine PPOISD22(q,fxy,isign,ffd,ax,ay,affp,we,nx,ny,kstrt,ny2d     1,kxp2,j2blok,nyd)c this subroutine solves 2d poisson's equation in fourier space forc force/charge (or convolution of electric field over particle shape)c with dirichelet boundary conditions (zero potential),c for distributed data.c fourier coefficients are constructed so that a real to complex fftc will perform the appropriate sin-cos, or cos-sin transformc for isign = 0,input: isign,ax,ay,affp,nx,ny,kstrt,ny2d,kxp2,j2blok,nydc               output: ffdc for isign /= 0, input: q,ffd,isign,nx,ny,kstrt,ny2d,kxp2,j2blok,nydc                output: fxy,wec approximate flop count is: 11*nx*nyc eqwuation used is:c fx(kx,ky) = -sqrt(-1)*kx*g(kx,ky)*s(kx,ky)*q(kx,ky),c fy(kx,ky) = -sqrt(-1)*ky*g(kx,ky)*s(kx,ky)*q(kx,ky),c where kx = pi*j/nx, ky = pi*k/ny, and j,k = fourier mode numbers,c g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky),c s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2), except forc q(k,j,l) = complex charge density for fourier mode (jj-1,k-1)c fxy(1,k,j,l) = x component of complex force/charge,c fxy(2,k,j,l) = y component of complex force/charge,c all for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c if isign = 0, form factor array is preparedc ffd(k,2*j,l) = finite-size particle shape factor sc ffd(k,2*j-1,l) = potential green's function gc all for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c j2blok = number of data blocksc kxp2 = number of data values per blockc kstrt = starting data block numberc ax/ay = half-width of particle in x/y directionc affp = normalization constant = nx*ny/np, where np=number of particlesc electric field energy is also calculated, usingc we = 2*nx*ny*sum((affp/(kx**2+ky**2))*|q(kx,ky)*s(kx,ky)|**2)c nx/ny = system length in x/y directionc ny2d = first dimension of field arrays, must be >= 2*nyc nyd = first dimension of form factor array, must be >= ny      double precision wp      complex q, fxy, ffd, zero      dimension q(ny2d,kxp2,j2blok), fxy(2,ny2d,kxp2,j2blok)      dimension ffd(nyd,kxp2,j2blok)      ny2 = 2*ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx + nx)      dny = 6.28318530717959/float(ny + ny)      zero = cmplx(0.,0.)      if (isign.ne.0) go to 40      if (kstrt.gt.nx) returnc prepare form factor array      do 30 l = 1, j2blok      joff = kxp2*(l + ks) - 1      do 20 j = 1, kxp2      dkx = dnx*float(j + joff)      at1 = dkx*dkx      at2 = (dkx*ax)**2      do 10 k = 1, ny      dky = dny*float(k - 1)      at3 = dky*dky + at1      at4 = exp(-.5*((dky*ay)**2 + at2))      if (at3.eq.0.) then         ffd(k,j,l) = cmplx(affp,1.)      else         ffd(k,j,l) = cmplx(affp*at4/at3,at4)      endif   10 continue   20 continue   30 continue      returnc calculate force/charge and sum field energy   40 wp = 0.0d0      if (kstrt.gt.nx) go to 90      do 80 l = 1, j2blokc mode numbers kx > 0 and 0 < ky < ny      joff = kxp2*(l + ks) - 1      do 60 j = 1, kxp2      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 50 k = 2, ny         k1 = ny2 - k         at1 = real(ffd(k,j,l))*aimag(ffd(k,j,l))         at3 = -at1*real(q(k,j,l))         at2 = dkx*at3         at3 = dny*float(k - 1)*at3         fxy(1,k,j,l) = cmplx(0.,at2)         fxy(2,k,j,l) = cmplx(0.,at3)         fxy(1,k1,j,l) = cmplx(0.,-at2)         fxy(2,k1,j,l) = cmplx(0.,at3)         wp = wp + at1*real(q(k,j,l))**2   50    continue      endifc mode numbers ky = 0, ny      fxy(1,1,j,l) = zero      fxy(2,1,j,l) = zero      fxy(1,ny+1,j,l) = zero      fxy(2,ny+1,j,l) = zero   60 continuec mode number kx = 0      if ((l+ks).eq.0) then         do 70 k = 2, ny         k1 = ny2 - k         fxy(1,k,1,l) = zero         fxy(2,k,1,l) = zero         fxy(1,k1,1,l) = zero         fxy(2,k1,1,l) = zero   70    continue      endif   80 continue   90 continue      we = 2.0*float(nx*ny)*wp      return      endc-----------------------------------------------------------------------      subroutine PPOISDX23(q,fxy,isign,ffd,ax,ay,affp,we,nx,ny,kstrt,ny2     1d,kxp2,j2blok,nyd)c this subroutine solves 2d poisson's equation in fourier space forc force/charge (or convolution of electric field over particle shape)c with dirichelet boundary conditions (zero potential),c for distributed data.  Zeros out z componentc fourier coefficients are constructed so that a real to complex fftc will perform the appropriate sin-cos, or cos-sin transformc for isign = 0,input: isign,ax,ay,affp,nx,ny,kstrt,ny2d,kxp2,j2blok,nydc               output: ffdc for isign /= 0, input: q,ffd,isign,nx,ny,kstrt,ny2d,kxp2,j2blok,nydc                output: fxy,wec approximate flop count is: 11*nx*nyc eqwuation used is:c fx(kx,ky) = -sqrt(-1)*kx*g(kx,ky)*s(kx,ky)*q(kx,ky),c fy(kx,ky) = -sqrt(-1)*ky*g(kx,ky)*s(kx,ky)*q(kx,ky),c fz(kx,ky) = zero,c where kx = pi*j/nx, ky = pi*k/ny, and j,k = fourier mode numbers,c g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky),c s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2), except forc q(k,j,l) = complex charge density for fourier mode (jj-1,k-1)c fxy(1,k,j,l) = x component of complex force/charge,c fxy(2,k,j,l) = y component of complex force/charge,c fxy(3,k,j,l) = zero,c all for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c if isign = 0, form factor array is preparedc ffd(k,2*j,l) = finite-size particle shape factor sc ffd(k,2*j-1,l) = potential green's function gc all for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c j2blok = number of data blocksc kxp2 = number of data values per blockc kstrt = starting data block numberc ax/ay = half-width of particle in x/y directionc affp = normalization constant = nx*ny/np, where np=number of particlesc electric field energy is also calculated, usingc we = 2*nx*ny*sum((affp/(kx**2+ky**2))*|q(kx,ky)*s(kx,ky)|**2)c nx/ny = system length in x/y directionc ny2d = first dimension of field arrays, must be >= 2*nyc nyd = first dimension of form factor array, must be >= ny      double precision wp      complex q, fxy, ffd, zero      dimension q(ny2d,kxp2,j2blok), fxy(3,ny2d,kxp2,j2blok)      dimension ffd(nyd,kxp2,j2blok)      ny2 = 2*ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx + nx)      dny = 6.28318530717959/float(ny + ny)      zero = cmplx(0.,0.)      if (isign.ne.0) go to 40      if (kstrt.gt.nx) returnc prepare form factor array      do 30 l = 1, j2blok      joff = kxp2*(l + ks) - 1      do 20 j = 1, kxp2      dkx = dnx*float(j + joff)      at1 = dkx*dkx      at2 = (dkx*ax)**2      do 10 k = 1, ny      dky = dny*float(k - 1)      at3 = dky*dky + at1      at4 = exp(-.5*((dky*ay)**2 + at2))      if (at3.eq.0.) then         ffd(k,j,l) = cmplx(affp,1.)      else         ffd(k,j,l) = cmplx(affp*at4/at3,at4)      endif   10 continue   20 continue   30 continue      returnc calculate force/charge and sum field energy   40 wp = 0.0d0      if (kstrt.gt.nx) go to 90      do 80 l = 1, j2blokc mode numbers kx > 0 and 0 < ky < ny      joff = kxp2*(l + ks) - 1      do 60 j = 1, kxp2      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 50 k = 2, ny         k1 = ny2 - k         at1 = real(ffd(k,j,l))*aimag(ffd(k,j,l))         at3 = -at1*real(q(k,j,l))         at2 = dkx*at3         at3 = dny*float(k - 1)*at3         fxy(1,k,j,l) = cmplx(0.,at2)         fxy(2,k,j,l) = cmplx(0.,at3)         fxy(3,k,j,l) = zero         fxy(1,k1,j,l) = cmplx(0.,-at2)         fxy(2,k1,j,l) = cmplx(0.,at3)         fxy(3,k1,j,l) = zero         wp = wp + at1*real(q(k,j,l))**2   50    continue      endifc mode numbers ky = 0, ny      fxy(1,1,j,l) = zero      fxy(2,1,j,l) = zero      fxy(3,1,j,l) = zero      fxy(1,ny+1,j,l) = zero      fxy(2,ny+1,j,l) = zero      fxy(3,ny+1,j,l) = zero   60 continuec mode number kx = 0      if ((l+ks).eq.0) then         do 70 k = 2, ny         k1 = ny2 - k         fxy(1,k,1,l) = zero         fxy(2,k,1,l) = zero         fxy(3,k,1,l) = zero         fxy(1,k1,1,l) = zero         fxy(2,k1,1,l) = zero         fxy(3,k1,1,l) = zero   70    continue      endif   80 continue   90 continue      we = 2.0*float(nx*ny)*wp      return      endc-----------------------------------------------------------------------      subroutine PPOISD23(q,fxy,isign,ffd,ax,ay,affp,we,nx,ny,kstrt,nyv,     1kxp2,j2blok,nyd)c this subroutine solves 2d poisson's equation in fourier space forc force/charge (or convolution of electric field over particle shape)c with dirichelet boundary conditions (zero potential),c for distributed data.  Zeros out z componentc fourier coefficients are constructed so that a real to complex fftc will perform the appropriate sin-cos, or cos-sin transformc for isign = 0,input: isign,ax,ay,affp,nx,ny,kstrt,ny2d,kxp2,j2blok,nydc               output: ffdc for isign /= 0, input: q,ffd,isign,nx,ny,kstrt,ny2d,kxp2,j2blok,nydc                output: fxy,wec approximate flop count is: 11*nx*nyc eqwuation used is:c fx(kx,ky) = -sqrt(-1)*kx*g(kx,ky)*s(kx,ky)*q(kx,ky),c fy(kx,ky) = -sqrt(-1)*ky*g(kx,ky)*s(kx,ky)*q(kx,ky),c fz(kx,ky) = zero,c where kx = pi*j/nx, ky = pi*k/ny, and j,k = fourier mode numbers,c g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky),c s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2), except forc q(k,j,l) = complex charge density for fourier mode (jj-1,k-1)c fxy(1,k,j,l) = x component of complex force/charge,c fxy(2,k,j,l) = y component of complex force/charge,c fxy(3,k,j,l) = zero,c all for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c if isign = 0, form factor array is preparedc ffd(k,2*j,l) = finite-size particle shape factor sc ffd(k,2*j-1,l) = potential green's function gc all for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c j2blok = number of data blocksc kxp2 = number of data values per blockc kstrt = starting data block numberc ax/ay = half-width of particle in x/y directionc affp = normalization constant = nx*ny/np, where np=number of particlesc electric field energy is also calculated, usingc we = 2*nx*ny*sum((affp/(kx**2+ky**2))*|q(kx,ky)*s(kx,ky)|**2)c nx/ny = system length in x/y directionc nyv = first dimension of field arrays, must be >= nyc nyd = first dimension of form factor array, must be >= ny      double precision wp      complex ffd      dimension q(nyv,kxp2,j2blok), fxy(3,nyv,kxp2,j2blok)      dimension ffd(nyd,kxp2,j2blok)      ks = kstrt - 2      dnx = 6.28318530717959/float(nx + nx)      dny = 6.28318530717959/float(ny + ny)      if (isign.ne.0) go to 40      if (kstrt.gt.nx) returnc prepare form factor array      do 30 l = 1, j2blok      joff = kxp2*(l + ks) - 1      do 20 j = 1, kxp2      dkx = dnx*float(j + joff)      at1 = dkx*dkx      at2 = (dkx*ax)**2      do 10 k = 1, ny      dky = dny*float(k - 1)      at3 = dky*dky + at1      at4 = exp(-.5*((dky*ay)**2 + at2))      if (at3.eq.0.) then         ffd(k,j,l) = cmplx(affp,1.)      else         ffd(k,j,l) = cmplx(affp*at4/at3,at4)      endif   10 continue   20 continue   30 continue      returnc calculate force/charge and sum field energy   40 wp = 0.0d0      if (kstrt.gt.nx) go to 90      do 80 l = 1, j2blokc mode numbers kx > 0 and 0 < ky < ny      joff = kxp2*(l + ks) - 1      do 60 j = 1, kxp2      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 50 k = 2, ny         at1 = real(ffd(k,j,l))*aimag(ffd(k,j,l))         at3 = -at1*real(q(k,j,l))         at2 = dkx*at3         at3 = dny*float(k - 1)*at3         fxy(1,k,j,l) = at2         fxy(2,k,j,l) = at3         fxy(3,k,j,l) = 0.         wp = wp + at1*q(k,j,l)**2   50    continue      endifc mode numbers ky = 0, ny      fxy(1,1,j,l) = 0.      fxy(2,1,j,l) = 0.      fxy(3,1,j,l) = 0.   60 continuec mode number kx = 0      if ((l+ks).eq.0) then         do 70 k = 2, ny         fxy(1,k,1,l) = 0.         fxy(2,k,1,l) = 0.         fxy(3,k,1,l) = 0.   70    continue      endif   80 continue   90 continue      we = 2.0*float(nx*ny)*wp      return      endc-----------------------------------------------------------------------      subroutine PCUPERPDX2(cu,nx,ny,kstrt,ny2d,kxp2,j2blok)c this subroutine calculates the transverse current in fourier spacec with dirichlet boundary conditions (zero potential).c input: all, output: cuc approximate flop count is: 13*nxc*nycc and nxc*nyc dividesc where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc the transverse current is calculated using the equation:c cux(kx,ky) = cux(kx,ky)-kx*(kx*cux(kx,ky)+ky*cuy(kx,ky))/(kx*kx+ky*ky)c cuy(kx,ky) = cuy(kx,ky)-ky*(kx*cux(kx,ky)+ky*cuy(kx,ky))/(kx*kx+ky*ky)c where kx = pi*j/nx, ky = pi*k/ny, and j,k = fourier mode numbers,c cu(i,k,j,l) = i-th component of complex current density andc for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c nx/ny = system length in x/y directionc kstrt = starting data block numberc ny2d = first dimension of field arrays, must be >= 2*nyc j2blok = number of data blocksc kxp2 = number of data values per block      complex cu, zero      dimension cu(3,ny2d,kxp2,j2blok)      ny2 = 2*ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx + nx)      dny = 6.28318530717959/float(ny + ny)      zero = cmplx(0.,0.)c calculate transverse part of current      if (kstrt.gt.nx) return      do 40 l = 1, j2blokc mode numbers 0 < kx < nx and 0 < ky < ny      joff = kxp2*(l + ks) - 1      do 20 j = 1, kxp2      dkx = dnx*float(j + joff)      dkx2 = dkx*dkx      if ((j+joff).gt.0) then         do 10 k = 2, ny         k1 = ny2 - k         dky = dny*float(k - 1)         at1 = 1./(dky*dky + dkx2)         at2 = at1*(dkx*aimag(cu(1,k,j,l)) + dky*aimag(cu(2,k,j,l)))         at3 = aimag(cu(1,k,j,l)) - dkx*at2         at4 = aimag(cu(2,k,j,l)) - dky*at2         cu(1,k,j,l) = cmplx(0.,at3)         cu(2,k,j,l) = cmplx(0.,at4)         cu(1,k1,j,l) = cmplx(0.,-at3)         cu(2,k1,j,l) = cmplx(0.,at4)   10    continuec mode numbers ky = 0, ny         k1 = ny + 1         cu(1,1,j,l) = zero         cu(1,k1,j,l) = zero         cu(2,k1,j,l) = zero      endif   20 continuec mode numbers kx = 0, nx      if ((l+ks).eq.0) then         do 30 k = 2, ny         k1 = ny2 - k         cu(2,k,1,l) = zero         cu(1,k1,1,l) = zero         cu(2,k1,1,l) = zero   30    continue         k1 = ny + 1         cu(1,1,1,l) = zero         cu(2,1,1,l) = zero         cu(1,k1,1,l) = zero         cu(2,k1,1,l) = zero      endif   40 continue      return      endc-----------------------------------------------------------------------      subroutine PCUPERPD2(cu,nx,ny,kstrt,nyv,kxp2,j2blok)c this subroutine calculates the transverse current in fourier spacec with dirichlet boundary conditions (zero potential).c input: all, output: cuc approximate flop count is: 13*nxc*nycc and nxc*nyc dividesc where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc the transverse current is calculated using the equation:c cux(kx,ky) = cux(kx,ky)-kx*(kx*cux(kx,ky)+ky*cuy(kx,ky))/(kx*kx+ky*ky)c cuy(kx,ky) = cuy(kx,ky)-ky*(kx*cux(kx,ky)+ky*cuy(kx,ky))/(kx*kx+ky*ky)c where kx = pi*j/nx, ky = pi*k/ny, and j,k = fourier mode numbers,c cu(i,k,j,l) = i-th component of complex current density andc for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c nx/ny = system length in x/y directionc kstrt = starting data block numberc nyv = first dimension of field arrays, must be >= nyc j2blok = number of data blocksc kxp2 = number of data values per block      dimension cu(3,nyv,kxp2,j2blok)      ks = kstrt - 2      dnx = 6.28318530717959/float(nx + nx)      dny = 6.28318530717959/float(ny + ny)c calculate transverse part of current      if (kstrt.gt.nx) return      do 40 l = 1, j2blokc mode numbers 0 < kx < nx and 0 < ky < ny      joff = kxp2*(l + ks) - 1      do 20 j = 1, kxp2      dkx = dnx*float(j + joff)      dkx2 = dkx*dkx      if ((j+joff).gt.0) then         do 10 k = 2, ny         dky = dny*float(k - 1)         at1 = 1./(dky*dky + dkx2)         at2 = at1*(dkx*cu(1,k,j,l) + dky*cu(2,k,j,l))         at3 = cu(1,k,j,l) - dkx*at2         at4 = cu(2,k,j,l) - dky*at2         cu(1,k,j,l) = at3         cu(2,k,j,l) = at4   10    continuec mode numbers ky = 0, ny         cu(1,1,j,l) = 0.      endif   20 continuec mode numbers kx = 0, nx      if ((l+ks).eq.0) then         do 30 k = 2, ny         cu(2,k,1,l) = 0.   30    continue         cu(1,1,1,l) = 0.         cu(2,1,1,l) = 0.      endif   40 continue      return      endc-----------------------------------------------------------------------      subroutine PCUPERPD22(cu,nx,ny,kstrt,ny2d,kxp2,j2blok)c this subroutine calculates the transverse current in fourier spacec with dirichlet boundary conditions (zero potential).c input: all, output: cuc approximate flop count is: 13*nxc*nycc and nxc*nyc dividesc where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc the transverse current is calculated using the equation:c cux(kx,ky) = cux(kx,ky)-kx*(kx*cux(kx,ky)+ky*cuy(kx,ky))/(kx*kx+ky*ky)c cuy(kx,ky) = cuy(kx,ky)-ky*(kx*cux(kx,ky)+ky*cuy(kx,ky))/(kx*kx+ky*ky)c where kx = pi*j/nx, ky = pi*k/ny, and j,k = fourier mode numbers,c cu(i,k,j,l) = i-th component of complex current density andc for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c nx/ny = system length in x/y directionc kstrt = starting data block numberc ny2d = first dimension of field arrays, must be >= 2*nyc j2blok = number of data blocksc kxp2 = number of data values per block      complex cu, zero      dimension cu(2,ny2d,kxp2,j2blok)      ny2 = 2*ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx + nx)      dny = 6.28318530717959/float(ny + ny)      zero = cmplx(0.,0.)c calculate transverse part of current      if (kstrt.gt.nx) return      do 40 l = 1, j2blokc mode numbers 0 < kx < nx and 0 < ky < ny      joff = kxp2*(l + ks) - 1      do 20 j = 1, kxp2      dkx = dnx*float(j + joff)      dkx2 = dkx*dkx      if ((j+joff).gt.0) then         do 10 k = 2, ny         k1 = ny2 - k         dky = dny*float(k - 1)         at1 = 1./(dky*dky + dkx2)         at2 = at1*(dkx*aimag(cu(1,k,j,l)) + dky*aimag(cu(2,k,j,l)))         at3 = aimag(cu(1,k,j,l)) - dkx*at2         at4 = aimag(cu(2,k,j,l)) - dky*at2         cu(1,k,j,l) = cmplx(0.,at3)         cu(2,k,j,l) = cmplx(0.,at4)         cu(1,k1,j,l) = cmplx(0.,-at3)         cu(2,k1,j,l) = cmplx(0.,at4)   10    continuec mode numbers ky = 0, ny         k1 = ny + 1         cu(1,1,j,l) = zero         cu(1,k1,j,l) = zero         cu(2,k1,j,l) = zero      endif   20 continuec mode numbers kx = 0, nx      if ((l+ks).eq.0) then         do 30 k = 2, ny         k1 = ny2 - k         cu(2,k,1,l) = zero         cu(1,k1,1,l) = zero         cu(2,k1,1,l) = zero   30    continue         k1 = ny + 1         cu(1,1,1,l) = zero         cu(2,1,1,l) = zero         cu(1,k1,1,l) = zero         cu(2,k1,1,l) = zero      endif   40 continue      return      endc-----------------------------------------------------------------------      subroutine PBPOISDX23(cu,bxy,isign,ffd,ax,ay,affp,ci,wm,nx,ny,kstr     1t,ny2d,kxp2,j2blok,nyd)c this subroutine solves 2d poisson's equation in fourier space forc magnetic field (or convolution of magnetic field over particle shape)c or for vector potential, or provides a smoothing function,c with dirichlet boundary conditions (zero potential),c for distributed data.c fourier coefficients are constructed so that a real to complex fftc will perform the appropriate sin-cos, or cos-sin transformc for isign = 0, input: isign,ax,ay,affp,nx,ny,kstrt,ny2d,kxp,j2blok,nydc output: ffdc for isign = -1, input:cu,ffd,isign,ci,nx,ny,kstrt,ny2d,kxp2,j2blok,nydc output: bxy,wmc approximate flop count is: 21*nxc*nyc + 11*(nxc + nyc)c for isign = 1, input: cu,ffd,isign,ci,nx,ny,kstrt,ny2d,kxp2,j2blok,nydc output: bxy,wmc approximate flop count is: 15*nxc*nyc + 8*(nxc + nyc)c for isign = 2, input: cu,ffd,isign,nx,ny,kstrt,ny2d,kxp2,j2blok,nydc output: bxyc approximate flop count is: 8*nxc*nycc where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc if isign = 0, form factor array is preparedc if isign < 0, magnetic field is calculated using the equations:c bx(kx,ky) = ci*ci*sqrt(-1)*g(kx,ky)*ky*cuz(kx,ky)*s(kx,ky),c by(kx,ky) = -ci*ci*sqrt(-1)*g(kx,ky)*kx*cuz(kx,ky)*s(kx,ky),c bz(kx,ky) = ci*ci*sqrt(-1)*g(kx,ky)*(kx*cuy(kx,ky)-ky*cux(kx,ky))*c             s(kx,ky),c where kx = pi*j/nx, ky = pi*k/ny, and j,k = fourier mode numbers,c g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky),c s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2)c if isign = 1, vector potential is calculated using the equation:c bx(kx,ky) = ci*ci*g(kx,ky)*cux(kx,ky)c by(kx,ky) = ci*ci*g(kx,ky)*cuy(kx,ky)c bz(kx,ky) = ci*ci*g(kx,ky)*cuz(kx,ky)c if isign = 2, smoothing is calculated using the equation:c bx(kx,ky) = cux(kx,ky)*s(kx,ky)c by(kx,ky) = cuy(kx,ky)*s(kx,ky)c bz(kx,ky) = cuz(kx,ky)*s(kx,ky)c cu(i,k,j,l) = i-th component of complex current density andc bxy(i,k,j,l) = i-th component of complex magnetic field,c for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c j2blok = number of data blocksc kxp2 = number of data values per blockc kstrt = starting data block numberc aimag(ffd(k,j,l)) = finite-size particle shape factor sc real(ffd(k,j,l)) = potential green's function gc for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c ax/ay = half-width of particle in x/y directionc affp = normalization constant = nx*ny/np, where np=number of particlesc ci = reciprical of velocity of lightc magnetic field energy is also calculated, usingc wm = nx*ny*nz*sum((affp/(kx**2+ky**2+kz**2))*ci*cic    |cu(kx,ky,kz)*s(kx,ky,kz)|**2)c this expression is valid only if the current is divergence-freec nx/ny = system length in x/y directionc ny2d = first dimension of field arrays, must be >= 2*nyc nyd = first dimension of form factor array, must be >= ny      double precision wp      complex cu, bxy, ffd, zero      dimension cu(3,ny2d,kxp2,j2blok), bxy(3,ny2d,kxp2,j2blok)      dimension ffd(nyd,kxp2,j2blok)      ny2 = 2*ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx + nx)      dny = 6.28318530717959/float(ny + ny)      zero = cmplx(0.,0.)      ci2 = ci*ci      if (isign.ne.0) go to 40      if (kstrt.gt.nx) returnc prepare form factor array      do 30 l = 1, j2blok      joff = kxp2*(l + ks) - 1      do 20 j = 1, kxp2      dkx = dnx*float(j + joff)      at1 = dkx*dkx      at2 = (dkx*ax)**2      do 10 k = 1, ny      dky = dny*float(k - 1)      at3 = dky*dky + at1      at4 = exp(-.5*((dky*ay)**2 + at2))      if (at3.eq.0.) then         ffd(k,j,l) = cmplx(affp,1.)      else         ffd(k,j,l) = cmplx(affp*at4/at3,at4)      endif   10 continue   20 continue   30 continue      return   40 if (isign.gt.0) go to 100c calculate magnetic field and sum field energy      wp = 0.0d0      if (kstrt.gt.nx) go to 90      do 80 l = 1, j2blokc mode numbers 0 < kx < nx and 0 < ky < ny      joff = kxp2*(l + ks) - 1      do 60 j = 1, kxp2      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 50 k = 2, ny         k1 = ny2 - k         dky = dny*float(k - 1)         at1 = ci2*real(ffd(k,j,l))*aimag(ffd(k,j,l))         at2 = dky*at1         at3 = dkx*at1         bxy(1,k,j,l) = cmplx(0.,at2*real(cu(3,k,j,l)))         bxy(2,k,j,l) = cmplx(0.,-at3*real(cu(3,k,j,l)))         bxy(3,k,j,l) = cmplx(at2*aimag(cu(1,k,j,l))-at3*aimag(cu(2,k,j,     1l)),0.)         bxy(1,k1,j,l) = bxy(1,k,j,l)         bxy(2,k1,j,l) = -bxy(2,k,j,l)         bxy(3,k1,j,l) = bxy(3,k,j,l)         wp = wp + 2.0*at1*(aimag(cu(1,k,j,l))**2 + aimag(cu(2,k,j,l))**     12 + real(cu(3,k,j,l))**2)   50    continuec mode numbers ky = 0, ny         k1 = ny + 1         at1 = ci2*real(ffd(1,j,l))*aimag(ffd(1,j,l))         at2 = dkx*at1         bxy(1,1,j,l) = zero         bxy(2,1,j,l) = zero         bxy(3,1,j,l) = cmplx(-at2*aimag(cu(2,1,j,l)),0.)         bxy(1,k1,j,l) = zero         bxy(2,k1,j,l) = zero         bxy(3,k1,j,l) = zero         wp = wp + at1*(aimag(cu(2,1,j,l))**2 + real(cu(3,1,j,l))**2)      endif   60 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 70 k = 2, ny         k1 = ny2 - k         dky = dny*float(k - 1)         at1 = ci2*real(ffd(k,1,l))*aimag(ffd(k,1,l))         at2 = dky*at1         bxy(1,k,1,l) = zero         bxy(2,k,1,l) = zero         bxy(3,k,1,l) = cmplx(at2*aimag(cu(1,k,1,l)),0.)         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero         bxy(3,k1,1,l) = zero         wp = wp + at1*(aimag(cu(1,k,1,l))**2 + real(cu(3,k,1,l))**2)   70    continue         k1 = ny + 1         bxy(1,1,1,l) = zero         bxy(2,1,1,l) = zero         bxy(3,1,1,l) = zero         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero         bxy(3,k1,1,l) = zero      endif   80 continue   90 continue      wm = float(nx*ny)*wp      returnc calculate vector potential and sum field energy  100 if (isign.gt.1) go to 160      wp = 0.0d0      if (kstrt.gt.nx) go to 150      do 140 l = 1, j2blokc mode numbers 0 < kx < nx and 0 < ky < ny      joff = kxp2*(l + ks) - 1      do 120 j = 1, kxp2      if ((j+joff).gt.0) then         do 110 k = 2, ny         k1 = ny2 - k         at2 = ci2*real(ffd(k,j,l))         at1 = at2*aimag(ffd(k,j,l))         bxy(1,k,j,l) = cmplx(0.,at2*aimag(cu(1,k,j,l)))         bxy(2,k,j,l) = cmplx(0.,at2*aimag(cu(2,k,j,l)))         bxy(3,k,j,l) = cmplx(at2*real(cu(3,k,j,l)),0.)         bxy(1,k1,j,l) = -bxy(1,k,j,l)         bxy(2,k1,j,l) = bxy(2,k,j,l)         bxy(3,k1,j,l) = -bxy(3,k,j,l)         wp = wp + 2.0*at1*(aimag(cu(1,k,j,l))**2 + aimag(cu(2,k,j,l))**     12 + real(cu(3,k,j,l))**2)  110    continuec mode numbers ky = 0, ny         k1 = ny + 1         at2 = ci2*real(ffd(1,j,l))         at1 = at2*aimag(ffd(1,j,l))         bxy(1,1,j,l) = zero         bxy(2,1,j,l) = cmplx(0.,at2*aimag(cu(2,1,j,l)))         bxy(3,1,j,l) = zero         bxy(1,k1,j,l) = zero         bxy(2,k1,j,l) = zero         bxy(3,k1,j,l) = zero         wp = wp + at1*(aimag(cu(2,1,j,l))**2 + real(cu(3,1,j,l))**2)      endif  120 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 130 k = 2, ny         k1 = ny2 - k         at2 = ci2*real(ffd(k,1,l))         at1 = at2*aimag(ffd(k,1,l))         bxy(1,k,1,l) = cmplx(0.,at2*aimag(cu(1,k,1,l)))         bxy(2,k,1,l) = zero         bxy(3,k,1,l) = zero         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero         bxy(3,k1,1,l) = zero         wp = wp + at1*(aimag(cu(1,k,1,l))**2 + real(cu(3,k,1,l))**2)  130    continue         k1 = ny + 1         bxy(1,1,1,l) = zero         bxy(2,1,1,l) = zero         bxy(3,1,1,l) = zero         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero         bxy(3,k1,1,l) = zero      endif  140 continue  150 continue      wm = float(nx*ny)*wp      returnc calculate smoothing  160 if (kstrt.gt.nx) go to 210      do 200 l = 1, j2blokc mode numbers 0 < kx < nx and 0 < ky < ny      joff = kxp2*(l + ks) - 1      do 180 j = 1, kxp2      if ((j+joff).gt.0) then         do 170 k = 2, ny         k1 = ny2 - k         at1 = aimag(ffd(k,j,l))         bxy(1,k,j,l) = cmplx(0.,at1*aimag(cu(1,k,j,l)))         bxy(2,k,j,l) = cmplx(0.,at1*aimag(cu(2,k,j,l)))         bxy(3,k,j,l) = cmplx(at1*real(cu(3,k,j,l)),0.)         bxy(1,k1,j,l) = -bxy(1,k,j,l)         bxy(2,k1,j,l) = bxy(2,k,j,l)         bxy(3,k1,j,l) = -bxy(3,k,j,l)  170    continuec mode numbers ky = 0, ny         k1 = ny + 1         at1 = aimag(ffd(1,j,l))         bxy(1,1,j,l) = zero         bxy(2,1,j,l) = cmplx(0.,at1*aimag(cu(2,1,j,l)))         bxy(3,1,j,l) = zero         bxy(1,k1,j,l) = zero         bxy(2,k1,j,l) = zero         bxy(3,k1,j,l) = zero      endif  180 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 190 k = 2, ny         k1 = ny2 - k         at1 = aimag(ffd(k,1,l))         bxy(1,k,1,l) = cmplx(0.,at1*aimag(cu(1,k,1,l)))         bxy(2,k,1,l) = zero         bxy(3,k,1,l) = zero         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero         bxy(3,k1,1,l) = zero  190    continue         k1 = ny + 1         bxy(1,1,1,l) = zero         bxy(2,1,1,l) = zero         bxy(3,1,1,l) = zero         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero         bxy(3,k1,1,l) = zero      endif  200 continue  210 continue      return      endc-----------------------------------------------------------------------      subroutine PBPOISD23(cu,bxy,isign,ffd,ax,ay,affp,ci,wm,nx,ny,kstrt     1,nyv,kxp2,j2blok,nyd)c this subroutine solves 2d poisson's equation in fourier space forc magnetic field (or convolution of magnetic field over particle shape)c or for vector potential, or provides a smoothing function,c with dirichlet boundary conditions (zero potential),c for distributed data.c fourier coefficients are constructed so that a real to complex fftc will perform the appropriate sin-cos, or cos-sin transformc for isign = 0, input: isign,ax,ay,affp,nx,ny,kstrt,ny2d,kxp,j2blok,nydc output: ffdc for isign = -1, input:cu,ffd,isign,ci,nx,ny,kstrt,ny2d,kxp2,j2blok,nydc output: bxy,wmc approximate flop count is: 21*nxc*nyc + 11*(nxc + nyc)c for isign = 1, input: cu,ffd,isign,ci,nx,ny,kstrt,ny2d,kxp2,j2blok,nydc output: bxy,wmc approximate flop count is: 15*nxc*nyc + 8*(nxc + nyc)c for isign = 2, input: cu,ffd,isign,nx,ny,kstrt,ny2d,kxp2,j2blok,nydc output: bxyc approximate flop count is: 8*nxc*nycc where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc if isign = 0, form factor array is preparedc if isign < 0, magnetic field is calculated using the equations:c bx(kx,ky) = ci*ci*sqrt(-1)*g(kx,ky)*ky*cuz(kx,ky)*s(kx,ky),c by(kx,ky) = -ci*ci*sqrt(-1)*g(kx,ky)*kx*cuz(kx,ky)*s(kx,ky),c bz(kx,ky) = ci*ci*sqrt(-1)*g(kx,ky)*(kx*cuy(kx,ky)-ky*cux(kx,ky))*c             s(kx,ky),c where kx = pi*j/nx, ky = pi*k/ny, and j,k = fourier mode numbers,c g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky),c s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2)c if isign = 1, vector potential is calculated using the equation:c bx(kx,ky) = ci*ci*g(kx,ky)*cux(kx,ky)c by(kx,ky) = ci*ci*g(kx,ky)*cuy(kx,ky)c bz(kx,ky) = ci*ci*g(kx,ky)*cuz(kx,ky)c if isign = 2, smoothing is calculated using the equation:c bx(kx,ky) = cux(kx,ky)*s(kx,ky)c by(kx,ky) = cuy(kx,ky)*s(kx,ky)c bz(kx,ky) = cuz(kx,ky)*s(kx,ky)c cu(i,k,j,l) = i-th component of complex current density andc bxy(i,k,j,l) = i-th component of complex magnetic field,c for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c j2blok = number of data blocksc kxp2 = number of data values per blockc kstrt = starting data block numberc aimag(ffd(k,j,l)) = finite-size particle shape factor sc real(ffd(k,j,l)) = potential green's function gc for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c ax/ay = half-width of particle in x/y directionc affp = normalization constant = nx*ny/np, where np=number of particlesc ci = reciprical of velocity of lightc magnetic field energy is also calculated, usingc wm = nx*ny*nz*sum((affp/(kx**2+ky**2+kz**2))*ci*cic    |cu(kx,ky,kz)*s(kx,ky,kz)|**2)c this expression is valid only if the current is divergence-freec nx/ny = system length in x/y directionc nyv = first dimension of field arrays, must be >= nyc nyd = first dimension of form factor array, must be >= ny      double precision wp      complex ffd      dimension cu(3,nyv,kxp2,j2blok), bxy(3,nyv,kxp2,j2blok)      dimension ffd(nyd,kxp2,j2blok)      ks = kstrt - 2      dnx = 6.28318530717959/float(nx + nx)      dny = 6.28318530717959/float(ny + ny)      ci2 = ci*ci      if (isign.ne.0) go to 40      if (kstrt.gt.nx) returnc prepare form factor array      do 30 l = 1, j2blok      joff = kxp2*(l + ks) - 1      do 20 j = 1, kxp2      dkx = dnx*float(j + joff)      at1 = dkx*dkx      at2 = (dkx*ax)**2      do 10 k = 1, ny      dky = dny*float(k - 1)      at3 = dky*dky + at1      at4 = exp(-.5*((dky*ay)**2 + at2))      if (at3.eq.0.) then         ffd(k,j,l) = cmplx(affp,1.)      else         ffd(k,j,l) = cmplx(affp*at4/at3,at4)      endif   10 continue   20 continue   30 continue      return   40 if (isign.gt.0) go to 100c calculate magnetic field and sum field energy      wp = 0.0d0      if (kstrt.gt.nx) go to 90      do 80 l = 1, j2blokc mode numbers 0 < kx < nx and 0 < ky < ny      joff = kxp2*(l + ks) - 1      do 60 j = 1, kxp2      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 50 k = 2, ny         dky = dny*float(k - 1)         at1 = ci2*real(ffd(k,j,l))*aimag(ffd(k,j,l))         at2 = dky*at1         at3 = dkx*at1         bxy(1,k,j,l) = at2*cu(3,k,j,l)         bxy(2,k,j,l) = -at3*cu(3,k,j,l)         bxy(3,k,j,l) = at2*cu(1,k,j,l) - at3*cu(2,k,j,l)         wp = wp + 2.0*at1*(cu(1,k,j,l)**2 + cu(2,k,j,l)**2 + cu(3,k,j,l     1)**2)   50    continuec mode numbers ky = 0, ny         at1 = ci2*real(ffd(1,j,l))*aimag(ffd(1,j,l))         at2 = dkx*at1         bxy(1,1,j,l) = 0.         bxy(2,1,j,l) = 0.         bxy(3,1,j,l) = -at2*cu(2,1,j,l)         wp = wp + at1*(cu(2,1,j,l)**2 + cu(3,1,j,l)**2)      endif   60 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 70 k = 2, ny         dky = dny*float(k - 1)         at1 = ci2*real(ffd(k,1,l))*aimag(ffd(k,1,l))         at2 = dky*at1         bxy(1,k,1,l) = 0.         bxy(2,k,1,l) = 0.         bxy(3,k,1,l) = at2*cu(1,k,1,l)         wp = wp + at1*(cu(1,k,1,l)**2 + cu(3,k,1,l)**2)   70    continue         bxy(1,1,1,l) = 0.         bxy(2,1,1,l) = 0.         bxy(3,1,1,l) = 0.      endif   80 continue   90 continue      wm = float(nx*ny)*wp      returnc calculate vector potential and sum field energy  100 if (isign.gt.1) go to 160      wp = 0.0d0      if (kstrt.gt.nx) go to 150      do 140 l = 1, j2blokc mode numbers 0 < kx < nx and 0 < ky < ny      joff = kxp2*(l + ks) - 1      do 120 j = 1, kxp2      if ((j+joff).gt.0) then         do 110 k = 2, ny         at2 = ci2*real(ffd(k,j,l))         at1 = at2*aimag(ffd(k,j,l))         bxy(1,k,j,l) = at2*cu(1,k,j,l)         bxy(2,k,j,l) = at2*cu(2,k,j,l)         bxy(3,k,j,l) = at2*cu(3,k,j,l)         wp = wp + 2.0*at1*(cu(1,k,j,l)**2 + cu(2,k,j,l)**2 + cu(3,k,j,l     1)**2)  110    continuec mode numbers ky = 0, ny         at2 = ci2*real(ffd(1,j,l))         at1 = at2*aimag(ffd(1,j,l))         bxy(1,1,j,l) = 0.         bxy(2,1,j,l) = at2*cu(2,1,j,l)         bxy(3,1,j,l) = 0.         wp = wp + at1*(cu(2,1,j,l)**2 + cu(3,1,j,l)**2)      endif  120 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 130 k = 2, ny         at2 = ci2*real(ffd(k,1,l))         at1 = at2*aimag(ffd(k,1,l))         bxy(1,k,1,l) = at2*cu(1,k,1,l)         bxy(2,k,1,l) = 0.         bxy(3,k,1,l) = 0.         wp = wp + at1*(cu(1,k,1,l)**2 + cu(3,k,1,l)**2)  130    continue         bxy(1,1,1,l) = 0.         bxy(2,1,1,l) = 0.         bxy(3,1,1,l) = 0.      endif  140 continue  150 continue      wm = float(nx*ny)*wp      returnc calculate smoothing  160 if (kstrt.gt.nx) go to 210      do 200 l = 1, j2blokc mode numbers 0 < kx < nx and 0 < ky < ny      joff = kxp2*(l + ks) - 1      do 180 j = 1, kxp2      if ((j+joff).gt.0) then         do 170 k = 2, ny         at1 = aimag(ffd(k,j,l))         bxy(1,k,j,l) = at1*cu(1,k,j,l)         bxy(2,k,j,l) = at1*cu(2,k,j,l)         bxy(3,k,j,l) = at1*cu(3,k,j,l)  170    continuec mode numbers ky = 0, ny         at1 = aimag(ffd(1,j,l))         bxy(1,1,j,l) = 0.         bxy(2,1,j,l) = at1*cu(2,1,j,l)         bxy(3,1,j,l) = 0.      endif  180 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 190 k = 2, ny         at1 = aimag(ffd(k,1,l))         bxy(1,k,1,l) = at1*cu(1,k,1,l)         bxy(2,k,1,l) = 0.         bxy(3,k,1,l) = 0.  190    continue         bxy(1,1,1,l) = 0.         bxy(2,1,1,l) = 0.         bxy(3,1,1,l) = 0.      endif  200 continue  210 continue      return      endc-----------------------------------------------------------------------      subroutine PBPOISD22(cu,bxy,bz,isign,ffd,ax,ay,affp,ci,wm,nx,ny,ks     1trt,ny2d,kxp2,j2blok,nyd)c this subroutine solves 2d poisson's equation in fourier space forc magnetic field (or convolution of magnetic field over particle shape)c or for vector potential, or provides a smoothing function,c with dirichlet boundary conditions (zero potential),c for distributed data.c fourier coefficients are constructed so that a real to complex fftc will perform the appropriate sin-cos, or cos-sin transformc for isign = 0, input: isign,ax,ay,affp,nx,ny,kstrt,ny2d,kxp,j2blok,nydc output: ffdc for isign = -1, input:cu,ffd,isign,ci,nx,ny,kstrt,ny2d,kxp2,j2blok,nydc output: bz,wmc approximate flop count is: 15*nxc*nyc + 8*(nxc + nyc)c for isign = 1, input: cu,ffd,isign,ci,nx,ny,kstrt,ny2d,kxp2,j2blok,nydc output: bxy,wmc approximate flop count is: 11*nxc*nyc + 6*(nxc + nyc)c for isign = 2, input: cu,ffd,isign,nx,ny,kstrt,ny2d,kxp2,j2blok,nydc output: bxyc approximate flop count is: 6*nxc*nycc where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc if isign = 0, form factor array is preparedc if isign < 0, magnetic field is calculated using the equations:c bz(kx,ky) = ci*ci*sqrt(-1)*g(kx,ky)*(kx*cuy(kx,ky)-ky*cux(kx,ky))*c             s(kx,ky),c where kx = pi*j/nx, ky = pi*k/ny, and j,k = fourier mode numbers,c g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky),c s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2)c if isign = 1, vector potential is calculated using the equation:c bx(kx,ky) = ci*ci*g(kx,ky)*cux(kx,ky)c by(kx,ky) = ci*ci*g(kx,ky)*cuy(kx,ky)c if isign = 2, smoothing is calculated using the equation:c bx(kx,ky) = cux(kx,ky)*s(kx,ky)c by(kx,ky) = cuy(kx,ky)*s(kx,ky)c cu(i,k,j,l) = i-th component of complex current density andc bxy(i,k,j,l) = i-th component of complex vector potential,c bz(k,j,l) = i-th component of complex magnetic field,c for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c j2blok = number of data blocksc kxp2 = number of data values per blockc kstrt = starting data block numberc aimag(ffd(k,j,l)) = finite-size particle shape factor sc real(ffd(k,j,l)) = potential green's function gc for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c ax/ay = half-width of particle in x/y directionc affp = normalization constant = nx*ny/np, where np=number of particlesc ci = reciprical of velocity of lightc magnetic field energy is also calculated, usingc wm = nx*ny*nz*sum((affp/(kx**2+ky**2+kz**2))*ci*cic    |cu(kx,ky,kz)*s(kx,ky,kz)|**2)c this expression is valid only if the current is divergence-freec nx/ny = system length in x/y directionc ny2d = first dimension of field arrays, must be >= 2*nyc nyd = first dimension of form factor array, must be >= ny      double precision wp      complex cu, bxy, bz, ffd, zero      dimension cu(2,ny2d,kxp2,j2blok), bxy(2,ny2d,kxp2,j2blok)      dimension bz(ny2d,kxp2,j2blok)      dimension ffd(nyd,kxp2,j2blok)      ny2 = 2*ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx + nx)      dny = 6.28318530717959/float(ny + ny)      zero = cmplx(0.,0.)      ci2 = ci*ci      if (isign.ne.0) go to 40      if (kstrt.gt.nx) returnc prepare form factor array      do 30 l = 1, j2blok      joff = kxp2*(l + ks) - 1      do 20 j = 1, kxp2      dkx = dnx*float(j + joff)      at1 = dkx*dkx      at2 = (dkx*ax)**2      do 10 k = 1, ny      dky = dny*float(k - 1)      at3 = dky*dky + at1      at4 = exp(-.5*((dky*ay)**2 + at2))      if (at3.eq.0.) then         ffd(k,j,l) = cmplx(affp,1.)      else         ffd(k,j,l) = cmplx(affp*at4/at3,at4)      endif   10 continue   20 continue   30 continue      return   40 if (isign.gt.0) go to 100c calculate magnetic field and sum field energy      wp = 0.0d0      if (kstrt.gt.nx) go to 90      do 80 l = 1, j2blokc mode numbers 0 < kx < nx and 0 < ky < ny      joff = kxp2*(l + ks) - 1      do 60 j = 1, kxp2      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 50 k = 2, ny         k1 = ny2 - k         dky = dny*float(k - 1)         at1 = ci2*real(ffd(k,j,l))*aimag(ffd(k,j,l))         at2 = dky*at1         at3 = dkx*at1         bz(k,j,l) = cmplx(at2*aimag(cu(1,k,j,l))-at3*aimag(cu(2,k,j,l))     1,0.)         bz(k1,j,l) = bz(k,j,l)         wp = wp + 2.0*at1*(aimag(cu(1,k,j,l))**2 + aimag(cu(2,k,j,l))**     12)   50    continuec mode numbers ky = 0, ny         k1 = ny + 1         at1 = ci2*real(ffd(1,j,l))*aimag(ffd(1,j,l))         at2 = dkx*at1         bz(1,j,l) = cmplx(-at2*aimag(cu(2,1,j,l)),0.)         bz(k1,j,l) = zero         wp = wp + at1*(aimag(cu(2,1,j,l))**2)      endif   60 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 70 k = 2, ny         k1 = ny2 - k         dky = dny*float(k - 1)         at1 = ci2*real(ffd(k,1,l))*aimag(ffd(k,1,l))         at2 = dky*at1         bz(k,1,l) = cmplx(at2*aimag(cu(1,k,1,l)),0.)         bz(k1,1,l) = zero         wp = wp + at1*(aimag(cu(1,k,1,l))**2)   70    continue         k1 = ny + 1         bz(1,1,l) = zero         bz(k1,1,l) = zero      endif   80 continue   90 continue      wm = float(nx*ny)*wp      returnc calculate vector potential and sum field energy  100 if (isign.gt.1) go to 160      wp = 0.0d0      if (kstrt.gt.nx) go to 150      do 140 l = 1, j2blokc mode numbers 0 < kx < nx and 0 < ky < ny      joff = kxp2*(l + ks) - 1      do 120 j = 1, kxp2      if ((j+joff).gt.0) then         do 110 k = 2, ny         k1 = ny2 - k         at2 = ci2*real(ffd(k,j,l))         at1 = at2*aimag(ffd(k,j,l))         bxy(1,k,j,l) = cmplx(0.,at2*aimag(cu(1,k,j,l)))         bxy(2,k,j,l) = cmplx(0.,at2*aimag(cu(2,k,j,l)))         bxy(1,k1,j,l) = -bxy(1,k,j,l)         bxy(2,k1,j,l) = bxy(2,k,j,l)         wp = wp + 2.0*at1*(aimag(cu(1,k,j,l))**2 + aimag(cu(2,k,j,l))**     12)  110    continuec mode numbers ky = 0, ny         k1 = ny + 1         at2 = ci2*real(ffd(1,j,l))         at1 = at2*aimag(ffd(1,j,l))         bxy(1,1,j,l) = zero         bxy(2,1,j,l) = cmplx(0.,at2*aimag(cu(2,1,j,l)))         bxy(1,k1,j,l) = zero         bxy(2,k1,j,l) = zero         wp = wp + at1*(aimag(cu(2,1,j,l))**2)      endif  120 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 130 k = 2, ny         k1 = ny2 - k         at2 = ci2*real(ffd(k,1,l))         at1 = at2*aimag(ffd(k,1,l))         bxy(1,k,1,l) = cmplx(0.,at2*aimag(cu(1,k,1,l)))         bxy(2,k,1,l) = zero         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero         wp = wp + at1*(aimag(cu(1,k,1,l))**2)  130    continue         k1 = ny + 1         bxy(1,1,1,l) = zero         bxy(2,1,1,l) = zero         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero      endif  140 continue  150 continue      wm = float(nx*ny)*wp      returnc calculate smoothing  160 if (kstrt.gt.nx) go to 210      do 200 l = 1, j2blokc mode numbers 0 < kx < nx and 0 < ky < ny      joff = kxp2*(l + ks) - 1      do 180 j = 1, kxp2      if ((j+joff).gt.0) then         do 170 k = 2, ny         k1 = ny2 - k         at1 = aimag(ffd(k,j,l))         bxy(1,k,j,l) = cmplx(0.,at1*aimag(cu(1,k,j,l)))         bxy(2,k,j,l) = cmplx(0.,at1*aimag(cu(2,k,j,l)))         bxy(1,k1,j,l) = -bxy(1,k,j,l)         bxy(2,k1,j,l) = bxy(2,k,j,l)  170    continuec mode numbers ky = 0, ny         k1 = ny + 1         at1 = aimag(ffd(1,j,l))         bxy(1,1,j,l) = zero         bxy(2,1,j,l) = cmplx(0.,at1*aimag(cu(2,1,j,l)))         bxy(1,k1,j,l) = zero         bxy(2,k1,j,l) = zero      endif  180 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 190 k = 2, ny         k1 = ny2 - k         at1 = aimag(ffd(k,1,l))         bxy(1,k,1,l) = cmplx(0.,at1*aimag(cu(1,k,1,l)))         bxy(2,k,1,l) = zero         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero  190    continue         k1 = ny + 1         bxy(1,1,1,l) = zero         bxy(2,1,1,l) = zero         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero      endif  200 continue  210 continue      return      endc-----------------------------------------------------------------------      subroutine PMAXWELDX2(exy,bxy,cu,ffd,affp,ci,dt,wf,wm,nx,ny,kstrt,     1ny2d,kxp2,j2blok,nyd)c this subroutine solves 2d maxwell's equation in fourier space forc transverse electric and magnetic fields with dirichlet boundaryc conditions (zero potential).c input: all, output: wf, wm, exy, bxyc approximate flop count is: 62*nxc*nyc + 36*(nxc + nyc)c plus nxc*nyc dividesc where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc the magnetic field is first updated half a step using the equations:c bx(kx,ky) = bx(kx,ky) - .5*dt*sqrt(-1)*ky*ez(kx,ky)c by(kx,ky) = by(kx,ky) + .5*dt*sqrt(-1)*kx*ez(kx,ky)c bz(kx,ky) = bz(kx,ky) - .5*dt*sqrt(-1)*(kx*ey(kx,ky)-ky*ex(kx,ky))c the electric field is then updated a whole step using the equations:c ex(kx,ky) = ex(kx,ky) + c2*dt*sqrt(-1)*ky*bz(kx,ky)c                       - affp*dt*cux(kx,ky)*s(kx,ky)c ey(kx,ky) = ey(kx,ky) - c2*dt*sqrt(-1)*kx*bz(kx,ky)c                       - affp*dt*cuy(kx,ky)*s(kx,ky)c ez(kx,ky) = ez(kx,ky) + c2*dt*sqrt(-1)*(kx*by(kx,ky)-ky*bx(kx,ky))c                       - affp*dt*cuz(kx,ky)*s(kx,ky)c the magnetic field is finally updated the remaining half step withc the new electric field and the previous magnetic field equations.c where kx = pi*j/nx, ky = pi*k/ny, c2 = 1./(ci*ci)c and s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)c j,k = fourier mode numbersc and similarly for bx, by, bz.c cu(i,k,j,l) = i-th component of complex current density andc exy(i,k,j,l) = i-th component of complex electric field,c bxy(i,k,j,l) = i-th component of complex magnetic field,c for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c aimag(ffd(k,j,l)) = finite-size particle shape factor sc s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)c for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c affp = normalization constant = nx*ny/np, where np=number of particlesc ci = reciprical of velocity of lightc dt = time interval between successive calculationsc transverse electric field energy is also calculated, usingc wf = nx*ny*nz**sum((1/affp)*|exyz(kx,ky,kz)|**2)c magnetic field energy is also calculated, usingc wm = nx*ny*nz**sum((c2/affp)*|bxyz(kx,ky,kz)|**2)c nx/ny = system length in x/y directionc j2blok = number of data blocksc kxp2 = number of data values per blockc kstrt = starting data block numberc ny2d = first dimension of field arrays, must be >= 2*nyc nyd = first dimension of form factor array, must be >= ny      double precision wp, ws      complex exy, bxy, cu, ffd      complex zero      dimension exy(3,ny2d,kxp2,j2blok), bxy(3,ny2d,kxp2,j2blok)      dimension cu(3,ny2d,kxp2,j2blok)      dimension ffd(nyd,kxp2,j2blok)      if (ci.le.0.) return      ny2 = 2*ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx + nx)      dny = 6.28318530717959/float(ny + ny)      dth = .5*dt      c2 = 1./(ci*ci)      cdt = c2*dt      adt = affp*dt      zero = cmplx(0.,0.)      anorm = 1.0/affpc update electromagnetic field and sum field energies      ws = 0.0d0      wp = 0.0d0      if (kstrt.gt.nx) go to 50c calculate the electromagnetic fields      do 40 l = 1, j2blokc mode numbers 0 < kx < nx and 0 < ky < ny      joff = kxp2*(l + ks) - 1      do 20 j = 1, kxp2      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 10 k = 2, ny         k1 = ny2 - k         dky = dny*float(k - 1)         at1 = aimag(ffd(k,j,l))**2         afdt = adt*at1         at1 = anorm/at1         at7 = aimag(exy(1,k,j,l))         at8 = aimag(exy(2,k,j,l))         at9 = real(exy(3,k,j,l))c update magnetic field half time step, ky > 0         at4 = aimag(bxy(1,k,j,l)) - dth*(dky*at9)         at5 = aimag(bxy(2,k,j,l)) + dth*(dkx*at9)         at6 = real(bxy(3,k,j,l)) + dth*(dkx*at8 - dky*at7)c update electric field whole time step         at7 = at7 + cdt*(dky*at6) - afdt*aimag(cu(1,k,j,l))         at8 = at8 - cdt*(dkx*at6) - afdt*aimag(cu(2,k,j,l))         at9 = at9 + cdt*(dky*at4 - dkx*at5) - afdt*real(cu(3,k,j,l))c update magnetic field half time step and store electric field         at4 = at4 - dth*(dky*at9)         at5 = at5 + dth*(dkx*at9)         at6 = at6 + dth*(dkx*at8 - dky*at7)         ws = ws + 2.0*at1*(at7*at7 + at8*at8 + at9*at9)         wp = wp + 2.0*at1*(at4*at4 + at5*at5 + at6*at6)         exy(1,k,j,l) = cmplx(0.,at7)         exy(2,k,j,l) = cmplx(0.,at8)         exy(3,k,j,l) = cmplx(at9,0.)         bxy(1,k,j,l) = cmplx(0.,at4)         bxy(2,k,j,l) = cmplx(0.,at5)         bxy(3,k,j,l) = cmplx(at6,0.)c update electric and magnetic fields, ky < 0         exy(1,k1,j,l) = cmplx(0.,-at7)         exy(2,k1,j,l) = cmplx(0.,at8)         exy(3,k1,j,l) = cmplx(-at9,0.)         bxy(1,k1,j,l) = cmplx(0.,at4)         bxy(2,k1,j,l) = cmplx(0.,-at5)         bxy(3,k1,j,l) = cmplx(at6,0.)   10    continuec mode numbers ky = 0, ny         k1 = ny + 1         at1 = aimag(ffd(1,j,l))**2         afdt = adt*at1         at1 = anorm/at1         at8 = aimag(exy(2,1,j,l))         at9 = real(exy(3,1,j,l))c update magnetic field half time step, ky > 0         at5 = aimag(bxy(2,1,j,l)) + dth*(dkx*at9)         at6 = real(bxy(3,1,j,l)) + dth*(dkx*at8)c update electric field whole time step         at8 = at8 - cdt*(dkx*at6) - afdt*aimag(cu(2,1,j,l))         at9 = at9 - cdt*(dkx*at5) - afdt*real(cu(3,1,j,l))c update magnetic field half time step and store electric field         at5 = at5 + dth*(dkx*at9)         at6 = at6 + dth*(dkx*at8)         ws = ws + at1*(at8*at8 + at9*at9)         wp = wp + at1*(at5*at5 + at6*at6)         exy(1,1,j,l) = zero         exy(2,1,j,l) = cmplx(0.,at8)         exy(3,1,j,l) = cmplx(at9,0.)         bxy(1,1,j,l) = zero         bxy(2,1,j,l) = cmplx(0.,at5)         bxy(3,1,j,l) = cmplx(at6,0.)         bxy(1,k1,j,l) = zero         bxy(2,k1,j,l) = zero         bxy(3,k1,j,l) = zero         exy(1,k1,j,l) = zero         exy(2,k1,j,l) = zero         exy(3,k1,j,l) = zero      endif   20 continuec mode numbers kx = 0, nx      if ((l+ks).eq.0) then         do 30 k = 2, ny         k1 = ny2 - k         dky = dny*float(k - 1)         at1 = aimag(ffd(k,1,l))**2         afdt = adt*at1         at1 = anorm/at1         at7 = aimag(exy(1,k,1,l))         at9 = real(exy(3,k,1,l))c update magnetic field half time step, ky > 0         at4 = aimag(bxy(1,k,1,l)) - dth*(dky*at9)         at6 = real(bxy(3,k,1,l)) - dth*(dky*at7)c update electric field whole time step         at7 = at7 + cdt*(dky*at6) - afdt*aimag(cu(1,k,1,l))         at9 = at9 + cdt*(dky*at4) - afdt*real(cu(3,k,1,l))c update magnetic field half time step and store electric field         at4 = at4 - dth*(dky*at9)         at6 = at6 - dth*(dky*at7)         ws = ws + at1*(at7*at7 + at9*at9)         wp = wp + at1*(at4*at4 + at6*at6)         exy(1,k,1,l) = cmplx(0.,at7)         exy(2,k,1,l) = zero         exy(3,k,1,l) = cmplx(at9,0.)         bxy(1,k,1,l) = cmplx(0.,at4)         bxy(2,k,1,l) = zero         bxy(3,k,1,l) = cmplx(at6,0.)         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero         bxy(3,k1,1,l) = zero         exy(1,k1,1,l) = zero         exy(2,k1,1,l) = zero         exy(3,k1,1,l) = zero   30    continue         k1 = ny + 1         bxy(1,1,1,l) = zero         bxy(2,1,1,l) = zero         bxy(3,1,1,l) = zero         exy(1,1,1,l) = zero         exy(2,1,1,l) = zero         exy(3,1,1,l) = zero         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero         bxy(3,k1,1,l) = zero         exy(1,k1,1,l) = zero         exy(2,k1,1,l) = zero         exy(3,k1,1,l) = zero      endif   40 continue   50 continue      wf = float(nx*ny)*ws      wm = float(nx*ny)*c2*wp      return      endc-----------------------------------------------------------------------      subroutine PMAXWELD2(exy,bxy,cu,ffd,affp,ci,dt,wf,wm,nx,ny,kstrt,n     1yv,kxp2,j2blok,nyd)c this subroutine solves 2d maxwell's equation in fourier space forc transverse electric and magnetic fields with dirichlet boundaryc conditions (zero potential).c input: all, output: wf, wm, exy, bxyc approximate flop count is: 62*nxc*nyc + 36*(nxc + nyc)c plus nxc*nyc dividesc where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc the magnetic field is first updated half a step using the equations:c bx(kx,ky) = bx(kx,ky) - .5*dt*sqrt(-1)*ky*ez(kx,ky)c by(kx,ky) = by(kx,ky) + .5*dt*sqrt(-1)*kx*ez(kx,ky)c bz(kx,ky) = bz(kx,ky) - .5*dt*sqrt(-1)*(kx*ey(kx,ky)-ky*ex(kx,ky))c the electric field is then updated a whole step using the equations:c ex(kx,ky) = ex(kx,ky) + c2*dt*sqrt(-1)*ky*bz(kx,ky)c                       - affp*dt*cux(kx,ky)*s(kx,ky)c ey(kx,ky) = ey(kx,ky) - c2*dt*sqrt(-1)*kx*bz(kx,ky)c                       - affp*dt*cuy(kx,ky)*s(kx,ky)c ez(kx,ky) = ez(kx,ky) + c2*dt*sqrt(-1)*(kx*by(kx,ky)-ky*bx(kx,ky))c                       - affp*dt*cuz(kx,ky)*s(kx,ky)c the magnetic field is finally updated the remaining half step withc the new electric field and the previous magnetic field equations.c where kx = pi*j/nx, ky = pi*k/ny, c2 = 1./(ci*ci)c and s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)c j,k = fourier mode numbersc and similarly for bx, by, bz.c cu(i,k,j,l) = i-th component of complex current density andc exy(i,k,j,l) = i-th component of complex electric field,c bxy(i,k,j,l) = i-th component of complex magnetic field,c for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c aimag(ffd(k,j,l)) = finite-size particle shape factor sc s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)c for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c affp = normalization constant = nx*ny/np, where np=number of particlesc ci = reciprical of velocity of lightc dt = time interval between successive calculationsc transverse electric field energy is also calculated, usingc wf = nx*ny*nz**sum((1/affp)*|exyz(kx,ky,kz)|**2)c magnetic field energy is also calculated, usingc wm = nx*ny*nz**sum((c2/affp)*|bxyz(kx,ky,kz)|**2)c nx/ny = system length in x/y directionc j2blok = number of data blocksc kxp2 = number of data values per blockc kstrt = starting data block numberc nyv = first dimension of field arrays, must be >= nyc nyd = first dimension of form factor array, must be >= ny      double precision wp, ws      complex ffd      dimension exy(3,nyv,kxp2,j2blok), bxy(3,nyv,kxp2,j2blok)      dimension cu(3,nyv,kxp2,j2blok)      dimension ffd(nyd,kxp2,j2blok)      if (ci.le.0.) return      ks = kstrt - 2      dnx = 6.28318530717959/float(nx + nx)      dny = 6.28318530717959/float(ny + ny)      dth = .5*dt      c2 = 1./(ci*ci)      cdt = c2*dt      adt = affp*dt      anorm = 1.0/affpc update electromagnetic field and sum field energies      ws = 0.0d0      wp = 0.0d0      if (kstrt.gt.nx) go to 50c calculate the electromagnetic fields      do 40 l = 1, j2blokc mode numbers 0 < kx < nx and 0 < ky < ny      joff = kxp2*(l + ks) - 1      do 20 j = 1, kxp2      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 10 k = 2, ny         dky = dny*float(k - 1)         at1 = aimag(ffd(k,j,l))**2         afdt = adt*at1         at1 = anorm/at1         at7 = exy(1,k,j,l)         at8 = exy(2,k,j,l)         at9 = exy(3,k,j,l)c update magnetic field half time step, ky > 0         at4 = bxy(1,k,j,l) - dth*(dky*at9)         at5 = bxy(2,k,j,l) + dth*(dkx*at9)         at6 = bxy(3,k,j,l) + dth*(dkx*at8 - dky*at7)c update electric field whole time step         at7 = at7 + cdt*(dky*at6) - afdt*cu(1,k,j,l)         at8 = at8 - cdt*(dkx*at6) - afdt*cu(2,k,j,l)         at9 = at9 + cdt*(dky*at4 - dkx*at5) - afdt*cu(3,k,j,l)c update magnetic field half time step and store electric field         at4 = at4 - dth*(dky*at9)         at5 = at5 + dth*(dkx*at9)         at6 = at6 + dth*(dkx*at8 - dky*at7)         ws = ws + 2.0*at1*(at7*at7 + at8*at8 + at9*at9)         wp = wp + 2.0*at1*(at4*at4 + at5*at5 + at6*at6)         exy(1,k,j,l) = at7         exy(2,k,j,l) = at8         exy(3,k,j,l) = at9         bxy(1,k,j,l) = at4         bxy(2,k,j,l) = at5         bxy(3,k,j,l) = at6   10    continuec mode numbers ky = 0, ny         at1 = aimag(ffd(1,j,l))**2         afdt = adt*at1         at1 = anorm/at1         at8 = exy(2,1,j,l)         at9 = exy(3,1,j,l)c update magnetic field half time step, ky > 0         at5 = bxy(2,1,j,l) + dth*(dkx*at9)         at6 = bxy(3,1,j,l) + dth*(dkx*at8)c update electric field whole time step         at8 = at8 - cdt*(dkx*at6) - afdt*cu(2,1,j,l)         at9 = at9 - cdt*(dkx*at5) - afdt*cu(3,1,j,l)c update magnetic field half time step and store electric field         at5 = at5 + dth*(dkx*at9)         at6 = at6 + dth*(dkx*at8)         ws = ws + at1*(at8*at8 + at9*at9)         wp = wp + at1*(at5*at5 + at6*at6)         exy(1,1,j,l) = 0.         exy(2,1,j,l) = at8         exy(3,1,j,l) = at9         bxy(1,1,j,l) = 0.         bxy(2,1,j,l) = at5         bxy(3,1,j,l) = at6      endif   20 continuec mode numbers kx = 0, nx      if ((l+ks).eq.0) then         do 30 k = 2, ny         dky = dny*float(k - 1)         at1 = aimag(ffd(k,1,l))**2         afdt = adt*at1         at1 = anorm/at1         at7 = exy(1,k,1,l)         at9 = exy(3,k,1,l)c update magnetic field half time step, ky > 0         at4 = bxy(1,k,1,l) - dth*(dky*at9)         at6 = bxy(3,k,1,l) - dth*(dky*at7)c update electric field whole time step         at7 = at7 + cdt*(dky*at6) - afdt*cu(1,k,1,l)         at9 = at9 + cdt*(dky*at4) - afdt*cu(3,k,1,l)c update magnetic field half time step and store electric field         at4 = at4 - dth*(dky*at9)         at6 = at6 - dth*(dky*at7)         ws = ws + at1*(at7*at7 + at9*at9)         wp = wp + at1*(at4*at4 + at6*at6)         exy(1,k,1,l) = at7         exy(2,k,1,l) = 0.         exy(3,k,1,l) = at9         bxy(1,k,1,l) = at4         bxy(2,k,1,l) = 0.         bxy(3,k,1,l) = at6   30    continue         bxy(1,1,1,l) = 0.         bxy(2,1,1,l) = 0.         bxy(3,1,1,l) = 0.         exy(1,1,1,l) = 0.         exy(2,1,1,l) = 0.         exy(3,1,1,l) = 0.      endif   40 continue   50 continue      wf = float(nx*ny)*ws      wm = float(nx*ny)*c2*wp      return      endc-----------------------------------------------------------------------      subroutine PDMFIELDD2(q2,q,nx,ny,kstrt,ny2d,nyv,kxp2,j2blok)c this subroutine copies the charge density into a smaller array      implicit none      integer nx, ny, kstrt, nyv, ny2d, kxp2, j2blok      complex q2      real q      dimension q2(ny2d,kxp2,j2blok), q(nyv,kxp2,j2blok)      integer j, k, l      if (kstrt.gt.nx) return      do 30 l = 1, j2blok      do 20 j = 1, kxp2      do 10 k = 1, ny      q(k,j,l) = real(q2(k,j,l))   10 continue   20 continue   30 continue      return      endc-----------------------------------------------------------------------      subroutine PBMFIELDD2(bxy2,bxy,nx,ny,kstrt,ny2d,nyv,kxp2,j2blok)c this subroutine copies the magnetic field into a smaller array      implicit none      integer nx, ny, kstrt, nyv, ny2d, kxp2, j2blok      complex bxy2      real bxy      dimension bxy2(3,ny2d,kxp2,j2blok), bxy(3,nyv,kxp2,j2blok)      integer j, k, l      if (kstrt.gt.nx) return      do 30 l = 1, j2blok      do 20 j = 1, kxp2      do 10 k = 1, ny      bxy(1,k,j,l) = aimag(bxy2(1,k,j,l))      bxy(2,k,j,l) = aimag(bxy2(2,k,j,l))      bxy(3,k,j,l) = real(bxy2(3,k,j,l))   10 continue   20 continue   30 continue      return      endc-----------------------------------------------------------------------      subroutine PEMFIELDD2(fxy,exy,isign,nx,ny,kstrt,ny2d,nyv,kxp2,j2bl     1ok)c this subroutine either adds complex vector fields if isign > 0c or copies complex vector fields if isign <= 0c adds image charges appropriate for electric field if isign >= 0c or appropriate for magnetic field if isign < 0      implicit none      integer isign, nx, ny, kstrt, ny2d, nyv, kxp2, j2blok      complex fxy      real exy      dimension fxy(3,ny2d,kxp2,j2blok), exy(3,nyv,kxp2,j2blok)      integer j, k, l, ny2, ks, joff, k1      real zero      ny2 = 2*ny + 2      ks = kstrt - 2      zero = 0.      if (kstrt.gt.nx) returnc add the fields      if (isign.gt.0) then         do 40 l = 1, j2blok         do 20 j = 1, kxp2         joff = kxp2*(l + ks) - 1         if ((j+joff).gt.0) then            do 10 k = 2, ny            k1 = ny2 - k            fxy(1,k,j,l) = fxy(1,k,j,l) + cmplx(0.,exy(1,k,j,l))            fxy(2,k,j,l) = fxy(2,k,j,l) + cmplx(0.,exy(2,k,j,l))            fxy(3,k,j,l) = fxy(3,k,j,l) + cmplx(exy(3,k,j,l),0.)            fxy(1,k1,j,l) = fxy(1,k1,j,l) + cmplx(0.,-exy(1,k,j,l))            fxy(2,k1,j,l) = fxy(2,k1,j,l) + cmplx(0.,exy(2,k,j,l))            fxy(3,k1,j,l) = fxy(3,k1,j,l) + cmplx(-exy(3,k,j,l),0.)   10       continue            fxy(1,1,j,l) = fxy(1,1,j,l) + cmplx(0.,exy(1,1,j,l))            fxy(2,1,j,l) = fxy(2,1,j,l) + cmplx(0.,exy(2,1,j,l))            fxy(3,1,j,l) = fxy(3,1,j,l) + cmplx(exy(3,1,j,l),0.)         endif   20    continue         if ((l+ks).eq.0) then            do 30 k = 1, ny            fxy(1,k,1,l) = fxy(1,k,1,l) + cmplx(0.,exy(1,k,1,l))            fxy(2,k,1,l) = fxy(2,k,1,l) + cmplx(0.,exy(2,k,1,l))            fxy(3,k,1,l) = fxy(3,k,1,l) + cmplx(exy(3,k,1,l),0.)   30       continue         endif   40    continuec copy the magnetic fields      else if (isign.lt.0) then         do 80 l = 1, j2blok         do 60 j = 1, kxp2         joff = kxp2*(l + ks) - 1         if ((j+joff).gt.0) then            do 50 k = 2, ny            k1 = ny2 - k            fxy(1,k,j,l) = cmplx(0.,exy(1,k,j,l))            fxy(2,k,j,l) = cmplx(0.,exy(2,k,j,l))            fxy(3,k,j,l) = cmplx(exy(3,k,j,l),0.)            fxy(1,k1,j,l) = cmplx(0.,exy(1,k,j,l))            fxy(2,k1,j,l) = cmplx(0.,-exy(2,k,j,l))            fxy(3,k1,j,l) = cmplx(exy(3,k,j,l),0.)   50       continue            k1 = ny + 1            fxy(1,1,j,l) = cmplx(0.,exy(1,1,j,l))            fxy(2,1,j,l) = cmplx(0.,exy(2,1,j,l))            fxy(3,1,j,l) = cmplx(exy(3,1,j,l),0.)            fxy(1,k1,j,l) = zero            fxy(2,k1,j,l) = zero            fxy(3,k1,j,l) = zero         endif   60    continue         if ((l+ks).eq.0) then            do 70 k = 2, ny            k1 = ny2 - k            fxy(1,k,1,l) = cmplx(0.,exy(1,k,1,l))            fxy(2,k,1,l) = cmplx(0.,exy(2,k,1,l))            fxy(3,k,1,l) = cmplx(exy(3,k,1,l),0.)            fxy(1,k1,1,l) = zero            fxy(2,k1,1,l) = zero            fxy(3,k1,1,l) = zero   70       continue            k1 = ny + 1            fxy(1,1,1,l) = cmplx(0.,exy(1,1,1,l))            fxy(2,1,1,l) = cmplx(0.,exy(2,1,1,l))            fxy(3,1,1,l) = cmplx(exy(3,1,1,l),0.)            fxy(1,k1,1,l) = zero            fxy(2,k1,1,l) = zero            fxy(3,k1,1,l) = zero         endif   80    continuec copy the electric fields      else         do 120 l = 1, j2blok         do 100 j = 1, kxp2         joff = kxp2*(l + ks) - 1         if ((j+joff).gt.0) then            do 90 k = 2, ny            k1 = ny2 - k            fxy(1,k,j,l) = cmplx(0.,exy(1,k,j,l))            fxy(2,k,j,l) = cmplx(0.,exy(2,k,j,l))            fxy(3,k,j,l) = cmplx(exy(3,k,j,l),0.)            fxy(1,k1,j,l) = cmplx(0.,-exy(1,k,j,l))            fxy(2,k1,j,l) = cmplx(0.,exy(2,k,j,l))            fxy(3,k1,j,l) = cmplx(-exy(3,k,j,l),0.)   90       continue            k1 = ny + 1            fxy(1,1,j,l) = cmplx(0.,exy(1,1,j,l))            fxy(2,1,j,l) = cmplx(0.,exy(2,1,j,l))            fxy(3,1,j,l) = cmplx(exy(3,1,j,l),0.)            fxy(1,k1,j,l) = zero            fxy(2,k1,j,l) = zero            fxy(3,k1,j,l) = zero         endif  100    continue         if ((l+ks).eq.0) then            do 110 k = 2, ny            k1 = ny2 - k            fxy(1,k,1,l) = cmplx(0.,exy(1,k,1,l))            fxy(2,k,1,l) = cmplx(0.,exy(2,k,1,l))            fxy(3,k,1,l) = cmplx(exy(3,k,1,l),0.)            fxy(1,k1,1,l) = zero            fxy(2,k1,1,l) = zero            fxy(3,k1,1,l) = zero  110       continue            k1 = ny + 1            fxy(1,1,1,l) = cmplx(0.,exy(1,1,1,l))            fxy(2,1,1,l) = cmplx(0.,exy(2,1,1,l))            fxy(3,1,1,l) = cmplx(exy(3,1,1,l),0.)            fxy(1,k1,1,l) = zero            fxy(2,k1,1,l) = zero            fxy(3,k1,1,l) = zero         endif  120    continue      endif      return      endc-----------------------------------------------------------------------      subroutine PBNDRYV2(q,ffc,bv,nx,ny,kstrt,nyv,kxp,jblok,nyhd)c this subroutine calculates the boundary values of electric field ofc the periodic solution of poisson's equation in Fourier space from thec charge density.  The results are used in calculating the solution of ac laplacian in order to satisfy non-periodic boundary conditions.c algorithm used in described in V. K. Decyk and J. M. Dawson,c Journal of Computational Physics 30, 407 (1979).c input: q, ffp, nx, ny, nxvh, nxhd, nyhd, output: bvc approximate flop count = 16*nxc*nyc + 7*nyc + 7*nxcc where nxc = nx/2 - 1, nyc = ny/2 - 1c q(j,k) = input complex charge density,c real(ffc(j,k)) = finite-size particle shape factor s,c aimag(ffc(j,k)) = potential green's function g,c all for for fourier mode (j-1,k-1)c bv = boundary fields, bv(k,3) = KmPm and bv(k,4) = PIm, exceptc imag(PI0) = net charge density rhoc nx/ny = system length in x/y directionc nxvh = first dimension of field arrays, must be >= nx/2c nxhd = must be >= nx/2c nyhd = must be >= ny/2      implicit none      complex q, ffc, bv      integer nx, ny, kstrt, nyv, kxp, jblok, nyhd      dimension q(nyv,kxp,jblok), ffc(nyhd,kxp,jblok), bv(nyhd,4)c local data      integer nxh, nyh, ny2, j, k, k1, l, ks, joff      real dnx, dny, dky, sum1, sum2, sum3, sum4, at1, at2      nxh = nx/2      nyh = ny/2      ny2 = ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx)      dny = 6.28318530717959/float(ny)      if (kstrt.gt.nxh) return      do 40 l = 1, jblok      joff = kxp*(l + ks) - 1      do 20 k = 2, nyh      k1 = ny2 - k      dky = dny*float(k - 1)c calculate KmPm and PIm      sum1 = 0.      sum2 = 0.      sum3 = 0.      sum4 = 0.      do 10 j = 1, kxp      if ((j+joff).gt.0) then         at2 = real(ffc(k,j,l))         at1 = dky*at2         at2 = dnx*float(j + joff)*at2         sum1 = sum1 + at1*real(q(k,j,l) + q(k1,j,l))         sum2 = sum2 + at1*aimag(q(k,j,l) - q(k1,j,l))         sum3 = sum3 + at2*aimag(q(k,j,l) + q(k1,j,l))         sum4 = sum4 + at2*real(q(k1,j,l) - q(k,j,l))      endif   10 continue      bv(k,3) = cmplx(sum1,sum2)      bv(k,4) = cmplx(sum3,sum4)      if ((l+ks).eq.0) bv(k,3) = bv(k,3) + (dky*real(ffc(k,1,l)))*q(k,1,     1l)   20 continuec calculate P0 and PI0      sum1 = 0.      sum2 = 0.      do 30 j = 1, kxp      if ((j+joff).gt.0) then         at1 = real(ffc(1,j,l))         sum1 = sum1 + at1*real(q(1,j,l))         sum2 = sum2 + (dnx*float(j + joff)*at1)*aimag(q(1,j,l))      endif   30 continue      bv(1,3) = cmplx(sum1 + sum1,0.)c imaginary part of bv(1,4) contains net charge rho00      bv(1,4) = cmplx(sum2 + sum2,0.)      if ((l+ks).eq.0) bv(1,4) = bv(1,4) + cmplx(0.,real(ffc(1,1,l))*rea     1l(q(1,1,l)))   40 continue      return      endc-----------------------------------------------------------------------      subroutine PPOISB2(fx,fy,isign,ffb,bv,bcd,mixup,sct,t,we,affp,indx     1,ny,kstrt,nyv,kxp,jblok,nxhd,nyhd)c not yet complete !!!!c this subroutine finds corrections to 2d poisson's equation for c force/charge or potential with vacuum boundary conditions and c external surface charge, for distributed data.c average potential across system is zero.  a periodic solution isc assumed to have been found first with ppoisp2, and boundary valuesc with bndryv2c algorithm used in described in V. K. Decyk and J. M. Dawson,c Journal of Computational Physics 30, 407 (1979).c for isign = 0, input: isign,indx,nxh,ny,nyh,nxvhc                output: ffb,bcdc                scratch: mixup,sct,tc for isign = -1, input:  isign,fx,fy,ffb,bv,bcd,affp,indx,nyc                         nxvh,nxhd,nyhdc                 output: fx, fy, bv, wec approximate flop count is: 54*nxc*nyc + + 115*nyc + 3*nxcc for isign = 1, input:  isign,fx,ffb,bv,bcd,affp,indx,ny,nxvh,nxhd,nyhdc                output: fx, bv, wec approximate flop count is: 27*nxc*nyc + + 74*nyc + 6*nxcc where nxc = nx/2 - 1, nyc = ny/2 - 1c if isign < 0, the force/charge correction is calculated:c exc(km,x) = -Am*exp(-km*(Lx-x)) + Bm*exp(-km*x)c eyc(km,x) = -sqrt(-1)*(Am*exp(-km*(Lx-x)) + Bm*exp(-km*x))c exc(k0,x) = -4*pi*rho00*(Lx/2-x) - A0c eyc(k0,x) = 0.c where Am = .5*(4*pi*sigma(x=Lx,k) + PIm - km*Pm),c       Bm = .5*(4*pi*sigma(x=0,k) - PIm - km*Pm),c and   A0 = 2*pi*sigma(x=Lx) - 2*pi*sigma(x=0) + PI0c where PIm and Pm are the periodic ex and phi at the boundariesc the calculations are done in fourier space and are added to thec periodic forces already in fx, fyc on output, bv = value of electric fields on right boundary:c bv(k,5) = ex(x=Lx), bv(k,6) = ey(x=Lx)c if isign = 1, potential correction is calculated:c potc(km,x) = (Am*exp(-km*(Lx-x)) + Bm*exp(-km*x)/kmc potc(k0,x) = 2*pi*rho00*x*(Lx-x) - A0*(Lx/2-x) - P0c the calculation is done in fourier space and is added to thec periodic potential already in fx.c on output, bv = value of potential on right boundary:c bv(k,6) = phi(x=Lx)c if isign = 0, form factor arrays ffb and bcd are preparedc on input, fx and/or fy contain periodic part of solutionc on output, fx and/or fy contain total solutionc ffb(j,k) = (1/nx)*inverse fft(exp(-dky*float(nx + 1 - j))))c real(ffb(j,1)) = (1/nx)*inverse fft((j - 1)*(nx + 1 - j))))c aimag(ffb(j,1)) = (1/nx)*inverse fft((nx/2 + 1 - j)))c on input, bv = input surface charge and boundary valuesc for fourier mode k-1:c bv(k,1) = 4*pi*sigma(x=0), bv(k,2) = 4*pi*sigma(x=Lx)c bv(k,3) = KmPm, bv(k,4) = PImc both are normalized in the same way as the electric field.c bcd(k) = exp(-ky*Lx)c mixup = array of bit reversed addresses for fftc sct = sine/cosine table for fftc t = complex scratch array, used during initialiation of fft tablesc we = bounded corrections to periodic electric field energyc affp = normalization constant for poisson's equationc indx = exponent which determines length in x direction, where nx=2**indxc ny = system length in y directionc nxvh = first dimension of field arrays, must be >= nx/2c nxhd = must be >= nx/2c nyhd = must be >= ny/2      implicit none      complex fx, fy, ffb, bv, sct, t      integer isign, mixup, indx, ny, kstrt, nyv, kxp, jblok, nxhd, nyhd      real bcd, we, affp      dimension fx(nyv,kxp,jblok), fy(nyv,kxp,jblok)      dimension ffb(nyhd,kxp,jblok), bv(nyhd,6), bcd(nyhd)      dimension mixup(nxhd), sct(nxhd), t(nxhd)c local data      double precision wp, wb      complex zc, zd, zt1, zt2, zt3, zt4      integer nx, nxh, nx1, nyh, ny2      integer is, j, j1, j2, j3, k, k1, ks, l, joff      real dny, anx, anxi, dky, at1, at2, at3, at4, rho, rholx, dkyi      real sum1, sum2, sum3, sum4      nx = 2**indx      nxh = nx/2      nx1 = nx + 1      nyh = ny/2      ny2 = ny + 2      ks = kstrt - 2      dny = 6.28318530717959/float(ny)      anx = float(nx)c initialization      if (isign.ne.0) go to 50      if (kstrt.gt.nxh) returnc prepare fft tables      is = 0c     call FFT1RX(ffb,t,is,mixup,sct,indx,nx,nxh)      is = -1c prepare form factor array      do 10 j = 1, nxh      j1 = j - 1      j2 = j1 + j1      j3 = j2 + 1c     ffb(j,1) = cmplx(float(j2*(nx - j2)),float(j3*(nx - j3)))c     ffb(j,2) = cmplx(float(nxh - j2),float(nxh - j3))   10 continuec     call FFT1RX(ffb(1,1),t,is,mixup,sct,indx,nx,nxh)c     call FFT1RX(ffb(1,2),t,is,mixup,sct,indx,nx,nxh)      do 20 j = 1, nxhc     ffb(j,1) = cmplx(real(ffb(j,1)),aimag(ffb(j,2)))   20 continue      do 40 k = 2, nyh      dky = dny*float(k - 1)      do 30 j = 1, nxh      j2 = j + j      j1 = j2 - 1c     ffb(j,k) = cmplx(exp(-amin1(50.,dky*float(nx1 - j1))),exp(-amin1(5c    10.,dky*float(nx1 - j2))))   30 continue      bcd(k) = exp(-amin1(50.,dky*anx))c     call FFT1RX(ffb(1,k),t,is,mixup,sct,indx,nx,nxh)   40 continue      return   50 if (isign.gt.0) go to 100c calculate force/charge and sum field energy      anxi = 1./anx      wp = 0.0d0      wb = 0.0d0      do 90 l = 1, jblok      joff = kxp*(l + ks) - 1      do 70 k = 2, nyh      k1 = ny2 - k      dky = dny*float(k - 1)c find constants for solution of homogeneous equation      zc = .5*(bv(k,1) - bv(k,3) - bv(k,4))      zd = .5*(bv(k,2) - bv(k,3) + bv(k,4))      zt1 = zc - zd      zt2 = cmplx(0.,1.)*conjg(zc + zd)c boundary fields      zt3 = zc + zd*bcd(k)      zt4 = zc*bcd(k) + zdc calculate internal and boundary energy corrections      at2 = anxi/dky      wp = wp + (aimag(zt2*bv(k,3)) - real(conjg(zt1)*bv(k,4)))*at2*(1.      1- bcd(k))      wb = wb + (conjg(bv(k,1))*(bv(k,3) + zt3) + conjg(bv(k,2))*(bv(k,3     1) + zt4))*at2c homogenous electric field in x direction at x = Lx      bv(k,5) = zc*bcd(k) - zdc homogenous electric field in y direction at x = Lx      bv(k,6) = -cmplx(0.,1.)*zt4c homogenous electric field in x direction at x = 0c     bv(k,7) = zc - zd*bcd(k)c homogenous electric field in y direction at x = 0c     bv(k,8) = -cmplx(0.,1.)*zt3c calculate extra term in homogeneous solution      zc = zc*(1. - bcd(k))*anxi      zd = -cmplx(0.,1.)*zcc find boundary values of periodic solution      sum1 = 0.      sum2 = 0.      sum3 = 0.      sum4 = 0.c add solutions of homogeneous equation to periodic solution      do 60 j = 2, nxh      sum1 = sum1 + real(fx(k,j,l) + fx(k1,j,l))      sum2 = sum2 + aimag(fx(k,j,l) - fx(k1,j,l))      sum3 = sum3 + real(fy(k,j,l) + fy(k1,j,l))      sum4 = sum4 + aimag(fy(k,j,l) - fy(k1,j,l))      fx(k,j,l) = fx(k,j,l) + zt1*real(ffb(k,j,l)) + conjg(zt2)*aimag(ff     1b(k,j,l)) + zc      fx(k1,j,l) = fx(k1,j,l) + conjg(zt1)*real(ffb(k,j,l)) - zt2*aimag(     1ffb(k,j,l)) + conjg(zc)      fy(k,j,l) = fy(k,j,l) + conjg(zt2)*real(ffb(k,j,l)) - zt1*aimag(ff     1b(k,j,l)) + zd      fy(k1,j,l) = fy(k1,j,l) + zt2*real(ffb(k,j,l)) + conjg(zt1)*aimag(     1ffb(k,j,l)) + conjg(zd)   60 continuec modes with n = 0, nx/2 are special      sum1 = sum1 + real(fx(k,1,l))      sum2 = sum2 + aimag(fx(k,1,l))      sum3 = sum3 + real(fy(k,1,l))      sum4 = sum4 + aimag(fy(k,1,l))      fx(k,1,l) = zt1*real(ffb(k,1,l)) + zc      fx(k1,1,l) = conjg(zt1)*aimag(ffb(k,1,l)) + conjg(zc)      fy(k,1,l) = fy(k,1,l) + conjg(zt2)*real(ffb(k,1,l)) + zd      fy(k1,1,l) = zt2*aimag(ffb(k,1,l)) + conjg(zd)c electric field in x direction at x = Lx      bv(k,5) = bv(k,5) + cmplx(sum1,sum2)c electric field in y direction at x = Lx      bv(k,6) = bv(k,6) + cmplx(sum3,sum4)c electric field in x direction at x = 0c     bv(k,7) = bv(k,7) + cmplx(sum1,sum2)c electric field in y direction at x = 0c     bv(k,8) = bv(k,8) + cmplx(sum3,sum4)   70 continuec find constants for solution of homogeneous equation      rho = aimag(bv(1,4))      rholx = .5*rho*anxc find constants for solution of homogeneous equation      at1 = rho*aimag(ffb(1,1,l))      at2 = -(.5*(bv(1,2) - bv(1,1)) + bv(1,4))      at3 = .5*at2*anxc calculate energies      wp = wp - .5*(at2*bv(1,4) - rho*(rholx*anx/6. - 2.*real(bv(1,3))))      wb = wb - .5*(bv(1,2) - bv(1,1))*at2      we = anx*float(ny)*(wp + wb)/affpc find boundary values of periodic solution      sum1 = 0.      sum2 = 0.c add solution of homogeneous equation to periodic solution      do 80 j = 2, nxh      sum1 = sum1 + real(fx(1,j,l))      sum2 = sum2 + real(fy(1,j,l))      if (rho.ne.0.) fx(1,j,l) = fx(1,j,l) - cmplx(at1,rho*aimag(ffb(1,j     1,l)))   80 continue      sum1 = sum1 + sum1      sum2 = sum2 + sum2      fx(1,1,l) = cmplx(at2 - at1,-at1)c electric field in x direction at x = Lx      bv(1,5) = cmplx(at2+rholx,0.) + cmplx(sum1,0.)c electric field in y direction at x = Lx      bv(1,6) = cmplx(sum2,0.)c electric field in x direction at x = 0c     bv(1,7) = cmplx(at2-rholx,0.) + cmplx(sum1,0.)c electric field in y direction at x = 0c     bv(1,8) = cmplx(sum2,0.)   90 continue      returnc calculate potential and sum field energy  100 anxi = 1./anx      wp = 0.0d0      wb = 0.0d0      do 140 l = 1, jblok      joff = kxp*(l + ks) - 1      do 120 k = 2, nyh      k1 = ny2 - k      dky = dny*float(k - 1)      dkyi = .5/dkyc find constants for solution of homogeneous equation      zc = dkyi*(bv(k,1) - bv(k,3) - bv(k,4))      zd = dkyi*(bv(k,2) - bv(k,3) + bv(k,4))      zt1 = zc + zd      zt2 = cmplx(0.,1.)*conjg(zc - zd)c boundary potentials      zt3 = zc + zd*bcd(k)      zt4 = zc*bcd(k) + zdc calculate internal and boundary energy corrections      at2 = anxi/dky      wp = wp + (real(conjg(zt1)*bv(k,3)) - aimag(zt2*bv(k,4)))*anxi*(1.     1- bcd(k))      wb = wb + (conjg(bv(k,1))*(bv(k,3) + zt3*dky) + conjg(bv(k,2))*(bv     1(k,3) + zt4*dky))*at2c calculate extra term in homogeneous solution      zc = zc*(1. - bcd(k))*anxic find boundary values of periodic solution      sum1 = 0.      sum2 = 0.c add solutions of homogeneous equation to periodic solution      do 110 j = 2, nxh      sum1 = sum1 + real(fx(k,j,l) + fx(k1,j,l))      sum2 = sum2 + aimag(fx(k,j,l) - fx(k1,j,l))      fx(k,j,l) = fx(k,j,l) + zt1*real(ffb(k,j,l)) + conjg(zt2)*aimag(ff     1b(k,j,l)) + zc      fx(k1,j,l) = fx(k1,j,l) + conjg(zt1)*real(ffb(k,j,l)) - zt2*aimag(     1ffb(k,j,l)) + conjg(zc)  110 continuec modes with n = 0, nx/2 are special      sum1 = sum1 + real(fx(k,1,l))      sum2 = sum2 + aimag(fx(k,1,l))      fx(k,1,l) = fx(k,1,l) + zt1*real(ffb(k,1,l)) + zc      fx(k1,1,l) = conjg(zt1)*aimag(ffb(k,1,l)) + conjg(zc)c potential at x = Lx      bv(k,6) = zt4 + cmplx(sum1,sum2)c potential at x = 0c     bv(k,5) = zt3 + cmplx(sum1,sum2)  120 continuec find constants for solution of homogeneous equation      rho = aimag(bv(1,4))      rholx = .5*rho*anxc find constants for solution of homogeneous equation      at2 = -(.5*(bv(1,2) - bv(1,1)) + bv(1,4))      at3 = .5*at2*anx      at1 = at2*aimag(ffb(1,1,l))      at4 = -bv(1,3)c calculate energies      wp = wp - .5*(at2*bv(1,4) - rho*(rholx*anx/6. + 2.*at4))      wb = wb - .5*(bv(1,2) - bv(1,1))*at2      we = anx*float(ny)*(wp + wb)/affpc homogenous potential at x = Lx      bv(1,6) = cmplx(-at3,0.)c homogenous potential at x = 0c     bv(1,5) = cmplx(at3,0.)      at3 = .5*rhoc find boundary values of periodic solution      sum1 = 0.c add solution of homogeneous equation to periodic solution      do 130 j = 2, nxh      sum1 = sum1 + real(fx(1,j,l))      fx(1,j,l) = fx(1,j,l) + cmplx(at1 + at3*real(ffb(1,j,l)),at2*aimag     1(ffb(1,j,l)))  130 continue      sum1 = sum1 + sum1      fx(1,1,l) = at3*conjg(ffb(1,1,l)) + cmplx(at1 + at4,at1)c potential at x = Lx      bv(1,6) = bv(1,6) + cmplx(sum1+at4,0.)c potential at x = 0c     bv(1,5) = bv(1,5) + cmplx(sum1+at4,0.)  140 continue      return      end