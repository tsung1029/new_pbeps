c 2d parallel PIC library for solving field equationsc written by viktor k. decyk, uclac copyright 1995, regents of the university of californiac update: february 7, 2006c-----------------------------------------------------------------------      subroutine PCGUARD2X(fxy,nyp,nx,nxe,nypmx,nblok)c replicate extended periodic fieldc quadratic interpolation, for distributed data      implicit none      real fxy      integer nyp, nx, nxe, nypmx, nblok      dimension fxy(2,nxe,nypmx,nblok), nyp(nblok)      integer i, k, l, nyp3      do 30 l = 1, nblok      nyp3 = nyp(l) + 3      do 20 k = 1, nyp3      do 10 i = 1, 2      fxy(i,1,k,l) = fxy(i,nx+1,k,l)      fxy(i,nx+2,k,l) = fxy(i,2,k,l)      fxy(i,nx+3,k,l) = fxy(i,3,k,l)   10 continue   20 continue   30 continue      return      endc-----------------------------------------------------------------------      subroutine PDGUARD2X(q,nyp,nx,nxe,nypmx,nblok)c replicate extended periodic scalar fieldc quadratic interpolation, for distributed data      implicit none      real q      integer nyp, nx, nxe, nypmx, nblok      dimension q(nxe,nypmx,nblok), nyp(nblok)      integer k, l, nyp3      do 20 l = 1, nblok      nyp3 = nyp(l) + 3      do 10 k = 1, nyp3      q(1,k,l) = q(nx+1,k,l)      q(nx+2,k,l) = q(2,k,l)      q(nx+3,k,l) = q(3,k,l)   10 continue   20 continue      return      endc-----------------------------------------------------------------------      subroutine PBGUARD2X(bxy,nyp,nx,nxe,nypmx,nblok)c replicate extended periodic vector fieldc quadratic interpolation, for distributed data      implicit none      real bxy      integer nyp, nx, nxe, nypmx, nblok      dimension bxy(3,nxe,nypmx,nblok), nyp(nblok)      integer i, k, l, nyp3      do 30 l = 1, nblok      nyp3 = nyp(l) + 3      do 20 k = 1, nyp3      do 10 i = 1, 3      bxy(i,1,k,l) = bxy(i,nx+1,k,l)      bxy(i,nx+2,k,l) = bxy(i,2,k,l)      bxy(i,nx+3,k,l) = bxy(i,3,k,l)   10 continue   20 continue   30 continue      return      endc-----------------------------------------------------------------------      subroutine PSCGUARD2(cu,nyp,xj0,yj0,zj0,nx,nxe,nypmx,nblok)c initialize extended periodic fieldc quadratic interpolation, for distributed data      implicit none      real cu, xj0, yj0, zj0      integer nyp, nx, nxe, nypmx, nblok      dimension cu(3,nxe,nypmx,nblok), nyp(nblok)      integer i, j, k, l, nyp3, nx3c initialize extended field, with zero in the edges      nx3 = nx + 3      do 60 l = 1, nblok      nyp3 = nyp(l) + 3      do 30 k = 1, nyp(l)      do 10 j = 1, nx      cu(1,j+1,k+1,l) = xj0      cu(2,j+1,k+1,l) = yj0      cu(3,j+1,k+1,l) = zj0   10 continue      do 20 i = 1, 3      cu(i,1,k+1,l) = 0.      cu(i,nx+2,k+1,l) = 0.      cu(i,nx+3,k+1,l) = 0.   20 continue   30 continue      do 50 j = 1, nx3      do 40 i = 1, 3      cu(i,j,1,l) = 0.      cu(i,j,nyp3-1,l) = 0.      cu(i,j,nyp3,l) = 0.   40 continue   50 continue   60 continue      return      endc-----------------------------------------------------------------------      subroutine PSCGUARD22(cu,nyp,xj0,yj0,nx,nxe,nypmx,nblok)c initialize extended periodic fieldc quadratic interpolation, for distributed data      implicit none      real cu, xj0, yj0      integer nyp, nx, nxe, nypmx, nblok      dimension cu(2,nxe,nypmx,nblok), nyp(nblok)      integer i, j, k, l, nyp3, nx3c initialize extended field, with zero in the edges      nx3 = nx + 3      do 60 l = 1, nblok      nyp3 = nyp(l) + 3      do 30 k = 1, nyp(l)      do 10 j = 1, nx      cu(1,j+1,k+1,l) = xj0      cu(2,j+1,k+1,l) = yj0   10 continue      do 20 i = 1, 2      cu(i,1,k+1,l) = 0.      cu(i,nx+2,k+1,l) = 0.      cu(i,nx+3,k+1,l) = 0.   20 continue   30 continue      do 50 j = 1, nx3      do 40 i = 1, 2      cu(i,j,1,l) = 0.      cu(i,j,nyp3-1,l) = 0.      cu(i,j,nyp3,l) = 0.   40 continue   50 continue   60 continue      return      endc-----------------------------------------------------------------------      subroutine PSGUARD2(q,nyp,qi0,nx,nxe,nypmx,nblok)c initialize extended periodic scalar fieldc quadratic interpolation, for distributed data      implicit none      real q, qi0      integer nyp, nx, nxe, nypmx, nblok      dimension q(nxe,nypmx,nblok), nyp(nblok)      integer j, k, l, nyp3, nx3c initialize extended field, with zero in the edges      nx3 = nx + 3      do 40 l = 1, nblok      nyp3 = nyp(l) + 3      do 20 k = 1, nyp(l)      do 10 j = 1, nx      q(j+1,k+1,l) = qi0   10 continue      q(1,k+1,l) = 0.      q(nx+2,k+1,l) = 0.      q(nx+3,k+1,l) = 0.   20 continue      do 30 j = 1, nx3      q(j,1,l) = 0.      q(j,nyp3-1,l) = 0.      q(j,nyp3,l) = 0.   30 continue   40 continue      return      endc-----------------------------------------------------------------------      subroutine PACGUARD2X(cu,nyp,nx,nxe,nypmx,nblok)c accumulate extended periodic fieldc quadratic interpolation, for distributed data      implicit none      real cu      integer nyp, nx, nxe, nypmx, nblok      dimension cu(3,nxe,nypmx,nblok), nyp(nblok)      integer i, k, l, nyp3c accumulate edges of extended field      do 30 l = 1, nblok      nyp3 = nyp(l) + 3      do 20 k = 1, nyp3      do 10 i = 1, 3      cu(i,2,k,l) = cu(i,2,k,l) + cu(i,nx+2,k,l)      cu(i,3,k,l) = cu(i,3,k,l) + cu(i,nx+3,k,l)      cu(i,nx+1,k,l) = cu(i,nx+1,k,l) + cu(i,1,k,l)      cu(i,1,k,l) = 0.      cu(i,nx+2,k,l) = 0.      cu(i,nx+3,k,l) = 0.   10 continue   20 continue   30 continue      return      endc-----------------------------------------------------------------------      subroutine PACGUARD22X(cu,nyp,nx,nxe,nypmx,nblok)c accumulate extended periodic fieldc quadratic interpolation, for distributed data      implicit none      real cu      integer nyp, nx, nxe, nypmx, nblok      dimension cu(2,nxe,nypmx,nblok), nyp(nblok)      integer i, k, l, nyp3c accumulate edges of extended field      do 30 l = 1, nblok      nyp3 = nyp(l) + 3      do 20 k = 1, nyp3      do 10 i = 1, 2      cu(i,2,k,l) = cu(i,2,k,l) + cu(i,nx+2,k,l)      cu(i,3,k,l) = cu(i,3,k,l) + cu(i,nx+3,k,l)      cu(i,nx+1,k,l) = cu(i,nx+1,k,l) + cu(i,1,k,l)      cu(i,1,k,l) = 0.      cu(i,nx+2,k,l) = 0.      cu(i,nx+3,k,l) = 0.   10 continue   20 continue   30 continue      return      endc-----------------------------------------------------------------------      subroutine PAGUARD2X(q,nyp,nx,nxe,nypmx,nblok)c accumulate extended periodic scalar fieldc quadratic interpolation, for distributed data      implicit none      real q      integer nyp, nx, nxe, nypmx, nblok      dimension q(nxe,nypmx,nblok), nyp(nblok)      integer k, l, nyp3c accumulate edges of extended field      do 20 l = 1, nblok      nyp3 = nyp(l) + 3      do 10 k = 1, nyp3      q(2,k,l) = q(2,k,l) + q(nx+2,k,l)      q(3,k,l) = q(3,k,l) + q(nx+3,k,l)      q(nx+1,k,l) = q(nx+1,k,l) + q(1,k,l)      q(1,k,l) = 0.      q(nx+2,k,l) = 0.      q(nx+3,k,l) = 0.   10 continue   20 continue      return      endc-----------------------------------------------------------------------      subroutine PZCGUARD2(cu,nyp,nx,nxe,nypmx,nblok)c zero out guard cells in extended periodic vector fieldc quadratic interpolation, for distributed data      implicit none      real cu      integer nyp, nx, nxe, nypmx, nblok      dimension cu(3,nxe,nypmx,nblok), nyp(nblok)      integer i, j, k, l, nx3      nx3 = nx + 3      do 50 l = 1, nblokc zero out guard cells in x      do 20 k = 1, nyp(l)      do 10 i = 1, 3      cu(i,1,k+1,l) = 0.      cu(i,nx+2,k+1,l) = 0.      cu(i,nx+3,k+1,l) = 0.   10 continue   20 continuec zero out guard cells in y      do 40 j = 1, nx3      do 30 i = 1, 3      cu(i,j,1,l) = 0.      cu(i,j,nyp(l)+2,l) = 0.      cu(i,j,nyp(l)+3,l) = 0.   30 continue   40 continue   50 continue      return      endc-----------------------------------------------------------------------      subroutine PZCGUARD22(cu,nyp,nx,nxe,nypmx,nblok)c zero out guard cells in extended periodic vector fieldc quadratic interpolation, for distributed data      implicit none      real cu      integer nyp, nx, nxe, nypmx, nblok      dimension cu(2,nxe,nypmx,nblok), nyp(nblok)      integer i, j, k, l, nx3      nx3 = nx + 3      do 50 l = 1, nblokc zero out guard cells in x      do 20 k = 1, nyp(l)      do 10 i = 1, 2      cu(i,1,k+1,l) = 0.      cu(i,nx+2,k+1,l) = 0.      cu(i,nx+3,k+1,l) = 0.   10 continue   20 continuec zero out guard cells in y      do 40 j = 1, nx3      do 30 i = 1, 2      cu(i,j,1,l) = 0.      cu(i,j,nyp(l)+2,l) = 0.      cu(i,j,nyp(l)+3,l) = 0.   30 continue   40 continue   50 continue      return      endc-----------------------------------------------------------------------      subroutine PZGUARD2(q,nyp,nx,nxe,nypmx,nblok)c zero out guard cells in extended periodic scalar fieldc quadratic interpolation, for distributed data      implicit none      real q      integer nyp, nx, nxe, nypmx, nblok      dimension q(nxe,nypmx,nblok), nyp(nblok)      integer j, k, l, nx3      nx3 = nx + 3      do 30 l = 1, nblokc zero out guard cells in x      do 10 k = 1, nyp(l)      q(1,k+1,l) = 0.      q(nx+2,k+1,l) = 0.      q(nx+3,k+1,l) = 0.   10 continuec zero out guard cells in y      do 20 j = 1, nx3      q(j,1,l) = 0.      q(j,nyp(l)+2,l) = 0.      q(j,nyp(l)+3,l) = 0.   20 continue   30 continue      return      endc-----------------------------------------------------------------------      subroutine PCGUARD2XL(fxy,nyp,nx,nxe,nypmx,nblok)c replicate extended periodic fieldc linear interpolation, for distributed data      implicit none      real fxy      integer nyp, nx, nxe, nypmx, nblok      dimension fxy(2,nxe,nypmx,nblok), nyp(nblok)      integer k, l, nyp1      do 20 l = 1, nblok      nyp1 = nyp(l) + 1      do 10 k = 1, nyp1      fxy(1,nx+1,k,l) = fxy(1,1,k,l)      fxy(2,nx+1,k,l) = fxy(2,1,k,l)   10 continue   20 continue      return      endc-----------------------------------------------------------------------      subroutine PDGUARD2XL(q,nyp,nx,nxe,nypmx,nblok)c replicate extended periodic scalar fieldc linear interpolation, for distributed data      implicit none      real q      integer nyp, nx, nxe, nypmx, nblok      dimension q(nxe,nypmx,nblok), nyp(nblok)      integer k, l, nyp1      do 20 l = 1, nblok      nyp1 = nyp(l) + 1      do 10 k = 1, nyp1      q(nx+1,k,l) = q(1,k,l)   10 continue   20 continue      return      endc-----------------------------------------------------------------------      subroutine PBGUARD2XL(bxy,nyp,nx,nxe,nypmx,nblok)c replicate extended periodic vector fieldc linear interpolation, for distributed data      implicit none      real bxy      integer nyp, nx, nxe, nypmx, nblok      dimension bxy(3,nxe,nypmx,nblok), nyp(nblok)      integer k, l, nyp1      do 20 l = 1, nblok      nyp1 = nyp(l) + 1      do 10 k = 1, nyp1      bxy(1,nx+1,k,l) = bxy(1,1,k,l)      bxy(2,nx+1,k,l) = bxy(2,1,k,l)      bxy(3,nx+1,k,l) = bxy(3,1,k,l)   10 continue   20 continue      return      endc-----------------------------------------------------------------------      subroutine PSCGUARD2L(cu,nyp,xj0,yj0,zj0,nx,nxe,nypmx,nblok)c initialize extended periodic fieldc linear interpolation, for distributed data      implicit none      real cu, xj0, yj0, zj0      integer nyp, nx, nxe, nypmx, nblok      dimension cu(3,nxe,nypmx,nblok), nyp(nblok)      integer i, j, k, l, nyp1, nx1c initialize extended field, with zero in the edges      nx1 = nx + 1      do 60 l = 1, nblok      nyp1 = nyp(l) + 1      do 30 k = 1, nyp(l)      do 10 j = 1, nx      cu(1,j,k,l) = xj0      cu(2,j,k,l) = yj0      cu(3,j,k,l) = zj0   10 continue      do 20 i = 1, 3      cu(i,nx+1,k,l) = 0.   20 continue   30 continue      do 50 j = 1, nx1      do 40 i = 1, 3      cu(i,j,nyp1,l) = 0.   40 continue   50 continue   60 continue      return      endc-----------------------------------------------------------------------      subroutine PSCGUARD22L(cu,nyp,xj0,yj0,nx,nxe,nypmx,nblok)c initialize extended periodic fieldc linear interpolation, for distributed data      implicit none      real cu, xj0, yj0      integer nyp, nx, nxe, nypmx, nblok      dimension cu(2,nxe,nypmx,nblok), nyp(nblok)      integer i, j, k, l, nyp1, nx1c initialize extended field, with zero in the edges      nx1 = nx + 1      do 60 l = 1, nblok      nyp1 = nyp(l) + 1      do 30 k = 1, nyp(l)      do 10 j = 1, nx      cu(1,j,k,l) = xj0      cu(2,j,k,l) = yj0   10 continue      do 20 i = 1, 2      cu(i,nx+1,k,l) = 0.   20 continue   30 continue      do 50 j = 1, nx1      do 40 i = 1, 2      cu(i,j,nyp1,l) = 0.   40 continue   50 continue   60 continue      return      endc-----------------------------------------------------------------------      subroutine PSGUARD2L(q,nyp,qi0,nx,nxe,nypmx,nblok)c initialize extended periodic scalar fieldc linear interpolation, for distributed data      implicit none      real q, qi0      integer nyp, nx, nxe, nypmx, nblok      dimension q(nxe,nypmx,nblok), nyp(nblok)      integer j, k, l, nyp1, nx1c initialize extended field, with zero in the edges      nx1 = nx + 1      do 40 l = 1, nblok      nyp1 = nyp(l) + 1      do 20 k = 1, nyp(l)      do 10 j = 1, nx      q(j,k,l) = qi0   10 continue      q(nx+1,k,l) = 0.   20 continue      do 30 j = 1, nx1      q(j,nyp1,l) = 0.   30 continue   40 continue      return      endc-----------------------------------------------------------------------      subroutine PACGUARD2XL(cu,nyp,nx,nxe,nypmx,nblok)c accumulate extended periodic fieldc linear interpolation, for distributed data      implicit none      real cu      integer nyp, nx, nxe, nypmx, nblok      dimension cu(3,nxe,nypmx,nblok), nyp(nblok)      integer i, k, l, nyp1c accumulate edges of extended field      do 30 l = 1, nblok      nyp1 = nyp(l) + 1      do 20 k = 1, nyp1      do 10 i = 1, 3      cu(i,1,k,l) = cu(i,1,k,l) + cu(i,nx+1,k,l)      cu(i,nx+1,k,l) = 0.   10 continue   20 continue   30 continue      return      endc-----------------------------------------------------------------------      subroutine PACGUARD22XL(cu,nyp,nx,nxe,nypmx,nblok)c accumulate extended periodic fieldc linear interpolation, for distributed data      implicit none      real cu      integer nyp, nx, nxe, nypmx, nblok      dimension cu(2,nxe,nypmx,nblok), nyp(nblok)      integer i, k, l, nyp1c accumulate edges of extended field      do 30 l = 1, nblok      nyp1 = nyp(l) + 1      do 20 k = 1, nyp1      do 10 i = 1, 2      cu(i,1,k,l) = cu(i,1,k,l) + cu(i,nx+1,k,l)      cu(i,nx+1,k,l) = 0.   10 continue   20 continue   30 continue      return      endc-----------------------------------------------------------------------      subroutine PAGUARD2XL(q,nyp,nx,nxe,nypmx,nblok)c accumulate extended periodic scalar fieldc linear interpolation, for distributed data      implicit none      real q      integer nyp, nx, nxe, nypmx, nblok      dimension q(nxe,nypmx,nblok), nyp(nblok)      integer k, l, nyp1c accumulate edges of extended field      do 20 l = 1, nblok      nyp1 = nyp(l) + 1      do 10 k = 1, nyp1      q(1,k,l) = q(1,k,l) + q(nx+1,k,l)      q(nx+1,k,l) = 0.   10 continue   20 continue      return      endc-----------------------------------------------------------------------      subroutine PZCGUARD2L(cu,nyp,nx,nxe,nypmx,nblok)c zero out guard cells in extended periodic vector fieldc linear interpolation, for distributed data      implicit none      real cu      integer nyp, nx, nxe, nypmx, nblok      dimension cu(3,nxe,nypmx,nblok), nyp(nblok)      integer i, j, k, l, nx1      nx1 = nx + 1c zero out guard cells in x      do 50 l = 1, nblokc zero out guard cells in x      do 20 k = 1, nyp(l)      do 10 i = 1, 3      cu(i,nx+1,k,l) = 0.   10 continue   20 continuec zero out guard cells in y      do 40 j = 1, nx1      do 30 i = 1, 3      cu(i,j,nyp(l)+1,l) = 0.   30 continue   40 continue   50 continue      return      endc-----------------------------------------------------------------------      subroutine PZCGUARD22L(cu,nyp,nx,nxe,nypmx,nblok)c zero out guard cells in extended periodic vector fieldc linear interpolation, for distributed data      implicit none      real cu      integer nyp, nx, nxe, nypmx, nblok      dimension cu(2,nxe,nypmx,nblok), nyp(nblok)      integer i, j, k, l, nx1      nx1 = nx + 1c zero out guard cells in x      do 50 l = 1, nblokc zero out guard cells in x      do 20 k = 1, nyp(l)      do 10 i = 1, 2      cu(i,nx+1,k,l) = 0.   10 continue   20 continuec zero out guard cells in y      do 40 j = 1, nx1      do 30 i = 1, 2      cu(i,j,nyp(l)+1,l) = 0.   30 continue   40 continue   50 continue      return      endc-----------------------------------------------------------------------      subroutine PZGUARD2L(q,nyp,nx,nxe,nypmx,nblok)c zero out guard cells in extended periodic scalar fieldc linear interpolation, for distributed data      implicit none      real q      integer nyp, nx, nxe, nypmx, nblok      dimension q(nxe,nypmx,nblok), nyp(nblok)      integer j, k, l, nx1      nx1 = nx + 1c zero out guard cells in x      do 30 l = 1, nblokc zero out guard cells in x      do 10 k = 1, nyp(l)      q(nx+1,k,l) = 0.   10 continuec zero out guard cells in y      do 20 j = 1, nx1      q(j,nyp(l)+1,l) = 0.   20 continue   30 continue      return      endc-----------------------------------------------------------------------      subroutine PPOISP2(q,fx,fy,isign,ffc,ax,ay,affp,we,nx,ny,kstrt,nyv     1,kxp,jblok,nyhd)c this subroutine solves 2d poisson's equation in fourier space forc force/charge (or convolution of electric field over particle shape)c or for potential, or provides a smoothing function,c with periodic boundary conditions for distributed data.c for isign = 0, input: isign,ax,ay,affp,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: ffcc for isign = -1, input: q,ffc,isign,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: fx,fy,wec approximate flop count is: 33*nxc*nyc + 15*(nxc + nyc)c for isign = 1, input: q,ffc,isign,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: fx,wec approximate flop count is: 21*nxc*nyc + 11*(nxc + nyc)c for isign = 2, input: q,ffc,isign,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: fyc approximate flop count is: 4*nxc*nyc + 2*(nxc + nyc)c where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc if isign < 0, force/charge is calculated using the equations:c fx(kx,ky) = -sqrt(-1)*kx*g(kx,ky)*q(kx,ky)*s(kx,ky),c fy(kx,ky) = -sqrt(-1)*ky*g(kx,ky)*q(kx,ky)*s(kx,ky),c where kx = 2pi*j/nx, ky = 2pi*k/ny, and j,k = fourier mode numbers,c g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky),c s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2), except forc fx(kx=pi) = fy(kx=pi) = fx(ky=pi) = fy(ky=pi) = 0, andc fx(kx=0,ky=0) = fy(kx=0,ky=0) = 0.c if isign = 1, potential is calculated using the equation:c fx(kx,ky) = g(kx,ky)*q(kx,ky)c if isign = 2, smoothing is calculated using the equation:c fy(kx,ky) = q(kx,ky)*s(kx,ky)c q(k,j,l) = complex charge density for fourier mode (jj-1,k-1)c fx(k,j,l) = x component of complex force/charge,c fy(k,j,l) = y component of complex force/charge,c for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c jblok = number of data blocksc kxp = number of data values per blockc kstrt = starting data block numberc if isign = 0, form factor array is preparedc aimag(ffc(k,j,l)) = finite-size particle shape factor sc real(ffc(k,j,l)) = potential green's function gc for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c ax/ay = half-width of particle in x/y directionc affp = normalization constant = nx*ny/np, where np=number of particlesc electric field energy is also calculated, usingc we = nx*ny*sum((affp/(kx**2+ky**2))*|q(kx,ky)*s(kx,ky)|**2)c nx/ny = system length in x/y directionc nyv = first dimension of field arrays, must be >= nyc nyhd = first dimension of form factor array, must be >= nyh      double precision wp      complex q, fx, fy, ffc, zero      dimension q(nyv,kxp,jblok)      dimension fx(nyv,kxp,jblok), fy(nyv,kxp,jblok)      dimension ffc(nyhd,kxp,jblok)      nxh = nx/2      nyh = ny/2      ny2 = ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx)      dny = 6.28318530717959/float(ny)      zero = cmplx(0.,0.)      if (isign.ne.0) go to 40      if (kstrt.gt.nxh) returnc prepare form factor array      do 30 l = 1, jblok      joff = kxp*(l + ks) - 1      do 20 j = 1, kxp      dkx = dnx*float(j + joff)      at1 = dkx*dkx      at2 = (dkx*ax)**2      do 10 k = 1, nyh      dky = dny*float(k - 1)      at3 = dky*dky + at1      at4 = exp(-.5*((dky*ay)**2 + at2))      if (at3.eq.0.) then         ffc(k,j,l) = cmplx(affp,1.)      else         ffc(k,j,l) = cmplx(affp*at4/at3,at4)      endif   10 continue   20 continue   30 continue      return   40 if (isign.gt.0) go to 100c calculate force/charge and sum field energy      wp = 0.0d0      if (kstrt.gt.nxh) go to 90      do 80 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 60 j = 1, kxp      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 50 k = 2, nyh         k1 = ny2 - k         at1 = real(ffc(k,j,l))*aimag(ffc(k,j,l))         at2 = dkx*at1         at3 = dny*float(k - 1)*at1         fx(k,j,l) = at2*cmplx(aimag(q(k,j,l)),-real(q(k,j,l)))         fx(k1,j,l) = at2*cmplx(aimag(q(k1,j,l)),-real(q(k1,j,l)))         fy(k,j,l) = at3*cmplx(aimag(q(k,j,l)),-real(q(k,j,l)))         fy(k1,j,l) = at3*cmplx(-aimag(q(k1,j,l)),real(q(k1,j,l)))         wp = wp + at1*(q(k,j,l)*conjg(q(k,j,l)) + q(k1,j,l)*conjg(q(k1,     1j,l)))   50    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         at1 = real(ffc(1,j,l))*aimag(ffc(1,j,l))         fx(1,j,l) = dkx*at1*cmplx(aimag(q(1,j,l)),-real(q(1,j,l)))         fx(k1,j,l) = zero         fy(1,j,l) = zero         fy(k1,j,l) = zero         wp = wp + at1*(q(1,j,l)*conjg(q(1,j,l)))      endif   60 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 70 k = 2, nyh         k1 = ny2 - k         at1 = real(ffc(k,1,l))*aimag(ffc(k,1,l))         fx(k,1,l) = zero         fx(k1,1,l) = zero         fy(k,1,l) = dny*float(k - 1)*at1*cmplx(aimag(q(k,1,l)),-real(q(     1k,1,l)))         fy(k1,1,l) = zero         wp = wp + at1*(q(k,1,l)*conjg(q(k,1,l)))   70    continue         k1 = nyh + 1         fx(1,1,l) = zero         fx(k1,1,l) = zero         fy(1,1,l) = zero         fy(k1,1,l) = zero      endif   80 continue   90 continue      we = float(nx*ny)*wp      returnc calculate potential and sum field energy  100 if (isign.gt.1) go to 160      wp = 0.0d0      if (kstrt.gt.nxh) go to 150      do 140 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 120 j = 1, kxp      if ((j+joff).gt.0) then         do 110 k = 2, nyh         k1 = ny2 - k         at2 = real(ffc(k,j,l))         at1 = at2*aimag(ffc(k,j,l))         fx(k,j,l) = at2*q(k,j,l)         fx(k1,j,l) = at2*q(k1,j,l)         wp = wp + at1*(q(k,j,l)*conjg(q(k,j,l)) + q(k1,j,l)*conjg(q(k1,     1j,l)))  110    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         at2 = real(ffc(1,j,l))         at1 = at2*aimag(ffc(1,j,l))         fx(1,j,l) = at2*q(1,j,l)         fx(k1,j,l) = zero         wp = wp + at1*(q(1,j,l)*conjg(q(1,j,l)))      endif  120 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 130 k = 2, nyh         k1 = ny2 - k         at2 = real(ffc(k,1,l))         at1 = at2*aimag(ffc(k,1,l))         fx(k,1,l) = at2*q(k,1,l)         fx(k1,1,l) = zero         wp = wp + at1*(q(k,1,l)*conjg(q(k,1,l)))  130    continue         k1 = nyh + 1         fx(1,1,l) = zero         fx(k1,1,l) = zero      endif  140 continue  150 continue      we = float(nx*ny)*wp      returnc calculate smoothing  160 if (kstrt.gt.nxh) go to 210      do 200 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 180 j = 1, kxp      if ((j+joff).gt.0) then         do 170 k = 2, nyh         k1 = ny2 - k         at1 = aimag(ffc(k,j,l))         fy(k,j,l) = at1*q(k,j,l)         fy(k1,j,l) = at1*q(k1,j,l)  170    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         at1 = aimag(ffc(1,j,l))         fy(1,j,l) = at1*q(1,j,l)         fy(k1,j,l) = zero      endif  180 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 190 k = 2, nyh         k1 = ny2 - k         at1 = aimag(ffc(k,1,l))         fy(k,1,l) = at1*q(k,1,l)         fy(k1,1,l) = zero  190    continue         k1 = nyh + 1         fy(1,1,l) = cmplx(aimag(ffc(1,1,l))*real(q(1,1,l)),0.)         fy(k1,1,l) = zero      endif  200 continue  210 continue      return      endc-----------------------------------------------------------------------      subroutine PPOISP21(q,fx,isign,ffc,ax,affp,we,nx,kstrt,kxp,jblok)c this subroutine solves 1d poisson's equation in fourier space forc force/charge (or convolution of electric field over particle shape)c or for potential, or provides a smoothing function,c with periodic boundary conditions for distributed data.c for isign = 0, input: isign,ax,affp,nx,kstrt,kxp,jblok, output: ffcc for isign = -1, input: q,ffc,isign,nx,kstrt,kxp,jblok, output: fx,wec approximate flop count is: 15*nxcc for isign = 1, input: q,ffc,isign,nx,kstrt,kxp,jblok, output: fx,wec approximate flop count is: 11*nxcc for isign = 2, input: q,ffc,isign,nx,kstrt,kxp,jblok, output: fxc approximate flop count is: 2*nxcc where nxc = (nx/2-1)/nvp, and nvp = number of procsc if isign < 0, force/charge is calculated using the equations:c fx(kx) = -sqrt(-1)*kx*g(kx)*q(kx)*s(kx),c where kx = 2pi*j/nx, and j = fourier mode number,c g(kx) = (affp/(kx**2)*s(kx,ky),c s(kx) = exp(-((kx*ax)**2)/2), except forc fx(kx=pi) = 0, and fx(kx=0) = 0.c if isign = 1, potential is calculated using the equation:c fx(kx) = g(kx)*q(kx)c if isign = 2, smoothing is calculated using the equation:c fx(kx) = q(kx)*s(kx)c q(j,l) = complex charge density for fourier mode (jj-1)c fx(j,l) = x component of complex force/charge,c for fourier mode (jj-1, where jj = j + kxp*(l - 1)c jblok = number of data blocksc kxp = number of data values per blockc kstrt = starting data block numberc if isign = 0, form factor array is preparedc aimag(ffc(j,l)) = finite-size particle shape factor sc real(ffc(j,l)) = potential green's function gc for fourier mode (jj-1), where jj = j + kxp*(l - 1)c ax = half-width of particle in x directionc affp = normalization constant = nx/np, where np=number of particlesc electric field energy is also calculated, usingc we = nx*sum((affp/(kx**2))*|q(kx)*s(kx)|**2)c nx = system length in x direction      double precision wp      complex q, fx, ffc, zero      dimension q(kxp,jblok), fx(kxp,jblok), ffc(kxp,jblok)      nxh = nx/2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx)      zero = cmplx(0.,0.)      if (isign.ne.0) go to 30      if (kstrt.gt.nxh) returnc prepare form factor array      do 20 l = 1, jblok      joff = kxp*(l + ks) - 1      do 10 j = 1, kxp      dkx = dnx*float(j + joff)      at1 = dkx*dkx      at2 = exp(-.5*((dkx*ax)**2))      if (at1.eq.0.) then         ffc(j,l) = cmplx(affp,1.)      else         ffc(j,l) = cmplx(affp*at2/at1,at2)      endif   10 continue   20 continue      return   30 if (isign.gt.0) go to 70c calculate force/charge and sum field energy      wp = 0.0d0      if (kstrt.gt.nxh) go to 60      do 50 l = 1, jblokc mode numbers 0 < kx < nx/2      joff = kxp*(l + ks) - 1      do 40 j = 1, kxp      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         at1 = real(ffc(j,l))*aimag(ffc(j,l))         fx(j,l) = dkx*at1*cmplx(aimag(q(j,l)),-real(q(j,l)))         wp = wp + at1*(q(j,l)*conjg(q(j,l)))      endif   40 continue      if ((l+ks).eq.0) fx(1,l) = zero   50 continue   60 continue      we = float(nx)*wp      returnc calculate potential and sum field energy   70 if (isign.gt.1) go to 110      wp = 0.0d0      if (kstrt.gt.nxh) go to 100      do 90 l = 1, jblokc mode numbers 0 < kx < nx/2      joff = kxp*(l + ks) - 1      do 80 j = 1, kxp      if ((j+joff).gt.0) then         at2 = real(ffc(j,l))         at1 = at2*aimag(ffc(j,l))         fx(j,l) = at2*q(j,l)         wp = wp + at1*(q(j,l)*conjg(q(j,l)))      endif   80 continue      if ((l+ks).eq.0) fx(1,l) = zero   90 continue  100 continue      we = float(nx)*wp      returnc calculate smoothing  110 if (kstrt.gt.nxh) go to 140      do 130 l = 1, jblokc mode numbers 0 < kx < nx/2      joff = kxp*(l + ks) - 1      do 120 j = 1, kxp      if ((j+joff).gt.0) then         at1 = aimag(ffc(j,l))         fx(j,l) = at1*q(j,l)      endif  120 continue      if ((l+ks).eq.0) then         fx(1,l) = cmplx(aimag(ffc(1,l))*real(q(1,l)),0.)      endif  130 continue  140 continue      return      endc-----------------------------------------------------------------------      subroutine PPOIS22(q,fxy,isign,ffc,ax,ay,affp,we,nx,ny,kstrt,nyv,k     1xp,jblok,nyhd)c this subroutine solves 2d poisson's equation in fourier space forc force/charge (or convolution of electric field over particle shape)c with periodic boundary conditions, for distributed data.c for isign = 0, input: isign,ax,ay,affp,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: ffcc for isign /= 0, input: q,ffc,isign,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: fxy,wec approximate flop count is: 33*nxc*nyc + 15*(nxc + nyc)c where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc the equation used is:c fx(kx,ky) = -sqrt(-1)*kx*g(kx,ky)*s(kx,ky)*q(kx,ky),c fy(kx,ky) = -sqrt(-1)*ky*g(kx,ky)*s(kx,ky)*q(kx,ky),c where kx = 2pi*j/nx, ky = 2pi*k/ny, and j,k = fourier mode numbers,c g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky),c s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2), except forc fx(kx=pi) = fy(kx=pi) = fx(ky=pi) = fy(ky=pi) = 0, andc fx(kx=0,ky=0) = fy(kx=0,ky=0) = 0.c q(k,j,l) = complex charge density for fourier mode (jj-1,k-1)c fxy(1,k,j,l) = x component of complex force/charge,c fxy(2,k,j,l) = y component of complex force/charge,c for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c jblok = number of data blocksc kxp = number of data values per blockc kstrt = starting data block numberc if isign = 0, form factor array is preparedc if isign is not equal to 0, force/charge is calculated.c aimag(ffc(k,j,l)) = finite-size particle shape factor sc real(ffc(k,j,l)) = potential green's function gc for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c ax/ay = half-width of particle in x/y directionc affp = normalization constant = nx*ny/np, where np=number of particlesc electric field energy is also calculated, usingc we = nx*ny*sum((affp/(kx**2+ky**2))*|q(kx,ky)*s(kx,ky)|**2)c nx/ny = system length in x/y directionc nyv = first dimension of field arrays, must be >= nyc nyhd = first dimension of form factor array, must be >= nyh      double precision wp      complex q, fxy, ffc, zero, zt1, zt2      dimension q(nyv,kxp,jblok), fxy(2,nyv,kxp,jblok)      dimension ffc(nyhd,kxp,jblok)      nxh = nx/2      nyh = ny/2      ny2 = ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx)      dny = 6.28318530717959/float(ny)      zero = cmplx(0.,0.)      if (isign.ne.0) go to 40      if (kstrt.gt.nxh) returnc prepare form factor array      do 30 l = 1, jblok      joff = kxp*(l + ks) - 1      do 20 j = 1, kxp      dkx = dnx*float(j + joff)      at1 = dkx*dkx      at2 = (dkx*ax)**2      do 10 k = 1, nyh      dky = dny*float(k - 1)      at3 = dky*dky + at1      at4 = exp(-.5*((dky*ay)**2 + at2))      if (at3.eq.0.) then         ffc(k,j,l) = cmplx(affp,1.)      else         ffc(k,j,l) = cmplx(affp*at4/at3,at4)      endif   10 continue   20 continue   30 continue      returnc calculate force/charge and sum field energy   40 wp = 0.0d0      if (kstrt.gt.nxh) go to 90      do 80 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 60 j = 1, kxp      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 50 k = 2, nyh         k1 = ny2 - k         at1 = real(ffc(k,j,l))*aimag(ffc(k,j,l))         at2 = dkx*at1         at3 = dny*float(k - 1)*at1         zt1 = cmplx(aimag(q(k,j,l)),-real(q(k,j,l)))         zt2 = cmplx(aimag(q(k1,j,l)),-real(q(k1,j,l)))         fxy(1,k,j,l) = at2*zt1         fxy(2,k,j,l) = at3*zt1         fxy(1,k1,j,l) = at2*zt2         fxy(2,k1,j,l) = -at3*zt2         wp = wp + at1*(q(k,j,l)*conjg(q(k,j,l)) + q(k1,j,l)*conjg(q(k1,     1j,l)))   50    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         at1 = real(ffc(1,j,l))*aimag(ffc(1,j,l))         at3 = dkx*at1         zt1 = cmplx(aimag(q(1,j,l)),-real(q(1,j,l)))         fxy(1,1,j,l) = at3*zt1         fxy(2,1,j,l) = zero         fxy(1,k1,j,l) = zero         fxy(2,k1,j,l) = zero         wp = wp + at1*(q(1,j,l)*conjg(q(1,j,l)))      endif   60 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 70 k = 2, nyh         k1 = ny2 - k         at1 = real(ffc(k,1,l))*aimag(ffc(k,1,l))         at2 = dny*float(k - 1)*at1         zt1 = cmplx(aimag(q(k,1,l)),-real(q(k,1,l)))         fxy(1,k,1,l) = zero         fxy(2,k,1,l) = at2*zt1         fxy(1,k1,1,l) = zero         fxy(2,k1,1,l) = zero         wp = wp + at1*(q(k,1,l)*conjg(q(k,1,l)))   70    continue         k1 = nyh + 1         fxy(1,1,1,l) = zero         fxy(2,1,1,l) = zero         fxy(1,k1,1,l) = zero         fxy(2,k1,1,l) = zero      endif   80 continue   90 continue      we = float(nx*ny)*wp      return      endc-----------------------------------------------------------------------      subroutine PPOIS23(q,fxy,isign,ffc,ax,ay,affp,we,nx,ny,kstrt,nyv,k     1xp,jblok,nyhd)c this subroutine solves 2d poisson's equation in fourier space forc force/charge (or convolution of electric field over particle shape)c with periodic boundary conditions.  Zeros out z component.c for distributed data.c for isign = 0, input: isign,ax,ay,affp,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: ffcc for isign /= 0, input: q,ffc,isign,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: fxy,wec approximate flop count is: 33*nxc*nyc + 15*(nxc + nyc)c where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc the equation used is:c fx(kx,ky) = -sqrt(-1)*kx*g(kx,ky)*s(kx,ky)*q(kx,ky),c fy(kx,ky) = -sqrt(-1)*ky*g(kx,ky)*s(kx,ky)*q(kx,ky),c fz(kx,ky) = zero,c where kx = 2pi*j/nx, ky = 2pi*k/ny, and j,k = fourier mode numbers,c g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky),c s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2), except forc fx(kx=pi) = fy(kx=pi) = fx(ky=pi) = fy(ky=pi) = 0, andc fx(kx=0,ky=0) = fy(kx=0,ky=0) = 0.c q(k,j,l) = complex charge density for fourier mode (jj-1,k-1)c fxy(1,k,j,l) = x component of complex force/charge,c fxy(2,k,j,l) = y component of complex force/charge,c fxy(3,k,j,l) = zero,c for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c jblok = number of data blocksc kxp = number of data values per blockc kstrt = starting data block numberc if isign = 0, form factor array is preparedc if isign is not equal to 0, force/charge is calculated.c aimag(ffc(k,j,l)) = finite-size particle shape factor sc real(ffc(k,j,l)) = potential green's function gc for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c ax/ay = half-width of particle in x/y directionc affp = normalization constant = nx*ny/np, where np=number of particlesc electric field energy is also calculated, usingc we = nx*ny*sum((affp/(kx**2+ky**2))*|q(kx,ky)*s(kx,ky)|**2)c nx/ny = system length in x/y directionc nyv = first dimension of field arrays, must be >= nyc nyhd = first dimension of form factor array, must be >= nyh      double precision wp      complex q, fxy, ffc, zero, zt1, zt2      dimension q(nyv,kxp,jblok), fxy(3,nyv,kxp,jblok)      dimension ffc(nyhd,kxp,jblok)      nxh = nx/2      nyh = ny/2      ny2 = ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx)      dny = 6.28318530717959/float(ny)      zero = cmplx(0.,0.)      if (isign.ne.0) go to 40      if (kstrt.gt.nxh) returnc prepare form factor array      do 30 l = 1, jblok      joff = kxp*(l + ks) - 1      do 20 j = 1, kxp      dkx = dnx*float(j + joff)      at1 = dkx*dkx      at2 = (dkx*ax)**2      do 10 k = 1, nyh      dky = dny*float(k - 1)      at3 = dky*dky + at1      at4 = exp(-.5*((dky*ay)**2 + at2))      if (at3.eq.0.) then         ffc(k,j,l) = cmplx(affp,1.)      else         ffc(k,j,l) = cmplx(affp*at4/at3,at4)      endif   10 continue   20 continue   30 continue      returnc calculate force/charge and sum field energy   40 wp = 0.0d0      if (kstrt.gt.nxh) go to 90      do 80 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 60 j = 1, kxp      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 50 k = 2, nyh         k1 = ny2 - k         at1 = real(ffc(k,j,l))*aimag(ffc(k,j,l))         at2 = dkx*at1         at3 = dny*float(k - 1)*at1         zt1 = cmplx(aimag(q(k,j,l)),-real(q(k,j,l)))         zt2 = cmplx(aimag(q(k1,j,l)),-real(q(k1,j,l)))         fxy(1,k,j,l) = at2*zt1         fxy(2,k,j,l) = at3*zt1         fxy(3,k,j,l) = zero         fxy(1,k1,j,l) = at2*zt2         fxy(2,k1,j,l) = -at3*zt2         fxy(3,k1,j,l) = zero         wp = wp + at1*(q(k,j,l)*conjg(q(k,j,l)) + q(k1,j,l)*conjg(q(k1,     1j,l)))   50    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         at1 = real(ffc(1,j,l))*aimag(ffc(1,j,l))         at3 = dkx*at1         zt1 = cmplx(aimag(q(1,j,l)),-real(q(1,j,l)))         fxy(1,1,j,l) = at3*zt1         fxy(2,1,j,l) = zero         fxy(3,1,j,l) = zero         fxy(1,k1,j,l) = zero         fxy(2,k1,j,l) = zero         fxy(3,k1,j,l) = zero         wp = wp + at1*(q(1,j,l)*conjg(q(1,j,l)))      endif   60 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 70 k = 2, nyh         k1 = ny2 - k         at1 = real(ffc(k,1,l))*aimag(ffc(k,1,l))         at2 = dny*float(k - 1)*at1         zt1 = cmplx(aimag(q(k,1,l)),-real(q(k,1,l)))         fxy(1,k,1,l) = zero         fxy(2,k,1,l) = at2*zt1         fxy(3,k,1,l) = zero         fxy(1,k1,1,l) = zero         fxy(2,k1,1,l) = zero         fxy(3,k1,1,l) = zero         wp = wp + at1*(q(k,1,l)*conjg(q(k,1,l)))   70    continue         k1 = nyh + 1         fxy(1,1,1,l) = zero         fxy(2,1,1,l) = zero         fxy(3,1,1,l) = zero         fxy(1,k1,1,l) = zero         fxy(2,k1,1,l) = zero         fxy(3,k1,1,l) = zero      endif   80 continue   90 continue      we = float(nx*ny)*wp      return      endc-----------------------------------------------------------------------      subroutine PDIVF2(f,df,nx,ny,kstrt,ndim,nyv,kxp,jblok)c this subroutine calculates the divergence in fourier spacec input: all except df, output: dfc approximate flop count is: 16*nxc*nyc + 5*(nxc + nyc)c where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc the divergence is calculated using the equation:c df(kx,ky) = sqrt(-1)*(kx*fx(kx,ky)+ky*fy(kx,ky))c where kx = 2pi*j/nx, ky = 2pi*k/ny, and j,k = fourier mode numbers,c except for df(kx=pi) = df(ky=pi) = df(kx=0,ky=0) = 0.c nx/ny = system length in x/y directionc ndim = number of field arrays, must be >= 2c kstrt = starting data block numberc nyv = first dimension of field arrays, must be >= nyc kxp = number of data values per blockc jblok = number of data blocks      complex f, df, zero, zt1      dimension f(ndim,nyv,kxp,jblok), df(nyv,kxp,jblok)      if (ndim.lt.2) return      nxh = nx/2      nyh = ny/2      ny2 = ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx)      dny = 6.28318530717959/float(ny)      zero = cmplx(0.,0.)c calculate the divergence      if (kstrt.gt.nxh) return      do 40 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 20 j = 1, kxp      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 10 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         zt1 = dkx*f(1,k,j,l) + dky*f(2,k,j,l)         df(k,j,l) = cmplx(-aimag(zt1),real(zt1))         zt1 = dkx*f(1,k1,j,l) - dky*f(2,k1,j,l)         df(k1,j,l) = cmplx(-aimag(zt1),real(zt1))   10    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         df(1,j,l) = dkx*cmplx(-aimag(f(1,1,j,l)),real(f(1,1,j,l)))         df(k1,j,l) = zero      endif   20 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 30 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         df(k,1,l) = dky*cmplx(-aimag(f(2,k,1,l)),real(f(2,k,1,l)))         df(k1,1,l) = zero   30    continue         k1 = nyh + 1         df(1,1,l) = zero         df(k1,1,l) = zero      endif   40 continue      return      endc-----------------------------------------------------------------------      subroutine PGRADF2(df,f,nx,ny,kstrt,ndim,nyv,kxp,jblok)c this subroutine calculates the gradient in fourier spacec input: all except f, output: fc approximate flop count is: 12*nxc*nyc + 4*(nxc + nyc)c where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc the gradient is calculated using the equations:c fx(kx,ky) = sqrt(-1)*kx*df(kx,ky)c fy(kx,ky) = sqrt(-1)*ky*df(kx,ky)c where kx = 2pi*j/nx, ky = 2pi*k/ny, and j,k = fourier mode numbers,c except for fx(kx=pi) = fy(kx=pi) = 0, fx(ky=pi) = fy(ky=pi) = 0,c and fx(kx=0,ky=0) = fy(kx=0,ky=0) = 0.c nx/ny = system length in x/y directionc ndim = number of field arrays, must be >= 2c kstrt = starting data block numberc nyv = first dimension of field arrays, must be >= nyc kxp = number of data values per blockc jblok = number of data blocks      complex df, f, zero, zt1      dimension df(nyv,kxp,jblok), f(ndim,nyv,kxp,jblok)      nxh = nx/2      nyh = ny/2      ny2 = ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx)      dny = 6.28318530717959/float(ny)      zero = cmplx(0.,0.)c calculate the gradient      if (kstrt.gt.nxh) return      do 40 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 20 j = 1, kxp      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 10 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         zt1 = cmplx(-aimag(df(k,j,l)),real(df(k,j,l)))         f(1,k,j,l) = dkx*zt1         f(2,k,j,l) = dky*zt1         zt1 = cmplx(-aimag(df(k1,j,l)),real(df(k1,j,l)))         f(1,k1,j,l) = dkx*zt1         f(2,k1,j,l) = -dky*zt1   10    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         f(1,1,j,l) = dkx*cmplx(-aimag(df(1,j,l)),real(df(1,j,l)))         f(2,1,j,l) = zero         f(1,k1,j,l) = zero         f(2,k1,j,l) = zero      endif   20 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 30 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         f(1,k,1,l) = zero         f(2,k,1,l) = dky*cmplx(-aimag(df(k,1,l)),real(df(k,1,l)))         f(1,k1,1,l) = zero         f(2,k1,1,l) = zero   30    continue         k1 = nyh + 1         f(1,1,1,l) = zero         f(2,1,1,l) = zero         f(1,k1,1,l) = zero         f(2,k1,1,l) = zero      endif   40 continue      return      endc-----------------------------------------------------------------------      subroutine PCURLF2(f,g,nx,ny,kstrt,nyv,kxp,jblok)c this subroutine calculates the curl in fourier spacec input: all except g, output: gc approximate flop count is: 32*nxc*nyc + 10*(nxc + nyc)c where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc the curl is calculated using the equations:c gx(kx,ky) = sqrt(-1)*ky*fz(kx,ky)c gy(kx,ky) = -sqrt(-1)*kx*fz(kx,ky)c gz(kx,ky) = sqrt(-1)*(kx*fy(kx,ky)-ky*fx(kx,ky))c where kx = 2pi*j/nx, ky = 2pi*k/ny, and j,k = fourier mode numbers,c except for gx(kx=pi) = gy(kx=pi) = 0, gx(ky=pi) = gy(ky=pi) = 0,c and gx(kx=0,ky=0) = gy(kx=0,ky=0) = 0.c nx/ny = system length in x/y directionc kstrt = starting data block numberc nyv = first dimension of field arrays, must be >= nyc kxp = number of data values per blockc jblok = number of data blocks      complex f, g, zero, zt1, zt2, zt3      dimension f(3,nyv,kxp,jblok), g(3,nyv,kxp,jblok)      nxh = nx/2      nyh = ny/2      ny2 = ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx)      dny = 6.28318530717959/float(ny)      zero = cmplx(0.,0.)c calculate the curl      if (kstrt.gt.nxh) return      do 40 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 20 j = 1, kxp      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 10 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         zt1 = cmplx(-aimag(f(3,k,j,l)),real(f(3,k,j,l)))         zt2 = cmplx(-aimag(f(2,k,j,l)),real(f(2,k,j,l)))         zt3 = cmplx(-aimag(f(1,k,j,l)),real(f(1,k,j,l)))         g(1,k,j,l) = dky*zt1         g(2,k,j,l) = -dkx*zt1         g(3,k,j,l) = dkx*zt2 - dky*zt3         zt1 = cmplx(-aimag(f(3,k1,j,l)),real(f(3,k1,j,l)))         zt2 = cmplx(-aimag(f(2,k1,j,l)),real(f(2,k1,j,l)))         zt3 = cmplx(-aimag(f(1,k1,j,l)),real(f(1,k1,j,l)))         g(1,k1,j,l) = -dky*zt1         g(2,k1,j,l) = -dkx*zt1         g(3,k1,j,l) = dkx*zt2 + dky*zt3   10    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         zt1 = cmplx(-aimag(f(3,1,j,l)),real(f(3,1,j,l)))         zt2 = cmplx(-aimag(f(2,1,j,l)),real(f(2,1,j,l)))         g(1,1,j,l) = zero         g(2,1,j,l) = -dkx*zt1         g(3,1,j,l) = dkx*zt2         g(1,k1,j,l) = zero         g(2,k1,j,l) = zero         g(3,k1,j,l) = zero      endif   20 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 30 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         zt1 = cmplx(-aimag(f(3,k,1,l)),real(f(3,k,1,l)))         zt2 = cmplx(-aimag(f(1,k,1,l)),real(f(1,k,1,l)))         g(1,k,1,l) = dky*zt1         g(2,k,1,l) = zero         g(3,k,1,l) = -dky*zt2         g(1,k1,1,l) = zero         g(2,k1,1,l) = zero         g(3,k1,1,l) = zero   30    continue         k1 = nyh + 1         g(1,1,1,l) = zero         g(2,1,1,l) = zero         g(3,1,1,l) = zero         g(1,k1,1,l) = zero         g(2,k1,1,l) = zero         g(3,k1,1,l) = zero      endif   40 continue      return      endc-----------------------------------------------------------------------      subroutine PCURLF22(f,g,nx,ny,kstrt,nyv,kxp,jblok)c this subroutine calculates the curl in fourier spacec input: all except g, output: gc approximate flop count is: 32*nxc*nyc + 10*(nxc + nyc)c where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc the curl is calculated using the equations:c g(kx,ky) = sqrt(-1)*(kx*fy(kx,ky)-ky*fx(kx,ky))c where kx = 2pi*j/nx, ky = 2pi*k/ny, and j,k = fourier mode numbers,c nx/ny = system length in x/y directionc kstrt = starting data block numberc nyv = first dimension of field arrays, must be >= nyc kxp = number of data values per blockc jblok = number of data blocks      complex f, g, zero, zt2, zt3      dimension f(2,nyv,kxp,jblok), g(nyv,kxp,jblok)      nxh = nx/2      nyh = ny/2      ny2 = ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx)      dny = 6.28318530717959/float(ny)      zero = cmplx(0.,0.)c calculate the curl      if (kstrt.gt.nxh) return      do 40 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 20 j = 1, kxp      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 10 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         zt2 = cmplx(-aimag(f(2,k,j,l)),real(f(2,k,j,l)))         zt3 = cmplx(-aimag(f(1,k,j,l)),real(f(1,k,j,l)))         g(k,j,l) = dkx*zt2 - dky*zt3         zt2 = cmplx(-aimag(f(2,k1,j,l)),real(f(2,k1,j,l)))         zt3 = cmplx(-aimag(f(1,k1,j,l)),real(f(1,k1,j,l)))         g(k1,j,l) = dkx*zt2 + dky*zt3   10    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         zt2 = cmplx(-aimag(f(2,1,j,l)),real(f(2,1,j,l)))         g(1,j,l) = dkx*zt2         g(k1,j,l) = zero      endif   20 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 30 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         zt2 = cmplx(-aimag(f(1,k,1,l)),real(f(1,k,1,l)))         g(k,1,l) = -dky*zt2         g(k1,1,l) = zero   30    continue         k1 = nyh + 1         g(1,1,l) = zero         g(k1,1,l) = zero      endif   40 continue      return      endc-----------------------------------------------------------------------      subroutine PCUPERP2(cu,nx,ny,kstrt,nyv,kxp,jblok)c this subroutine calculates the transverse current in fourier spacec input: all, output: cuc approximate flop count is: 36*nxc*nycc and nxc*nyc dividesc where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc the transverse current is calculated using the equation:c cux(kx,ky) = cux(kx,ky)-kx*(kx*cux(kx,ky)+ky*cuy(kx,ky))/(kx*kx+ky*ky)c cuy(kx,ky) = cuy(kx,ky)-ky*(kx*cux(kx,ky)+ky*cuy(kx,ky))/(kx*kx+ky*ky)c where kx = 2pi*j/nx, ky = 2pi*k/ny, and j,k = fourier mode numbers,c except for cux(kx=pi) = cuy(kx=pi) = 0, cux(ky=pi) = cuy(ky=pi) = 0,c and cux(kx=0,ky=0) = cuy(kx=0,ky=0) = 0.c cu(i,k,j,l) = i-th component of complex current density andc for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c nx/ny = system length in x/y directionc kstrt = starting data block numberc nyv = first dimension of field arrays, must be >= nyc kxp = number of data values per blockc jblok = number of data blocks      complex cu, zero, zt1      dimension cu(3,nyv,kxp,jblok)      nxh = nx/2      nyh = ny/2      ny2 = ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx)      dny = 6.28318530717959/float(ny)      zero = cmplx(0.,0.)c calculate transverse part of current      if (kstrt.gt.nxh) return      do 40 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 20 j = 1, kxp      dkx = dnx*float(j + joff)      dkx2 = dkx*dkx      if ((j+joff).gt.0) then         do 10 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         at1 = 1./(dky*dky + dkx2)         zt1 = at1*(dkx*cu(1,k,j,l) + dky*cu(2,k,j,l))         cu(1,k,j,l) = cu(1,k,j,l) - dkx*zt1         cu(2,k,j,l) = cu(2,k,j,l) - dky*zt1         zt1 = at1*(dkx*cu(1,k1,j,l) - dky*cu(2,k1,j,l))         cu(1,k1,j,l) = cu(1,k1,j,l) - dkx*zt1         cu(2,k1,j,l) = cu(2,k1,j,l) + dky*zt1   10    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         cu(1,1,j,l) = zero         cu(1,k1,j,l) = zero         cu(2,k1,j,l) = zero      endif   20 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 30 k = 2, nyh         k1 = ny2 - k         cu(2,k,1,l) = zero         cu(1,k1,1,l) = zero         cu(2,k1,1,l) = zero   30    continue         k1 = nyh + 1         cu(1,1,1,l) = zero         cu(2,1,1,l) = zero         cu(1,k1,1,l) = zero         cu(2,k1,1,l) = zero      endif   40 continue      return      endc-----------------------------------------------------------------------      subroutine PCUPERP22(cu,nx,ny,kstrt,nyv,kxp,jblok)c this subroutine calculates the transverse current in fourier spacec input: all, output: cuc approximate flop count is: 36*nxc*nycc and nxc*nyc dividesc where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc the transverse current is calculated using the equation:c cux(kx,ky) = cux(kx,ky)-kx*(kx*cux(kx,ky)+ky*cuy(kx,ky))/(kx*kx+ky*ky)c cuy(kx,ky) = cuy(kx,ky)-ky*(kx*cux(kx,ky)+ky*cuy(kx,ky))/(kx*kx+ky*ky)c where kx = 2pi*j/nx, ky = 2pi*k/ny, and j,k = fourier mode numbers,c except for cux(kx=pi) = cuy(kx=pi) = 0, cux(ky=pi) = cuy(ky=pi) = 0,c and cux(kx=0,ky=0) = cuy(kx=0,ky=0) = 0.c cu(i,k,j,l) = i-th component of complex current density andc for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c nx/ny = system length in x/y directionc kstrt = starting data block numberc nyv = first dimension of field arrays, must be >= nyc kxp = number of data values per blockc jblok = number of data blocks      complex cu, zero, zt1      dimension cu(2,nyv,kxp,jblok)      nxh = nx/2      nyh = ny/2      ny2 = ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx)      dny = 6.28318530717959/float(ny)      zero = cmplx(0.,0.)c calculate transverse part of current      if (kstrt.gt.nxh) return      do 40 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 20 j = 1, kxp      dkx = dnx*float(j + joff)      dkx2 = dkx*dkx      if ((j+joff).gt.0) then         do 10 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         at1 = 1./(dky*dky + dkx2)         zt1 = at1*(dkx*cu(1,k,j,l) + dky*cu(2,k,j,l))         cu(1,k,j,l) = cu(1,k,j,l) - dkx*zt1         cu(2,k,j,l) = cu(2,k,j,l) - dky*zt1         zt1 = at1*(dkx*cu(1,k1,j,l) - dky*cu(2,k1,j,l))         cu(1,k1,j,l) = cu(1,k1,j,l) - dkx*zt1         cu(2,k1,j,l) = cu(2,k1,j,l) + dky*zt1   10    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         cu(1,1,j,l) = zero         cu(1,k1,j,l) = zero         cu(2,k1,j,l) = zero      endif   20 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 30 k = 2, nyh         k1 = ny2 - k         cu(2,k,1,l) = zero         cu(1,k1,1,l) = zero         cu(2,k1,1,l) = zero   30    continue         k1 = nyh + 1         cu(1,1,1,l) = zero         cu(2,1,1,l) = zero         cu(1,k1,1,l) = zero         cu(2,k1,1,l) = zero      endif   40 continue      return      endc-----------------------------------------------------------------------      subroutine PBPOISP23(cu,bxy,isign,ffc,ax,ay,affp,ci,wm,nx,ny,kstrt     1,nyv,kxp,jblok,nyhd)c this subroutine solves 2-1/2d poisson's equation in fourier space forc magnetic field (or convolution of magnetic field over particle shape)c or for vector potential, or provides a smoothing function,c with periodic boundary conditions for distributed data.c for isign = 0, input: isign,ax,ay,affp,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: ffcc for isign = -1, input: cu,ffc,isign,ci,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: bxy,wmc approximate flop count is: 85*nxc*nyc + 36*(nxc + nyc)c for isign = 1, input: cu,ffc,isign,ci,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: bxy,wmc approximate flop count is: 63*nxc*nyc + 33*(nxc + nyc)c for isign = 2, input: cu,ffc,isign,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: bxyc approximate flop count is: 12*nxc*nyc + 6*(nxc + nyc)c where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc if isign = 0, form factor array is preparedc if isign < 0, magnetic field is calculated using the equations:c bx(kx,ky) = ci*ci*sqrt(-1)*g(kx,ky)*ky*cuz(kx,ky)*s(kx,ky),c by(kx,ky) = -ci*ci*sqrt(-1)*g(kx,ky)*kx*cuz(kx,ky)*s(kx,ky),c bz(kx,ky) = ci*ci*sqrt(-1)*g(kx,ky)*(kx*cuy(kx,ky)-ky*cux(kx,ky))*c             s(kx,ky),c where kx = 2pi*j/nx, ky = 2pi*k/ny, and j,k = fourier mode numbers,c g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky),c s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2), except forc bx(kx=pi) = by(kx=pi) = bz(kx=pi) = 0,c bx(ky=pi) = by(ky=pi) = bz(ky=pi) = 0,c bx(kx=0,ky=0) = by(kx=0,ky=0) = bz(kx=0,ky=0) = 0.c if isign = 1, vector potential is calculated using the equation:c bx(kx,ky) = ci*ci*g(kx,ky)*cux(kx,ky)c by(kx,ky) = ci*ci*g(kx,ky)*cuy(kx,ky)c bz(kx,ky) = ci*ci*g(kx,ky)*cuz(kx,ky)c if isign = 2, smoothing is calculated using the equation:c bx(kx,ky) = cux(kx,ky)*s(kx,ky)c by(kx,ky) = cuy(kx,ky)*s(kx,ky)c bz(kx,ky) = cuz(kx,ky)*s(kx,ky)c cu(i,k,j,l) = i-th component of complex current density andc bxy(i,k,j,l) = i-th component of complex magnetic field,c for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c jblok = number of data blocksc kxp = number of data values per blockc kstrt = starting data block numberc aimag(ffc(k,j,l)) = finite-size particle shape factor sc real(ffc(k,j,l)) = potential green's function gc for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c ax/ay = half-width of particle in x/y directionc affp = normalization constant = nx*ny/np, where np=number of particlesc ci = reciprical of velocity of lightc magnetic field energy is also calculated, usingc wm = nx*ny*nz*sum((affp/(kx**2+ky**2+kz**2))*ci*cic    |cu(kx,ky,kz)*s(kx,ky,kz)|**2)c this expression is valid only if the current is divergence-freec nx/ny = system length in x/y directionc nyv = first dimension of field arrays, must be >= nyc nyhd = first dimension of form factor array, must be >= nyh      double precision wp      complex cu, bxy, ffc, zero, zt1, zt2, zt3      dimension cu(3,nyv,kxp,jblok)      dimension bxy(3,nyv,kxp,jblok)      dimension ffc(nyhd,kxp,jblok)      nxh = nx/2      nyh = ny/2      ny2 = ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx)      dny = 6.28318530717959/float(ny)      zero = cmplx(0.,0.)      ci2 = ci*ci      if (isign.ne.0) go to 40      if (kstrt.gt.nxh) returnc prepare form factor array      do 30 l = 1, jblok      joff = kxp*(l + ks) - 1      do 20 j = 1, kxp      dkx = dnx*float(j + joff)      at1 = dkx*dkx      at2 = (dkx*ax)**2      do 10 k = 1, nyh      dky = dny*float(k - 1)      at3 = dky*dky + at1      at4 = exp(-.5*((dky*ay)**2 + at2))      if (at3.eq.0.) then         ffc(k,j,l) = cmplx(affp,1.)      else         ffc(k,j,l) = cmplx(affp*at4/at3,at4)      endif   10 continue   20 continue   30 continue      return   40 if (isign.gt.0) go to 100c calculate magnetic field and sum field energy      wp = 0.0d0      if (kstrt.gt.nxh) go to 90      do 80 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 60 j = 1, kxp      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 50 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         at1 = ci2*real(ffc(k,j,l))*aimag(ffc(k,j,l))         at2 = dky*at1         at3 = dkx*at1         zt1 = cmplx(-aimag(cu(3,k,j,l)),real(cu(3,k,j,l)))         zt2 = cmplx(-aimag(cu(2,k,j,l)),real(cu(2,k,j,l)))         zt3 = cmplx(-aimag(cu(1,k,j,l)),real(cu(1,k,j,l)))         bxy(1,k,j,l) = at2*zt1         bxy(2,k,j,l) = -at3*zt1         bxy(3,k,j,l) = at3*zt2 - at2*zt3         zt1 = cmplx(-aimag(cu(3,k1,j,l)),real(cu(3,k1,j,l)))         zt2 = cmplx(-aimag(cu(2,k1,j,l)),real(cu(2,k1,j,l)))         zt3 = cmplx(-aimag(cu(1,k1,j,l)),real(cu(1,k1,j,l)))         bxy(1,k1,j,l) = -at2*zt1         bxy(2,k1,j,l) = -at3*zt1         bxy(3,k1,j,l) = at3*zt2 + at2*zt3         wp = wp + at1*(cu(1,k,j,l)*conjg(cu(1,k,j,l)) + cu(2,k,j,l)*con     1jg(cu(2,k,j,l)) + cu(3,k,j,l)*conjg(cu(3,k,j,l)) + cu(1,k1,j,l)*co     2njg(cu(1,k1,j,l)) + cu(2,k1,j,l)*conjg(cu(2,k1,j,l)) + cu(3,k1,j,l     3)*conjg(cu(3,k1,j,l)))   50    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         at1 = ci2*real(ffc(1,j,l))*aimag(ffc(1,j,l))         at2 = dkx*at1         zt1 = cmplx(-aimag(cu(3,1,j,l)),real(cu(3,1,j,l)))         zt2 = cmplx(-aimag(cu(2,1,j,l)),real(cu(2,1,j,l)))         bxy(1,1,j,l) = zero         bxy(2,1,j,l) = -at2*zt1         bxy(3,1,j,l) = at2*zt2         bxy(1,k1,j,l) = zero         bxy(2,k1,j,l) = zero         bxy(3,k1,j,l) = zero         wp = wp + at1*(cu(1,1,j,l)*conjg(cu(1,1,j,l)) + cu(2,1,j,l)*con     1jg(cu(2,1,j,l)) + cu(3,1,j,l)*conjg(cu(3,1,j,l)))      endif   60 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 70 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         at1 = ci2*real(ffc(k,1,l))*aimag(ffc(k,1,l))         at2 = dky*at1         zt1 = cmplx(-aimag(cu(3,k,1,l)),real(cu(3,k,1,l)))         zt2 = cmplx(-aimag(cu(1,k,1,l)),real(cu(1,k,1,l)))         bxy(1,k,1,l) = at2*zt1         bxy(2,k,1,l) = zero         bxy(3,k,1,l) = -at2*zt2         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero         bxy(3,k1,1,l) = zero         wp = wp + at1*(cu(1,k,1,l)*conjg(cu(1,k,1,l)) + cu(2,k,1,l)*con     1jg(cu(2,k,1,l)) + cu(3,k,1,l)*conjg(cu(3,k,1,l)))   70    continue         k1 = nyh + 1         bxy(1,1,1,l) = zero         bxy(2,1,1,l) = zero         bxy(3,1,1,l) = zero         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero         bxy(3,k1,1,l) = zero      endif   80 continue   90 continue      wm = float(nx*ny)*wp      returnc calculate vector potential and sum field energy  100 if (isign.gt.1) go to 160      wp = 0.0d0      if (kstrt.gt.nxh) go to 150      do 140 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 120 j = 1, kxp      if ((j+joff).gt.0) then         do 110 k = 2, nyh         k1 = ny2 - k         at2 = ci2*real(ffc(k,j,l))         at1 = at2*aimag(ffc(k,j,l))         bxy(1,k,j,l) = at2*cu(1,k,j,l)         bxy(2,k,j,l) = at2*cu(2,k,j,l)         bxy(3,k,j,l) = at2*cu(3,k,j,l)         bxy(1,k1,j,l) = at2*cu(1,k1,j,l)         bxy(2,k1,j,l) = at2*cu(2,k1,j,l)         bxy(3,k1,j,l) = at2*cu(3,k1,j,l)         wp = wp + at1*(cu(1,k,j,l)*conjg(cu(1,k,j,l)) + cu(2,k,j,l)*con     1jg(cu(2,k,j,l)) + cu(3,k,j,l)*conjg(cu(3,k,j,l)) + cu(1,k1,j,l)*co     2njg(cu(1,k1,j,l)) + cu(2,k1,j,l)*conjg(cu(2,k1,j,l)) + cu(3,k1,j,l     3)*conjg(cu(3,k1,j,l)))  110    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         at2 = ci2*real(ffc(1,j,l))         at1 = at2*aimag(ffc(1,j,l))         bxy(1,1,j,l) = at2*cu(1,1,j,l)         bxy(2,1,j,l) = at2*cu(2,1,j,l)         bxy(3,1,j,l) = at2*cu(3,1,j,l)         bxy(1,k1,j,l) = zero         bxy(2,k1,j,l) = zero         bxy(3,k1,j,l) = zero         wp = wp + at1*(cu(1,1,j,l)*conjg(cu(1,1,j,l)) + cu(2,1,j,l)*con     1jg(cu(2,1,j,l)) + cu(3,1,j,l)*conjg(cu(3,1,j,l)))      endif  120 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 130 k = 2, nyh         k1 = ny2 - k         at2 = ci2*real(ffc(k,1,l))         at1 = at2*aimag(ffc(k,1,l))         bxy(1,k,1,l) = at2*cu(1,k,1,l)         bxy(2,k,1,l) = at2*cu(2,k,1,l)         bxy(3,k,1,l) = at2*cu(3,k,1,l)         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero         bxy(3,k1,1,l) = zero         wp = wp + at1*(cu(1,k,1,l)*conjg(cu(1,k,1,l)) + cu(2,k,1,l)*con     1jg(cu(2,k,1,l)) + cu(3,k,1,l)*conjg(cu(3,k,1,l)))  130    continue         k1 = nyh + 1         bxy(1,1,1,l) = zero         bxy(2,1,1,l) = zero         bxy(3,1,1,l) = zero         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero         bxy(3,k1,1,l) = zero      endif  140 continue  150 continue      wm = float(nx*ny)*wp      returnc calculate smoothing  160 if (kstrt.gt.nxh) go to 210      do 200 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 180 j = 1, kxp      if ((j+joff).gt.0) then         do 170 k = 2, nyh         k1 = ny2 - k         at1 = aimag(ffc(k,j,l))         bxy(1,k,j,l) = at1*cu(1,k,j,l)         bxy(2,k,j,l) = at1*cu(2,k,j,l)         bxy(3,k,j,l) = at1*cu(3,k,j,l)         bxy(1,k1,j,l) = at1*cu(1,k1,j,l)         bxy(2,k1,j,l) = at1*cu(2,k1,j,l)         bxy(3,k1,j,l) = at1*cu(3,k1,j,l)  170    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         at1 = aimag(ffc(1,j,l))         bxy(1,1,j,l) = at1*cu(1,1,j,l)         bxy(2,1,j,l) = at1*cu(2,1,j,l)         bxy(3,1,j,l) = at1*cu(3,1,j,l)         bxy(1,k1,j,l) = zero         bxy(2,k1,j,l) = zero         bxy(3,k1,j,l) = zero      endif  180 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 190 k = 2, nyh         k1 = ny2 - k         at1 = aimag(ffc(k,1,l))         bxy(1,k,1,l) = at1*cu(1,k,1,l)         bxy(2,k,1,l) = at1*cu(2,k,1,l)         bxy(3,k,1,l) = at1*cu(3,k,1,l)         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero         bxy(3,k1,1,l) = zero  190    continue         k1 = nyh + 1         at1 = aimag(ffc(1,1,l))         bxy(1,1,1,l) = cmplx(at1*real(cu(1,1,1,l)),0.)         bxy(2,1,1,l) = cmplx(at1*real(cu(2,1,1,l)),0.)         bxy(3,1,1,l) = cmplx(at1*real(cu(3,1,1,l)),0.)         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero         bxy(3,k1,1,l) = zero      endif  200 continue  210 continue      return      endc-----------------------------------------------------------------------      subroutine PBPOISP22(cu,bxy,bz,isign,ffc,ax,ay,affp,ci,wm,nx,ny,ks     1trt,nyv,kxp,jblok,nyhd)c this subroutine solves 2d poisson's equation in fourier space forc magnetic field (or convolution of magnetic field over particle shape)c or for vector potential, or provides a smoothing function,c with periodic boundary conditions for distributed data.c for isign = 0, input: isign,ax,ay,affp,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: ffcc for isign = -1, input: cu,ffc,isign,ci,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: bz,wmc approximate flop count is: 55*nxc*nyc + 24*(nxc + nyc)c for isign = 1, input: cu,ffc,isign,ci,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: bxy,wmc approximate flop count is: 45*nxc*nyc + 24*(nxc + nyc)c for isign = 2, input: cu,ffc,isign,nx,ny,kstrt,nyv,kxp,jblok,nyhd,c output: bxyc approximate flop count is: 8*nxc*nyc + 4*(nxc + nyc)c where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc if isign = 0, form factor array is preparedc if isign < 0, magnetic field is calculated using the equations:c bz(kx,ky) = ci*ci*sqrt(-1)*g(kx,ky)*(kx*cuy(kx,ky)-ky*cux(kx,ky))*c             s(kx,ky),c where kx = 2pi*j/nx, ky = 2pi*k/ny, and j,k = fourier mode numbers,c g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky),c s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2), except forc bz(kx=pi) = 0, bz(ky=pi) = 0, bz(kx=0,ky=0) = 0.c if isign = 1, vector potential is calculated using the equation:c bx(kx,ky) = ci*ci*g(kx,ky)*cux(kx,ky)c by(kx,ky) = ci*ci*g(kx,ky)*cuy(kx,ky)c if isign = 2, smoothing is calculated using the equation:c bx(kx,ky) = cux(kx,ky)*s(kx,ky)c by(kx,ky) = cuy(kx,ky)*s(kx,ky)c cu(i,k,j,l) = i-th component of complex current density andc bxy(i,k,j,l) = i-th component of complex vector potential,c bz(k,j,l) = z component of complex magnetic field,c for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c jblok = number of data blocksc kxp = number of data values per blockc kstrt = starting data block numberc aimag(ffc(k,j,l)) = finite-size particle shape factor sc real(ffc(k,j,l)) = potential green's function gc for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c ax/ay = half-width of particle in x/y directionc affp = normalization constant = nx*ny/np, where np=number of particlesc ci = reciprical of velocity of lightc magnetic field energy is also calculated, usingc wm = nx*ny*nz*sum((affp/(kx**2+ky**2+kz**2))*ci*cic    |cu(kx,ky,kz)*s(kx,ky,kz)|**2)c this expression is valid only if the current is divergence-freec nx/ny = system length in x/y directionc nyv = first dimension of field arrays, must be >= nyc nyhd = first dimension of form factor array, must be >= nyh      double precision wp      complex cu, bxy, bz, ffc, zero, zt2, zt3      dimension cu(2,nyv,kxp,jblok)      dimension bxy(2,nyv,kxp,jblok), bz(nyv,kxp,jblok)      dimension ffc(nyhd,kxp,jblok)      nxh = nx/2      nyh = ny/2      ny2 = ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx)      dny = 6.28318530717959/float(ny)      zero = cmplx(0.,0.)      ci2 = ci*ci      if (isign.ne.0) go to 40      if (kstrt.gt.nxh) returnc prepare form factor array      do 30 l = 1, jblok      joff = kxp*(l + ks) - 1      do 20 j = 1, kxp      dkx = dnx*float(j + joff)      at1 = dkx*dkx      at2 = (dkx*ax)**2      do 10 k = 1, nyh      dky = dny*float(k - 1)      at3 = dky*dky + at1      at4 = exp(-.5*((dky*ay)**2 + at2))      if (at3.eq.0.) then         ffc(k,j,l) = cmplx(affp,1.)      else         ffc(k,j,l) = cmplx(affp*at4/at3,at4)      endif   10 continue   20 continue   30 continue      return   40 if (isign.gt.0) go to 100c calculate magnetic field and sum field energy      wp = 0.0d0      if (kstrt.gt.nxh) go to 90      do 80 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 60 j = 1, kxp      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 50 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         at1 = ci2*real(ffc(k,j,l))*aimag(ffc(k,j,l))         at2 = dky*at1         at3 = dkx*at1         zt2 = cmplx(-aimag(cu(2,k,j,l)),real(cu(2,k,j,l)))         zt3 = cmplx(-aimag(cu(1,k,j,l)),real(cu(1,k,j,l)))         bz(k,j,l) = at3*zt2 - at2*zt3         zt2 = cmplx(-aimag(cu(2,k1,j,l)),real(cu(2,k1,j,l)))         zt3 = cmplx(-aimag(cu(1,k1,j,l)),real(cu(1,k1,j,l)))         bz(k1,j,l) = at3*zt2 + at2*zt3         wp = wp + at1*(cu(1,k,j,l)*conjg(cu(1,k,j,l)) + cu(2,k,j,l)*con     1jg(cu(2,k,j,l)) + cu(1,k1,j,l)*conjg(cu(1,k1,j,l)) + cu(2,k1,j,l)*     2conjg(cu(2,k1,j,l)))   50    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         at1 = ci2*real(ffc(1,j,l))*aimag(ffc(1,j,l))         at2 = dkx*at1         zt2 = cmplx(-aimag(cu(2,1,j,l)),real(cu(2,1,j,l)))         bz(1,j,l) = at2*zt2         bz(k1,j,l) = zero         wp = wp + at1*(cu(1,1,j,l)*conjg(cu(1,1,j,l)) + cu(2,1,j,l)*con     1jg(cu(2,1,j,l)))      endif   60 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 70 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         at1 = ci2*real(ffc(k,1,l))*aimag(ffc(k,1,l))         at2 = dky*at1         zt2 = cmplx(-aimag(cu(1,k,1,l)),real(cu(1,k,1,l)))         bz(k,1,l) = -at2*zt2         bz(k1,1,l) = zero         wp = wp + at1*(cu(1,k,1,l)*conjg(cu(1,k,1,l)) + cu(2,k,1,l)*con     1jg(cu(2,k,1,l)))   70    continue         k1 = nyh + 1         bz(1,1,l) = zero         bz(k1,1,l) = zero      endif   80 continue   90 continue      wm = float(nx*ny)*wp      returnc calculate vector potential and sum field energy  100 if (isign.gt.1) go to 160      wp = 0.0d0      if (kstrt.gt.nxh) go to 150      do 140 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 120 j = 1, kxp      if ((j+joff).gt.0) then         do 110 k = 2, nyh         k1 = ny2 - k         at2 = ci2*real(ffc(k,j,l))         at1 = at2*aimag(ffc(k,j,l))         bxy(1,k,j,l) = at2*cu(1,k,j,l)         bxy(2,k,j,l) = at2*cu(2,k,j,l)         bxy(1,k1,j,l) = at2*cu(1,k1,j,l)         bxy(2,k1,j,l) = at2*cu(2,k1,j,l)         wp = wp + at1*(cu(1,k,j,l)*conjg(cu(1,k,j,l)) + cu(2,k,j,l)*con     1jg(cu(2,k,j,l)) + cu(1,k1,j,l)*conjg(cu(1,k1,j,l)) + cu(2,k1,j,l)*     2conjg(cu(2,k1,j,l)))  110    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         at2 = ci2*real(ffc(1,j,l))         at1 = at2*aimag(ffc(1,j,l))         bxy(1,1,j,l) = at2*cu(1,1,j,l)         bxy(2,1,j,l) = at2*cu(2,1,j,l)         bxy(1,k1,j,l) = zero         bxy(2,k1,j,l) = zero         wp = wp + at1*(cu(1,1,j,l)*conjg(cu(1,1,j,l)) + cu(2,1,j,l)*con     1jg(cu(2,1,j,l)))      endif  120 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 130 k = 2, nyh         k1 = ny2 - k         at2 = ci2*real(ffc(k,1,l))         at1 = at2*aimag(ffc(k,1,l))         bxy(1,k,1,l) = at2*cu(1,k,1,l)         bxy(2,k,1,l) = at2*cu(2,k,1,l)         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero         wp = wp + at1*(cu(1,k,1,l)*conjg(cu(1,k,1,l)) + cu(2,k,1,l)*con     1jg(cu(2,k,1,l)))  130    continue         k1 = nyh + 1         bxy(1,1,1,l) = zero         bxy(2,1,1,l) = zero         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero      endif  140 continue  150 continue      wm = float(nx*ny)*wp      returnc calculate smoothing  160 if (kstrt.gt.nxh) go to 210      do 200 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 180 j = 1, kxp      if ((j+joff).gt.0) then         do 170 k = 2, nyh         k1 = ny2 - k         at1 = aimag(ffc(k,j,l))         bxy(1,k,j,l) = at1*cu(1,k,j,l)         bxy(2,k,j,l) = at1*cu(2,k,j,l)         bxy(1,k1,j,l) = at1*cu(1,k1,j,l)         bxy(2,k1,j,l) = at1*cu(2,k1,j,l)  170    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         at1 = aimag(ffc(1,j,l))         bxy(1,1,j,l) = at1*cu(1,1,j,l)         bxy(2,1,j,l) = at1*cu(2,1,j,l)         bxy(1,k1,j,l) = zero         bxy(2,k1,j,l) = zero      endif  180 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 190 k = 2, nyh         k1 = ny2 - k         at1 = aimag(ffc(k,1,l))         bxy(1,k,1,l) = at1*cu(1,k,1,l)         bxy(2,k,1,l) = at1*cu(2,k,1,l)         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero  190    continue         k1 = nyh + 1         at1 = aimag(ffc(1,1,l))         bxy(1,1,1,l) = cmplx(at1*real(cu(1,1,1,l)),0.)         bxy(2,1,1,l) = cmplx(at1*real(cu(2,1,1,l)),0.)         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero      endif  200 continue  210 continue      return      endc-----------------------------------------------------------------------      subroutine IPBPOISP23(cu,bxy,ffc,ci,wm,nx,ny,kstrt,nyv,kxp,jblok,n     1yhd)c this subroutine solves 2-1/2d poisson's equation in fourier space forc magnetic field with periodic boundary conditions for distributed data.c input: cu,ffc,ci,nx,ny,kstrt,nyv,kxp,jblok,nyhd, output: bxy,wmc approximate flop count is: 85*nxc*nyc + 36*(nxc + nyc)c where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc magnetic field is calculated using the equations:c bx(kx,ky) = ci*ci*sqrt(-1)*g(kx,ky)*ky*cuz(kx,ky),c by(kx,ky) = -ci*ci*sqrt(-1)*g(kx,ky)*kx*cuz(kx,ky),c bz(kx,ky) = ci*ci*sqrt(-1)*g(kx,ky)*(kx*cuy(kx,ky)-ky*cux(kx,ky)),c where kx = 2pi*j/nx, ky = 2pi*k/ny, and j,k = fourier mode numbers,c g(kx,ky) = (affp/(kx**2+ky**2))*s(kx,ky),c s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)/2), except forc bx(kx=pi) = by(kx=pi) = bz(kx=pi) = 0,c bx(ky=pi) = by(ky=pi) = bz(ky=pi) = 0,c bx(kx=0,ky=0) = by(kx=0,ky=0) = bz(kx=0,ky=0) = 0.c cu(i,k,j,l) = i-th component of complex current density andc bxy(i,k,j,l) = i-th component of complex magnetic field,c for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c jblok = number of data blocksc kxp = number of data values per blockc kstrt = starting data block numberc aimag(ffc(k,j,l)) = finite-size particle shape factor sc real(ffc(k,j,l)) = potential green's function gc for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c ci = reciprical of velocity of lightc magnetic field energy is also calculated, usingc wm = nx*ny*nz*sum((affp/(kx**2+ky**2+kz**2))*ci*cic    |cu(kx,ky,kz)*s(kx,ky,kz)|**2), wherec affp = normalization constant = nx*ny/np, where np=number of particlesc this expression is valid only if the current is divergence-freec nx/ny = system length in x/y directionc nyv = first dimension of field arrays, must be >= nyc nyhd = first dimension of form factor array, must be >= nyh      double precision wp      complex cu, bxy, ffc, zero, zt1, zt2, zt3      dimension cu(3,nyv,kxp,jblok)      dimension bxy(3,nyv,kxp,jblok)      dimension ffc(nyhd,kxp,jblok)      nxh = nx/2      nyh = ny/2      ny2 = ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx)      dny = 6.28318530717959/float(ny)      zero = cmplx(0.,0.)      ci2 = ci*cic calculate magnetic field and sum field energy      wp = 0.0d0      if (kstrt.gt.nxh) go to 50      do 40 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 20 j = 1, kxp      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 10 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         at1 = ci2*real(ffc(k,j,l))         at2 = dky*at1         at3 = dkx*at1         at1 = at1*aimag(ffc(k,j,l))         zt1 = cmplx(-aimag(cu(3,k,j,l)),real(cu(3,k,j,l)))         zt2 = cmplx(-aimag(cu(2,k,j,l)),real(cu(2,k,j,l)))         zt3 = cmplx(-aimag(cu(1,k,j,l)),real(cu(1,k,j,l)))         bxy(1,k,j,l) = at2*zt1         bxy(2,k,j,l) = -at3*zt1         bxy(3,k,j,l) = at3*zt2 - at2*zt3         zt1 = cmplx(-aimag(cu(3,k1,j,l)),real(cu(3,k1,j,l)))         zt2 = cmplx(-aimag(cu(2,k1,j,l)),real(cu(2,k1,j,l)))         zt3 = cmplx(-aimag(cu(1,k1,j,l)),real(cu(1,k1,j,l)))         bxy(1,k1,j,l) = -at2*zt1         bxy(2,k1,j,l) = -at3*zt1         bxy(3,k1,j,l) = at3*zt2 + at2*zt3         wp = wp + at1*(cu(1,k,j,l)*conjg(cu(1,k,j,l)) + cu(2,k,j,l)*con     1jg(cu(2,k,j,l)) + cu(3,k,j,l)*conjg(cu(3,k,j,l)) + cu(1,k1,j,l)*co     2njg(cu(1,k1,j,l)) + cu(2,k1,j,l)*conjg(cu(2,k1,j,l)) + cu(3,k1,j,l     3)*conjg(cu(3,k1,j,l)))   10    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         at1 = ci2*real(ffc(1,j,l))         at2 = dkx*at1         at1 = at1*aimag(ffc(1,j,l))         zt1 = cmplx(-aimag(cu(3,1,j,l)),real(cu(3,1,j,l)))         zt2 = cmplx(-aimag(cu(2,1,j,l)),real(cu(2,1,j,l)))         bxy(1,1,j,l) = zero         bxy(2,1,j,l) = -at2*zt1         bxy(3,1,j,l) = at2*zt2         bxy(1,k1,j,l) = zero         bxy(2,k1,j,l) = zero         bxy(3,k1,j,l) = zero         wp = wp + at1*(cu(1,1,j,l)*conjg(cu(1,1,j,l)) + cu(2,1,j,l)*con     1jg(cu(2,1,j,l)) + cu(3,1,j,l)*conjg(cu(3,1,j,l)))      endif   20 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 30 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         at1 = ci2*real(ffc(k,1,l))         at2 = dky*at1         at1 = at1*aimag(ffc(k,1,l))         zt1 = cmplx(-aimag(cu(3,k,1,l)),real(cu(3,k,1,l)))         zt2 = cmplx(-aimag(cu(1,k,1,l)),real(cu(1,k,1,l)))         bxy(1,k,1,l) = at2*zt1         bxy(2,k,1,l) = zero         bxy(3,k,1,l) = -at2*zt2         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero         bxy(3,k1,1,l) = zero         wp = wp + at1*(cu(1,k,1,l)*conjg(cu(1,k,1,l)) + cu(2,k,1,l)*con     1jg(cu(2,k,1,l)) + cu(3,k,1,l)*conjg(cu(3,k,1,l)))   30    continue         k1 = nyh + 1         bxy(1,1,1,l) = zero         bxy(2,1,1,l) = zero         bxy(3,1,1,l) = zero         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero         bxy(3,k1,1,l) = zero      endif   40 continue   50 continue      wm = float(nx*ny)*wp      return      endc-----------------------------------------------------------------------      subroutine PMAXWEL2(exy,bxy,cu,ffc,affp,ci,dt,wf,wm,nx,ny,kstrt,ny     1v,kxp,jblok,nyhd)c this subroutine solves 2d maxwell's equation in fourier space forc transverse electric and magnetic fields with periodic boundaryc conditions.c input: all, output: wf, wm, exy, bxyc approximate flop count is: 286*nxc*nyc + 84*(nxc + nyc)c where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc the magnetic field is first updated half a step using the equations:c bx(kx,ky) = bx(kx,ky) - .5*dt*sqrt(-1)*ky*ez(kx,ky)c by(kx,ky) = by(kx,ky) + .5*dt*sqrt(-1)*kx*ez(kx,ky)c bz(kx,ky) = bz(kx,ky) - .5*dt*sqrt(-1)*(kx*ey(kx,ky)-ky*ex(kx,ky))c the electric field is then updated a whole step using the equations:c ex(kx,ky) = ex(kx,ky) + c2*dt*sqrt(-1)*ky*bz(kx,ky)c                       - affp*dt*cux(kx,ky)*s(kx,ky)c ey(kx,ky) = ey(kx,ky) - c2*dt*sqrt(-1)*kx*bz(kx,ky)c                       - affp*dt*cuy(kx,ky)*s(kx,ky)c ez(kx,ky) = ez(kx,ky) + c2*dt*sqrt(-1)*(kx*by(kx,ky)-ky*bx(kx,ky))c                       - affp*dt*cuz(kx,ky)*s(kx,ky)c the magnetic field is finally updated the remaining half step withc the new electric field and the previous magnetic field equations.c where kx = 2pi*j/nx, ky = 2pi*k/ny, c2 = 1./(ci*ci)c and s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)c j,k = fourier mode numbers, except forc ex(kx=pi) = ey(kx=pi) = ez(kx=pi) = 0,c ex(ky=pi) = ey(ky=pi) = ez(ky=pi) = 0,c ex(kx=0,ky=0) = ey(kx=0,ky=0) = ez(kx=0,ky=0) = 0.c and similarly for bx, by, bz.c cu(i,k,j,l) = i-th component of complex current density andc exy(i,k,j,l) = i-th component of complex electric field,c bxy(i,k,j,l) = i-th component of complex magnetic field,c for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c aimag(ffc(k,j,l)) = finite-size particle shape factor sc s(kx,ky) = exp(-((kx*ax)**2+(ky*ay)**2)c for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c affp = normalization constant = nx*ny/np, where np=number of particlesc ci = reciprical of velocity of lightc dt = time interval between successive calculationsc transverse electric field energy is also calculated, usingc wf = nx*ny*nz**sum((1/affp)*|exyz(kx,ky,kz)|**2)c magnetic field energy is also calculated, usingc wm = nx*ny*nz**sum((c2/affp)*|bxyz(kx,ky,kz)|**2)c nx/ny = system length in x/y directionc jblok = number of data blocksc kxp = number of data values per blockc kstrt = starting data block numberc nyv = first dimension of field arrays, must be >= nyc nyhd = first dimension of form factor array, must be >= nyh      double precision wp, ws      complex exy, bxy, cu, ffc      complex zero, zt1, zt2, zt3, zt4, zt5, zt6, zt7, zt8, zt9      dimension exy(3,nyv,kxp,jblok), bxy(3,nyv,kxp,jblok)      dimension cu(3,nyv,kxp,jblok)      dimension ffc(nyhd,kxp,jblok)      if (ci.le.0.) return      nxh = nx/2      nyh = ny/2      ny2 = ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx)      dny = 6.28318530717959/float(ny)      dth = .5*dt      c2 = 1./(ci*ci)      cdt = c2*dt      adt = affp*dt      zero = cmplx(0.,0.)      anorm = 1.0/affpc update electromagnetic field and sum field energies      ws = 0.0d0      wp = 0.0d0      if (kstrt.gt.nxh) go to 50c calculate the electromagnetic fields      do 40 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 20 j = 1, kxp      dkx = dnx*float(j + joff)      if ((j+joff).gt.0) then         do 10 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         afdt = adt*aimag(ffc(k,j,l))c update magnetic field half time step, ky > 0         zt1 = cmplx(-aimag(exy(3,k,j,l)),real(exy(3,k,j,l)))         zt2 = cmplx(-aimag(exy(2,k,j,l)),real(exy(2,k,j,l)))         zt3 = cmplx(-aimag(exy(1,k,j,l)),real(exy(1,k,j,l)))         zt4 = bxy(1,k,j,l) - dth*(dky*zt1)         zt5 = bxy(2,k,j,l) + dth*(dkx*zt1)         zt6 = bxy(3,k,j,l) - dth*(dkx*zt2 - dky*zt3)c update electric field whole time step         zt1 = cmplx(-aimag(zt6),real(zt6))         zt2 = cmplx(-aimag(zt5),real(zt5))         zt3 = cmplx(-aimag(zt4),real(zt4))         zt7 = exy(1,k,j,l) + cdt*(dky*zt1) - afdt*cu(1,k,j,l)         zt8 = exy(2,k,j,l) - cdt*(dkx*zt1) - afdt*cu(2,k,j,l)         zt9 = exy(3,k,j,l) + cdt*(dkx*zt2 - dky*zt3) - afdt*cu(3,k,j,l)c update magnetic field half time step and store electric field         zt1 = cmplx(-aimag(zt9),real(zt9))         zt2 = cmplx(-aimag(zt8),real(zt8))         zt3 = cmplx(-aimag(zt7),real(zt7))         exy(1,k,j,l) = zt7         exy(2,k,j,l) = zt8         exy(3,k,j,l) = zt9         ws = ws + anorm*(zt7*conjg(zt7) + zt8*conjg(zt8) + zt9*conjg(zt     19))         zt4 = zt4 - dth*(dky*zt1)         zt5 = zt5 + dth*(dkx*zt1)         zt6 = zt6 - dth*(dkx*zt2 - dky*zt3)         bxy(1,k,j,l) = zt4         bxy(2,k,j,l) = zt5         bxy(3,k,j,l) = zt6         wp = wp + anorm*(zt4*conjg(zt4) + zt5*conjg(zt5) + zt6*conjg(zt     16))c update magnetic field half time step, ky < 0         zt1 = cmplx(-aimag(exy(3,k1,j,l)),real(exy(3,k1,j,l)))         zt2 = cmplx(-aimag(exy(2,k1,j,l)),real(exy(2,k1,j,l)))         zt3 = cmplx(-aimag(exy(1,k1,j,l)),real(exy(1,k1,j,l)))         zt4 = bxy(1,k1,j,l) + dth*(dky*zt1)         zt5 = bxy(2,k1,j,l) + dth*(dkx*zt1)         zt6 = bxy(3,k1,j,l) - dth*(dkx*zt2 + dky*zt3)c update electric field whole time step         zt1 = cmplx(-aimag(zt6),real(zt6))         zt2 = cmplx(-aimag(zt5),real(zt5))         zt3 = cmplx(-aimag(zt4),real(zt4))         zt7 = exy(1,k1,j,l) - cdt*(dky*zt1) - afdt*cu(1,k1,j,l)         zt8 = exy(2,k1,j,l) - cdt*(dkx*zt1) - afdt*cu(2,k1,j,l)         zt9 = exy(3,k1,j,l) + cdt*(dkx*zt2 + dky*zt3) - afdt*cu(3,k1,j,     1l)c update magnetic field half time step and store electric field         zt1 = cmplx(-aimag(zt9),real(zt9))         zt2 = cmplx(-aimag(zt8),real(zt8))         zt3 = cmplx(-aimag(zt7),real(zt7))         exy(1,k1,j,l) = zt7         exy(2,k1,j,l) = zt8         exy(3,k1,j,l) = zt9         ws = ws + anorm*(zt7*conjg(zt7) + zt8*conjg(zt8) + zt9*conjg(zt     19))         zt4 = zt4 + dth*(dky*zt1)         zt5 = zt5 + dth*(dkx*zt1)         zt6 = zt6 - dth*(dkx*zt2 + dky*zt3)         bxy(1,k1,j,l) = zt4         bxy(2,k1,j,l) = zt5         bxy(3,k1,j,l) = zt6         wp = wp + anorm*(zt4*conjg(zt4) + zt5*conjg(zt5) + zt6*conjg(zt     16))   10    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         afdt = adt*aimag(ffc(1,j,l))c update magnetic field half time step         zt1 = cmplx(-aimag(exy(3,1,j,l)),real(exy(3,1,j,l)))         zt2 = cmplx(-aimag(exy(2,1,j,l)),real(exy(2,1,j,l)))         zt5 = bxy(2,1,j,l) + dth*(dkx*zt1)         zt6 = bxy(3,1,j,l) - dth*(dkx*zt2)c update electric field whole time step         zt1 = cmplx(-aimag(zt6),real(zt6))         zt2 = cmplx(-aimag(zt5),real(zt5))         zt8 = exy(2,1,j,l) - cdt*(dkx*zt1) - afdt*cu(2,1,j,l)         zt9 = exy(3,1,j,l) + cdt*(dkx*zt2) - afdt*cu(3,1,j,l)c update magnetic field half time step and store electric field         zt1 = cmplx(-aimag(zt9),real(zt9))         zt2 = cmplx(-aimag(zt8),real(zt8))         exy(1,1,j,l) = zero         exy(2,1,j,l) = zt8         exy(3,1,j,l) = zt9         ws = ws + anorm*(zt8*conjg(zt8) + zt9*conjg(zt9))         zt5 = zt5 + dth*(dkx*zt1)         zt6 = zt6 - dth*(dkx*zt2)         bxy(1,1,j,l) = zero         bxy(2,1,j,l) = zt5         bxy(3,1,j,l) = zt6         wp = wp + anorm*(zt5*conjg(zt5) + zt6*conjg(zt6))         bxy(1,k1,j,l) = zero         bxy(2,k1,j,l) = zero         bxy(3,k1,j,l) = zero         exy(1,k1,j,l) = zero         exy(2,k1,j,l) = zero         exy(3,k1,j,l) = zero      endif   20 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 30 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         afdt = adt*aimag(ffc(k,1,l))c update magnetic field half time step         zt1 = cmplx(-aimag(exy(3,k,1,l)),real(exy(3,k,1,l)))         zt3 = cmplx(-aimag(exy(1,k,1,l)),real(exy(1,k,1,l)))         zt4 = bxy(1,k,1,l) - dth*(dky*zt1)         zt6 = bxy(3,k,1,l) + dth*(dky*zt3)c update electric field whole time step         zt1 = cmplx(-aimag(zt6),real(zt6))         zt3 = cmplx(-aimag(zt4),real(zt4))         zt7 = exy(1,k,1,l) + cdt*(dky*zt1) - afdt*cu(1,k,1,l)         zt9 = exy(3,k,1,l) - cdt*(dky*zt3) - afdt*cu(3,k,1,l)c update magnetic field half time step and store electric field         zt1 = cmplx(-aimag(zt9),real(zt9))         zt3 = cmplx(-aimag(zt7),real(zt7))         exy(1,k,1,l) = zt7         exy(2,k,1,l) = zero         exy(3,k,1,l) = zt9         ws = ws + anorm*(zt7*conjg(zt7) + zt9*conjg(zt9))         zt4 = zt4 - dth*(dky*zt1)         zt6 = zt6 + dth*(dky*zt3)         bxy(1,k,1,l) = zt4         bxy(2,k,1,l) = zero         bxy(3,k,1,l) = zt6         wp = wp + anorm*(zt4*conjg(zt4) + zt6*conjg(zt6))         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero         bxy(3,k1,1,l) = zero         exy(1,k1,1,l) = zero         exy(2,k1,1,l) = zero         exy(3,k1,1,l) = zero   30    continue         k1 = nyh + 1         bxy(1,1,1,l) = zero         bxy(2,1,1,l) = zero         bxy(3,1,1,l) = zero         exy(1,1,1,l) = zero         exy(2,1,1,l) = zero         exy(3,1,1,l) = zero         bxy(1,k1,1,l) = zero         bxy(2,k1,1,l) = zero         bxy(3,k1,1,l) = zero         exy(1,k1,1,l) = zero         exy(2,k1,1,l) = zero         exy(3,k1,1,l) = zero      endif   40 continue   50 continue      wf = float(nx*ny)*ws      wm = float(nx*ny)*c2*wp      return      endc-----------------------------------------------------------------------      subroutine PEMFIELD2(fxy,exy,ffc,isign,nx,ny,kstrt,nyv,kxp,jblok,n     1yhd)c this subroutine either adds complex vector fields if isign > 0c or copies complex vector fields if isign < 0c includes additional smoothing      implicit none      integer isign, nx, ny, kstrt, nyv, kxp, jblok, nyhd      complex fxy, exy, ffc      dimension fxy(3,nyv,kxp,jblok), exy(3,nyv,kxp,jblok)      dimension ffc(nyhd,kxp,jblok)      integer i, j, k, l, nxh, nyh, ny2, k1      real at1      nxh = nx/2      nyh = ny/2      ny2 = ny + 2      if (kstrt.gt.nxh) returnc add the fields      if (isign.gt.0) then         do 50 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2         do 40 j = 1, kxp         do 20 k = 2, nyh         k1 = ny2 - k         at1 = aimag(ffc(k,j,l))         do 10 i = 1, 3         fxy(i,k,j,l) = fxy(i,k,j,l) + exy(i,k,j,l)*at1         fxy(i,k1,j,l) = fxy(i,k1,j,l) + exy(i,k1,j,l)*at1   10    continue   20    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         at1 = aimag(ffc(1,j,l))         do 30 i = 1, 3         fxy(i,1,j,l) = fxy(i,1,j,l) + exy(i,1,j,l)*at1         fxy(i,k1,j,l) = fxy(i,k1,j,l) + exy(i,k1,j,l)*at1   30    continue   40    continue   50    continuec copy the fields      else if (isign.lt.0) then         do 100 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2         do 90 j = 1, kxp         do 70 k = 2, nyh         k1 = ny2 - k         at1 = aimag(ffc(k,j,l))         do 60 i = 1, 3         fxy(i,k,j,l) = exy(i,k,j,l)*at1         fxy(i,k1,j,l) = exy(i,k1,j,l)*at1   60    continue   70    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         at1 = aimag(ffc(1,j,l))         do 80 i = 1, 3         fxy(i,1,j,l) = exy(i,1,j,l)*at1         fxy(i,k1,j,l) = exy(i,k1,j,l)*at1   80    continue   90    continue  100    continue      endif      return      endc-----------------------------------------------------------------------      subroutine PEMFIELDR2(fxy,exy,ffd,isign,nx,ny,kstrt,nyv,kxp2,j2blo     1k,nyd)c this subroutine either adds complex vector fields if isign > 0c or copies complex vector fields if isign < 0c includes additional smoothing      implicit none      integer isign, nx, ny, kstrt, nyv, kxp2, j2blok, nyd      real fxy, exy      complex ffd      dimension fxy(3,nyv,kxp2+1,j2blok), exy(3,nyv,kxp2+1,j2blok)      dimension ffd(nyd,kxp2,j2blok)      integer i, j, k, l, ny1      real at1      ny1 = ny + 1      if (kstrt.gt.nx) returnc smooth the em field and add      if (isign.gt.0) then         do 70 l = 1, j2blokc mode numbers 0 < kx < nx and 0 < ky < ny         do 40 j = 1, kxp2         do 20 k = 1, ny         at1 = aimag(ffd(k,j,l))         do 10 i = 1, 3         fxy(i,k,j,l) = fxy(i,k,j,l) + exy(i,k,j,l)*at1   10    continue   20    continuec mode numbers ky = 0, ny/2         do 30 i = 1, 3         fxy(i,ny+1,j,l) = fxy(i,ny+1,j,l) + exy(i,ny+1,j,l)   30    continue   40    continue         do 60 k = 1, ny1         do 50 i = 1, 3         fxy(i,k,kxp2+1,l) = fxy(i,k,kxp2+1,l) + exy(i,k,kxp2+1,l)   50    continue   60    continue   70    continuec copy and smooth the magnetic fields      else if (isign.lt.0) then         do 140 l = 1, j2blokc mode numbers 0 < kx < nx and 0 < ky < ny         do 110 j = 1, kxp2         do 90 k = 1, ny         at1 = aimag(ffd(k,j,l))         do 80 i = 1, 3         fxy(i,k,j,l) = exy(i,k,j,l)*at1   80    continue   90    continuec mode numbers ky = 0, ny/2         do 100 i = 1, 3         fxy(i,ny+1,j,l) = exy(i,ny+1,j,l)  100    continue  110    continue         do 130 k = 1, ny1         do 120 i = 1, 3         fxy(i,k,kxp2+1,l) = exy(i,k,kxp2+1,l)  120    continue  130    continue  140    continuec copy the electric fields      else if (isign.eq.0) then         do 210 l = 1, j2blokc mode numbers 0 < kx < nx and 0 < ky < ny         do 180 j = 1, kxp2         do 160 k = 1, ny         do 150 i = 1, 3         fxy(i,k,j,l) = exy(i,k,j,l)  150    continue  160    continuec mode numbers ky = 0, ny/2         do 170 i = 1, 3         fxy(i,ny+1,j,l) = exy(i,ny+1,j,l)  170    continue  180    continue         do 200 k = 1, ny1         do 190 i = 1, 3         fxy(i,k,kxp2+1,l) = exy(i,k,kxp2+1,l)  190    continue  200    continue  210    continue      endif      return      endc-----------------------------------------------------------------------      subroutine PAVPOT23(bxy,axy,nx,ny,kstrt,nyv,kxp,jblok)c this subroutine calculates 2-1/2d vector potential from magnetic fieldc in fourier space with periodic boundary conditionsc for distributed data.c input: bxy,nx,ny,kstrt,nyv,kxp,jblok, output: axyc approximate flop count is: 38*nxc*nyc + 10*(nxc + nyc)c and nxc*nyc dividesc where nxc = (nx/2-1)/nvp, nyc = ny/2 - 1, and nvp = number of procsc the vector potential is calculated using the equations:c ax(kx,ky) = sqrt(-1)*(ky*bz(kx,ky))/(kx*kx+ky*ky)c ay(kx,ky) = -sqrt(-1)*(kx*bz(kx,ky))/(kx*kx+ky*ky)c az(kx,ky) = sqrt(-1)*(kx*by(kx,ky)-ky*bx(kx,ky))/(kx*kx+ky*ky),c where kx = 2pi*j/nx, ky = 2pi*k/ny, and j,k = fourier mode numbers,c ax(kx=pi) = ay(kx=pi) = az(kx=pi) = 0,c ax(ky=pi) = ay(ky=pi) = az(ky=pi) = 0,c ax(kx=0,ky=0) = ay(kx=0,ky=0) = az(kx=0,ky=0) = 0.c bxy(i,k,j,l) = i-th component of complex magnetic field,c axy(i,k,j,l) = i-th component of complex vector potential,c for fourier mode (jj-1,k-1), where jj = j + kxp*(l - 1)c jblok = number of data blocksc kxp = number of data values per blockc kstrt = starting data block numberc nx/ny = system length in x/y directionc nyv = first dimension of field arrays, must be >= ny      complex bxy, axy, zero, zt1, zt2, zt3      dimension bxy(3,nyv,kxp,jblok), axy(3,nyv,kxp,jblok)      nxh = nx/2      nyh = ny/2      ny2 = ny + 2      ks = kstrt - 2      dnx = 6.28318530717959/float(nx)      dny = 6.28318530717959/float(ny)      zero = cmplx(0.,0.)c calculate vector potential      if (kstrt.gt.nxh) go to 50      do 40 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks) - 1      do 20 j = 1, kxp      dkx = dnx*float(j + joff)      dkx2 = dkx*dkx      if ((j+joff).gt.0) then         do 10 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         at1 = 1./(dky*dky + dkx2)         at2 = dky*at1         at3 = dkx*at1         zt1 = cmplx(-aimag(bxy(3,k,j,l)),real(bxy(3,k,j,l)))         zt2 = cmplx(-aimag(bxy(2,k,j,l)),real(bxy(2,k,j,l)))         zt3 = cmplx(-aimag(bxy(1,k,j,l)),real(bxy(1,k,j,l)))         axy(1,k,j,l) = at2*zt1         axy(2,k,j,l) = -at3*zt1         axy(3,k,j,l) = at3*zt2 - at2*zt3         zt1 = cmplx(-aimag(bxy(3,k1,j,l)),real(bxy(3,k1,j,l)))         zt2 = cmplx(-aimag(bxy(2,k1,j,l)),real(bxy(2,k1,j,l)))         zt3 = cmplx(-aimag(bxy(1,k1,j,l)),real(bxy(1,k1,j,l)))         axy(1,k1,j,l) = -at2*zt1         axy(2,k1,j,l) = -at3*zt1         axy(3,k1,j,l) = at3*zt2 + at2*zt3   10    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         at2 = 1.0/dkx         zt1 = cmplx(-aimag(bxy(3,1,j,l)),real(bxy(3,1,j,l)))         zt2 = cmplx(-aimag(bxy(2,1,j,l)),real(bxy(2,1,j,l)))         axy(1,1,j,l) = zero         axy(2,1,j,l) = -at2*zt1         axy(3,1,j,l) = at2*zt2         axy(1,k1,j,l) = zero         axy(2,k1,j,l) = zero         axy(3,k1,j,l) = zero      endif   20 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 30 k = 2, nyh         k1 = ny2 - k         dky = dny*float(k - 1)         at2 = 1.0/dky         zt1 = cmplx(-aimag(bxy(3,k,1,l)),real(bxy(3,k,1,l)))         zt2 = cmplx(-aimag(bxy(1,k,1,l)),real(bxy(1,k,1,l)))         axy(1,k,1,l) = at2*zt1         axy(2,k,1,l) = zero         axy(3,k,1,l) = -at2*zt2         axy(1,k1,1,l) = zero         axy(2,k1,1,l) = zero         axy(3,k1,1,l) = zero   30    continue         k1 = nyh + 1         axy(1,1,1,l) = zero         axy(2,1,1,l) = zero         axy(3,1,1,l) = zero         axy(1,k1,1,l) = zero         axy(2,k1,1,l) = zero         axy(3,k1,1,l) = zero      endif   40 continue   50 continue      return      endc-----------------------------------------------------------------------      subroutine PGTMODES2(pot,pott,nx,ny,it,modesx,modesy,kstrt,nyv,kxp     1,jblok,nt,modesxpd,modesyd)c this subroutine extracts lowest order modes from complex array potc and stores them into a location in a time history array pottc nx/ny = system length in x/y directionc it = current timec modesx/modesy = number of modes to store in x/y direction,c where modesx <= nx/2, modesy <= ny/2c kstrt = starting data block numberc nyv = first dimension of input array pot, nyv >= nyc kxp = number of data values per blockc jblok = number of data blocksc nt = first dimension of output array pott, nt >= itc modesyd = second dimension of array pott, modesyd  = 2*modesy-1c modesxpd = third dimension of array pott, modesxpd >= min(modesx,kxp)      complex pot, pott      dimension pot(nyv,kxp,jblok), pott(nt,modesyd,modesxpd,jblok)      if (it.gt.nt) return      nxh = nx/2      if ((modesx.gt.nxh).or.(modesy.gt.(ny/2))) return      ny2 = ny + 2      ks = kstrt - 2      if (kstrt.gt.nxh) go to 50      do 40 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks)      modesxp = modesx - joff      if (modesxp.gt.kxp) then         modesxp = kxp      else if (modesxp.le.0) then         modesxp = 0      endif      do 20 j = 1, modesxp      if ((j+joff).gt.1) then         do 10 k = 2, modesy         k1 = ny2 - k         pott(it,2*k-2,j,l) = pot(k,j,l)         pott(it,2*k-1,j,l) = pot(k1,j,l)   10    continuec mode numbers ky = 0, ny/2         pott(it,1,j,l) = pot(1,j,l)      endif   20 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 30 k = 2, modesy         pott(it,2*k-2,1,l) = pot(k,1,l)         pott(it,2*k-1,1,l) = conjg(pot(k,1,l))   30    continue         pott(it,1,1,l) = cmplx(real(pot(1,1,l)),0.0)      endif   40 continue   50 continue      return      endc-----------------------------------------------------------------------      subroutine PPTMODES2(pot,pott,nx,ny,it,modesx,modesy,kstrt,nyv,kxp     1,jblok,nt,modesxpd,modesyd)c this subroutine extracts lowest order modes from a location in a timec history array pott and stores them into complex array potc nx/ny = system length in x/y directionc it = current timec modesx/modesy = number of modes to store in x/y direction,c where modesx <= nx/2, modesy <= ny/2c kstrt = starting data block numberc nyv = first dimension of input array pot, nyv >= nyc kxp = number of data values per blockc jblok = number of data blocksc nt = first dimension of output array pott, nt >= itc modesyd = second dimension of array pott, modesyd  = 2*modesy-1c modesxpd = third dimension of array pott, modesxpd >= min(modesx,kxp)      complex pot, pott, zero      dimension pot(nyv,kxp,jblok), pott(nt,modesyd,modesxpd,jblok)      if (it.gt.nt) return      nxh = nx/2      nyh = ny/2      if ((modesx.gt.nxh).or.(modesy.gt.nyh)) return      ny2 = ny + 2      ks = kstrt - 2      zero = cmplx(0.,0.)      if (kstrt.gt.nxh) go to 100      do 90 l = 1, jblokc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      joff = kxp*(l + ks)      modesxp = modesx - joff      if (modesxp.gt.kxp) then         modesxp = kxp      else if (modesxp.le.0) then         modesxp = 0      endif      do 30 j = 1, modesxp      if ((j+joff).gt.1) then         do 10 k = 2, modesy         k1 = ny2 - k         pot(k,j,l) = pott(it,2*k-2,j,l)         pot(k1,j,l) = pott(it,2*k-1,j,l)   10    continue         do 20 k = modesy+1, nyh         k1 = ny2 - k         pot(k,j,l) = zero         pot(k1,j,l) = zero   20    continuec mode numbers ky = 0, ny/2         k1 = nyh + 1         pot(1,j,l) = pott(it,1,j,l)         pot(k1,j,l) = zero      endif   30 continue      do 60 j = modesxp+1, kxp      if ((j+joff).gt.1) then         do 40 k = 2, nyh         k1 = ny2 - k         pot(k,j,l) = zero         pot(k1,j,l) = zero   40    continue         k1 = nyh + 1c mode numbers ky = 0, ny/2         pot(1,j,l) = zero         pot(k1,j,l) = zero      endif   60 continuec mode numbers kx = 0, nx/2      if ((l+ks).eq.0) then         do 70 k = 2, modesy         k1 = ny2 - k         pot(k,1,l) = pott(it,2*k-2,1,l)         pot(k1,1,l) = zero   70    continue         do 80 k = modesy+1, nyh         k1 = ny2 - k         pot(k,1,l) = zero         pot(k1,1,l) = zero   80    continue         k1 = nyh + 1         pot(1,1,l) = cmplx(real(pott(it,1,1,l)),0.)         pot(k1,1,l) = zero      endif   90 continue  100 continue      return      end