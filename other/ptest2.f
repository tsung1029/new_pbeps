c-----------------------------------------------------------------------      program ptest2      implicit none      integer indx, indy, indnvp, mshare, nx, ny, nxh, nvp, kyp, kxp      integer kyb, kxb, jkmx, kxyb, kbmin, kblok, jbmin, jblok      integer nmx, nxy, nmxh, nxhy, nxv, nyv, nxvh, nxyhc indnvp = exponent which determines number of virtual processorsc mshare = (0,1) = (no,yes) architecture is shared memoryc     parameter( indx =   2, indy =   2, indnvp =   2, mshare =   0)      parameter( indx =   7, indy =   8, indnvp =   2, mshare =   0)      parameter(nx=2**indx,ny=2**indy,nxh=nx/2)      parameter(nvp=2**indnvp,kyp=(ny-1)/nvp+1,kxp=(nxh-1)/nvp+1)      parameter(kyb=ny/kyp,kxb=nxh/kxp,jkmx=kxb*(kyb/kxb)+kyb*(kxb/kyb))      parameter(kxyb=jkmx/(2-kxb/jkmx-kyb/jkmx))      parameter(kbmin=1+(1-mshare)*(kxyb/kxb-1))      parameter(kblok=1+mshare*(ny/kyp-1))      parameter(jbmin=1+(1-mshare)*(kxyb/kyb-1))      parameter(jblok=1+mshare*(nxh/kxp-1))      parameter(nmx=nx*(ny/nx)+ny*(nx/ny),nxy=nmx/(2-nx/nmx-ny/nmx))      parameter(nmxh=nxh*(ny/nxh)+ny*(nxh/ny))      parameter(nxhy=nmxh/(2-nxh/nmxh-ny/nmxh))      parameter(nxv=nx+2,nyv=ny+2,nxvh=nxv/2,nxyh=nxy/2)      integer mixup, msid, mrid, i, j, k, l, kk, k1, ntpose, isign      integer idproc, kstrt, ks, koff      real f, g, h, time, epsmax, eps, work1      complex sct, bs, br      double precision dtime      double precision ranorm      dimension f(nxv,kyp,kblok), g(2*nyv,kxp,jblok)      dimension h(nxv,ny)      dimension time(2)c mixup, sct = arrays for fft      dimension mixup(nxhy), sct(nxyh), msid(kxb), mrid(kyb)      dimension bs(kxp,kyp,kblok), br(kxp,kyp,jblok)c      integer nblok, nypmx, nxe, nye, idps, ngds, nyp, noff, ngx, ngy      parameter(nblok=1+mshare*(nvp-1),nypmx=kyp+3)      parameter(nxe=nx+4,nye=ny+3,idps=2,ngds=3*((idps-1)/2+1))      dimension nyp(nblok), noff(nblok)      real xj0, yj0, zj0, edges, qu, qug, sum1, sum2, sum3, scr      dimension edges(idps,nblok)c     dimension qu(3,nxe,nypmx,kblok), qug(3,nxe,nye)c     dimension qu(2,nxe,nypmx,kblok), qug(2,nxe,nye)      dimension qu(nxe,nypmx,kblok), qug(nxe,nye)      real sumg, workg      dimension sumg(3), workg(3)      dimension scr(3*nxe,ngds,nblok)cc ntpose = (0,1) = (no,yes) input, output data are transposed in pfft2r      data ntpose /1/c initialize for parallel processing      call PPINIT(idproc,nvp)      kstrt = idproc + 1      ks = kstrt - 2c prepare fft tables      isign = 0      call PFFT2R(f,g,bs,br,isign,ntpose,mixup,sct,indx,indy,kstrt,nxvh,     1nyv,kxp,kyp,kyp,jblok,kblok,nxhy,nxyh)c     call PFFT2RX(f,g,isign,ntpose,mixup,sct,indx,indy,kstrt,nxvh,nyv,kc    1xp,kyp,kyp,jblok,kblok,nxhy,nxyh)c     call PFFT2RY(f,g,msid,mrid,isign,ntpose,mixup,sct,indx,indy,kstrt,c    1nxvh,nyv,kxp,kyp,kxb,kyb,kyp,jblok,kblok,nxhy,nxyh)c      call DCOMP2(edges,nyp,noff,ny,kstrt,nvp,idps,nblok)c create test function      do 30 k = 1, ny      kk = (k - 1)/kyp      k1 = k - kyp*kk      do 20 j = 1, nx      h(j,k) = ranorm()c      qug(j+1,k+1) = ranorm()c     qug(1,j+1,k+1) = ranorm()c     qug(2,j+1,k+1) = ranorm()c     qug(3,j+1,k+1) = ranorm()c      do 10 l = 1, kblok      if (kk.eq.(l+ks)) f(j,k1,l) = h(j,k)c      if (kk.eq.(l+ks)) then         qu(j+1,k+1,l) = qug(j+1,k+1)c        qu(1,j+1,k+1,l) = qug(1,j+1,k+1)c        qu(2,j+1,k+1,l) = qug(2,j+1,k+1)c        qu(3,j+1,k+1,l) = qug(3,j+1,k+1)      endifc   10 continue   20 continue   30 continuec-----------------------------------------------------------------------      qu = 9.0; qug = -9.0      xj0 = 1.0; yj0 = 2.0; zj0 = 3.0c     ngx = 1; ngy = 1      ngx = 0; ngy = 0c-----------------------------------------------------------------------c     call LSCGUARD2(qug,xj0,yj0,zj0,nx,ny,ngx,ngy,nxe,nye)c     call LSCGUARD22(qug,xj0,yj0,nx,ny,ngx,ngy,nxe,nye)      call LSGUARD2(qug,xj0,nx,ny,ngx,ngy,nxe,nye)c     call LSCGUARD2L(qug,xj0,yj0,zj0,nx,ny,ngx,ngy,nxe,nye)c     call LSCGUARD22L(qug,xj0,yj0,nx,ny,ngx,ngy,nxe,nye)c     call LSGUARD2L(qug,xj0,nx,ny,ngx,ngy,nxe,nye)      sum1 = 0.      sum2 = 0.      sum3 = 0.      do k = 1, ny+3      do j = 1, nx+3      sum1 = sum1 + qug(j,k)c     sum1 = sum1 + qug(1,j,k)c     sum2 = sum2 + qug(2,j,k)c     sum3 = sum3 + qug(3,j,k)c     write (61,*) j,k,qug(1,j,k)      enddo      enddo      write (71,*) 'serial sum1,sum2,sum3=',sum1,sum2,sum3c-----------------------------------------------------------------------c     call PLSCGUARD2X(qu,kstrt,nvp,noff,nyp,xj0,yj0,zj0,nx,ny,ngx,ngy,nc    1xe,nypmx,nblok)c     call PLSCGUARD22X(qu,kstrt,nvp,noff,nyp,xj0,yj0,nx,ny,ngx,ngy,nxe,c    1nypmx,nblok)      call PLSGUARD2X(qu,kstrt,nvp,noff,nyp,xj0,nx,ny,ngx,ngy,nxe,nypmx,     1nblok)c     call PLSCGUARD2XL(qu,kstrt,nvp,noff,nyp,xj0,yj0,zj0,nx,ny,ngx,ngy,c    1nxe,nypmx,nblok)c     call PLSCGUARD22XL(qu,kstrt,nvp,noff,nyp,xj0,yj0,nx,ny,ngx,ngy,nxec    1,nypmx,nblok)c     call PLSGUARD2XL(qu,kstrt,nvp,noff,nyp,xj0,nx,ny,ngx,ngy,nxe,nypmxc    1,nblok)      sumg(1) = 0.      sumg(2) = 0.      sumg(3) = 0.      do l = 1, kblok      do k = 1, kyp+3      do j = 1, nx+3      sumg(1) = sumg(1) + qu(j,k,l)c     if (abs(qu(1,j,k,l)).gt.3.0) write (71,*) 1,j,k,qu(1,j,k,l)c     if (abs(qu(2,j,k,l)).gt.3.0) write (71,*) 2,j,k,qu(2,j,k,l)c     if (abs(qu(3,j,k,l)).gt.3.0) write (71,*) 3,j,k,qu(3,j,k,l)c     sumg(1) = sumg(1) + qu(1,j,k,l)c     sumg(2) = sumg(2) + qu(2,j,k,l)c     sumg(3) = sumg(3) + qu(3,j,k,l)c     write (62,*) j,k,qu(1,j,k,l)      enddo      enddo      enddo      write (71,*) 'local sum1,sum2,sum3=',sumg(1),sumg(2),sumg(3)      call psum(sumg,workg,3,1)      write (71,*) 'global sum1,sum2,sum3=',sumg(1),sumg(2),sumg(3)cc     call LACGUARD2(qug(1,2,2),nx-2,ny-2,nxe,nye)c     call PLACGUARD2X(qu(1,2,1,1),nyp,nx-2,nxe,nypmx,nblok)c     call PLACGUARD2(qu,scr,kstrt,nvp,nx,nxe,nypmx,kyp,kblok,ngds)c     call PLACGUARDS2(qu,kstrt,nvp,nx,nxe,nypmx,kyp,kblok)c      epsmax = 0.      if (kstrt.gt.ny) go to 90      do 80 l = 1, kblok      koff = kyp*(l + ks)      do 70 k = 1, kyp      k1 = k + koff      do 60 j = 1, nx+3      eps = abs(qu(j,k+1,l) - qug(j,k1+1))c     eps = abs(qu(j,k,l) - qug(j,k1))c     do 50 i = 1, 3c     eps = abs(qu(i,j,k+1,l) - qug(i,j,k1+1))c     eps = abs(qu(i,j,k,l) - qug(i,j,k1))      if (eps.gt.epsmax) then         write (71,*) j,k,':',k1,qu(j,k+1,l),qug(j,k1+1),epsc        write (71,*) j,k,':',k1,qu(j,k,l),qug(j,k1),epsc        write (71,*) i,j,k,':',k1,qu(i,j,k+1,l),qug(i,j,k1+1),epsc        write (71,*) i,j,k,':',k1,qu(i,j,k,l),qug(i,j,k1),eps         epsmax = eps      endifc  50 continue   60 continue   70 continue   80 continue   90 continue      write (71,*) 'local epsmax=',epsmax      call PSUM(epsmax,eps,1,1)      write (71,*) 'global epsmax=',epsmaxc      if (kstrt.ge.0) then         call PPEXIT         stop      endifcc     call PTIMERA(-1,time,dtime)c     do 40 i = 1, 10c transform to fourier spacec     isign = -1c     call PFFT2R(f,g,bs,br,isign,ntpose,mixup,sct,indx,indy,kstrt,nxvh,c    1nyv,kxp,kyp,kyp,jblok,kblok,nxhy,nxyh)c     call PFFT2RX(f,g,isign,ntpose,mixup,sct,indx,indy,kstrt,nxvh,nyv,kc    1xp,kyp,kyp,jblok,kblok,nxhy,nxyh)c     call PFFT2RY(f,g,msid,mrid,isign,ntpose,mixup,sct,indx,indy,kstrt,c    1nxvh,nyv,kxp,kyp,kxb,kyb,kyp,jblok,kblok,nxhy,nxyh)c     call PTPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kyp,jblok,c    1kblok)c     call PTPOSEX(f,g,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kyp,jblok,kblokc    1)c     call PTPOSEY(f,g,msid,mrid,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxb,kyb,kc    1xp,kyp,jblok,kblok)c transform to real spacec     isign = 1c     call PFFT2R(f,g,bs,br,isign,ntpose,mixup,sct,indx,indy,kstrt,nxvh,c    1nyv,kxp,kyp,kyp,jblok,kblok,nxhy,nxyh)c     call PFFT2RX(f,g,isign,ntpose,mixup,sct,indx,indy,kstrt,nxvh,nyv,kc    1xp,kyp,kyp,jblok,kblok,nxhy,nxyh)c     call PFFT2RY(f,g,msid,mrid,isign,ntpose,mixup,sct,indx,indy,kstrt,c    1nxvh,nyv,kxp,kyp,kxb,kyb,kyp,jblok,kblok,nxhy,nxyh)c     call PTPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kyp,kxp,kblok,c    1jblok)c     call PTPOSEX(g,f,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kyp,kxp,kblok,jblokc    1)c     call PTPOSEY(g,f,mrid,msid,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kyb,kxb,kc    1yp,kxp,kblok,jblok)c  40 continuec     call PTIMERA(1,time,dtime)c     sum1 = 0.c     if (kstrt.gt.ny) go to 80c     do 70 l = 1, kblokc     koff = kyp*(l + ks)c     do 60 k = 1, kypc     k1 = k + koffc     do 50 j = 1, nxc     eps = abs(f(j,k,l) - h(j,k1))c     if (eps.gt..000001) thenc        write (6,*) j,k1,h(j,k1)c     endifc     sum1 = sum1 + epsc  50 continuec  60 continuec  70 continuec  80 continuec     call PSUM(sum1,work1,1,1)c     call PPEXITc     if (kstrt.eq.1) thenc        write (6,*) 'pfft2rx max/min real time=',time(1),time(2),'sec'c        write (6,*) 'error=',sum1c        pausec     endif      stop      endc-----------------------------------------------------------------------      function ranorm()c this program calculates a random number y from a gaussian distributionc with zero mean and unit variance, according to the method ofc mueller and box:c    y(k) = (-2*ln(x(k)))**1/2*sin(2*pi*x(k+1))c    y(k+1) = (-2*ln(x(k)))**1/2*cos(2*pi*x(k+1)),c where x is a random number uniformly distributed on (0,1).c written for the ibm by viktor k. decyk, ucla      integer r1,r2,r4,r5      double precision ranorm,h1l,h1u,h2l,r0,r3,asc,bsc,temp      save iflg,r1,r2,r4,r5,h1l,h1u,h2l,r0      data r1,r2,r4,r5 /885098780,1824280461,1396483093,55318673/      data h1l,h1u,h2l /65531.0d0,32767.0d0,65525.0d0/      data iflg,r0 /0,0.0d0/      if (iflg.eq.0) go to 10      ranorm = r0      r0 = 0.0d0      iflg = 0      return   10 isc = 65536      asc = dfloat(isc)      bsc = asc*asc      i1 = r1 - (r1/isc)*isc      r3 = h1l*dfloat(r1) + asc*h1u*dfloat(i1)      i1 = r3/bsc      r3 = r3 - dfloat(i1)*bsc      bsc = 0.5d0*bsc      i1 = r2/isc      isc = r2 - i1*isc      r0 = h1l*dfloat(r2) + asc*h1u*dfloat(isc)      asc = 1.0d0/bsc      isc = r0*asc      r2 = r0 - dfloat(isc)*bsc      r3 = r3 + (dfloat(isc) + 2.0d0*h1u*dfloat(i1))      isc = r3*asc      r1 = r3 - dfloat(isc)*bsc      temp = dsqrt(-2.0d0*dlog((dfloat(r1) + dfloat(r2)*asc)*asc))      isc = 65536      asc = dfloat(isc)      bsc = asc*asc      i1 = r4 - (r4/isc)*isc      r3 = h2l*dfloat(r4) + asc*h1u*dfloat(i1)      i1 = r3/bsc      r3 = r3 - dfloat(i1)*bsc      bsc = 0.5d0*bsc      i1 = r5/isc      isc = r5 - i1*isc      r0 = h2l*dfloat(r5) + asc*h1u*dfloat(isc)      asc = 1.0d0/bsc      isc = r0*asc      r5 = r0 - dfloat(isc)*bsc      r3 = r3 + (dfloat(isc) + 2.0d0*h1u*dfloat(i1))      isc = r3*asc      r4 = r3 - dfloat(isc)*bsc      r0 = 6.28318530717959d0*((dfloat(r4) + dfloat(r5)*asc)*asc)      ranorm = temp*dsin(r0)      r0 = temp*dcos(r0)      iflg = 1      return      endc-----------------------------------------------------------------------      subroutine PFFT2R(f,g,bs,br,isign,ntpose,mixup,sct,indx,indy,kstrt     1,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)c this subroutine performs a two dimensional real to complex fastc fourier transform and its inverse, using complex arithmetic,c for data which is distributed in blocksc for isign = 0, input: isign, indx, indy, kstrt, nxhyd, nxyhdc output: mixup, sctc for isign = (-1,1), input: all, output: f, g, bs, brc for isign = -1, approximate flop count: N*(5*log2(N) + 10)/nvpc for isign = 1,  approximate flop count: N*(5*log2(N) + 8)/nvpc where N = (nx/2)*ny, and nvp = number of procsc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc ntpose = (0,1) = (no,yes) input, output data are transposedc if isign = 0, the fft tables are preparedc if isign = -1, an inverse fourier transform is performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(n,m,l) = (1/nx*ny)*sum(f(j,k,i)*c       exp(-sqrt(-1)*2pi*n*j/nx)*exp(-sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, f is the input and g is the outputc g(m,n,l) = (1/nx*ny)*sum(f(j,k,i)*c       exp(-sqrt(-1)*2pi*nn*j/nx)*exp(-sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c if isign = 1, a forward fourier transform is performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(j,k,i) = sum(f(n,m,l)*exp(sqrt(-1)*2pi*n*j/nx)*c       exp(sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, g is the input and f is the outputc f(j,k,i) = sum(g(m,n,l)*exp(sqrt(-1)*2pi*nn*j/nx)*c       exp(sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c bs, br = scratch arraysc kstrt = starting data block numberc nxvh/nyv = first dimension of f/gc kypd = second dimension of fc kxp/kyp = number of data values per block in x/yc jblok/kblok = number of data blocks in x/yc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxhyd = maximum of (nx/2,ny)c nxyhd = one half of maximum of (nx,ny)c the real data is stored in a complex array of length nx/2, nyc with the odd/even x points stored in the real/imaginary parts.c in complex notation, fourier coefficients are stored as follows:c if ntpose = 0,c f(j,k,i) = mode j-1,kk-1, where kk = k + kyp*(i - 1)c 1 <= j <= nx/2 and 1 <= kk <= ny, except forc f(1,k,i) = mode nx/2,kk-1, where ny/2+2 <= kk <= ny, andc imaginary part of f(1,1,1) = real part of mode nx/2,0 andc imaginary part of f(1,1,(ny/2)/kyp+1) = real part of mode nx/2,ny/2c if ntpose = 1,c g(k,j,i) = mode jj-1,k-1, where jj = j + kxp*(i - 1)c 1 <= jj <= nx/2 and 1 <= k <= ny, except forc g(k,1,1) = mode nx/2,k-1, where ny/2+2 <= k <= ny, andc imaginary part of g(1,1,1) = real part of mode nx/2,0 andc imaginary part of g(ny/2+1,1,1) = real part of mode nx/2,ny/2c written by viktor k. decyk, uclac parallel version      implicit none      integer isign, ntpose, indx, indy, kstrt, nxvh, nyv, kxp, kyp      integer kypd, jblok, kblok, nxhyd, nxyhd, mixup      complex f, g, bs, br, sct      dimension f(nxvh,kypd,kblok), g(nyv,kxp,jblok)      dimension bs(kxp,kyp,kblok), br(kxp,kyp,jblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, nxh, nxhh, nxh2, ny, nyh, ny2, nxy      integer nxhy, ks, j, k, lb, ll, jb, it, nxyh, nrx, nry, l, i, m      integer ns, ns2, km, kmr, k1, k2, j1, j2      real dnxy, arg, ani      complex s, t, t1      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nxh2 = nxh + 2      ny = 2**indy      nyh = ny/2      ny2 = ny + 2      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      if (isign) 50, 10, 300c prepare fft tablesc bit-reverse index table: mixup(j) = 1 + reversed bits of (j - 1)   10 do 30 j = 1, nxhy      lb = j - 1      ll = 0      do 20 k = 1, indx1y      jb = lb/2      it = lb - 2*jb      lb = jb      ll = 2*ll + it   20 continue      mixup(j) = ll + 1   30 continuec sine/cosine table for the angles 2*n*pi/nxy      nxyh = nxy/2      dnxy = 6.28318530717959/float(nxy)      do 40 j = 1, nxyh      arg = dnxy*float(j - 1)      sct(j) = cmplx(cos(arg),-sin(arg))   40 continue      returnc inverse fourier transform   50 if (kstrt.gt.ny) go to 180      nrx = nxhy/nxh      do 80 l = 1, kblokc bit-reverse array elements in x      do 70 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 70      do 60 k = 1, kyp      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = t   60 continue   70 continue   80 continuec first transform in x      nrx = nxy/nxh      do 130 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 120 l = 1, kblok      do 110 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 100 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 90 i = 1, kyp      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t   90 continue  100 continue  110 continue  120 continue  130 continuec unscramble coefficients and normalize      kmr = nxy/nx      ani = 1./float(2*nx*ny)      do 170 l = 1, kblok      do 150 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),-real(sct(1+kmr*(j-1))))      do 140 k = 1, kyp      t = conjg(f(nxh2-j,k,l))      s = f(j,k,l) + t      t = (f(j,k,l) - t)*t1      f(j,k,l) = ani*(s + t)      f(nxh2-j,k,l) = ani*conjg(s - t)  140 continue  150 continue      do 160 k = 1, kyp      f(nxhh+1,k,l) = 2.*ani*conjg(f(nxhh+1,k,l))      f(1,k,l) = 2.*ani*cmplx(real(f(1,k,l)) + aimag(f(1,k,l)),real(f(1,     1k,l)) - aimag(f(1,k,l)))  160 continue  170 continuec transpose f array to g  180 call PTPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kypd,jblok     1,kblok)      if (kstrt.gt.nxh) go to 290      nry = nxhy/ny      do 210 l = 1, jblokc bit-reverse array elements in y      do 200 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 200      do 190 j = 1, kxp      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = t  190 continue  200 continue  210 continuec then transform in y      nry = nxy/ny      do 260 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 250 l = 1, jblok      do 240 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 230 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 220 i = 1, kxp      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t  220 continue  230 continue  240 continue  250 continue  260 continuec unscramble modes kx = 0, nx/2      do 280 l = 1, jblok      if ((l+ks).gt.0) go to 280      do 270 k = 2, nyh      s = g(ny2-k,1,l)      g(ny2-k,1,l) = .5*cmplx(aimag(g(k,1,l) + s),real(g(k,1,l) - s))      g(k,1,l) = .5*cmplx(real(g(k,1,l) + s),aimag(g(k,1,l) - s))  270 continue  280 continuec transpose g array to f  290 if (ntpose.eq.0) call PTPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,kyp,k     1xp,kypd,kxp,kblok,jblok)      returnc forward fourier transformc transpose f array to g  300 if (ntpose.eq.0) call PTPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,kxp,k     1yp,kxp,kypd,jblok,kblok)      if (kstrt.gt.nxh) go to 410      nry = nxhy/ny      do 350 l = 1, jblokc scramble modes kx = 0, nx/2      if ((l+ks).gt.0) go to 320      do 310 k = 2, nyh      s = cmplx(aimag(g(ny2-k,1,l)),real(g(ny2-k,1,l)))      g(ny2-k,1,l) = conjg(g(k,1,l) - s)      g(k,1,l) = g(k,1,l) + s  310 continuec bit-reverse array elements in y  320 do 340 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 340      do 330 j = 1, kxp      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = t  330 continue  340 continue  350 continuec first transform in y      nry = nxy/ny      do 400 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 390 l = 1, jblok      do 380 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 370 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 360 i = 1, kxp      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t  360 continue  370 continue  380 continue  390 continue  400 continuec transpose g array to f  410 call PTPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kxp,kblok     1,jblok)      if (kstrt.gt.ny) return      nrx = nxhy/nxh      kmr = nxy/nx      do 470 l = 1, kblokc scramble coefficients      do 430 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),real(sct(1+kmr*(j-1))))      do 420 k = 1, kyp      t = conjg(f(nxh2-j,k,l))      s = f(j,k,l) + t      t = (f(j,k,l) - t)*t1      f(j,k,l) = s + t      f(nxh2-j,k,l) = conjg(s - t)  420 continue  430 continue      do 440 k = 1, kyp      f(nxhh+1,k,l) = 2.*conjg(f(nxhh+1,k,l))      f(1,k,l) = cmplx(real(f(1,k,l)) + aimag(f(1,k,l)),real(f(1,k,l)) -     1 aimag(f(1,k,l)))  440 continuec bit-reverse array elements in x      do 460 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 460      do 450 k = 1, kyp      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = t  450 continue  460 continue  470 continuec then transform in x      nrx = nxy/nxh      do 520 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 510 l = 1, kblok      do 500 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 490 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 480 i = 1, kyp      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t  480 continue  490 continue  500 continue  510 continue  520 continue      return      endc-----------------------------------------------------------------------      subroutine PFFT2RX(f,g,isign,ntpose,mixup,sct,indx,indy,kstrt,nxvh     1,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)c this subroutine performs a two dimensional real to complex fastc fourier transform and its inverse, using complex arithmetic,c for data which is distributed in blocksc for isign = 0, input: isign, indx, indy, kstrt, nxhyd, nxyhdc output: mixup, sctc for isign = (-1,1), input: all, output: f, gc for isign = -1, approximate flop count: N*(5*log2(N) + 10)/nvpc for isign = 1,  approximate flop count: N*(5*log2(N) + 8)/nvpc where N = (nx/2)*ny, and nvp = number of procsc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc ntpose = (0,1) = (no,yes) input, output data are transposedc if isign = 0, the fft tables are preparedc if isign = -1, an inverse fourier transform is performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(n,m,l) = (1/nx*ny)*sum(f(j,k,i)*c       exp(-sqrt(-1)*2pi*n*j/nx)*exp(-sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, f is the input and g is the outputc g(m,n,l) = (1/nx*ny)*sum(f(j,k,i)*c       exp(-sqrt(-1)*2pi*nn*j/nx)*exp(-sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c if isign = 1, a forward fourier transform is performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(j,k,i) = sum(f(n,m,l)*exp(sqrt(-1)*2pi*n*j/nx)*c       exp(sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, g is the input and f is the outputc f(j,k,i) = sum(g(m,n,l)*exp(sqrt(-1)*2pi*nn*j/nx)*c       exp(sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c kstrt = starting data block numberc nxvh/nyv = first dimension of f/gc kypd = second dimension of fc kxp/kyp = number of data values per block in x/yc jblok/kblok = number of data blocks in x/yc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxhyd = maximum of (nx/2,ny)c nxyhd = one half of maximum of (nx,ny)c the real data is stored in a complex array of length nx/2, nyc with the odd/even x points stored in the real/imaginary parts.c in complex notation, fourier coefficients are stored as follows:c if ntpose = 0,c f(j,k,i) = mode j-1,kk-1, where kk = k + kyp*(i - 1)c 1 <= j <= nx/2 and 1 <= kk <= ny, except forc f(1,k,i) = mode nx/2,kk-1, where ny/2+2 <= kk <= ny, andc imaginary part of f(1,1,1) = real part of mode nx/2,0 andc imaginary part of f(1,1,(ny/2)/kyp+1) = real part of mode nx/2,ny/2c if ntpose = 1,c g(k,j,i) = mode jj-1,k-1, where jj = j + kxp*(i - 1)c 1 <= jj <= nx/2 and 1 <= k <= ny, except forc g(k,1,1) = mode nx/2,k-1, where ny/2+2 <= k <= ny, andc imaginary part of g(1,1,1) = real part of mode nx/2,0 andc imaginary part of g(ny/2+1,1,1) = real part of mode nx/2,ny/2c written by viktor k. decyk, uclac parallel, RISC optimized version      implicit none      integer isign, ntpose, mixup, indx, indy, kstrt, nxvh      integer nyv, kxp, kyp, kypd, jblok, kblok, nxhyd, nxyhd      complex f, g, sct      dimension f(nxvh,kypd,kblok), g(nyv,kxp,jblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, nxh, nxhh, nxh2, ny, nyh, ny2, nxy      integer nxhy, ks, j, k, lb, ll, jb, it, nxyh, nrx, nry, l, i, m      integer ns, ns2, km, kmr, k1, k2, j1, j2      real dnxy, arg, ani      complex s, t, t1      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nxh2 = nxh + 2      ny = 2**indy      nyh = ny/2      ny2 = ny + 2      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      if (isign) 50, 10, 300c prepare fft tablesc bit-reverse index table: mixup(j) = 1 + reversed bits of (j - 1)   10 do 30 j = 1, nxhy      lb = j - 1      ll = 0      do 20 k = 1, indx1y      jb = lb/2      it = lb - 2*jb      lb = jb      ll = 2*ll + it   20 continue      mixup(j) = ll + 1   30 continuec sine/cosine table for the angles 2*n*pi/nxy      nxyh = nxy/2      dnxy = 6.28318530717959/float(nxy)      do 40 j = 1, nxyh      arg = dnxy*float(j - 1)      sct(j) = cmplx(cos(arg),-sin(arg))   40 continue      returnc inverse fourier transform   50 if (kstrt.gt.ny) go to 180      nrx = nxhy/nxh      do 80 l = 1, kblokc bit-reverse array elements in x      do 70 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 70      do 60 k = 1, kyp      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = t   60 continue   70 continue   80 continuec first transform in x      nrx = nxy/nxh      do 130 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 120 l = 1, kblok      do 110 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 100 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 90 i = 1, kyp      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t   90 continue  100 continue  110 continue  120 continue  130 continuec unscramble coefficients and normalize      kmr = nxy/nx      ani = 1./float(2*nx*ny)      do 170 l = 1, kblok      do 150 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),-real(sct(1+kmr*(j-1))))      do 140 k = 1, kyp      t = conjg(f(nxh2-j,k,l))      s = f(j,k,l) + t      t = (f(j,k,l) - t)*t1      f(j,k,l) = ani*(s + t)      f(nxh2-j,k,l) = ani*conjg(s - t)  140 continue  150 continue      do 160 k = 1, kyp      f(nxhh+1,k,l) = 2.*ani*conjg(f(nxhh+1,k,l))      f(1,k,l) = 2.*ani*cmplx(real(f(1,k,l)) + aimag(f(1,k,l)),real(f(1,     1k,l)) - aimag(f(1,k,l)))  160 continue  170 continuec transpose f array to g  180 call PTPOSEX(f,g,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kypd,jblok,kblo     1k)      if (kstrt.gt.nxh) go to 290      nry = nxhy/ny      do 210 l = 1, jblokc bit-reverse array elements in y      do 200 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 200      do 190 j = 1, kxp      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = t  190 continue  200 continue  210 continuec then transform in y      nry = nxy/ny      do 260 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 250 l = 1, jblok      do 240 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 230 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 220 i = 1, kxp      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t  220 continue  230 continue  240 continue  250 continue  260 continuec unscramble modes kx = 0, nx/2      do 280 l = 1, jblok      if ((l+ks).gt.0) go to 280      do 270 k = 2, nyh      s = g(ny2-k,1,l)      g(ny2-k,1,l) = .5*cmplx(aimag(g(k,1,l) + s),real(g(k,1,l) - s))      g(k,1,l) = .5*cmplx(real(g(k,1,l) + s),aimag(g(k,1,l) - s))  270 continue  280 continuec transpose g array to f  290 if (ntpose.eq.0) call PTPOSEX(g,f,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,ky     1pd,kxp,kblok,jblok)      returnc forward fourier transformc transpose f array to g  300 if (ntpose.eq.0) call PTPOSEX(f,g,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kx     1p,kypd,jblok,kblok)      if (kstrt.gt.nxh) go to 410      nry = nxhy/ny      do 350 l = 1, jblokc scramble modes kx = 0, nx/2      if ((l+ks).gt.0) go to 320      do 310 k = 2, nyh      s = cmplx(aimag(g(ny2-k,1,l)),real(g(ny2-k,1,l)))      g(ny2-k,1,l) = conjg(g(k,1,l) - s)      g(k,1,l) = g(k,1,l) + s  310 continuec bit-reverse array elements in y  320 do 340 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 340      do 330 j = 1, kxp      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = t  330 continue  340 continue  350 continuec first transform in y      nry = nxy/ny      do 400 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 390 l = 1, jblok      do 380 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 370 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 360 i = 1, kxp      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t  360 continue  370 continue  380 continue  390 continue  400 continuec transpose g array to f  410 call PTPOSEX(g,f,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kxp,kblok,jblo     1k)      if (kstrt.gt.ny) return      nrx = nxhy/nxh      kmr = nxy/nx      do 470 l = 1, kblokc scramble coefficients      do 430 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),real(sct(1+kmr*(j-1))))      do 420 k = 1, kyp      t = conjg(f(nxh2-j,k,l))      s = f(j,k,l) + t      t = (f(j,k,l) - t)*t1      f(j,k,l) = s + t      f(nxh2-j,k,l) = conjg(s - t)  420 continue  430 continue      do 440 k = 1, kyp      f(nxhh+1,k,l) = 2.*conjg(f(nxhh+1,k,l))      f(1,k,l) = cmplx(real(f(1,k,l)) + aimag(f(1,k,l)),real(f(1,k,l)) -     1 aimag(f(1,k,l)))  440 continuec bit-reverse array elements in x      do 460 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 460      do 450 k = 1, kyp      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = t  450 continue  460 continue  470 continuec then transform in x      nrx = nxy/nxh      do 520 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 510 l = 1, kblok      do 500 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 490 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 480 i = 1, kyp      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t  480 continue  490 continue  500 continue  510 continue  520 continue      return      endc-----------------------------------------------------------------------      subroutine PFFT2RY(f,g,msid,mrid,isign,ntpose,mixup,sct,indx,indy,     1kstrt,nxvh,nyv,kxp,kyp,kxb,kyb,kypd,jblok,kblok,nxhyd,nxyhd)c this subroutine performs a two dimensional real to complex fastc fourier transform and its inverse, using complex arithmetic,c for data which is distributed in blocksc for isign = 0, input: isign, indx, indy, kstrt, nxhyd, nxyhdc output: mixup, sctc for isign = (-1,1), input: all, output: f, gc for isign = -1, approximate flop count: N*(5*log2(N) + 10)/nvpc for isign = 1,  approximate flop count: N*(5*log2(N) + 8)/nvpc where N = (nx/2)*ny, and nvp = number of procsc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc ntpose = (0,1) = (no,yes) input, output data are transposedc if isign = 0, the fft tables are preparedc if isign = -1, an inverse fourier transform is performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(n,m,l) = (1/nx*ny)*sum(f(j,k,i)*c       exp(-sqrt(-1)*2pi*n*j/nx)*exp(-sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, f is the input and g is the outputc g(m,n,l) = (1/nx*ny)*sum(f(j,k,i)*c       exp(-sqrt(-1)*2pi*nn*j/nx)*exp(-sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c if isign = 1, a forward fourier transform is performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(j,k,i) = sum(f(n,m,l)*exp(sqrt(-1)*2pi*n*j/nx)*c       exp(sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, g is the input and f is the outputc f(j,k,i) = sum(g(m,n,l)*exp(sqrt(-1)*2pi*nn*j/nx)*c       exp(sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c msid, mrid = scratch arrays for identifying asynchronous messagesc kstrt = starting data block numberc nxvh/nyv = first dimension of f/gc kypd = second dimension of fc kxp/kyp = number of data values per block in x/yc kxb/kyb = number of processors in x/yc jblok/kblok = number of data blocks in x/yc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxhyd = maximum of (nx/2,ny)c nxyhd = one half of maximum of (nx,ny)c the real data is stored in a complex array of length nx/2, nyc with the odd/even x points stored in the real/imaginary parts.c in complex notation, fourier coefficients are stored as follows:c if ntpose = 0,c f(j,k,i) = mode j-1,kk-1, where kk = k + kyp*(i - 1)c 1 <= j <= nx/2 and 1 <= kk <= ny, except forc f(1,k,i) = mode nx/2,kk-1, where ny/2+2 <= kk <= ny, andc imaginary part of f(1,1,1) = real part of mode nx/2,0 andc imaginary part of f(1,1,(ny/2)/kyp+1) = real part of mode nx/2,ny/2c if ntpose = 1,c g(k,j,i) = mode jj-1,k-1, where jj = j + kxp*(i - 1)c 1 <= jj <= nx/2 and 1 <= k <= ny, except forc g(k,1,1) = mode nx/2,k-1, where ny/2+2 <= k <= ny, andc imaginary part of g(1,1,1) = real part of mode nx/2,0 andc imaginary part of g(ny/2+1,1,1) = real part of mode nx/2,ny/2c written by viktor k. decyk, uclac parallel, RISC optimized version      implicit none      integer msid, mrid, isign, ntpose, mixup, indx, indy, kstrt, nxvh      integer nyv, kxp, kyp, kxb, kyb, kypd, jblok, kblok, nxhyd, nxyhd      complex f, g, sct      dimension f(nxvh,kypd,kblok), g(nyv,kxp,jblok)      dimension msid(kxb), mrid(kyb)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, nxh, nxhh, nxh2, ny, nyh, ny2, nxy      integer nxhy, ks, j, k, lb, ll, jb, it, nxyh, nrx, nry, l, i, m      integer ns, ns2, km, kmr, k1, k2, j1, j2      real dnxy, arg, ani      complex s, t, t1      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nxh2 = nxh + 2      ny = 2**indy      nyh = ny/2      ny2 = ny + 2      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      if (isign) 50, 10, 300c prepare fft tablesc bit-reverse index table: mixup(j) = 1 + reversed bits of (j - 1)   10 do 30 j = 1, nxhy      lb = j - 1      ll = 0      do 20 k = 1, indx1y      jb = lb/2      it = lb - 2*jb      lb = jb      ll = 2*ll + it   20 continue      mixup(j) = ll + 1   30 continuec sine/cosine table for the angles 2*n*pi/nxy      nxyh = nxy/2      dnxy = 6.28318530717959/float(nxy)      do 40 j = 1, nxyh      arg = dnxy*float(j - 1)      sct(j) = cmplx(cos(arg),-sin(arg))   40 continue      returnc inverse fourier transform   50 if (kstrt.gt.ny) go to 180      nrx = nxhy/nxh      do 80 l = 1, kblokc bit-reverse array elements in x      do 70 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 70      do 60 k = 1, kyp      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = t   60 continue   70 continue   80 continuec first transform in x      nrx = nxy/nxh      do 130 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 120 l = 1, kblok      do 110 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 100 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 90 i = 1, kyp      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t   90 continue  100 continue  110 continue  120 continue  130 continuec unscramble coefficients and normalize      kmr = nxy/nx      ani = 1./float(2*nx*ny)      do 170 l = 1, kblok      do 150 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),-real(sct(1+kmr*(j-1))))      do 140 k = 1, kyp      t = conjg(f(nxh2-j,k,l))      s = f(j,k,l) + t      t = (f(j,k,l) - t)*t1      f(j,k,l) = ani*(s + t)      f(nxh2-j,k,l) = ani*conjg(s - t)  140 continue  150 continue      do 160 k = 1, kyp      f(nxhh+1,k,l) = 2.*ani*conjg(f(nxhh+1,k,l))      f(1,k,l) = 2.*ani*cmplx(real(f(1,k,l)) + aimag(f(1,k,l)),real(f(1,     1k,l)) - aimag(f(1,k,l)))  160 continue  170 continuec transpose f array to g  180 call PTPOSEY(f,g,msid,mrid,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxb,kyb,k     1xp,kypd,jblok,kblok)      if (kstrt.gt.nxh) go to 290      nry = nxhy/ny      do 210 l = 1, jblokc bit-reverse array elements in y      do 200 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 200      do 190 j = 1, kxp      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = t  190 continue  200 continue  210 continuec then transform in y      nry = nxy/ny      do 260 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 250 l = 1, jblok      do 240 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 230 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 220 i = 1, kxp      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t  220 continue  230 continue  240 continue  250 continue  260 continuec unscramble modes kx = 0, nx/2      do 280 l = 1, jblok      if ((l+ks).gt.0) go to 280      do 270 k = 2, nyh      s = g(ny2-k,1,l)      g(ny2-k,1,l) = .5*cmplx(aimag(g(k,1,l) + s),real(g(k,1,l) - s))      g(k,1,l) = .5*cmplx(real(g(k,1,l) + s),aimag(g(k,1,l) - s))  270 continue  280 continuec transpose g array to f  290 if (ntpose.eq.0) call PTPOSEY(g,f,mrid,msid,ny,nxh,kstrt,nyv,nxvh,     1kyp,kxp,kyb,kxb,kypd,kxp,kblok,jblok)      returnc forward fourier transformc transpose f array to g  300 if (ntpose.eq.0) call PTPOSEY(f,g,msid,mrid,nxh,ny,kstrt,nxvh,nyv,     1kxp,kyp,kxb,kyb,kxp,kypd,jblok,kblok)      if (kstrt.gt.nxh) go to 410      nry = nxhy/ny      do 350 l = 1, jblokc scramble modes kx = 0, nx/2      if ((l+ks).gt.0) go to 320      do 310 k = 2, nyh      s = cmplx(aimag(g(ny2-k,1,l)),real(g(ny2-k,1,l)))      g(ny2-k,1,l) = conjg(g(k,1,l) - s)      g(k,1,l) = g(k,1,l) + s  310 continuec bit-reverse array elements in y  320 do 340 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 340      do 330 j = 1, kxp      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = t  330 continue  340 continue  350 continuec first transform in y      nry = nxy/ny      do 400 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 390 l = 1, jblok      do 380 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 370 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 360 i = 1, kxp      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t  360 continue  370 continue  380 continue  390 continue  400 continuec transpose g array to f  410 call PTPOSEY(g,f,mrid,msid,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kyb,kxb,k     1ypd,kxp,kblok,jblok)      if (kstrt.gt.ny) return      nrx = nxhy/nxh      kmr = nxy/nx      do 470 l = 1, kblokc scramble coefficients      do 430 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),real(sct(1+kmr*(j-1))))      do 420 k = 1, kyp      t = conjg(f(nxh2-j,k,l))      s = f(j,k,l) + t      t = (f(j,k,l) - t)*t1      f(j,k,l) = s + t      f(nxh2-j,k,l) = conjg(s - t)  420 continue  430 continue      do 440 k = 1, kyp      f(nxhh+1,k,l) = 2.*conjg(f(nxhh+1,k,l))      f(1,k,l) = cmplx(real(f(1,k,l)) + aimag(f(1,k,l)),real(f(1,k,l)) -     1 aimag(f(1,k,l)))  440 continuec bit-reverse array elements in x      do 460 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 460      do 450 k = 1, kyp      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = t  450 continue  460 continue  470 continuec then transform in x      nrx = nxy/nxh      do 520 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 510 l = 1, kblok      do 500 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 490 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 480 i = 1, kyp      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t  480 continue  490 continue  500 continue  510 continue  520 continue      return      endc-----------------------------------------------------------------------      subroutine PPINIT(idproc,nvp)c this subroutine initializes parallel processingc input: nvp, output: idprocc idproc = processor idc nvp = number of real or virtual processors requested      implicit none      integer idproc, nvpc get definition of MPI constants      include 'mpif.h'c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplxc lstat = length of status array      parameter(lstat=8)c nproc = number of real or virtual processors obtainedc lgrp = current communicatorc mreal = default datatype for realsc mint = default datatype for integersc mcplx = default datatype for complex type      common /pparms/ nproc, lgrp, mreal, mint, mcplxc local data      integer ierror, ndprec      save /pparms/c ndprec = (0,1) = (no,yes) use (normal,autodouble) precision      data ndprec /1/c this segment is used for shared memory computersc     nproc = nvpc     idproc = 0c this segment is used for mpi computers      if (MPI_STATUS_SIZE.gt.lstat) then         write (2,*) ' status size too small, actual/required = ', lstat     1, MPI_STATUS_SIZE         stop      endifc initialize the MPI execution environment      call MPI_INIT(ierror)      if (ierror.ne.0) stop      lgrp = MPI_COMM_WORLDc determine the rank of the calling process in the communicator      call MPI_COMM_RANK(lgrp,idproc,ierror)c determine the size of the group associated with a communicator      call MPI_COMM_SIZE(lgrp,nproc,ierror)c set default datatypes         mint = MPI_INTEGERc single precision      if (ndprec.eq.0) then         mreal = MPI_REAL         mcplx = MPI_COMPLEXc double precision      else         mreal = MPI_DOUBLE_PRECISION         mcplx = MPI_DOUBLE_COMPLEX      endifc requested number of processors not obtained      if (nproc.ne.nvp) then         write (2,*) ' processor number error: nvp, nproc=', nvp, nproc         call PPEXIT         stop      endif      return      endc-----------------------------------------------------------------------      subroutine PPEXITc this subroutine terminates parallel processing      implicit nonec common block for parallel processing      integer nproc, lgrp, mreal, mint, mcplxc lgrp = current communicator      common /pparms/ nproc, lgrp, mreal, mint, mcplx      integer ierrorc synchronize processes      call MPI_BARRIER(lgrp,ierror)c terminate MPI execution environment      call MPI_FINALIZE(ierror)      return      endc-----------------------------------------------------------------------      subroutine PTPOSE(f,g,s,t,nx,ny,kstrt,nxv,nyv,kxp,kyp,kxpd,kypd,jb     1lok,kblok)c this subroutine performs a transpose of a matrix f, distributed in y,c to a matrix g, distributed in x, that is,c g(k+kyp*(m-1),j,l) = f(j+kxp*(l-1),k,m), wherec 1 <= j <= kxp, 1 <= k <= kyp, 1 <= l <= nx/kxp, 1 <= m <= ny/kypc and where indices l and m can be distributed across processors.c this subroutine sends and receives one message at a time, eitherc synchronously or asynchronously. it uses a minimum of system resourcesc f = complex input arrayc g = complex output arrayc s, t = complex scratch arraysc nx/ny = number of points in x/yc kstrt = starting data block numberc nxv/nyv = first dimension of f/gc kypd/kxpd = second dimension of f/gc kxp/kyp = number of data values per block in x/yc jblok/kblok = number of data blocks in x/y      implicit none      integer nx, ny, kstrt, nxv, nyv, kxp, kyp, kxpd, kypd      integer jblok, kblok      complex f, g, s, t      dimension f(nxv,kypd,kblok), g(nyv,kxpd,jblok)      dimension s(kxp,kyp,kblok), t(kxp,kyp,jblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplxc lstat = length of status array      parameter(lstat=8)c lgrp = current communicatorc mcplx = default datatype for complex      common /pparms/ nproc, lgrp, mreal, mint, mcplxc local data      integer ks, kxb, kyb      integer jkblok, kxym, mtr, ntr, mntr      integer l, i, joff, koff, k, j      integer ir0, is0, ii, ir, is, ierr, msid, istatus      dimension istatus(lstat)      ks = kstrt - 2      kxb = nx/kxp      kyb = ny/kypc this segment is used for shared memory computersc     if (kstrt.gt.nx) returnc     do 40 l = 1, jblokc     joff = kxp*(l + ks)c     do 30 i = 1, kybc     koff = kyp*(i - 1)c     do 20 k = 1, kypc     do 10 j = 1, kxpc     g(k+koff,j,l) = f(j+joff,k,i)c  10 continuec  20 continuec  30 continuec  40 continuec this segment is used for mpi computers      jkblok = max0(jblok,kblok)      kxym = min0(kxb,kyb)      mtr = kyb/kxym      ntr = kxb/kxym      mntr = max0(mtr,ntr)      do 70 l = 1, jkblok      do 60 i = 1, kxym      ir0 = iand(kxym-1,ieor(l+ks,i-1)) + 1      is0 = ir0      do 50 ii = 1, mntrc post receive      if ((kstrt.le.nx).and.(ii.le.mtr)) then         ir = ir0 + kxym*(ii - 1)         call MPI_IRECV(t(1,1,l),kxp*kyp,mcplx,ir-1,ir+kxym+1,lgrp,msid,     1ierr)      endifc send data      if ((kstrt.le.ny).and.(ii.le.ntr)) then         is = is0 + kxym*(ii - 1)         joff = kxp*(is - 1)         do 20 k = 1, kyp         do 10 j = 1, kxp         s(j,k,l) = f(j+joff,k,l)   10    continue   20    continue         call MPI_SEND(s(1,1,l),kxp*kyp,mcplx,is-1,l+ks+kxym+2,lgrp,ierr     1)      endifc receive data      if ((kstrt.le.nx).and.(ii.le.mtr)) then         koff = kyp*(ir - 1)         call MPI_WAIT(msid,istatus,ierr)         do 40 k = 1, kyp         do 30 j = 1, kxp         g(k+koff,j,l) = t(j,k,l)   30    continue   40    continue      endif   50 continue   60 continue   70 continue      return      endc-----------------------------------------------------------------------      subroutine PTPOSEX(f,g,nx,ny,kstrt,nxv,nyv,kxp,kyp,kxpd,kypd,jblok     1,kblok)c this subroutine performs a transpose of a matrix f, distributed in y,c to a matrix g, distributed in x, that is,c g(k+kyp*(m-1),j,l) = f(j+kxp*(l-1),k,m), wherec 1 <= j <= kxp, 1 <= k <= kyp, 1 <= l <= nx/kxp, 1 <= m <= ny/kypc and where indices l and m can be distributed across processors.c this subroutine sends and receives multiple asynchronous messages.c f = complex input arrayc g = complex output arrayc nx/ny = number of points in x/yc kstrt = starting data block numberc nxv/nyv = first dimension of f/gc kxp/kyp = number of data values per block in x/yc kypd/kxpd = second dimension of f/gc jblok/kblok = number of data blocks in x/yc optimized version      implicit none      integer nx, ny, kstrt, nxv, nyv, kxp, kyp      integer kxpd, kypd, jblok, kblok      complex f, g      dimension f(nxv*kypd*kblok), g(nyv*kxpd*jblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplxc lstat = length of status array      parameter(lstat=8)c lgrp = current communicatorc mcplx = default datatype for complex      common /pparms/ nproc, lgrp, mreal, mint, mcplxc local data      integer ks, kxb, kyb, l, i, joff, koff, k, j      integer jkblok, kxym, mtr, ntr, mntr, msid      integer ir0, is0, ii, ir, is, ioff, ierr, istatus      dimension istatus(lstat)      ks = kstrt - 2      kxb = nx/kxp      kyb = ny/kypc this segment is used for shared memory computersc     if (kstrt.gt.nx) returnc     do 40 l = 1, jblokc     joff = kxp*(l + ks)c     do 30 i = 1, kybc     koff = kyp*(i - 1)c     do 20 k = 1, kypc     do 10 j = 1, kxpc     g(k+koff+nyv*(j-1+kxpd*(l-1))) = f(j+joff+nxv*(k-1+kypd*(i-1)))c  10 continuec  20 continuec  30 continuec  40 continuec this segment is used for mpi computers      jkblok = max0(jblok,kblok)      kxym = min0(kxb,kyb)      mtr = kyb/kxym      ntr = kxb/kxym      mntr = max0(mtr,ntr)c transpose local data      do 50 l = 1, jkblok      ioff = kxb*(l - 1) - 1      koff = kypd*(l - 1) - 1      do 40 i = 1, kxym      is0 = iand(kxym-1,ieor(l+ks,i-1)) + 1      do 30 ii = 1, ntr      if (kstrt.le.ny) then         is = is0 + kxym*(ii - 1)         joff = kxp*(is - 1)         is = kyp*(is + ioff) - 1         do 20 k = 1, kyp         do 10 j = 1, kxp         g(j+kxp*(k+is)) = f(j+joff+nxv*(k+koff))   10    continue   20    continue      endif   30 continue   40 continue   50 continuec exchange data      do 80 l = 1, jkblok      ioff = kxb*(l - 1) - 1      koff = kyb*(l - 1) - 1      do 70 i = 1, kxym      ir0 = iand(kxym-1,ieor(l+ks,i-1)) + 1      is0 = ir0      do 60 ii = 1, mntrc post receive      if ((kstrt.le.nx).and.(ii.le.mtr)) then         ir = ir0 + kxym*(ii - 1)         call MPI_IRECV(f(1+kxp*kyp*(ir+koff)),kxp*kyp,mcplx,ir-1,ir+kxy     1m+1,lgrp,msid,ierr)      endifc send data      if ((kstrt.le.ny).and.(ii.le.ntr)) then         is = is0 + kxym*(ii - 1)         call MPI_SEND(g(1+kxp*kyp*(is+ioff)),kxp*kyp,mcplx,is-1,l+ks+kx     1ym+2,lgrp,ierr)      endifc receive data      if ((kstrt.le.nx).and.(ii.le.mtr)) then         call MPI_WAIT(msid,istatus,ierr)      endif   60 continue   70 continue   80 continuec transpose local data      do 130 l = 1, jkblok      ioff = kyb*(l - 1) - 1      joff = kxpd*(l - 1) - 1      do 120 i = 1, kxym      ir0 = iand(kxym-1,ieor(l+ks,i-1)) + 1      do 110 ii = 1, mtr      if (kstrt.le.nx) then         ir = ir0 + kxym*(ii - 1)         koff = kyp*(ir - 1)         ir = kyp*(ir + ioff) - 1         do 100 k = 1, kyp         do 90 j = 1, kxp         g(k+koff+nyv*(j+joff)) = f(j+kxp*(k+ir))   90    continue  100    continue      endif  110 continue  120 continue  130 continue      return      endc-----------------------------------------------------------------------      subroutine PTPOSEY(f,g,msid,mrid,nx,ny,kstrt,nxv,nyv,kxp,kyp,kxb,k     1yb,kxpd,kypd,jblok,kblok)c this subroutine performs a transpose of a matrix f, distributed in y,c to a matrix g, distributed in x, that is,c g(k+kyp*(m-1),j,l) = f(j+kxp*(l-1),k,m), wherec 1 <= j <= kxp, 1 <= k <= kyp, 1 <= l <= nx/kxp, 1 <= m <= ny/kypc and where indices l and m can be distributed across processors.c this subroutine sends and receives multiple asynchronous messages.c f = complex input arrayc g = complex output arrayc msid, mrid = scratch arrays for identifying asynchronous messagesc nx/ny = number of points in x/yc kstrt = starting data block numberc nxv/nyv = first dimension of f/gc kxp/kyp = number of data values per block in x/yc kxb/kyb = number of processors in x/yc kypd/kxpd = second dimension of f/gc jblok/kblok = number of data blocks in x/yc optimized version      implicit none      integer msid, mrid, nx, ny, kstrt, nxv, nyv, kxp, kyp, kxb, kyb      integer kxpd, kypd, jblok, kblok      complex f, g      dimension f(nxv*kypd*kblok), g(nyv*kxpd*jblok)      dimension msid(kxb), mrid(kyb)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplxc lstat = length of status array      parameter(lstat=8)c lgrp = current communicatorc mcplx = default datatype for complex      common /pparms/ nproc, lgrp, mreal, mint, mcplxc local data      integer ks, l, i, joff, koff, k, j      integer jkblok, kxym, mtr, ntr, mntr      integer ir0, is0, ii, ir, is, ioff, ierr, istatus      dimension istatus(lstat)      ks = kstrt - 2c this segment is used for shared memory computersc     if (kstrt.gt.nx) returnc     do 40 l = 1, jblokc     joff = kxp*(l + ks)c     do 30 i = 1, kybc     koff = kyp*(i - 1)c     do 20 k = 1, kypc     do 10 j = 1, kxpc     g(k+koff+nyv*(j-1+kxpd*(l-1))) = f(j+joff+nxv*(k-1+kypd*(i-1)))c  10 continuec  20 continuec  30 continuec  40 continuec this segment is used for mpi computers      jkblok = max0(jblok,kblok)      kxym = min0(kxb,kyb)      mtr = kyb/kxym      ntr = kxb/kxym      mntr = max0(mtr,ntr)c transpose local data      do 50 l = 1, jkblok      ioff = kxb*(l - 1) - 1      koff = kypd*(l - 1) - 1      do 40 i = 1, kxym      is0 = iand(kxym-1,ieor(l+ks,i-1)) + 1      do 30 ii = 1, ntr      if (kstrt.le.ny) then         is = is0 + kxym*(ii - 1)         joff = kxp*(is - 1)         is = kyp*(is + ioff) - 1         do 20 k = 1, kyp         do 10 j = 1, kxp         g(j+kxp*(k+is)) = f(j+joff+nxv*(k+koff))   10    continue   20    continue      endif   30 continue   40 continue   50 continuec post all receives      do 80 l = 1, jkblok      ioff = kyb*(l - 1) - 1      do 70 i = 1, kxym      ir0 = iand(kxym-1,ieor(l+ks,i-1)) + 1      do 60 ii = 1, mtr      if (kstrt.le.nx) then         ir = ir0 + kxym*(ii - 1)         call MPI_IRECV(f(1+kxp*kyp*(ir+ioff)),kxp*kyp,mcplx,ir-1,ir+kxy     1m+1,lgrp,mrid(ir),ierr)      endif   60 continue   70 continue   80 continuec post all sends      do 110 l = 1, jkblok      ioff = kxb*(l - 1) - 1      do 100 i = 1, kxym      is0 = iand(kxym-1,ieor(l+ks,i-1)) + 1      do 90 ii = 1, ntr      if (kstrt.le.ny) then         is = is0 + kxym*(ii - 1)         call MPI_ISEND(g(1+kxp*kyp*(is+ioff)),kxp*kyp,mcplx,is-1,l+ks+k     1xym+2,lgrp,msid(is),ierr)      endif   90 continue  100 continue  110 continuec wait for all messages      do 140 l = 1, jkblok      do 130 i = 1, kxym      ir0 = iand(kxym-1,ieor(l+ks,i-1)) + 1      is0 = ir0      do 120 ii = 1, mntrc wait for data to arrive      if ((kstrt.le.nx).and.(ii.le.mtr)) then         ir = ir0 + kxym*(ii - 1)         call MPI_WAIT(mrid(ir),istatus,ierr)      endifc make sure data was successfully sent      if ((kstrt.le.ny).and.(ii.le.ntr)) then         is = is0 + kxym*(ii - 1)         call MPI_WAIT(msid(is),istatus,ierr)      endif  120 continue  130 continue  140 continuec transpose local data      do 190 l = 1, jkblok      ioff = kyb*(l - 1) - 1      joff = kxpd*(l - 1) - 1      do 180 i = 1, kxym      ir0 = iand(kxym-1,ieor(l+ks,i-1)) + 1      do 170 ii = 1, mtr      if (kstrt.le.nx) then         ir = ir0 + kxym*(ii - 1)         koff = kyp*(ir - 1)         ir = kyp*(ir + ioff) - 1         do 160 k = 1, kyp         do 150 j = 1, kxp         g(k+koff+nyv*(j+joff)) = f(j+kxp*(k+ir))  150    continue  160    continue      endif  170 continue  180 continue  190 continue      return      endc-----------------------------------------------------------------------      subroutine PTIMERA(icntrl,time,dtime)c this subroutine performs parallel wall clock timingc input: icntrl, dtimec icntrl = (-1,0,1) = (initialize,ignore,read) clockc clock should be initialized before it is read!c time = maximum/minimum elapsed time in secondsc dtime = current timec written for mpi      implicit none      integer icntrl      real time      double precision dtime      dimension time(2)c get definition of MPI constants      include 'mpif.h'c common block for parallel processing      integer nproc, lgrp, mreal, mint, mcplxc lgrp = current communicatorc mreal = default datatype for reals      common /pparms/ nproc, lgrp, mreal, mint, mcplxc local data      integer ierr      real nclock      double precision jclockc initialize clock      if (icntrl.eq.(-1)) then         call MPI_BARRIER(lgrp,ierr)         dtime = MPI_WTIME()c read clock and write time difference from last clock initialization      else if (icntrl.eq.1) then         jclock = dtime         dtime = MPI_WTIME()         nclock = real(dtime - jclock)         call MPI_ALLREDUCE(nclock,time(2),1,mreal,MPI_MIN,lgrp,ierr)         call MPI_ALLREDUCE(nclock,time(1),1,mreal,MPI_MAX,lgrp,ierr)      endif      return      endc-----------------------------------------------------------------------      subroutine PSUM(f,g,nxp,nblok)c this subroutine performs a parallel sum of a vector, that is:c f(j,k) = sum over k of f(j,k)c assumes the number of processors nproc is a power of two.c the algorithm performs partial sums in binary pairs, as follows:c first, adjacent processors exchange vectors and sum them.  next,c processors separated by 2 exchange the new vectors and sum them, thenc those separated by 4, up to processors separated by nproc/2.  at thec end, all processors contain the same summation.c f = input and output datac g = scratch arrayc nxp = number of data values in vectorc nblok = number of data blocksc written by viktor k. decyk, ucla      implicit none      real f, g      integer nxp, nblok      dimension f(nxp,nblok), g(nxp,nblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplxc lstat = length of status array      parameter(lstat=8)c nproc = number of real or virtual processors obtainedc lgrp = current communicatorc mreal = default datatype for reals      common /pparms/ nproc, lgrp, mreal, mint, mcplxc local data      integer istatus, ierr, msid      integer idproc, kstrt, ks, l, kxs, k, kb, lb, j      dimension istatus(lstat)c find processor idc this line is used for shared memory computersc     idproc = 0c this line is used for mpi computers      call MPI_COMM_RANK(lgrp,idproc,ierr)      kstrt = idproc + 1      if (kstrt.gt.nproc) return      ks = kstrt - 2      l = 1      kxs = 1c main iteration loop   10 if (kxs.ge.nproc) go to 60c shift data      do 30 k = 1, nblok      kb = k + ks      lb = kb/kxs      kb = kb + 1      lb = lb - 2*(lb/2)c this loop is used for shared memory computersc     do 20 j = 1, nxpc     if (lb.eq.0) thenc        g(j,k) = f(j,kb+kxs)c     elsec        g(j,k) = f(j,kb-kxs)c     endifc  20 continuec this segment is used for mpi computers      if (lb.eq.0) then         call MPI_IRECV(g,nxp,mreal,kb+kxs-1,l+nxp,lgrp,msid,ierr)         call MPI_SEND(f,nxp,mreal,kb+kxs-1,l+nxp,lgrp,ierr)      else         call MPI_IRECV(g,nxp,mreal,kb-kxs-1,l+nxp,lgrp,msid,ierr)         call MPI_SEND(f,nxp,mreal,kb-kxs-1,l+nxp,lgrp,ierr)      endif      call MPI_WAIT(msid,istatus,ierr)   30 continuec perform sum      do 50 k = 1, nblok      do 40 j = 1, nxp      f(j,k) = f(j,k) + g(j,k)   40 continue   50 continue      l = l + 1      kxs = kxs + kxs      go to 10   60 return      endc-----------------------------------------------------------------------      subroutine DCOMP2(edges,nyp,noff,ny,kstrt,nvp,idps,nblok)c this subroutine determines spatial boundaries for particlec decomposition, calculates number of grid points in each spatialc region, and the offset of these grid points from the global addressc edges(1,l) = lower boundary of particle partition lc edges(2,l) = upper boundary of particle partition lc nyp(l) = number of primary gridpoints in particle partition l.c noff(l) = lowermost global gridpoint in particle partition l.c ny = system length in y directionc kstrt = starting data block numberc nvp = number of real or virtual processorsc idps = number of partition boundariesc nblok = number of particle partitions.      implicit none      real edges      integer nyp, noff, ny, kstrt, nvp, idps, nblok      dimension edges(idps,nblok)      dimension nyp(nblok), noff(nblok)c local data      integer ks, kb, kr, l      real at1      ks = kstrt - 2      at1 = float(ny)/float(nvp)      do 10 l = 1, nblok      kb = l + ks      edges(1,l) = at1*float(kb)      noff(l) = edges(1,l) + .5      edges(2,l) = at1*float(kb + 1)      kr = edges(2,l) + .5      nyp(l) = kr - noff(l)   10 continue      return      endc-----------------------------------------------------------------------      subroutine PLSCGUARD2X(cu,kstrt,nvp,noff,nyp,xj0,yj0,zj0,nx,ny,ngx     1,ngy,nxe,nypmx,nblok)c initialize extended non-periodic fieldc cu(i,j,k,l) = ith component of current density at grid point (j,kk),c where kk = k + noff(l) - 1c kstrt = starting data block numberc nvp = number of real or virtual processorsc noff(l) = lowermost global gridpoint in particle partition lc nyp(l) = number of primary gridpoints in particle partition lc xj0/yj0/zj0 = initialization constants in x/y/z directionc nx = system length in x directionc ngx/ngy = (0,1) number of grid cells away from edgec nxe = first dimension of charge array, must be >= nxc nypmx = maximum size of particle partition, including guard cellsc nblok = number of particle partitionsc quadratic interpolation, for distributed data      implicit none      real cu, xj0, yj0, zj0      integer kstrt, nvp, noff, nyp, nx, ny, ngx, ngy, nxe, nypmx, nblok      dimension cu(3,nxe,nypmx,nblok), nyp(nblok), noff(nblok)      integer i, j, k, l, ks, kk, nyp3, nxg, nx3      real chx, chy, chz      if ((ngx.lt.0).or.(ngx.gt.1).or.(ngy.lt.0).or.(ngy.gt.1)) returnc initialize extended field, with zero in the edges      nxg = nx - 2*ngx      nx3 = nx + 3      ks = kstrt - 2      chx = .5*xj0      chy = .5*yj0      chz = .5*zj0      do 120 l = 1, nblok      nyp3 = nyp(l) + 3c handle first grid point in y      if ((l+ks).eq.0) then         do 20 j = 1, nx3         do 10 i = 1, 3         cu(i,j,2,l) = 0.   10    continue   20    continue      endifc handle interior grid points in y      do 70 k = 1, nyp(l)      kk = k + noff(l)      if ((kk.ge.(ngy+2)).and.(kk.le.(ny-ngy))) then         do 30 j = 2, nxg         cu(1,j+ngx+1,k+1,l) = xj0         cu(2,j+ngx+1,k+1,l) = yj0         cu(3,j+ngx+1,k+1,l) = zj0   30    continue         do 40 i = 1, 3         cu(i,1,k+1,l) = 0.         cu(i,2,k+1,l) = 0.         cu(i,nx+2,k+1,l) = 0.         cu(i,nx+3,k+1,l) = 0.   40    continue         cu(1,ngx+2,k+1,l) = chx         cu(2,ngx+2,k+1,l) = chy         cu(3,ngx+2,k+1,l) = chz         cu(1,nx-ngx+2,k+1,l) = chx         cu(2,nx-ngx+2,k+1,l) = chy         cu(3,nx-ngx+2,k+1,l) = chz      else if ((kk.eq.(ngy+1)).or.(kk.eq.(ny-ngy+1))) then         do 50 j = 2, nxg         cu(1,j+ngx+1,k+1,l) = chx         cu(2,j+ngx+1,k+1,l) = chy         cu(3,j+ngx+1,k+1,l) = chz   50    continue         do 60 i = 1, 3         cu(i,1,k+1,l) = 0.         cu(i,2,k+1,l) = 0.         cu(i,nx+2,k+1,l) = 0.         cu(i,nx+3,k+1,l) = 0.   60    continue         cu(1,ngx+2,k+1,l) = .5*chx         cu(2,ngx+2,k+1,l) = .5*chy         cu(3,ngx+2,k+1,l) = .5*chz         cu(1,nx-ngx+2,k+1,l) = .5*chx         cu(2,nx-ngx+2,k+1,l) = .5*chy         cu(3,nx-ngx+2,k+1,l) = .5*chz      endif   70 continuec guard cells in y      do 90 j = 1, nx3      do 80 i = 1, 3      cu(i,j,1,l) = 0.      cu(i,j,nyp3-1,l) = 0.      cu(i,j,nyp3,l) = 0.   80 continue   90 continuec handle last grid point in y      if (((nyp(l)+noff(l)).lt.(ny-ngy+1)).and.((l+ks).eq.(nvp-1))) then         do 100 j = 2, nxg         cu(1,j+ngx+1,nyp3-ngy-1,l) = chx         cu(2,j+ngx+1,nyp3-ngy-1,l) = chy         cu(3,j+ngx+1,nyp3-ngy-1,l) = chz  100    continue         do 110 i = 1, 3         cu(i,1,nyp3-ngy-1,l) = 0.         cu(i,2,nyp3-ngy-1,l) = 0.         cu(i,nx+2,nyp3-ngy-1,l) = 0.         cu(i,nx+3,nyp3-ngy-1,l) = 0.  110    continue         cu(1,ngx+2,nyp3-ngy-1,l) = .5*chx         cu(2,ngx+2,nyp3-ngy-1,l) = .5*chy         cu(3,ngx+2,nyp3-ngy-1,l) = .5*chz         cu(1,nx-ngx+2,nyp3-ngy-1,l) = .5*chx         cu(2,nx-ngx+2,nyp3-ngy-1,l) = .5*chy         cu(3,nx-ngx+2,nyp3-ngy-1,l) = .5*chz      endif  120 continue      return      endc-----------------------------------------------------------------------      subroutine PLSCGUARD22X(cu,kstrt,nvp,noff,nyp,xj0,yj0,nx,ny,ngx,ng     1y,nxe,nypmx,nblok)c initialize extended non-periodic fieldc cu(i,j,k,l) = ith component of current density at grid point (j,kk),c where kk = k + noff(l) - 1c kstrt = starting data block numberc nvp = number of real or virtual processorsc noff(l) = lowermost global gridpoint in particle partition lc nyp(l) = number of primary gridpoints in particle partition lc xj0/yj0 = initialization constants in x/y directionc nx = system length in x directionc ngx/ngy = (0,1) number of grid cells away from edgec nxe = first dimension of charge array, must be >= nxc nypmx = maximum size of particle partition, including guard cellsc nblok = number of particle partitionsc quadratic interpolation, for distributed data      implicit none      real cu, xj0, yj0      integer kstrt, nvp, noff, nyp, nx, ny, ngx, ngy, nxe, nypmx, nblok      dimension cu(2,nxe,nypmx,nblok), nyp(nblok), noff(nblok)      integer i, j, k, l, ks, kk, nyp3, nxg, nx3      real chx, chy      if ((ngx.lt.0).or.(ngx.gt.1).or.(ngy.lt.0).or.(ngy.gt.1)) returnc initialize extended field, with zero in the edges      nxg = nx - 2*ngx      nx3 = nx + 3      ks = kstrt - 2      chx = .5*xj0      chy = .5*yj0      do 120 l = 1, nblok      nyp3 = nyp(l) + 3c handle first grid point in y      if ((l+ks).eq.0) then         do 20 j = 1, nx3         do 10 i = 1, 2         cu(i,j,2,l) = 0.   10    continue   20    continue      endifc handle interior grid points in y      do 70 k = 1, nyp(l)      kk = k + noff(l)      if ((kk.ge.(ngy+2)).and.(kk.le.(ny-ngy))) then         do 30 j = 2, nxg         cu(1,j+ngx+1,k+1,l) = xj0         cu(2,j+ngx+1,k+1,l) = yj0   30    continue         do 40 i = 1, 2         cu(i,1,k+1,l) = 0.         cu(i,2,k+1,l) = 0.         cu(i,nx+2,k+1,l) = 0.         cu(i,nx+3,k+1,l) = 0.   40    continue         cu(1,ngx+2,k+1,l) = chx         cu(2,ngx+2,k+1,l) = chy         cu(1,nx-ngx+2,k+1,l) = chx         cu(2,nx-ngx+2,k+1,l) = chy      else if ((kk.eq.(ngy+1)).or.(kk.eq.(ny-ngy+1))) then         do 50 j = 2, nxg         cu(1,j+ngx+1,k+1,l) = chx         cu(2,j+ngx+1,k+1,l) = chy   50    continue         do 60 i = 1, 2         cu(i,1,k+1,l) = 0.         cu(i,2,k+1,l) = 0.         cu(i,nx+2,k+1,l) = 0.         cu(i,nx+3,k+1,l) = 0.   60    continue         cu(1,ngx+2,k+1,l) = .5*chx         cu(2,ngx+2,k+1,l) = .5*chy         cu(1,nx-ngx+2,k+1,l) = .5*chx         cu(2,nx-ngx+2,k+1,l) = .5*chy      endif   70 continuec guard cells in y      do 90 j = 1, nx3      do 80 i = 1, 2      cu(i,j,1,l) = 0.      cu(i,j,nyp3-1,l) = 0.      cu(i,j,nyp3,l) = 0.   80 continue   90 continuec handle last grid point in y      if (((nyp(l)+noff(l)).lt.(ny-ngy+1)).and.((l+ks).eq.(nvp-1))) then         do 100 j = 2, nxg         cu(1,j+ngx+1,nyp3-ngy-1,l) = chx         cu(2,j+ngx+1,nyp3-ngy-1,l) = chy  100    continue         do 110 i = 1, 2         cu(i,1,nyp3-ngy-1,l) = 0.         cu(i,2,nyp3-ngy-1,l) = 0.         cu(i,nx+2,nyp3-ngy-1,l) = 0.         cu(i,nx+3,nyp3-ngy-1,l) = 0.  110    continue         cu(1,ngx+2,nyp3-ngy-1,l) = .5*chx         cu(2,ngx+2,nyp3-ngy-1,l) = .5*chy         cu(1,nx-ngx+2,nyp3-ngy-1,l) = .5*chx         cu(2,nx-ngx+2,nyp3-ngy-1,l) = .5*chy      endif  120 continue      return      endc-----------------------------------------------------------------------      subroutine PLSGUARD2X(q,kstrt,nvp,noff,nyp,qi0,nx,ny,ngx,ngy,nxe,n     1ypmx,nblok)c initialize extended non-periodic scalar fieldc q(j,k,l) = charge density at grid point (j,kk),c where kk = k + noff(l) - 1c kstrt = starting data block numberc nvp = number of real or virtual processorsc noff(l) = lowermost global gridpoint in particle partition lc nyp(l) = number of primary gridpoints in particle partition lc qi0 = initialization constantsc nx = system length in x directionc ngx/ngy = (0,1) number of grid cells away from edgec nxe = first dimension of charge array, must be >= nxc nypmx = maximum size of particle partition, including guard cellsc nblok = number of particle partitionsc quadratic interpolation, for distributed data      implicit none      real q, qi0      integer kstrt, nvp, noff, nyp, nx, ny, ngx, ngy, nxe, nypmx, nblok      dimension q(nxe,nypmx,nblok), nyp(nblok), noff(nblok)      integer j, k, l, ks, kk, nyp3, nxg, nx3      real qh      if ((ngx.lt.0).or.(ngx.gt.1).or.(ngy.lt.0).or.(ngy.gt.1)) returnc initialize extended field, with zero in the edges      nxg = nx - 2*ngx      nx3 = nx + 3      ks = kstrt - 2      qh = .5*qi0      do 70 l = 1, nblok      nyp3 = nyp(l) + 3c handle first grid point in y      if ((l+ks).eq.0) then         do 10 j = 1, nx3         q(j,2,l) = 0.   10    continue      endifc handle interior grid points in y      do 40 k = 1, nyp(l)      kk = k + noff(l)      if ((kk.ge.(ngy+2)).and.(kk.le.(ny-ngy))) then         do 20 j = 2, nxg         q(j+ngx+1,k+1,l) = qi0   20    continue         q(1,k+1,l) = 0.         q(2,k+1,l) = 0.         q(nx+2,k+1,l) = 0.         q(nx+3,k+1,l) = 0.         q(ngx+2,k+1,l) = qh         q(nx-ngx+2,k+1,l) = qh      else if ((kk.eq.(ngy+1)).or.(kk.eq.(ny-ngy+1))) then         do 30 j = 2, nxg         q(j+ngx+1,k+1,l) = qh   30    continue         q(1,k+1,l) = 0.         q(2,k+1,l) = 0.         q(nx+2,k+1,l) = 0.         q(nx+3,k+1,l) = 0.         q(ngx+2,k+1,l) = .5*qh         q(nx-ngx+2,k+1,l) = .5*qh      endif   40 continuec guard cells in y      do 50 j = 1, nx3      q(j,1,l) = 0.      q(j,nyp3-1,l) = 0.      q(j,nyp3,l) = 0.   50 continuec handle last grid point in y      if (((nyp(l)+noff(l)).lt.(ny-ngy+1)).and.((l+ks).eq.(nvp-1))) then         do 60 j = 2, nxg         q(j+ngx+1,nyp3-ngy-1,l) = qh   60    continue         q(1,nyp3-ngy-1,l) = 0.         q(2,nyp3-ngy-1,l) = 0.         q(nx+2,nyp3-ngy-1,l) = 0.         q(nx+3,nyp3-ngy-1,l) = 0.         q(ngx+2,nyp3-ngy-1,l) = .5*qh         q(nx-ngx+2,nyp3-ngy-1,l) = .5*qh      endif   70 continue      return      endc-----------------------------------------------------------------------      subroutine LSCGUARD2(cu,xj0,yj0,zj0,nx,ny,ngx,ngy,nxe,nye)c initialize extended non-periodic fieldc ngx/ngy = (0,1) = number of grid cells away from edgec quadratic interpolation      implicit none      real cu, xj0, yj0, zj0      integer nx, ny, ngx, ngy, nxe, nye      dimension cu(3,nxe,nye)      integer i, j, k, nxg, nyg, nx3      if ((ngx.lt.0).or.(ngx.gt.1).or.(ngy.lt.0).or.(ngy.gt.1)) returnc initialize extended field, with zero in the edges      nxg = nx - 2*ngx      nyg = ny - 2*ngy      nx3 = nx + 3      do 30 k = 2, nyg      do 10 j = 2, nxg      cu(1,j+ngx+1,k+ngy+1) = xj0      cu(2,j+ngx+1,k+ngy+1) = yj0      cu(3,j+ngx+1,k+ngy+1) = zj0   10 continue      do 20 i = 1, 3      cu(i,1,k+ngy+1) = 0.      cu(i,2,k+ngy+1) = 0.      cu(i,nx+2,k+ngy+1) = 0.      cu(i,nx+3,k+ngy+1) = 0.   20 continue      cu(1,ngx+2,k+ngy+1) = .5*xj0      cu(2,ngx+2,k+ngy+1) = .5*yj0      cu(3,ngx+2,k+ngy+1) = .5*zj0      cu(1,nx-ngx+2,k+ngy+1) = .5*xj0      cu(2,nx-ngx+2,k+ngy+1) = .5*yj0      cu(3,nx-ngx+2,k+ngy+1) = .5*zj0   30 continue      do 50 j = 1, nx3      do 40 i = 1, 3      cu(i,j,1) = 0.      cu(i,j,2) = 0.      cu(i,j,ny+2) = 0.      cu(i,j,ny+3) = 0.   40 continue   50 continue      do 60 j = 2, nxg      cu(1,j+ngx+1,ngy+2) = .5*xj0      cu(2,j+ngx+1,ngy+2) = .5*yj0      cu(3,j+ngx+1,ngy+2) = .5*zj0      cu(1,j+ngx+1,ny-ngy+2) = .5*xj0      cu(2,j+ngx+1,ny-ngy+2) = .5*yj0      cu(3,j+ngx+1,ny-ngy+2) = .5*zj0   60 continue      do 70 i = 1, 3      cu(i,1,ngy+2) = 0.      cu(i,2,ngy+2) = 0.      cu(i,nx+2,ngy+2) = 0.      cu(i,nx+3,ngy+2) = 0.      cu(i,1,ny-ngy+2) = 0.      cu(i,2,ny-ngy+2) = 0.      cu(i,nx+2,ny-ngy+2) = 0.      cu(i,nx+3,ny-ngy+2) = 0.   70 continue      cu(1,ngx+2,ngy+2) = .25*xj0      cu(2,ngx+2,ngy+2) = .25*yj0      cu(3,ngx+2,ngy+2) = .25*zj0      cu(1,nx-ngx+2,ngy+2) = .25*xj0      cu(2,nx-ngx+2,ngy+2) = .25*yj0      cu(3,nx-ngx+2,ngy+2) = .25*zj0      cu(1,ngx+2,ny-ngy+2) = .25*xj0      cu(2,ngx+2,ny-ngy+2) = .25*yj0      cu(3,ngx+2,ny-ngy+2) = .25*zj0      cu(1,nx-ngx+2,ny-ngy+2) = .25*xj0      cu(2,nx-ngx+2,ny-ngy+2) = .25*yj0      cu(3,nx-ngx+2,ny-ngy+2) = .25*zj0      return      endc-----------------------------------------------------------------------      subroutine LSCGUARD22(cu,xj0,yj0,nx,ny,ngx,ngy,nxe,nye)c initialize extended non-periodic fieldc ngx/ngy = (0,1) = number of grid cells away from edgec quadratic interpolation      implicit none      real cu, xj0, yj0      integer nx, ny, ngx, ngy, nxe, nye      dimension cu(2,nxe,nye)      integer i, j, k, nxg, nyg, nx3      if ((ngx.lt.0).or.(ngx.gt.1).or.(ngy.lt.0).or.(ngy.gt.1)) returnc initialize extended field, with zero in the edges      nxg = nx - 2*ngx      nyg = ny - 2*ngy      nx3 = nx + 3      do 30 k = 2, nyg      do 10 j = 2, nxg      cu(1,j+ngx+1,k+ngy+1) = xj0      cu(2,j+ngx+1,k+ngy+1) = yj0   10 continue      do 20 i = 1, 2      cu(i,1,k+ngy+1) = 0.      cu(i,2,k+ngy+1) = 0.      cu(i,nx+2,k+ngy+1) = 0.      cu(i,nx+3,k+ngy+1) = 0.   20 continue      cu(1,ngx+2,k+ngy+1) = .5*xj0      cu(2,ngx+2,k+ngy+1) = .5*yj0      cu(1,nx-ngx+2,k+ngy+1) = .5*xj0      cu(2,nx-ngx+2,k+ngy+1) = .5*yj0   30 continue      do 50 j = 1, nx3      do 40 i = 1, 2      cu(i,j,1) = 0.      cu(i,j,2) = 0.      cu(i,j,ny+2) = 0.      cu(i,j,ny+3) = 0.   40 continue   50 continue      do 60 j = 2, nxg      cu(1,j+ngx+1,ngy+2) = .5*xj0      cu(2,j+ngx+1,ngy+2) = .5*yj0      cu(1,j+ngx+1,ny-ngy+2) = .5*xj0      cu(2,j+ngx+1,ny-ngy+2) = .5*yj0   60 continue      do 70 i = 1, 2      cu(i,1,ngy+2) = 0.      cu(i,2,ngy+2) = 0.      cu(i,nx+2,ngy+2) = 0.      cu(i,nx+3,ngy+2) = 0.      cu(i,1,ny-ngy+2) = 0.      cu(i,2,ny-ngy+2) = 0.      cu(i,nx+2,ny-ngy+2) = 0.      cu(i,nx+3,ny-ngy+2) = 0.   70 continue      cu(1,ngx+2,ngy+2) = .25*xj0      cu(2,ngx+2,ngy+2) = .25*yj0      cu(1,nx-ngx+2,ngy+2) = .25*xj0      cu(2,nx-ngx+2,ngy+2) = .25*yj0      cu(1,ngx+2,ny-ngy+2) = .25*xj0      cu(2,ngx+2,ny-ngy+2) = .25*yj0      cu(1,nx-ngx+2,ny-ngy+2) = .25*xj0      cu(2,nx-ngx+2,ny-ngy+2) = .25*yj0      return      endc-----------------------------------------------------------------------      subroutine LSGUARD2(q,qi0,nx,ny,ngx,ngy,nxe,nye)c initialize extended non-periodic scalar fieldc ngx/ngy = (0,1) = number of grid cells away from edgec quadratic interpolation      implicit none      real q, qi0      integer nx, ny, ngx, ngy, nxe, nye      dimension q(nxe,nye)      integer j, k, nxg, nyg, nx3      if ((ngx.lt.0).or.(ngx.gt.1).or.(ngy.lt.0).or.(ngy.gt.1)) returnc initialize extended field, with zero in the edges      nxg = nx - 2*ngx      nyg = ny - 2*ngy      nx3 = nx + 3      do 20 k = 2, nyg      do 10 j = 2, nxg      q(j+ngx+1,k+ngy+1) = qi0   10 continue      q(1,k+ngy+1) = 0.      q(2,k+ngy+1) = 0.      q(nx+2,k+ngy+1) = 0.      q(nx+3,k+ngy+1) = 0.      q(ngx+2,k+ngy+1) = .5*qi0      q(nx-ngx+2,k+ngy+1) = .5*qi0   20 continue      do 30 j = 1, nx3      q(j,1) = 0.      q(j,2) = 0.      q(j,ny+2) = 0.      q(j,ny+3) = 0.   30 continue      do 40 j = 2, nxg      q(j+ngx+1,ngy+2) = .5*qi0      q(j+ngx+1,ny-ngy+2) = .5*qi0   40 continue      q(1,ngy+2) = 0.      q(2,ngy+2) = 0.      q(nx+2,ngy+2) = 0.      q(nx+3,ngy+2) = 0.      q(1,ny-ngy+2) = 0.      q(2,ny-ngy+2) = 0.      q(nx+2,ny-ngy+2) = 0.      q(nx+3,ny-ngy+2) = 0.      q(ngx+2,ngy+2) = .25*qi0      q(nx-ngx+2,ngy+2) = .25*qi0      q(ngx+2,ny-ngy+2) = .25*qi0      q(nx-ngx+2,ny-ngy+2) = .25*qi0      return      endc-----------------------------------------------------------------------      subroutine PLSCGUARD2XL(cu,kstrt,nvp,noff,nyp,xj0,yj0,zj0,nx,ny,ng     1x,ngy,nxe,nypmx,nblok)c initialize extended non-periodic fieldc cu(i,j,k,l) = ith component of current density at grid point (j,kk),c where kk = k + noff(l)c kstrt = starting data block numberc nvp = number of real or virtual processorsc noff(l) = lowermost global gridpoint in particle partition lc nyp(l) = number of primary gridpoints in particle partition lc xj0/yj0/zj0 = initialization constants in x/y/z directionc nx = system length in x directionc ngx/ngy = (0,1) number of grid cells away from edgec nxe = first dimension of charge array, must be >= nxc nypmx = maximum size of particle partition, including guard cellsc nblok = number of particle partitionsc linear interpolation, for distributed data      implicit none      real cu, xj0, yj0, zj0      integer kstrt, nvp, noff, nyp, nx, ny, ngx, ngy, nxe, nypmx, nblok      dimension cu(3,nxe,nypmx,nblok), nyp(nblok), noff(nblok)      integer i, j, k, l, ks, kk, nyp1, nxg, nx1      real chx, chy, chz      if ((ngx.lt.0).or.(ngx.gt.1).or.(ngy.lt.0).or.(ngy.gt.1)) returnc initialize extended field, with zero in the edges      nxg = nx - 2*ngx      nx1 = nx + 1      ks = kstrt - 2      chx = .5*xj0      chy = .5*yj0      chz = .5*zj0      do 120 l = 1, nblok      nyp1 = nyp(l) + 1c handle first grid point in y      if ((l+ks).eq.0) then         do 20 j = 1, nx1         do 10 i = 1, 3         cu(i,j,1,l) = 0.   10    continue   20    continue      endifc handle interior grid points in y      do 70 k = 1, nyp(l)      kk = k + noff(l)      if ((kk.ge.(ngy+2)).and.(kk.le.(ny-ngy))) then         do 30 j = 2, nxg         cu(1,j+ngx,k,l) = xj0         cu(2,j+ngx,k,l) = yj0         cu(3,j+ngx,k,l) = zj0   30    continue         do 40 i = 1, 3         cu(i,1,k,l) = 0.         cu(i,nx+1,k,l) = 0.   40    continue         cu(1,ngx+1,k,l) = chx         cu(2,ngx+1,k,l) = chy         cu(3,ngx+1,k,l) = chz         cu(1,nx-ngx+1,k,l) = chx         cu(2,nx-ngx+1,k,l) = chy         cu(3,nx-ngx+1,k,l) = chz      else if ((kk.eq.(ngy+1)).or.(kk.eq.(ny-ngy+1))) then         do 50 j = 2, nxg         cu(1,j+ngx,k,l) = chx         cu(2,j+ngx,k,l) = chy         cu(3,j+ngx,k,l) = chz   50    continue         do 60 i = 1, 3         cu(i,1,k,l) = 0.         cu(i,nx+1,k,l) = 0.   60    continue         cu(1,ngx+1,k,l) = .5*chx         cu(2,ngx+1,k,l) = .5*chy         cu(3,ngx+1,k,l) = .5*chz         cu(1,nx-ngx+1,k,l) = .5*chx         cu(2,nx-ngx+1,k,l) = .5*chy         cu(3,nx-ngx+1,k,l) = .5*chz      endif   70 continuec guard cells in y      do 90 j = 1, nx1      do 80 i = 1, 3      cu(i,j,nyp1,l) = 0.   80 continue   90 continuec handle last grid point in y      if (((nyp(l)+noff(l)).lt.(ny-ngy+1)).and.((l+ks).eq.(nvp-1))) then         do 100 j = 2, nxg         cu(1,j+ngx,nyp1-ngy,l) = chx         cu(2,j+ngx,nyp1-ngy,l) = chy         cu(3,j+ngx,nyp1-ngy,l) = chz  100    continue         do 110 i = 1, 3         cu(i,1,nyp1-ngy,l) = 0.         cu(i,nx+1,nyp1-ngy,l) = 0.  110    continue         cu(1,ngx+1,nyp1-ngy,l) = .5*chx         cu(2,ngx+1,nyp1-ngy,l) = .5*chy         cu(3,ngx+1,nyp1-ngy,l) = .5*chz         cu(1,nx-ngx+1,nyp1-ngy,l) = .5*chx         cu(2,nx-ngx+1,nyp1-ngy,l) = .5*chy         cu(3,nx-ngx+1,nyp1-ngy,l) = .5*chz      endif  120 continue      return      endc-----------------------------------------------------------------------      subroutine PLSCGUARD22XL(cu,kstrt,nvp,noff,nyp,xj0,yj0,nx,ny,ngx,n     1gy,nxe,nypmx,nblok)c initialize extended non-periodic fieldc cu(i,j,k,l) = ith component of current density at grid point (j,kk),c where kk = k + noff(l)c kstrt = starting data block numberc nvp = number of real or virtual processorsc noff(l) = lowermost global gridpoint in particle partition lc nyp(l) = number of primary gridpoints in particle partition lc xj0/yj0 = initialization constants in x/y/ directionc nx = system length in x directionc ngx/ngy = (0,1) number of grid cells away from edgec nxe = first dimension of charge array, must be >= nxc nypmx = maximum size of particle partition, including guard cellsc nblok = number of particle partitionsc linear interpolation, for distributed data      implicit none      real cu, xj0, yj0      integer kstrt, nvp, noff, nyp, nx, ny, ngx, ngy, nxe, nypmx, nblok      dimension cu(2,nxe,nypmx,nblok), nyp(nblok), noff(nblok)      integer i, j, k, l, ks, kk, nyp1, nxg, nx1      real chx, chy      if ((ngx.lt.0).or.(ngx.gt.1).or.(ngy.lt.0).or.(ngy.gt.1)) returnc initialize extended field, with zero in the edges      nxg = nx - 2*ngx      nx1 = nx + 1      ks = kstrt - 2      chx = .5*xj0      chy = .5*yj0      do 120 l = 1, nblok      nyp1 = nyp(l) + 1c handle first grid point in y      if ((l+ks).eq.0) then         do 20 j = 1, nx1         do 10 i = 1, 2         cu(i,j,1,l) = 0.   10    continue   20    continue      endifc handle interior grid points in y      do 70 k = 1, nyp(l)      kk = k + noff(l)      if ((kk.ge.(ngy+2)).and.(kk.le.(ny-ngy))) then         do 30 j = 2, nxg         cu(1,j+ngx,k,l) = xj0         cu(2,j+ngx,k,l) = yj0   30    continue         do 40 i = 1, 2         cu(i,1,k,l) = 0.         cu(i,nx+1,k,l) = 0.   40    continue         cu(1,ngx+1,k,l) = chx         cu(2,ngx+1,k,l) = chy         cu(1,nx-ngx+1,k,l) = chx         cu(2,nx-ngx+1,k,l) = chy      else if ((kk.eq.(ngy+1)).or.(kk.eq.(ny-ngy+1))) then         do 50 j = 2, nxg         cu(1,j+ngx,k,l) = chx         cu(2,j+ngx,k,l) = chy   50    continue         do 60 i = 1, 2         cu(i,1,k,l) = 0.         cu(i,nx+1,k,l) = 0.   60    continue         cu(1,ngx+1,k,l) = .5*chx         cu(2,ngx+1,k,l) = .5*chy         cu(1,nx-ngx+1,k,l) = .5*chx         cu(2,nx-ngx+1,k,l) = .5*chy      endif   70 continuec guard cells in y      do 90 j = 1, nx1      do 80 i = 1, 2      cu(i,j,nyp1,l) = 0.   80 continue   90 continuec handle last grid point in y      if (((nyp(l)+noff(l)).lt.(ny-ngy+1)).and.((l+ks).eq.(nvp-1))) then         do 100 j = 2, nxg         cu(1,j+ngx,nyp1-ngy,l) = chx         cu(2,j+ngx,nyp1-ngy,l) = chy  100    continue         do 110 i = 1, 2         cu(i,1,nyp1-ngy,l) = 0.         cu(i,nx+1,nyp1-ngy,l) = 0.  110    continue         cu(1,ngx+1,nyp1-ngy,l) = .5*chx         cu(2,ngx+1,nyp1-ngy,l) = .5*chy         cu(1,nx-ngx+1,nyp1-ngy,l) = .5*chx         cu(2,nx-ngx+1,nyp1-ngy,l) = .5*chy      endif  120 continue      return      endc-----------------------------------------------------------------------      subroutine PLSGUARD2XL(q,kstrt,nvp,noff,nyp,qi0,nx,ny,ngx,ngy,nxe,     1nypmx,nblok)c initialize extended non-periodic scalar fieldc q(j,k,l) = charge density at grid point (j,kk),c where kk = k + noff(l)c kstrt = starting data block numberc nvp = number of real or virtual processorsc noff(l) = lowermost global gridpoint in particle partition lc nyp(l) = number of primary gridpoints in particle partition lc qi0 = initialization constantc nx = system length in x directionc ngx/ngy = (0,1) number of grid cells away from edgec nxe = first dimension of charge array, must be >= nxc nypmx = maximum size of particle partition, including guard cellsc nblok = number of particle partitionsc linear interpolation, for distributed data      implicit none      real q, qi0      integer kstrt, nvp, noff, nyp, nx, ny, ngx, ngy, nxe, nypmx, nblok      dimension q(nxe,nypmx,nblok), nyp(nblok), noff(nblok)      integer j, k, l, ks, kk, nyp1, nxg, nx1      real qh      if ((ngx.lt.0).or.(ngx.gt.1).or.(ngy.lt.0).or.(ngy.gt.1)) returnc initialize extended field, with zero in the edges      nxg = nx - 2*ngx      nx1 = nx + 1      ks = kstrt - 2      qh = .5*qi0      do 70 l = 1, nblok      nyp1 = nyp(l) + 1c handle first grid point in y      if ((l+ks).eq.0) then         do 10 j = 1, nx1         q(j,1,l) = 0.   10    continue      endifc handle interior grid points in y      do 40 k = 1, nyp(l)      kk = k + noff(l)      if ((kk.ge.(ngy+2)).and.(kk.le.(ny-ngy))) then         do 20 j = 2, nxg         q(j+ngx,k,l) = qi0   20    continue         q(1,k,l) = 0.         q(nx+1,k,l) = 0.         q(ngx+1,k,l) = qh         q(nx-ngx+1,k,l) = qh      else if ((kk.eq.(ngy+1)).or.(kk.eq.(ny-ngy+1))) then         do 30 j = 2, nxg         q(j+ngx,k,l) = qh   30    continue         q(1,k,l) = 0.         q(nx+1,k,l) = 0.         q(ngx+1,k,l) = .5*qh         q(nx-ngx+1,k,l) = .5*qh      endif   40 continuec guard cells in y      do 50 j = 1, nx1      q(j,nyp1,l) = 0.   50 continuec handle last grid point in y      if (((nyp(l)+noff(l)).lt.(ny-ngy+1)).and.((l+ks).eq.(nvp-1))) then         do 60 j = 2, nxg         q(j+ngx,nyp1-ngy,l) = qh   60    continue         q(1,nyp1-ngy,l) = 0.         q(nx+1,nyp1-ngy,l) = 0.         q(ngx+1,nyp1-ngy,l) = .5*qh         q(nx-ngx+1,nyp1-ngy,l) = .5*qh      endif   70 continue      return      endc-----------------------------------------------------------------------      subroutine LSCGUARD2L(cu,xj0,yj0,zj0,nx,ny,ngx,ngy,nxe,nye)c initialize extended non-periodic fieldc ngx/ngy = (0,1) = number of grid cells away from edgec linear interpolation      implicit none      real cu, xj0, yj0, zj0      integer nx, ny, ngx, ngy, nxe, nye      dimension cu(3,nxe,nye)      integer i, j, k, nxg, nyg, nx1      if ((ngx.lt.0).or.(ngx.gt.1).or.(ngy.lt.0).or.(ngy.gt.1)) returnc initialize extended field, with zero in the edges      nxg = nx - 2*ngx      nyg = ny - 2*ngy      nx1 = nx + 1      do 30 k = 2, nyg      do 10 j = 2, nxg      cu(1,j+ngx,k+ngy) = xj0      cu(2,j+ngx,k+ngy) = yj0      cu(3,j+ngx,k+ngy) = zj0   10 continue      do 20 i = 1, 3      cu(i,1,k+ngy) = 0.      cu(i,nx+1,k+ngy) = 0.   20 continue      cu(1,ngx+1,k+ngy) = .5*xj0      cu(2,ngx+1,k+ngy) = .5*yj0      cu(3,ngx+1,k+ngy) = .5*zj0      cu(1,nx-ngx+1,k+ngy) = .5*xj0      cu(2,nx-ngx+1,k+ngy) = .5*yj0      cu(3,nx-ngx+1,k+ngy) = .5*zj0   30 continue      do 50 j = 1, nx1      do 40 i = 1, 3      cu(i,j,1) = 0.      cu(i,j,ny+1) = 0.   40 continue   50 continue      do 60 j = 2, nxg      cu(1,j+ngx,ngy+1) = .5*xj0      cu(2,j+ngx,ngy+1) = .5*yj0      cu(3,j+ngx,ngy+1) = .5*zj0      cu(1,j+ngx,ny-ngy+1) = .5*xj0      cu(2,j+ngx,ny-ngy+1) = .5*yj0      cu(3,j+ngx,ny-ngy+1) = .5*zj0   60 continue      do 70 i = 1, 3      cu(i,1,ngy+1) = 0.      cu(i,nx+1,ngy+1) = 0.      cu(i,1,ny-ngy+1) = 0.      cu(i,nx+1,ny-ngy+1) = 0.   70 continue      cu(1,ngx+1,ngy+1) = .25*xj0      cu(2,ngx+1,ngy+1) = .25*yj0      cu(3,ngx+1,ngy+1) = .25*zj0      cu(1,nx-ngx+1,ngy+1) = .25*xj0      cu(2,nx-ngx+1,ngy+1) = .25*yj0      cu(3,nx-ngx+1,ngy+1) = .25*zj0      cu(1,ngx+1,ny-ngy+1) = .25*xj0      cu(2,ngx+1,ny-ngy+1) = .25*yj0      cu(3,ngx+1,ny-ngy+1) = .25*zj0      cu(1,nx-ngx+1,ny-ngy+1) = .25*xj0      cu(2,nx-ngx+1,ny-ngy+1) = .25*yj0      cu(3,nx-ngx+1,ny-ngy+1) = .25*zj0      return      endc-----------------------------------------------------------------------      subroutine LSCGUARD22L(cu,xj0,yj0,nx,ny,ngx,ngy,nxe,nye)c initialize extended non-periodic fieldc ngx/ngy = (0,1) = number of grid cells away from edgec linear interpolation      implicit none      real cu, xj0, yj0      integer nx, ny, ngx, ngy, nxe, nye      dimension cu(2,nxe,nye)      integer i, j, k, nxg, nyg, nx1      if ((ngx.lt.0).or.(ngx.gt.1).or.(ngy.lt.0).or.(ngy.gt.1)) returnc initialize extended field, with zero in the edges      nxg = nx - 2*ngx      nyg = ny - 2*ngy      nx1 = nx + 1      do 30 k = 2, nyg      do 10 j = 2, nxg      cu(1,j+ngx,k+ngy) = xj0      cu(2,j+ngx,k+ngy) = yj0   10 continue      do 20 i = 1, 2      cu(i,1,k+ngy) = 0.      cu(i,nx+1,k+ngy) = 0.   20 continue      cu(1,ngx+1,k+ngy) = .5*xj0      cu(2,ngx+1,k+ngy) = .5*yj0      cu(1,nx-ngx+1,k+ngy) = .5*xj0      cu(2,nx-ngx+1,k+ngy) = .5*yj0   30 continue      do 50 j = 1, nx1      do 40 i = 1, 2      cu(i,j,1) = 0.      cu(i,j,ny+1) = 0.   40 continue   50 continue      do 60 j = 2, nxg      cu(1,j+ngx,ngy+1) = .5*xj0      cu(2,j+ngx,ngy+1) = .5*yj0      cu(1,j+ngx,ny-ngy+1) = .5*xj0      cu(2,j+ngx,ny-ngy+1) = .5*yj0   60 continue      do 70 i = 1, 2      cu(i,1,ngy+1) = 0.      cu(i,nx+1,ngy+1) = 0.      cu(i,1,ny-ngy+1) = 0.      cu(i,nx+1,ny-ngy+1) = 0.   70 continue      cu(1,ngx+1,ngy+1) = .25*xj0      cu(2,ngx+1,ngy+1) = .25*yj0      cu(1,nx-ngx+1,ngy+1) = .25*xj0      cu(2,nx-ngx+1,ngy+1) = .25*yj0      cu(1,ngx+1,ny-ngy+1) = .25*xj0      cu(2,ngx+1,ny-ngy+1) = .25*yj0      cu(1,nx-ngx+1,ny-ngy+1) = .25*xj0      cu(2,nx-ngx+1,ny-ngy+1) = .25*yj0      return      endc-----------------------------------------------------------------------      subroutine LSGUARD2L(q,qi0,nx,ny,ngx,ngy,nxe,nye)c initialize extended non-periodic scalar fieldc ngx/ngy = (0,1) = number of grid cells away from edgec linear interpolation      implicit none      real q, qi0      integer nx, ny, ngx, ngy, nxe, nye      dimension q(nxe,nye)      integer j, k, nxg, nyg, nx1      if ((ngx.lt.0).or.(ngx.gt.1).or.(ngy.lt.0).or.(ngy.gt.1)) returnc initialize extended field, with zero in the edges      nxg = nx - 2*ngx      nyg = ny - 2*ngy      nx1 = nx + 1      do 20 k = 2, nyg      do 10 j = 2, nxg      q(j+ngx,k+ngy) = qi0   10 continue      q(1,k+ngy) = 0.      q(nx+1,k+ngy) = 0.      q(ngx+1,k+ngy) = .5*qi0      q(nx-ngx+1,k+ngy) = .5*qi0   20 continue      do 30 j = 1, nx1      q(j,1) = 0.      q(j,ny+1) = 0.   30 continue      do 40 j = 2, nxg      q(j+ngx,ngy+1) = .5*qi0      q(j+ngx,ny-ngy+1) = .5*qi0   40 continue      q(1,ngy+1) = 0.      q(nx+1,ngy+1) = 0.      q(1,ny-ngy+1) = 0.      q(nx+1,ny-ngy+1) = 0.      q(ngx+1,ngy+1) = .25*qi0      q(nx-ngx+1,ngy+1) = .25*qi0      q(ngx+1,ny-ngy+1) = .25*qi0      q(nx-ngx+1,ny-ngy+1) = .25*qi0      return      endc-----------------------------------------------------------------------      subroutine PLACGUARD2X(cu,nyp,nx,nxe,nypmx,nblok)c this subroutine adds adds up guard cells so as to disablec quadratic interpolation within a half a cell of the edges,c and reduce it to linear interpolation in the x directionc for distributed data      implicit none      real cu      integer nyp, nx, nxe, nypmx, nblok      dimension cu(3,nxe,nypmx,nblok), nyp(nblok)c local data      integer i, k, l, nyp3c add up guard cells      do 30 l = 1, nblok      nyp3 = nyp(l) + 3      do 20 k = 1, nyp3      do 10 i = 1, 3      cu(i,2,k,l) = cu(i,2,k,l) + 2.*cu(i,1,k,l)      cu(i,3,k,l) = cu(i,3,k,l) - cu(i,1,k,l)      cu(i,nx+1,k,l) = cu(i,nx+1,k,l) - cu(i,nx+3,k,l)      cu(i,nx+2,k,l) = cu(i,nx+2,k,l) + 2.*cu(i,nx+3,k,l)      cu(i,1,k,l) = 0.      cu(i,nx+3,k,l) = 0.   10 continue   20 continue   30 continue      return      endc-----------------------------------------------------------------------      subroutine PLACGUARD2(f,scr,kstrt,nvp,nx,nxv,nypmx,kyp,kblok,ngds)c this subroutine copies data from particle to field partitions, addingc data from guard cells, where the field and particle partitions are c assumed to be the same.c the field is added up so as to disable quadratic interpolationc within half a cell of the edges, and reduce it to linear interpolationc in the y direction.c f(3,j,k,l) = real data for grid j,k in particle partition l. number ofc grids per partition is uniform and includes three extra guard cells.c scr(j,idps,k) = scratch array for particle partition kc kstrt = starting data block numberc nvp = number of real or virtual processorsc nx = system length in x directionc nxv = first dimension of f, must be >= nxc nypmx = maximum size of particle partition, including guard cells.c kyp = number of complex grids in each field partition.c kblok = number of field partitions.c ngds = number of guard cellsc quadratic interpolation, for distributed data      implicit none      real f, scr      integer kstrt, nvp, nx, nxv, nypmx, kyp, kblok, ngds      dimension f(3,nxv,nypmx,kblok), scr(3,nxv,ngds,kblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=8)c lgrp = current communicatorc mreal = default datatype for reals      common /pparms/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer istatus, msid, ierr      integer nx3, ks, moff, kr, krr, kl, kll, ngc, j, l, m      dimension istatus(lstat)      nx3 = nx + 3      ks = kstrt - 2      moff = nypmx*nvpc add guard cells      do 170 l = 1, kblok      kr = l + ks + 2      krr = kr      kl = l + ks      kll = kl      ngc = 2c special case of only one grid per processor      if (kyp.eq.1) then         krr = krr + 1         kll = kll - 1         ngc = 1      endifc this segment is used for shared memory computersc     if (kl.ge.1) thenc        do 10 j = 1, nx3c        do 10 m = 1, 3c        scr(m,j,1,l) = f(m,j,kyp+2,kl)c        scr(m,j,2,l) = f(m,j,kyp+3,kll)c  10    continuec  20    continuec     elsec        do 40 j = 1, nx3c        do 30 m = 1, 3c        scr(m,j,1,l) = 2.*f(m,j,1,l)c        scr(m,j,2,l) = -f(m,j,1,l)c  30    continuec  40    continuec     endifc     if (kr.le.nvp) thenc        do 60 j = 1, nx3c        do 50 m = 1, 3c        scr(m,j,3,l) = f(m,j,1,kr)c  50    continuec  60    continuec     elsec        do 80 j = 1, nx3c        do 70 m = 1, 3c        scr(m,j,3,l) = -f(m,j,kyp+3,l)c        f(m,j,kyp+2,l) = f(m,j,kyp+2,l) + 2.*f(m,j,kyp+3,l)c        f(m,j,kyp+3,l) = 0.c  70    continuec  80    continuec     endifc     if (kyp.eq.1) thenc        if (kl.eq.1) thenc           do 100 j = 1, nx3c           do 90 m = 1, 3c           scr(m,j,1,l) = f(m,j,kyp+2,kl)c           scr(m,j,2,l) = -f(m,j,1,kl)c  90       continuec 100       continuec        else if (kl.eq.0) thenc           do 120 j = 1, nx3c           do 110 m = 1, 3c           scr(m,j,2,l) = 0.c 110       continuec 120       continuec        endifc last point is special with only one gridc        if ((kl.eq.(nvp-1)).and.(kl.ge.1)) thenc           do 140 j = 1, nx3c           do 130 m = 1, 3c           f(m,j,kyp+2,l) = f(m,j,kyp+2,l) + f(m,j,kyp+3,kl)c 130    continuec 140    continuec        endifc     endifc this segment is used for mpi computers      if (kl.ge.1) then         call MPI_IRECV(scr,3*ngc*nxv,mreal,kl-1,moff+1,lgrp,msid,ierr)      endif      if (kr.le.nvp) then         call MPI_SEND(f(1,1,kyp+2,l),3*ngc*nxv,mreal,kr-1,moff+1,lgrp,i     1err)      endif      if (kl.ge.1) then         call MPI_WAIT(msid,istatus,ierr)      else         do 20 j = 1, nx3         do 10 m = 1, 3         scr(m,j,1,l) = 2.*f(m,j,1,l)         scr(m,j,2,l) = -f(m,j,1,l)   10    continue   20    continue      endif      if (kr.le.nvp) then         call MPI_IRECV(scr(1,1,3,l),3*nxv,mreal,kr-1,moff+2,lgrp,msid,i     1err)      endif      if (kl.ge.1) then         call MPI_SEND(f(1,1,1,l),3*nxv,mreal,kl-1,moff+2,lgrp,ierr)      endif      if (kr.le.nvp) then         call MPI_WAIT(msid,istatus,ierr)      else         do 40 j = 1, nx3         do 30 m = 1, 3         scr(m,j,3,l) = -f(m,j,kyp+3,l)         f(m,j,kyp+2,l) = f(m,j,kyp+2,l) + 2.*f(m,j,kyp+3,l)         f(m,j,kyp+3,l) = 0.   30    continue   40    continue      endifc special case of only one grid per processor      if (kyp.eq.1) then         if (kll.ge.1) then            call MPI_IRECV(scr(1,1,2,l),3*nxv,mreal,kll-1,moff+5,lgrp,ms     1id,ierr)         else if (kl.eq.1) then            call MPI_IRECV(scr(1,1,2,l),3*nxv,mreal,kl-1,moff+5,lgrp,msi     1d,ierr)         endif         if (krr.le.nvp) then            call MPI_SEND(f(1,1,kyp+3,l),3*nxv,mreal,krr-1,moff+5,lgrp,i     1err)         endif         if ((kl.eq.0).and.(kr.le.nvp)) then            call MPI_SEND(f(1,1,1,l),3*nxv,mreal,kr-1,moff+5,lgrp,ierr)         endif         if (kl.ge.1) then            call MPI_WAIT(msid,istatus,ierr)            if (kl.eq.1) then               do 60 j = 1, nx3               do 50 m = 1, 3               scr(m,j,2,l) = -scr(m,j,2,l)   50          continue   60          continue            endif         else            do 80 j = 1, nx3            do 70 m = 1, 3            scr(m,j,2,l) = 0.   70       continue   80       continue         endifc last point is special with only one grid         if ((kl.eq.(nvp-1)).and.(kl.ge.1)) then            call MPI_IRECV(f(1,1,kyp+3,l),3*nxv,mreal,kl-1,moff+6,lgrp,m     1sid,ierr)         endif         if (kr.eq.nvp) then            call MPI_SEND(f(1,1,kyp+3,l),3*nxv,mreal,kr-1,moff+6,lgrp,ie     1rr)         endif         if ((kl.eq.(nvp-1)).and.(kl.ge.1)) then            call MPI_WAIT(msid,istatus,ierr)            do 140 j = 1, nx3            do 130 m = 1, 3            f(m,j,kyp+2,l) = f(m,j,kyp+2,l) + f(m,j,kyp+3,l)            f(m,j,kyp+3,l) = 0.  130       continue  140       continue         endif      endifc add up the guard cells      do 160 j = 1, nx3      do 150 m = 1, 3      f(m,j,2,l) = f(m,j,2,l) + scr(m,j,1,l)      f(m,j,ngc+1,l) = f(m,j,ngc+1,l) + scr(m,j,2,l)      f(m,j,kyp+1,l) = f(m,j,kyp+1,l) + scr(m,j,3,l)  150 continue  160 continue  170 continuec zero out the left edge      do 200 l = 1, kblok      kl = l + ks      if (kl.eq.0) then         do 190 j = 1, nx3         do 180 m = 1, 3         f(m,j,1,l) = 0.  180    continue  190    continue      endif  200 continue      return      endc-----------------------------------------------------------------------      subroutine PLACGUARDS2(f,kstrt,nvp,nx,nxv,nypmx,kyp,kblok)c this subroutine corrects the change density data for particle boundaryc conditions which keep particles one grid away from the edgesc the field is added up so as to disable quadratic interpolationc within half a cell of the edges, and reduce it to linear interpolationc in the y direction.c f(3,j,k,l) = real data for grid j,k in particle partition l. number ofc grids per partition is uniform and includes three extra guard cells.c kstrt = starting data block numberc nvp = number of real or virtual processorsc nx = system length in x directionc nxv = first dimension of f, must be >= nxc nypmx = maximum size of particle partition, including guard cells.c kyp = number of complex grids in each field partition.c kblok = number of field partitions.c quadratic interpolation, for distributed data      implicit none      real f      integer kstrt, nvp, nx, nxv, nypmx, kyp, kblok      dimension f(3,nxv,nypmx,kblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=8)c lgrp = current communicatorc mreal = default datatype for reals      common /pparms/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer istatus, msid, nsid, ierr      integer ks, moff, kr, krr, kl, kll, j, l, m      dimension istatus(lstat)      ks = kstrt - 2      moff = nypmx*nvpc add guard cells      do 210 l = 1, kblok      kr = l + ks + 2      krr = kr      kl = l + ks      kll = klc special case of only one grid per processor      if (kyp.eq.1) then         krr = krr + 1         kll = kll - 1      endifc fix edges if all points are on the same processor      if (kl.eq.0) then         if (kyp.gt.2) then            do 20 j = 2, nx            do 10 m = 1, 3            f(m,j+1,3,l) = f(m,j+1,3,l) + 2.*f(m,j+1,2,l)            f(m,j+1,4,l) = f(m,j+1,4,l) - f(m,j+1,2,l)            f(m,j+1,2,l) = 0.   10       continue   20       continue         else if (kyp.eq.2) then            do 40 j = 2, nx            do 30 m = 1, 3            f(m,j+1,3,l) = f(m,j+1,3,l) + 2.*f(m,j+1,2,l)   30       continue   40       continue         endif      endif      if (kr.eq.(nvp+1)) then         if (kyp.gt.1) then            do 60 j = 2, nx            do 50 m = 1, 3            f(m,j+1,kyp,l) = f(m,j+1,kyp,l) - f(m,j+1,kyp+2,l)            f(m,j+1,kyp+1,l) = f(m,j+1,kyp+1,l) + 2.*f(m,j+1,kyp+2,l)            f(m,j+1,kyp+2,l) = 0.   50       continue   60       continue         else if (kyp.eq.1) then            do 80 j = 2, nx            do 70 m = 1, 3            f(m,j+1,kyp+1,l) = f(m,j+1,kyp+1,l) + 2.*f(m,j+1,kyp+2,l)   70       continue   80       continue         endif      endifc this segment is used for shared memory computersc     if (kyp.eq.2) thenc        if (kl.eq.1) thenc           do 120 j = 2, nxc           do 110 m = 1, 3c           f(m,j+1,2,l) = f(m,j+1,2,l) - f(m,j+1,2,kl)c 110       continuec 120       continuec        endifc     else if (kyp.eq.1) thenc        if (kl.eq.1) thenc           do 140 j = 2, nxc           do 130 m = 1, 3c           f(m,j+1,2,l) = f(m,j+1,2,l) + 2.*f(m,j+1,2,kl)c 130       continuec 140       continuec        endifc        if (kll.eq.1) thenc           do 160 j = 2, nxc           do 150 m = 1, 3c           f(m,j+1,2,l) = f(m,j+1,2,l) - f(m,j+1,2,kll)c 150       continuec 160       continuec        endifc        if (kr.eq.nvp) thenc           do 180 j = 2, nxc           do 170 m = 1, 3c           f(m,j+1,kyp+1,l) = f(m,j+1,kyp+1,l) - f(m,j+1,kyp+2,kr)c 170       continuec 180       continuec        endifc     endifc this segment is used for mpi computers      if (kyp.eq.2) then         if (kl.eq.1) then            call MPI_IRECV(f(1,1,1,l),3*nxv,mreal,kl-1,moff+1,lgrp,msid,     1ierr)         endif         if (kl.eq.0) then            call MPI_SEND(f(1,1,2,l),3*nxv,mreal,kr-1,moff+1,lgrp,ierr)            do 100 j = 2, nx            do 90 m = 1, 3            f(m,j+1,2,l) = 0.   90       continue  100       continue         endif         if (kl.eq.1) then            call MPI_WAIT(msid,istatus,ierr)            do 120 j = 2, nx            do 110 m = 1, 3            f(m,j+1,2,l) = f(m,j+1,2,l) - f(m,j+1,1,l)            f(m,j+1,1,l) = 0.  110       continue  120       continue         endif      else if (kyp.eq.1) then         if (kl.eq.1) then            call MPI_IRECV(f(1,1,1,l),3*nxv,mreal,kl-1,moff+1,lgrp,msid,     1ierr)         endif         if (kll.eq.1) then            call MPI_IRECV(f(1,1,1,l),3*nxv,mreal,kll-1,moff+1,lgrp,nsid     1,ierr)         endif         if (kl.eq.0) then            call MPI_SEND(f(1,1,2,l),3*nxv,mreal,kr-1,moff+1,lgrp,ierr)            call MPI_SEND(f(1,1,2,l),3*nxv,mreal,krr-1,moff+1,lgrp,ierr)            do 140 j = 2, nx            do 130 m = 1, 3            f(m,j+1,2,l) = 0.  130       continue  140       continue         endif         if (kl.eq.1) then            call MPI_WAIT(msid,istatus,ierr)            do 160 j = 2, nx            do 150 m = 1, 3            f(m,j+1,2,l) = f(m,j+1,2,l) + 2.*f(m,j+1,1,l)            f(m,j+1,1,l) = 0.  150       continue  160       continue         endif         if (kll.eq.1) then            call MPI_WAIT(nsid,istatus,ierr)            do 180 j = 2, nx            do 170 m = 1, 3            f(m,j+1,2,l) = f(m,j+1,2,l) - f(m,j+1,1,l)            f(m,j+1,1,l) = 0.  170       continue  180       continue         endif         if (kr.eq.nvp) then            call MPI_IRECV(f(1,1,1,l),3*nxv,mreal,kr-1,moff+2,lgrp,msid,     1ierr)         endif         if (kr.eq.(nvp+1)) then            call MPI_SEND(f(1,1,kyp+2,l),3*nxv,mreal,kl-1,moff+2,lgrp,ie     1rr)         endif         if (kr.eq.nvp) then            call MPI_WAIT(msid,istatus,ierr)            do 200 j = 2, nx            do 190 m = 1, 3            f(m,j+1,kyp+1,l) = f(m,j+1,kyp+1,l) - f(m,j+1,1,l)            f(m,j+1,1,l) = 0.  190       continue  200       continue         endif      endif  210 continue      return      endc-----------------------------------------------------------------------      subroutine LACGUARD2(cu,nx,ny,nxe,nye)c this subroutine adds adds up guard cells so as to disablec quadratic interpolation within a half a cell of the edges,c and reduce it to linear interpolation on both boundariesc nx/ny = system length in x/y directionc nxe = first dimension of input array q, must be >= nx+3c nxe = second dimension of input array q, must be >= ny+3      implicit none      real cu      integer nx, ny, nxe, nye      dimension cu(3,nxe,nye)c local data      integer i, j, k, nx1, ny3      nx1 = nx + 1      ny3 = ny + 3c add up guard cells      do 20 k = 1, ny3      do 10 i = 1, 3      cu(i,2,k) = cu(i,2,k) + 2.*cu(i,1,k)      cu(i,3,k) = cu(i,3,k) - cu(i,1,k)      cu(i,nx+1,k) = cu(i,nx+1,k) - cu(i,nx+3,k)      cu(i,nx+2,k) = cu(i,nx+2,k) + 2.*cu(i,nx+3,k)      cu(i,1,k) = 0.      cu(i,nx+3,k) = 0.   10 continue   20 continue      do 40 j = 1, nx1      do 30 i = 1, 3      cu(i,j+1,2) = cu(i,j+1,2) + 2.*cu(i,j+1,1)      cu(i,j+1,3) = cu(i,j+1,3) - cu(i,j+1,1)      cu(i,j+1,ny+1) = cu(i,j+1,ny+1) - cu(i,j+1,ny+3)      cu(i,j+1,ny+2) = cu(i,j+1,ny+2) + 2.*cu(i,j+1,ny+3)      cu(i,j+1,1) = 0.      cu(i,j+1,ny+3) = 0.   30 continue   40 continue      return      end