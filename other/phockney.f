c-----------------------------------------------------------------------      program phockney      implicit none      integer indx, indy, indx1, indy1, nx, ny, nx1, ny1, nx2, ny2      integer nxh, nyh, nxv, nyv, nx2v, ny2v, nmx, nxy, nxyh, nmxh, nxhy      integer nxhy2, nxyh2      real pi4ic      integer indnvp, mshare      integer nvp, kyp, kypmx, kblok      integer kxp2, j2blok, kyp2, k2blok, kxb2, kyb2, jkmx2, kxyb2      integer kbmin2, kxp21c      parameter(indx=5,indy=6)      parameter(nx=2**indx,ny=2**indy,indx1=indx+1,indy1=indy+1)      parameter(nx1=nx+1,ny1=ny+1,nx2=2*nx,ny2=2*ny,nxh=nx/2,nyh=ny/2)      parameter(nxv=nx+4,nyv=ny+3,nx2v=2*nxv,ny2v=2*nyv)      parameter(nmx=nx*(ny/nx)+ny*(nx/ny),nxy=nmx/(2-nx/nmx-ny/nmx))      parameter(nxyh=nxy/2,nmxh=nxh*(ny/nxh)+ny*(nxh/ny))      parameter(nxhy=nmxh/(2-nxh/nmxh-ny/nmxh))      parameter(nxhy2=2*nxhy,nxyh2=2*nxyh)      parameter(pi4i=0.5/6.28318530717959)c      parameter( indnvp =   2, mshare =   0)      parameter(nvp=2**indnvp,kyp=(ny-1)/nvp+1,kypmx=kyp+3)      parameter(kblok=1+mshare*(ny/kyp-1))      parameter(kxp2=(nx-1)/nvp+1,j2blok=1+mshare*(nx/kxp2-1))      parameter(kxb2=nx/kxp2)      parameter(kyp2=(ny2-1)/nvp+1,k2blok=1+mshare*(ny2/kyp2-1))      parameter(kyb2=ny2/kyp2)      parameter(jkmx2=kxb2*(kyb2/kxb2)+kyb2*(kxb2/kyb2))      parameter(kxyb2=jkmx2/(2-kxb2/jkmx2-kyb2/jkmx2))      parameter(kbmin2=1+(1-mshare)*(kxyb2/kxb2-1))      parameter(kxp21=kxp2+1)c      double precision ranormc      integer isign, irc, ix0, iy0, i, j, k, l, j1, k1, j2, k2      integer idproc, kstrt, ntpose, joff, koff, ks      real qm, ar, affp, anorm, we, wf      complex zt1      complex sct2      integer mixup2, link      real q, f, g, q2, fxy2, fx2, fy2, ffg      complex qt2, fxyt2, fxt2, fyt2c      dimension q(nxv,kypmx,kblok)      dimension f(nxv,kypmx,kblok), g(nxv,kypmx,kblok)      dimension q2(2*nxv,kyp2*kbmin2,k2blok), qt2(ny2,kxp2,j2blok)      dimension ffg(4,ny1,kxp21,j2blok)      dimension fx2(2*nxv,kyp2*kbmin2,k2blok), fxt2(ny2,kxp2,j2blok)      dimension fy2(2*nxv,kyp2*kbmin2,k2blok), fyt2(ny2,kxp2,j2blok)      dimension fxy2(2,2*nxv,kyp2*kbmin2,k2blok)      dimension fxyt2(2,ny2,kxp2,j2blok)      dimension link(nxv,kypmx,kblok)c      real den, h2, hxy2, hx2, hy2, ffh      dimension den(nxv,nyv)      dimension h2(nx2v,ny2v), hxy2(2,nx2v,ny2v)      dimension hx2(nx2v,ny2v), hy2(nx2v,ny2v)      dimension ffh(4,nx1,ny1)c      dimension mixup2(nxhy2), sct2(nxyh2)      real POTC3, POTC2      external POTC3, POTC2c debug      real dnx, dny, dkx, dky, at1, at2, at3      real ffc      real eps, epsmax, sum1      dimension ffc(nx2v,ny1)c end debugc ar = half-width of particle in r direction      data qm, ar /1.0,0.866667/      data ntpose /1/      affp = 1.0cc initialize for parallel processing      call ppinit(idproc,nvp)      kstrt = idproc + 1      ks = kstrt - 2c prepare fft tables      isign = 0      call PFFT2RX(q2,qt2,isign,ntpose,mixup2,sct2,indx1,indy1,kstrt,nxv     1,ny2,kxp2,kyp2,kyp2,j2blok,k2blok,nxhy2,nxyh2)      call FFT2RX(h2,isign,mixup2,sct2,indx1,indy1,nxv,ny2,nxhy2,nxyh2)c open graphics device      call GROPEN      call SETNPLT(4,irc)      call STPALIT(1)c calculate green's functions      call PFORMC2(ffg,q2,qt2,POTC3,mixup2,sct2,affp,ar,indx1,indy1,kstr     1t,nxv,ny2,kxp2,kyp2,j2blok,k2blok,kxp21,ny1,nxhy2,nxyh2)      call FORMC2(ffh,h2,POTC3,mixup2,sct2,affp,ar,indx1,indy1,nx1,ny1,n     1xv,ny2v,nxhy2,nxyh2)c     call FORMC2(ffh,h2,POTC2,mixup2,sct2,affp,ar,indx1,indy1,nx1,ny1,nc    1xv,ny2v,nxhy2,nxyh2)c verify form factors      do 50 i = 1, 4      epsmax = 0.0      do 40 l = 1, j2blok      joff = kxp2*(l + ks)      do 30 j = 1, kxp2      j1 = j + joff      do 20 k = 1, ny1      eps = abs(ffg(i,k,j,l)-ffh(i,j1,k))      if (eps.gt.epsmax) then         write (71,*) j,j1,k,ffg(i,k,j,l),ffh(i,j1,k),eps         epsmax = eps      endif   20 continue   30 continue      if ((l+ks).eq.0) then         j = kxp2 + 1         j1 = nx1         do 10 k = 1, ny1         eps = abs(ffg(i,k,j,l)-ffh(i,j1,k))         if (eps.gt.epsmax) then            write (71,*) j,j1,k,ffg(i,k,j,l),ffh(i,j1,k),eps            epsmax = eps         endif   10    continue      endif   40 continue      write (71,*) 'local ffg epsmax=', i, epsmax      call PSUM(epsmax,eps,1,1)      write (71,*) 'global ffg epsmax=', i, epsmax   50 continuecc create doubled size array      do 70 k = 1, ny2      do 60 j = 1, nx2      h2(j,k) = 0.0   60 continue   70 continuec set charge density      do 100 k = 1, ny      k2 = (k - 1)/kyp      k1 = k - kyp*k2      do 90 j = 1, nx      den(j,k) = qm*ranorm()c debugc     if ((j.eq.1).and.(k.eq.1)) thenc        den(j,k) = qmc     elsec        den(j,k) = 0.0c     endifc end debug      do 80 l = 1, kblok      if (k2.eq.(l+ks)) q(j,k1,l) = den(j,k)   80 continue      h2(j,k) = den(j,k)   90 continue  100 continue      call PZDBL2D(q,q2,nx,ny,kstrt,nxv,kyp,kypmx,kyp2,kblok,k2blok)cc transform charge density to fourier space      isign = -1      call PFFT2RX(q2,qt2,isign,ntpose,mixup2,sct2,indx1,indy1,kstrt,nxv     1,ny2,kxp2,kyp2,kyp2,j2blok,k2blok,nxhy2,nxyh2)      call FFT2RX(h2,isign,mixup2,sct2,indx1,indy1,nxv,ny2,nxhy2,nxyh2)cc calculate electric fields numerically      isign = -1      call PPOISC2(qt2,fxt2,fyt2,isign,ffg,we,nx,ny,kstrt,ny2,kxp2,j2blo     1k,ny1,kxp21)      call PSUM(we,wf,1,1)      call POISC2(h2,hx2,hy2,isign,ffh,wf,nx,ny,nx2v,ny2v,nx1,ny1)      write (71,*) 'efield fourier space energy=', we, wfc verify fourier space components      epsmax = 0.0      do 160 l = 1, j2blok      joff = kxp2*(l + ks)      do 150 j = 1, kxp2      j1 = j + joff      do 140 k = 1, ny1      zt1 = cmplx(hx2(2*j1-1,k),hx2(2*j1,k))      eps = abs(fxt2(k,j,l)-zt1)      if (eps.gt.epsmax) then         write (71,*) k,j,j1,fxt2(k,j,l),zt1,eps         epsmax = eps      endif  140 continue  150 continue  160 continue      write (71,*) 'local fxt2 epsmax=', epsmax      call PSUM(epsmax,eps,1,1)      write (71,*) 'global fxt2 epsmax=', epsmax      epsmax = 0.0      do 190 l = 1, j2blok      joff = kxp2*(l + ks)      do 180 j = 1, kxp2      j1 = j + joff      do 170 k = 1, ny1      zt1 = cmplx(hy2(2*j1-1,k),hy2(2*j1,k))      eps = abs(fyt2(k,j,l)-zt1)      if (eps.gt.epsmax) then         write (71,*) k,j,j1,fyt2(k,j,l),zt1,eps         epsmax = eps      endif  170 continue  180 continue  190 continue      write (71,*) 'local fyt2 epsmax=', epsmax      call PSUM(epsmax,eps,1,1)      write (71,*) 'global fyt2 epsmax=', epsmaxc debugc-----------------------------------------------------------------------      call PPOISC22(qt2,fxyt2,ffg,we,nx,ny,kstrt,ny2,kxp2,j2blok,ny1,kxp     121)      call PSUM(we,wf,1,1)      write (71,*) 'efield fourier space energy=', we      epsmax = 0.0      do l = 1, j2blok      joff = kxp2*(l + ks)      do j = 1, kxp2      j1 = j + joff      do k = 1, ny1      eps = abs(fxt2(k,j,l)-fxyt2(1,k,j,l))      if (eps.gt.epsmax) then         write (71,*) k,j,j1,fxt2(k,j,l),fxyt2(1,k,j,l),eps         epsmax = eps      endif      enddo      enddo      enddo      write (71,*) 'local fxyt2(1) epsmax=', epsmax      call PSUM(epsmax,eps,1,1)      write (71,*) 'global fxyt2(1) epsmax=', epsmax      epsmax = 0.0      do l = 1, j2blok      joff = kxp2*(l + ks)      do j = 1, kxp2      j1 = j + joff      do k = 1, ny1      eps = abs(fyt2(k,j,l)-fxyt2(2,k,j,l))      if (eps.gt.epsmax) then         write (71,*) k,j,j1,fyt2(k,j,l),fxyt2(2,k,j,l),eps         epsmax = eps      endif      enddo      enddo      enddo      write (71,*) 'local fxyt2(2) epsmax=', epsmax      call PSUM(epsmax,eps,1,1)      write (71,*) 'global fxyt2(2) epsmax=', epsmaxc end debugcc transform field to real space      isign = 1      call PFFT2RX(fx2,fxt2,isign,ntpose,mixup2,sct2,indx1,indy1,kstrt,n     1xv,ny2,kxp2,kyp2,kyp2,j2blok,k2blok,nxhy2,nxyh2)      call PFFT2RX(fy2,fyt2,isign,ntpose,mixup2,sct2,indx1,indy1,kstrt,n     1xv,ny2,kxp2,kyp2,kyp2,j2blok,k2blok,nxhy2,nxyh2)      call FFT2RX(hx2,isign,mixup2,sct2,indx1,indy1,nxv,ny2,nxhy2,nxyh2)      call FFT2RX(hy2,isign,mixup2,sct2,indx1,indy1,nxv,ny2,nxhy2,nxyh2)c verify real space components      epsmax = 0.0      do 230 l = 1, k2blok      koff = kyp2*(l + ks)      do 220 k = 1, kyp2      k1 = k + koff      do 210 j = 1, nx2      eps = abs(fx2(j,k,l)-hx2(j,k1))      if (eps.gt.epsmax) then         write (71,*) j,k,k1,fx2(j,k,l),hx2(j,k1),eps         epsmax = eps      endif   210 continue  220 continue  230 continue      write (71,*) 'local fx2 epsmax=', epsmax      call PSUM(epsmax,eps,1,1)      write (71,*) 'global fx2 epsmax=', epsmax      epsmax = 0.0      do 260 l = 1, k2blok      koff = kyp2*(l + ks)      do 250 k = 1, kyp2      k1 = k + koff      do 240 j = 1, nx2      eps = abs(fy2(j,k,l)-hy2(j,k1))      if (eps.gt.epsmax) then         write (71,*) j,k,k1,fy2(j,k,l),hy2(j,k1),eps         epsmax = eps      endif   240 continue  250 continue  260 continue      write (71,*) 'local fy2 epsmax=', epsmax      call PSUM(epsmax,eps,1,1)      write (71,*) 'global fy2 epsmax=', epsmaxcc copy guard cells and display      call PHAFDBL2D(f,fx2,nx,ny,kstrt,nxv,kyp,kypmx,kyp2,kblok,k2blok)      call PCONTUR(f,g,link,nvp,' EX FIELD ',999,0,nx1,ny,nxv,kypmx,kblo     1k,' ',15,irc)      if (irc.eq.1) go to 900      call PHAFDBL2D(f,fy2,nx,ny,kstrt,nxv,kyp,kypmx,kyp2,kblok,k2blok)      call PCONTUR(f,g,link,nvp,' EY FIELD ',999,0,nx1,ny,nxv,kypmx,kblo     1k,' ',15,irc)      if (irc.eq.1) go to 900cc calculate potential and density numerically      isign = 1      call PPOISC2(qt2,fxt2,fyt2,isign,ffg,we,nx,ny,kstrt,ny2,kxp2,j2blo     1k,ny1,kxp21)      call PSUM(we,wf,1,1)      call POISC2(h2,hx2,hy2,isign,ffh,wf,nx,ny,nx2v,ny2v,nx1,ny1)      write (71,*) 'potential fourier space energy=', we, wf      isign = 2      call PPOISC2(qt2,fxt2,fyt2,isign,ffg,we,nx,ny,kstrt,ny2,kxp2,j2blo     1k,ny1,kxp21)      call POISC2(h2,hx2,hy2,isign,ffh,wf,nx,ny,nx2v,ny2v,nx1,ny1)c verify fourier space components      epsmax = 0.0      do 290 l = 1, j2blok      joff = kxp2*(l + ks)      do 280 j = 1, kxp2      j1 = j + joff      do 270 k = 1, ny1      zt1 = cmplx(hx2(2*j1-1,k),hx2(2*j1,k))      eps = abs(fxt2(k,j,l)-zt1)      if (eps.gt.epsmax) then         write (71,*) k,j,j1,fxt2(k,j,l),zt1,eps         epsmax = eps      endif  270 continue  280 continue  290 continue      write (71,*) 'local pott2 epsmax=', epsmax      call PSUM(epsmax,eps,1,1)      write (71,*) 'global pott2 epsmax=', epsmax      epsmax = 0.0      do 320 l = 1, j2blok      joff = kxp2*(l + ks)      do 310 j = 1, kxp2      j1 = j + joff      do 300 k = 1, ny1      zt1 = cmplx(hy2(2*j1-1,k),hy2(2*j1,k))      eps = abs(fyt2(k,j,l)-zt1)      if (eps.gt.epsmax) then         write (71,*) k,j,j1,fyt2(k,j,l),zt1,eps         epsmax = eps      endif  300 continue  310 continue  320 continue      write (71,*) 'local dent2 epsmax=', epsmax      call PSUM(epsmax,eps,1,1)      write (71,*) 'global dent2 epsmax=', epsmaxc transform field to real space      isign = 1      call PFFT2RX(fx2,fxt2,isign,ntpose,mixup2,sct2,indx1,indy1,kstrt,n     1xv,ny2,kxp2,kyp2,kyp2,j2blok,k2blok,nxhy2,nxyh2)      call PFFT2RX(fy2,fyt2,isign,ntpose,mixup2,sct2,indx1,indy1,kstrt,n     1xv,ny2,kxp2,kyp2,kyp2,j2blok,k2blok,nxhy2,nxyh2)      call FFT2RX(hx2,isign,mixup2,sct2,indx1,indy1,nxv,ny2,nxhy2,nxyh2)      call FFT2RX(hy2,isign,mixup2,sct2,indx1,indy1,nxv,ny2,nxhy2,nxyh2)c verify real space components      epsmax = 0.0      do 350 l = 1, k2blok      koff = kyp2*(l + ks)      do 340 k = 1, kyp2      k1 = k + koff      do 330 j = 1, nx2      eps = abs(fx2(j,k,l)-hx2(j,k1))      if (eps.gt.epsmax) then         write (71,*) j,k,k1,fx2(j,k,l),hx2(j,k1),eps         epsmax = eps      endif   330 continue  340 continue  350 continue      write (71,*) 'local pot2 epsmax=', epsmax      call PSUM(epsmax,eps,1,1)      write (71,*) 'global pot2 epsmax=', epsmax      epsmax = 0.0      do 380 l = 1, k2blok      koff = kyp2*(l + ks)      do 370 k = 1, kyp2      k1 = k + koff      do 360 j = 1, nx2      eps = abs(fy2(j,k,l)-hy2(j,k1))      if (eps.gt.epsmax) then         write (71,*) j,k,k1,fy2(j,k,l),hy2(j,k1),eps         epsmax = eps      endif   360 continue  370 continue  380 continue      write (71,*) 'local den2 epsmax=', epsmax      call PSUM(epsmax,eps,1,1)      write (71,*) 'global den2 epsmax=', epsmaxc copy guard cells and display      call PHAFDBL2D(f,fx2,nx,ny,kstrt,nxv,kyp,kypmx,kyp2,kblok,k2blok)      call PCONTUR(f,g,link,nvp,' POTENTIAL',999,0,nx1,ny,nxv,kypmx,kblo     1k,' ',15,irc)      if (irc.eq.1) go to 900      call PHAFDBL2D(f,fy2,nx,ny,kstrt,nxv,kyp,kypmx,kyp2,kblok,k2blok)      call PCONTUR(f,g,link,nvp,' DENSITY  ',999,0,nx1,ny,nxv,kypmx,kblo     1k,' ',15,irc)      if (irc.eq.1) go to 900c close graphics device  900 call GRCLOSE      call ppexit      stop      endc-----------------------------------------------------------------------      subroutine ppinit(idproc,nvp)c this subroutine initializes parallel processingc input: nvp, output: idprocc idproc = processor idc nvp = number of real or virtual processors requested      implicit none      integer idproc, nvpc get definition of MPI constants      include 'mpif.h'c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=8)c nproc = number of real or virtual processors obtainedc lgrp = current communicatorc mreal = default datatype for realsc mint = default datatype for integersc mcplx = default datatype for complex type      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer ierror, ndprec      save /PPARMS/c ndprec = (0,1) = (no,yes) use (normal,autodouble) precision      data ndprec /1/c this segment is used for shared memory computersc     nproc = nvpc     idproc = 0c this segment is used for mpi computers      if (MPI_STATUS_SIZE.gt.lstat) then         write (2,*) ' status size too small, actual/required = ', lstat     1, MPI_STATUS_SIZE         stop      endifc initialize the MPI execution environment      call MPI_INIT(ierror)      if (ierror.ne.0) stop      lgrp = MPI_COMM_WORLDc determine the rank of the calling process in the communicator      call MPI_COMM_RANK(lgrp,idproc,ierror)c determine the size of the group associated with a communicator      call MPI_COMM_SIZE(lgrp,nproc,ierror)c set default datatypes         mint = MPI_INTEGERc single precision      if (ndprec.eq.0) then         mreal = MPI_REAL         mcplx = MPI_COMPLEXc double precision      else         mreal = MPI_DOUBLE_PRECISION         mcplx = MPI_DOUBLE_COMPLEX      endifc requested number of processors not obtained      if (nproc.ne.nvp) then         write (2,*) ' processor number error: nvp, nproc=', nvp, nproc         call ppexit         stop      endif      return      endc-----------------------------------------------------------------------      subroutine ppexitc this subroutine terminates parallel processing      implicit nonec common block for parallel processing      integer nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc lgrp = current communicator      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworld      integer ierrorc synchronize processes      call MPI_BARRIER(lgrp,ierror)c terminate MPI execution environment      call MPI_FINALIZE(ierror)      return      endc-----------------------------------------------------------------------      subroutine PSUM(f,g,nxp,nblok)c this subroutine performs a parallel sum of a vector, that is:c f(j,k) = sum over k of f(j,k)c assumes the number of processors nproc is a power of two.c the algorithm performs partial sums in binary pairs, as follows:c first, adjacent processors exchange vectors and sum them.  next,c processors separated by 2 exchange the new vectors and sum them, thenc those separated by 4, up to processors separated by nproc/2.  at thec end, all processors contain the same summation.c f = input and output datac g = scratch arrayc nxp = number of data values in vectorc nblok = number of data blocksc written by viktor k. decyk, ucla      implicit none      real f, g      integer nxp, nblok      dimension f(nxp,nblok), g(nxp,nblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=8)c nproc = number of real or virtual processors obtainedc lgrp = current communicatorc mreal = default datatype for reals      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer istatus      integer idproc, ierr, kstrt, ks, l, kxs, k, kb, lb, msid, j      dimension istatus(lstat)c find processor idc this line is used for shared memory computersc     idproc = 0c this line is used for mpi computers      call MPI_COMM_RANK(lgrp,idproc,ierr)      kstrt = idproc + 1      if (kstrt.gt.nproc) return      ks = kstrt - 2      l = 1      kxs = 1c main iteration loop   10 if (kxs.ge.nproc) go to 60c shift data      do 30 k = 1, nblok      kb = k + ks      lb = kb/kxs      kb = kb + 1      lb = lb - 2*(lb/2)c this loop is used for shared memory computersc     do 20 j = 1, nxpc     if (lb.eq.0) thenc        g(j,k) = f(j,kb+kxs)c     elsec        g(j,k) = f(j,kb-kxs)c     endifc  20 continuec this segment is used for mpi computers      if (lb.eq.0) then         call MPI_IRECV(g,nxp,mreal,kb+kxs-1,l+nxp,lgrp,msid,ierr)         call MPI_SEND(f,nxp,mreal,kb+kxs-1,l+nxp,lgrp,ierr)      else         call MPI_IRECV(g,nxp,mreal,kb-kxs-1,l+nxp,lgrp,msid,ierr)         call MPI_SEND(f,nxp,mreal,kb-kxs-1,l+nxp,lgrp,ierr)      endif      call MPI_WAIT(msid,istatus,ierr)   30 continuec perform sum      do 50 k = 1, nblok      do 40 j = 1, nxp      f(j,k) = f(j,k) + g(j,k)   40 continue   50 continue      l = l + 1      kxs = kxs + kxs      go to 10   60 return      endc-----------------------------------------------------------------------      subroutine HARTBEAT(msg,n)c participating nodes send a message msg to non-participating nodesc msg = message to sendc n = length of messagec input: msg, nc output: msg      implicit none      integer n      double precision msg      dimension msg(n)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=10)c nproc = number of real or virtual processors obtainedc lgrp = current communicatorc mdouble = default double precision typec lworld = MPI_COMM_WORLD communicator      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer istatus, nvp, idproc, ierror      dimension istatus(lstat)c determine the size of the group associated with a communicator      call MPI_COMM_SIZE(lworld,nvp,ierror)c quit if communicators are the same size      if (nvp.eq.nproc) returnc determine the rank of the calling process in the communicator      call MPI_COMM_RANK(lworld,idproc,ierror)c send message      if (idproc.eq.0) then         call MPI_RECV(msg,n,mdouble,1,999,lworld,istatus,ierror)      elseif (idproc.eq.1) then         call MPI_SEND(msg,n,mdouble,0,999,lworld,ierror)      endifc broadcast message to non-participating nodes      if (nvp.gt.(2*nproc)) then         call MPI_BCAST(msg,n,mdouble,0,lgrp,ierror)      endif      return      endc-----------------------------------------------------------------------      subroutine PBICAST(f,nxp)c this subroutine broadcasts integer data fc f = data to be broadcastc nxp = size of data fc input: f, nxpc output: f      implicit none      integer nxp      integer f      dimension f(nxp)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=10)c nproc = number of real or virtual processors obtainedc lgrp = current communicatorc mint = default datatype for integersc lworld = MPI_COMM_WORLD communicator      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer istatus, nvp, idproc, np, ioff, i, id, ierr      dimension istatus(lstat)c this segment is used for mpi computersc determine the rank of the calling process in the communicator      call MPI_COMM_RANK(lworld,idproc,ierr)c determine the size of the group associated with a communicator      call MPI_COMM_SIZE(lworld,nvp,ierr)c node 0 sends messages to other nodes      if (idproc.eq.0) thenc no special diagnostic node         if (nvp.eq.nproc) then            np = nvp            ioff = 1c special diagnostic node present         else            np = nvp - nproc            ioff = 0         endifc first send data to remaining nodes         do 10 i = 2, np            id = i - ioff            call MPI_SEND(f,nxp,mint,id,96,lworld,ierr)   10    continuec then send data to node 0         if (ioff.eq.0) then            id = 1            call MPI_SEND(f,nxp,mint,id,96,lworld,ierr)         endifc other nodes receive data from node 0      elseif (idproc.le.(nproc+1)) then         call MPI_RECV(f,nxp,mint,0,96,lworld,istatus,ierr)      endif      return      endc-----------------------------------------------------------------------      subroutine PMAX(f,g,nxp,nblok)c this subroutine finds parallel maximum for each element of a vectorc that is, f(j,k) = maximum as a function of k of f(j,k)c assumes the number of processors nproc is a power of two.c the algorithm performs partial sums in binary pairs, as follows:c first, adjacent processors exchange vectors and sum them.  next,c processors separated by 2 exchange the new vectors and sum them, thenc those separated by 4, up to processors separated by nproc/2.  at thec end, all processors contain the same summation.c f = input and output datac g = scratch arrayc nxp = number of data values in vectorc nblok = number of data blocksc written by viktor k. decyk, ucla      implicit none      real f, g      integer nxp, nblok      dimension f(nxp,nblok), g(nxp,nblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=10)c nproc = number of real or virtual processors obtainedc lgrp = current communicatorc mreal = default datatype for reals      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer istatus, ierr, msid      integer idproc, kstrt, ks, l, kxs, k, kb, lb, j      dimension istatus(lstat)c find processor idc this line is used for shared memory computersc     idproc = 0c this line is used for mpi computers      call MPI_COMM_RANK(lgrp,idproc,ierr)      kstrt = idproc + 1      if (kstrt.gt.nproc) return      ks = kstrt - 2      l = 1      kxs = 1c main iteration loop   10 if (kxs.ge.nproc) go to 60c shift data      do 30 k = 1, nblok      kb = k + ks      lb = kb/kxs      kb = kb + 1      lb = lb - 2*(lb/2)c this loop is used for shared memory computersc     do 20 j = 1, nxpc     if (lb.eq.0) thenc        g(j,k) = f(j,kb+kxs)c     elsec        g(j,k) = f(j,kb-kxs)c     endifc  20 continuec this segment is used for mpi computers      if (lb.eq.0) then         call MPI_IRECV(g,nxp,mreal,kb+kxs-1,l+nxp,lgrp,msid,ierr)         call MPI_SEND(f,nxp,mreal,kb+kxs-1,l+nxp,lgrp,ierr)      else         call MPI_IRECV(g,nxp,mreal,kb-kxs-1,l+nxp,lgrp,msid,ierr)         call MPI_SEND(f,nxp,mreal,kb-kxs-1,l+nxp,lgrp,ierr)      endif      call MPI_WAIT(msid,istatus,ierr)   30 continuec find maximum      do 50 k = 1, nblok      do 40 j = 1, nxp      f(j,k) = amax1(f(j,k),g(j,k))   40 continue   50 continue      l = l + 1      kxs = kxs + kxs      go to 10   60 return      endc-----------------------------------------------------------------------      subroutine PFFT2RX(f,g,isign,ntpose,mixup,sct,indx,indy,kstrt,nxvh     1,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)c this subroutine performs a two dimensional real to complex fastc fourier transform and its inverse, using complex arithmetic,c for data which is distributed in blocksc for isign = 0, input: isign, indx, indy, kstrt, nxhyd, nxyhdc output: mixup, sctc for isign = (-1,1), input: all, output: f, gc for isign = -1, approximate flop count: N*(5*log2(N) + 10)/nvpc for isign = 1,  approximate flop count: N*(5*log2(N) + 8)/nvpc where N = (nx/2)*ny, and nvp = number of procsc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc ntpose = (0,1) = (no,yes) input, output data are transposedc if isign = 0, the fft tables are preparedc if isign = -1, an inverse fourier transform is performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(n,m,l) = (1/nx*ny)*sum(f(j,k,i)*c       exp(-sqrt(-1)*2pi*n*j/nx)*exp(-sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, f is the input and g is the outputc g(m,n,l) = (1/nx*ny)*sum(f(j,k,i)*c       exp(-sqrt(-1)*2pi*nn*j/nx)*exp(-sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c if isign = 1, a forward fourier transform is performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(j,k,i) = sum(f(n,m,l)*exp(sqrt(-1)*2pi*n*j/nx)*c       exp(sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, g is the input and f is the outputc f(j,k,i) = sum(g(m,n,l)*exp(sqrt(-1)*2pi*nn*j/nx)*c       exp(sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c kstrt = starting data block numberc nxvh/nyv = first dimension of f/gc kypd = second dimension of fc kxp/kyp = number of data values per block in x/yc jblok/kblok = number of data blocks in x/yc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxhyd = maximum of (nx/2,ny)c nxyhd = one half of maximum of (nx,ny)c the real data is stored in a complex array of length nx/2, nyc with the odd/even x points stored in the real/imaginary parts.c in complex notation, fourier coefficients are stored as follows:c if ntpose = 0,c f(j,k,i) = mode j-1,kk-1, where kk = k + kyp*(i - 1)c 1 <= j <= nx/2 and 1 <= kk <= ny, except forc f(1,k,i) = mode nx/2,kk-1, where ny/2+2 <= kk <= ny, andc imaginary part of f(1,1,1) = real part of mode nx/2,0 andc imaginary part of f(1,1,(ny/2)/kyp+1) = real part of mode nx/2,ny/2c if ntpose = 1,c g(k,j,i) = mode jj-1,k-1, where jj = j + kxp*(i - 1)c 1 <= jj <= nx/2 and 1 <= k <= ny, except forc g(k,1,1) = mode nx/2,k-1, where ny/2+2 <= k <= ny, andc imaginary part of g(1,1,1) = real part of mode nx/2,0 andc imaginary part of g(ny/2+1,1,1) = real part of mode nx/2,ny/2c written by viktor k. decyk, uclac parallel, RISC optimized version      implicit none      integer isign, ntpose, mixup, indx, indy, kstrt, nxvh      integer nyv, kxp, kyp, kypd, jblok, kblok, nxhyd, nxyhd      complex f, g, sct      dimension f(nxvh,kypd,kblok), g(nyv,kxp,jblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, nxh, nxhh, nxh2, ny, nyh, ny2, nxy      integer nxhy, ks, j, k, lb, ll, jb, it, nxyh, nrx, nry, l, i, m      integer ns, ns2, km, kmr, k1, k2, j1, j2      real dnxy, arg, ani      complex s, t, t1      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nxh2 = nxh + 2      ny = 2**indy      nyh = ny/2      ny2 = ny + 2      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      if (isign) 50, 10, 300c prepare fft tablesc bit-reverse index table: mixup(j) = 1 + reversed bits of (j - 1)   10 do 30 j = 1, nxhy      lb = j - 1      ll = 0      do 20 k = 1, indx1y      jb = lb/2      it = lb - 2*jb      lb = jb      ll = 2*ll + it   20 continue      mixup(j) = ll + 1   30 continuec sine/cosine table for the angles 2*n*pi/nxy      nxyh = nxy/2      dnxy = 6.28318530717959/float(nxy)      do 40 j = 1, nxyh      arg = dnxy*float(j - 1)      sct(j) = cmplx(cos(arg),-sin(arg))   40 continue      returnc inverse fourier transform   50 if (kstrt.gt.ny) go to 180      nrx = nxhy/nxh      do 80 l = 1, kblokc bit-reverse array elements in x      do 70 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 70      do 60 k = 1, kyp      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = t   60 continue   70 continue   80 continuec first transform in x      nrx = nxy/nxh      do 130 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 120 l = 1, kblok      do 110 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 100 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 90 i = 1, kyp      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t   90 continue  100 continue  110 continue  120 continue  130 continuec unscramble coefficients and normalize      kmr = nxy/nx      ani = 1./float(2*nx*ny)      do 170 l = 1, kblok      do 150 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),-real(sct(1+kmr*(j-1))))      do 140 k = 1, kyp      t = conjg(f(nxh2-j,k,l))      s = f(j,k,l) + t      t = (f(j,k,l) - t)*t1      f(j,k,l) = ani*(s + t)      f(nxh2-j,k,l) = ani*conjg(s - t)  140 continue  150 continue      do 160 k = 1, kyp      f(nxhh+1,k,l) = 2.*ani*conjg(f(nxhh+1,k,l))      f(1,k,l) = 2.*ani*cmplx(real(f(1,k,l)) + aimag(f(1,k,l)),real(f(1,     1k,l)) - aimag(f(1,k,l)))  160 continue  170 continuec transpose f array to g  180 call PTPOSEX(f,g,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kypd,jblok,kblo     1k)      if (kstrt.gt.nxh) go to 290      nry = nxhy/ny      do 210 l = 1, jblokc bit-reverse array elements in y      do 200 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 200      do 190 j = 1, kxp      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = t  190 continue  200 continue  210 continuec then transform in y      nry = nxy/ny      do 260 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 250 l = 1, jblok      do 240 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 230 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 220 i = 1, kxp      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t  220 continue  230 continue  240 continue  250 continue  260 continuec unscramble modes kx = 0, nx/2      do 280 l = 1, jblok      if ((l+ks).gt.0) go to 280      do 270 k = 2, nyh      s = g(ny2-k,1,l)      g(ny2-k,1,l) = .5*cmplx(aimag(g(k,1,l) + s),real(g(k,1,l) - s))      g(k,1,l) = .5*cmplx(real(g(k,1,l) + s),aimag(g(k,1,l) - s))  270 continue  280 continuec transpose g array to f  290 if (ntpose.eq.0) call PTPOSEX(g,f,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,ky     1pd,kxp,kblok,jblok)      returnc forward fourier transformc transpose f array to g  300 if (ntpose.eq.0) call PTPOSEX(f,g,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kx     1p,kypd,jblok,kblok)      if (kstrt.gt.nxh) go to 410      nry = nxhy/ny      do 350 l = 1, jblokc scramble modes kx = 0, nx/2      if ((l+ks).gt.0) go to 320      do 310 k = 2, nyh      s = cmplx(aimag(g(ny2-k,1,l)),real(g(ny2-k,1,l)))      g(ny2-k,1,l) = conjg(g(k,1,l) - s)      g(k,1,l) = g(k,1,l) + s  310 continuec bit-reverse array elements in y  320 do 340 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 340      do 330 j = 1, kxp      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = t  330 continue  340 continue  350 continuec first transform in y      nry = nxy/ny      do 400 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 390 l = 1, jblok      do 380 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 370 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 360 i = 1, kxp      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t  360 continue  370 continue  380 continue  390 continue  400 continuec transpose g array to f  410 call PTPOSEX(g,f,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kxp,kblok,jblo     1k)      if (kstrt.gt.ny) return      nrx = nxhy/nxh      kmr = nxy/nx      do 470 l = 1, kblokc scramble coefficients      do 430 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),real(sct(1+kmr*(j-1))))      do 420 k = 1, kyp      t = conjg(f(nxh2-j,k,l))      s = f(j,k,l) + t      t = (f(j,k,l) - t)*t1      f(j,k,l) = s + t      f(nxh2-j,k,l) = conjg(s - t)  420 continue  430 continue      do 440 k = 1, kyp      f(nxhh+1,k,l) = 2.*conjg(f(nxhh+1,k,l))      f(1,k,l) = cmplx(real(f(1,k,l)) + aimag(f(1,k,l)),real(f(1,k,l)) -     1 aimag(f(1,k,l)))  440 continuec bit-reverse array elements in x      do 460 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 460      do 450 k = 1, kyp      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = t  450 continue  460 continue  470 continuec then transform in x      nrx = nxy/nxh      do 520 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 510 l = 1, kblok      do 500 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 490 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 480 i = 1, kyp      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t  480 continue  490 continue  500 continue  510 continue  520 continue      return      endc-----------------------------------------------------------------------      subroutine PTPOSEX(f,g,nx,ny,kstrt,nxv,nyv,kxp,kyp,kxpd,kypd,jblok     1,kblok)c this subroutine performs a transpose of a matrix f, distributed in y,c to a matrix g, distributed in x, that is,c g(k+kyp*(m-1),j,l) = f(j+kxp*(l-1),k,m), wherec 1 <= j <= kxp, 1 <= k <= kyp, 1 <= l <= nx/kxp, 1 <= m <= ny/kypc and where indices l and m can be distributed across processors.c this subroutine sends and receives multiple asynchronous messages.c f = complex input arrayc g = complex output arrayc nx/ny = number of points in x/yc kstrt = starting data block numberc nxv/nyv = first dimension of f/gc kxp/kyp = number of data values per block in x/yc kypd/kxpd = second dimension of f/gc jblok/kblok = number of data blocks in x/yc optimized version      implicit none      integer nx, ny, kstrt, nxv, nyv, kxp, kyp      integer kxpd, kypd, jblok, kblok      complex f, g      dimension f(nxv*kypd*kblok), g(nyv*kxpd*jblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=8)c lgrp = current communicatorc mcplx = default datatype for complex      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer ks, kxb, kyb, l, i, joff, koff, k, j      integer jkblok, kxym, mtr, ntr, mntr, msid      integer ir0, is0, ii, ir, is, ioff, ierr, istatus      dimension istatus(lstat)      ks = kstrt - 2      kxb = nx/kxp      kyb = ny/kypc this segment is used for shared memory computersc     if (kstrt.gt.nx) returnc     do 40 l = 1, jblokc     joff = kxp*(l + ks)c     do 30 i = 1, kybc     koff = kyp*(i - 1)c     do 20 k = 1, kypc     do 10 j = 1, kxpc     g(k+koff+nyv*(j-1+kxpd*(l-1))) = f(j+joff+nxv*(k-1+kypd*(i-1)))c  10 continuec  20 continuec  30 continuec  40 continuec this segment is used for mpi computers      jkblok = max0(jblok,kblok)      kxym = min0(kxb,kyb)      mtr = kyb/kxym      ntr = kxb/kxym      mntr = max0(mtr,ntr)c transpose local data      do 50 l = 1, jkblok      ioff = kxb*(l - 1) - 1      koff = kypd*(l - 1) - 1      do 40 i = 1, kxym      is0 = iand(kxym-1,ieor(l+ks,i-1)) + 1      do 30 ii = 1, ntr      if (kstrt.le.ny) then         is = is0 + kxym*(ii - 1)         joff = kxp*(is - 1)         is = kyp*(is + ioff) - 1         do 20 k = 1, kyp         do 10 j = 1, kxp         g(j+kxp*(k+is)) = f(j+joff+nxv*(k+koff))   10    continue   20    continue      endif   30 continue   40 continue   50 continuec exchange data      do 80 l = 1, jkblok      ioff = kxb*(l - 1) - 1      koff = kyb*(l - 1) - 1      do 70 i = 1, kxym      ir0 = iand(kxym-1,ieor(l+ks,i-1)) + 1      is0 = ir0      do 60 ii = 1, mntrc post receive      if ((kstrt.le.nx).and.(ii.le.mtr)) then         ir = ir0 + kxym*(ii - 1)         call MPI_IRECV(f(1+kxp*kyp*(ir+koff)),kxp*kyp,mcplx,ir-1,ir+kxy     1m+1,lgrp,msid,ierr)      endifc send data      if ((kstrt.le.ny).and.(ii.le.ntr)) then         is = is0 + kxym*(ii - 1)         call MPI_SEND(g(1+kxp*kyp*(is+ioff)),kxp*kyp,mcplx,is-1,l+ks+kx     1ym+2,lgrp,ierr)      endifc receive data      if ((kstrt.le.nx).and.(ii.le.mtr)) then         call MPI_WAIT(msid,istatus,ierr)      endif   60 continue   70 continue   80 continuec transpose local data      do 130 l = 1, jkblok      ioff = kyb*(l - 1) - 1      joff = kxpd*(l - 1) - 1      do 120 i = 1, kxym      ir0 = iand(kxym-1,ieor(l+ks,i-1)) + 1      do 110 ii = 1, mtr      if (kstrt.le.nx) then         ir = ir0 + kxym*(ii - 1)         koff = kyp*(ir - 1)         ir = kyp*(ir + ioff) - 1         do 100 k = 1, kyp         do 90 j = 1, kxp         g(k+koff+nyv*(j+joff)) = f(j+kxp*(k+ir))   90    continue  100    continue      endif  110 continue  120 continue  130 continue      return      endc-----------------------------------------------------------------------      subroutine PHAFDBL2D(q,q2,nx,ny,kstrt,nxv,kyp,kypd,kyp2,kblok,k2bl     1ok)c this subroutine copies data from a double array to regular arrayc with guard cells for scalar field and linear interpolationc for distributed datac q2 array may be modifiedc nx/ny = system length in x/y directionc kstrt = starting data block numberc nxv = second dimension of output array fxy, must be >= nxc kyp = number of data values per block in yc kypd = third dimension of output array fxy, must be >= kyp+1c kyp2 = third dimension of output array fxy2, must be >= kyp2c kblok = number of data blocks in yc k2blok = number of data blocks in y for doubled data      implicit none      real q, q2      integer nx, ny, kstrt, nxv, kyp, kypd, kyp2, kblok, k2blok      dimension q(nxv,kypd,kblok), q2(2*nxv,kyp2,k2blok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=8)c lgrp = current communicatorc mreal = default datatype for reals      common /pparms/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer istatus, msid, nsid, ierr      integer j, k, l, nx1, ny1, kyb, kyb2, kyp1, ks, joff, koff, moff      integer  kk, ll, lm      dimension istatus(lstat)      nx1 = nx + 1      ny1 = ny + 1      kyb = ny/kyp      kyb2 = (ny + ny)/kyp2      kyp1 = kyp + 1      ks = kstrt - 2      moff = kypd + kyb      do 90 l = 1, k2blok      koff = kyp2*(l + ks)      lm = koff/kyp + 1      koff = kyp*(l + ks)      ll = koff/kyp2 + 1      koff = koff - kyp2*(ll - 1)c special case for one processor      if (kyb2.eq.1) then         do 20 k = 1, ny1         do 10 j = 1, nx1         q(j,k,l) = q2(j,k,l)   10    continue   20    continue         go to 90      endifc this segment is used for shared memory computersc     if (ll.le.kyb) thenc        if ((koff.eq.0).and.(kyp.lt.kyp2)) thenc           do 40 k = 1, kyp1c           do 30 j = 1, nx1c           q(j,k,l) = q2(j,k,ll)c  30       continuec  40       continuec        elsec           do 60 k = 1, kypc           do 50 j = 1, nx1c           q(j,k,l) = q2(j,k+koff,ll)c  50       continuec  60       continuec           do 70 j = 1, nx1c           q(j,kyp+1,l) = q2(j,1,ll+1)c  70       continuec        endifc     endifc this segment is used for mpi computers      if (ll.le.kyb) then         if ((koff.eq.0).and.(kyp.lt.kyp2)) then            call MPI_IRECV(q(1,1,l),nxv*kyp1,mreal,ll-1,moff+4,lgrp,msid     1,ierr)         else            call MPI_IRECV(q(1,1,l),nxv*kyp,mreal,ll-1,moff+4,lgrp,msid,     1ierr)            call MPI_IRECV(q(1,kyp+1,l),nxv,mreal,ll,moff+4,lgrp,nsid,ie     1rr)         endif      endifc pack data and send it      if (lm.le.kyb) then         if (kyp.lt.kyp2) then            do 40 k = 2, kyp1            kk = (k - 1)/2 + 1            joff = nxv*(k - 2*kk + 1)            do 30 j = 1, nxv            q2(j+joff,kk,l) = q2(j,k,l)   30       continue   40       continue            call MPI_SEND(q2(1,1,l),nxv*kyp1,mreal,lm-1,moff+4,lgrp,ierr     1)            do 60 k = 2, kyp            kk = (k - 1)/2 + 1            joff = nxv*(k - 2*kk + 1)            do 50 j = 1, nxv            q2(j+joff,kk+kyp,l) = q2(j,k+kyp,l)   50       continue   60       continue            call MPI_SEND(q2(1,kyp+1,l),nxv*kyp,mreal,lm,moff+4,lgrp,ier     1r)         else            do 80 k = 2, kyp            kk = (k - 1)/2 + 1            joff = nxv*(k - 2*kk + 1)            do 70 j = 1, nxv            q2(j+joff,kk,l) = q2(j,k,l)   70       continue   80       continue            call MPI_SEND(q2(1,1,l),nxv*kyp,mreal,lm-1,moff+4,lgrp,ierr)         endif         if (lm.gt.1) then            call MPI_SEND(q2(1,1,l),nxv,mreal,lm-2,moff+4,lgrp,ierr)         endif      else if (lm.eq.(kyb+1)) then         call MPI_SEND(q2(1,1,l),nxv,mreal,lm-2,moff+4,lgrp,ierr)      endifc wait for data      if (ll.le.kyb) then         if ((koff.eq.0).and.(kyp.lt.kyp2)) then            call MPI_WAIT(msid,istatus,ierr)         else            call MPI_WAIT(msid,istatus,ierr)            call MPI_WAIT(nsid,istatus,ierr)         endif      endif   90 continue      return      endc-----------------------------------------------------------------------c 2d parallel PIC library for solving field equations with open (vacuum)c boundary conditionsc written by viktor k. decyk, uclac copyright 1991, regents of the university of californiac update: november 27, 2004c-----------------------------------------------------------------------      subroutine PFORMC2(ffg,f,ft,fpotc,mixup2,sct2,affp,ar,indx1,indy1,     1kstrt,nxv,ny2d,kxp2,kyp2,j2blok,k2blok,kxp2d,ny1d,nxhy2,nxyh2)c this subroutine calculates the form factor array ffg needed by fieldc solvers with open (vacuum) boundary conditions using hockney's method.c input: fpotc,mixup2,sct2,affp,ar,indx1,indy1,kstrt,nxv,ny2d,kxp2,kyp2,c        j2blok,k2blok,kxp2d,ny1d,nxhy2,nxyh2)c output: ffg, fc the four green's functions calculated are:c g(kx,ky) = affp*inverse FFT of potrc s(kx,ky) = inverse FFT of the density of a finite-sized particlec gx(kx,ky) = affp*s(kx,ky)*inverse FFT of (x/r)*Erc gy(kx,ky) = affp*s(kx,ky)*inverse FFT of (y/r)*Erc where the fields due to the finite-sized particles are given by fpotcc input: mixup2,sct2,affp,ar,indx1,indy1,nx1d,ny1d,nx2v,ny2v,nxhy2,nxyh2c output: ffg, fc ffg(1,k,j,l) = potential green's function gc ffg(2,k,j,l) = finite-size particle shape factor sc ffg(3,k,j,l) = x component of electric field green's function gxc ffg(4,k,j,l) = y component of electric field green's function gyc on processor 0, ffg(i,k,kxp2+1,l) = ffg(i,k,NX+1,l)c on other processors, ffg(i,k,kxp2+1,l) = ffg(i,k,1,l) on processor 0c f, ft = scratch arrays used by FFTc fpotc = a function which returns various radially symmetric fieldsc mixup2/sct2 = bit-reverse and sine-cosine table used by FFTc affp = normalization constant = nx*ny/np, where np=number of particlesc ar = half-width of particle in r directionc indx1/indy1 = exponent which determines FFT length in x/y direction,c where 2*nx=2**indx1, 2*ny=2**indy1c kstrt = starting data block numberc nxv = half of first dimension of field arrays, must be >= nxc ny2d = second dimension of field arrays, must be >= 2*nyc kxp2/kyp2 = number of data values per block in x/yc j2blok/k2blok = number of data blocks in x/yc kxp2d = third dimension of ffg arrays, must be >= nx+1c ny1d = second dimension of field arrays, must be >= ny+1c nxhy2 = maximum of (nx,2*ny)c nxyh2 = maximum of (nx,ny)      implicit none      real ffg, f      complex ft      integer mixup2      complex sct2      real affp, ar      integer indx1, indy1, kstrt, kxp2d, ny1d, nxv, ny2d, kxp2, kyp2      integer j2blok, k2blok, nxhy2, nxyh2      dimension ffg(4,ny1d,kxp2d,j2blok)      dimension f(2*nxv,kyp2,k2blok), ft(ny2d,kxp2,j2blok)      dimension mixup2(nxhy2), sct2(nxyh2)      real fpotc      external fpotcc local data      integer ntpose, nx, ny, ny1, nx2, ny2, isign, j, k, l, j1, k1, ks      integer joff, koff, ifun      real an, ari, at1, x, y, r      real POTC2      external POTC2      data ntpose /1/      nx2 = 2**(indx1)      ny2 = 2**(indy1)      nx = nx2/2      ny = ny2/2      ny1 = ny + 1      ks = kstrt - 2      ari = 0.0      if (ar.gt.0.) ari = 1.0/ar      an = float(nx2*ny2)c calculate potential green's function      ifun = 1      if (kstrt.gt.ny2) go to 40      do 30 l = 1, k2blok      koff = kyp2*(l + ks) - 1      do 20 k = 1, kyp2      k1 = k + koff      if (k1.gt.ny) k1 = k1 - ny2      at1 = float(k1)**2      do 10 j = 1, nx2      j1 = j - 1      if (j1.gt.nx) j1 = j1 - nx2      r = sqrt(at1 + float(j1)**2)      f(j,k,l) = fpotc(r,affp,ari,1)   10 continue   20 continue   30 continue      isign = -1      call PFFT2RX(f,ft,isign,ntpose,mixup2,sct2,indx1,indy1,kstrt,nxv,n     1y2d,kxp2,kyp2,kyp2,j2blok,k2blok,nxhy2,nxyh2)   40 if (kstrt.gt.nx) go to 100      do 90 l = 1, j2blok      joff = kxp2*(l + ks) - 1      do 60 j = 1, kxp2      do 50 k = 1, ny1      ffg(ifun,k,j,l) = an*real(ft(k,j,l))   50 continue   60 continue      if ((l+ks).eq.0) then         do 70 k = 2, ny         k1 = ny2 + 2 - k         ffg(ifun,k,kxp2+1,l) = an*real(ft(k1,1,l))   70    continue         ffg(ifun,1,kxp2+1,l) = an*aimag(ft(1,1,l))         ffg(ifun,ny1,kxp2+1,l) = an*aimag(ft(ny1,1,l))      else         do 80 k = 1, ny1         ffg(ifun,k,kxp2+1,l) = 0.0   80    continue      endif   90 continuec calculate particle smoothing function  100 ifun = ifun + 1      if (kstrt.gt.ny2) go to 140      do 130 l = 1, k2blok      koff = kyp2*(l + ks) - 1      do 120 k = 1, kyp2      k1 = k + koff      if (k1.gt.ny) k1 = k1 - ny2      at1 = float(k1)**2      do 110 j = 1, nx2      j1 = j - 1      if (j1.gt.nx) j1 = j1 - nx2      r = sqrt(at1 + float(j1)**2)      f(j,k,l) = POTC2(r,affp,ari,2)  110 continue  120 continue  130 continue      isign = -1      call PFFT2RX(f,ft,isign,ntpose,mixup2,sct2,indx1,indy1,kstrt,nxv,n     1y2d,kxp2,kyp2,kyp2,j2blok,k2blok,nxhy2,nxyh2)  140 if (kstrt.gt.nx) go to 200      do 190 l = 1, j2blok      joff = kxp2*(l + ks) - 1      do 160 j = 1, kxp2      do 150 k = 1, ny1      ffg(ifun,k,j,l) = an*real(ft(k,j,l))  150 continue  160 continue      if ((l+ks).eq.0) then         do 170 k = 2, ny         k1 = ny2 + 2 - k         ffg(ifun,k,kxp2+1,l) = an*real(ft(k1,1,l))  170    continue         ffg(ifun,1,kxp2+1,l) = an*aimag(ft(1,1,l))         ffg(ifun,ny1,kxp2+1,l) = an*aimag(ft(ny1,1,l))      else         do 180 k = 1, ny1         ffg(ifun,k,kxp2+1,l) = 0.0  180    continue      endif  190 continuec calculate green's function for x component of electric field  200 ifun = ifun + 1      if (kstrt.gt.ny2) go to 240      do 230 l = 1, k2blok      koff = kyp2*(l + ks) - 1      do 220 k = 1, kyp2      k1 = k + koff      if (k1.gt.ny) k1 = k1 - ny2      at1 = float(k1)**2      do 210 j = 1, nx2      j1 = j - 1      if (j1.gt.nx) j1 = j1 - nx2      x = float(j1)      r = sqrt(at1 + x*x)      f(j,k,l) = fpotc(r,affp,ari,3)      if (r.gt.0.) f(j,k,l) = f(j,k,l)*(x/r)  210 continue  220 continue  230 continue      isign = -1      call PFFT2RX(f,ft,isign,ntpose,mixup2,sct2,indx1,indy1,kstrt,nxv,n     1y2d,kxp2,kyp2,kyp2,j2blok,k2blok,nxhy2,nxyh2)  240 if (kstrt.gt.nx) go to 300      do 290 l = 1, j2blok      joff = kxp2*(l + ks) - 1      do 260 j = 1, kxp2      if ((j+joff).gt.0) then         do 250 k = 1, ny1         ffg(ifun,k,j,l) = an*aimag(ft(k,j,l))  250    continue      endif  260 continue      if ((l+ks).eq.0) then         do 270 k = 2, ny         k1 = ny2 + 2 - k         ffg(ifun,k,1,l) = an*real(ft(k,1,l))         ffg(ifun,k,kxp2+1,l) = an*real(ft(k1,1,l))  270    continue         ffg(ifun,1,1,l) = an*real(ft(1,1,l))         ffg(ifun,1,kxp2+1,l) = an*aimag(ft(1,1,l))         ffg(ifun,ny1,1,l) = an*real(ft(ny1,1,l))         ffg(ifun,ny1,kxp2+1,l) = an*aimag(ft(ny1,1,l))      else         do 280 k = 1, ny1         ffg(ifun,k,kxp2+1,l) = 0.0  280    continue      endif  290 continuec calculate green's function for x component of electric field  300 ifun = ifun + 1      if (kstrt.gt.ny2) go to 340      do 330 l = 1, k2blok      koff = kyp2*(l + ks) - 1      do 320 k = 1, kyp2      k1 = k + koff      if (k1.gt.ny) k1 = k1 - ny2      y = float(k1)      at1 = y*y      do 310 j = 1, nx2      j1 = j - 1      if (j1.gt.nx) j1 = j1 - nx2      r = sqrt(at1 + float(j1)**2)      f(j,k,l) = fpotc(r,affp,ari,3)      if (r.gt.0.) f(j,k,l) = f(j,k,l)*(y/r)  310 continue  320 continue  330 continue      isign = -1      call PFFT2RX(f,ft,isign,ntpose,mixup2,sct2,indx1,indy1,kstrt,nxv,n     1y2d,kxp2,kyp2,kyp2,j2blok,k2blok,nxhy2,nxyh2)  340 if (kstrt.gt.nx) go to 400      do 390 l = 1, j2blok      joff = kxp2*(l + ks) - 1      do 360 j = 1, kxp2      if ((j+joff).gt.0) then         do 350 k = 2, ny         ffg(ifun,k,j,l) = an*aimag(ft(k,j,l))  350    continue         ffg(ifun,1,j,l) = an*real(ft(1,j,l))         ffg(ifun,ny1,j,l) = an*real(ft(ny1,j,l))      endif  360 continue      if ((l+ks).eq.0) then         do 370 k = 2, ny         k1 = ny2 + 2 - k         ffg(ifun,k,1,l) = an*aimag(ft(k,1,l))         ffg(ifun,k,kxp2+1,l) = an*aimag(ft(k1,1,l))  370    continue         ffg(ifun,1,1,l) = an*real(ft(1,1,l))         ffg(ifun,1,kxp2+1,l) = an*aimag(ft(1,1,l))         ffg(ifun,ny1,1,l) = an*real(ft(ny1,1,l))         ffg(ifun,ny1,kxp2+1,l) = an*aimag(ft(ny1,1,l))      else         do 380 k = 1, ny1         ffg(ifun,k,kxp2+1,l) = 0.0  380    continue      endif  390 continuec copy ffg(i,k,1,l) on node 0 to ffg(i,k,kxp2+1,l) on other nodes  400 do 410 l = 1, j2blok      call P0COPY(ffg(1,1,1,l),ffg(1,1,kxp2+1,l),4*ny1d)  410 continue      return      endc-----------------------------------------------------------------------      subroutine PPOISC2(q,fx,fy,isign,ffg,we,nx,ny,kstrt,ny2d,kxp2,j2bl     1ok,ny1d,kxp2d)c this subroutine solves 2d poisson's equation in fourier space forc force/charge (or convolution of electric field over particle shape)c or for potential, or provides a smoothing function, with open (vacuum)c boundary conditions using hockney's method, for distributed data.c fourier coefficients are constructed so that a real to complex fftc will perform the appropriate convolutionc for isign = -1, c input: q,ffg,isign,nx,ny,kstrt,ny2d,kxp2,j2blok,ny1d,kxp2dc output: fx,fy,wec approximate flop count is: 44*nx*ny + 36*(nx + ny)c for isign = 1,c input: q,ffg,isign,nx,ny,kstrt,ny2d,kxp2,j2blok,ny1d,kxp2dc output: fx,wec approximate flop count is: 22*nx*ny + 24(nx + ny)c for isign = 2,c input: q,ffg,isign,nx,ny,kstrt,ny2d,kxp2,j2blok,ny1d,kxp2dc output: fyc approximate flop count is: 4*nx*ny + 2*(nx + ny)c if isign < 0, force/charge is calculated using the equations:c fx(kx,ky) = gx(kx,ky)*s(kx,ky)*q(kx,ky),c fy(kx,ky) = gy(kx,ky)*s(kx,ky)*q(kx,ky),c where kx = pi*j/nx, ky = pi*k/ny, and j,k = fourier mode numbers,c gx(kx,ky) = s(kx,ky)*inverse FFT of (x/r)*Erc gy(kx,ky) = s(kx,ky)*inverse FFT of (y/r)*Erc where Er is the electric field of a single finite-sized particlec s(kx,ky) = inverse FFT of the density of a finite-sized particlec if isign = 1, potential is calculated using the equation:c fx(kx,ky) = g(kx,ky)*q(kx,ky)c where g(kx,ky) = affp*inverse FFT of potrc where potr is the potential of a single finite-sized particlec if isign = 2, smoothing is calculated using the equation:c fy(kx,ky) = q(kx,ky)*s(kx,ky)c q(k,j,l) = complex charge density for fourier mode (jj-1,k-1)c fx(k,j,l) = x component of complex force/charge,c fy(k,j,l) = y component of complex force/charge,c ffg(1,k,j,l) = potential green's function gc ffg(2,k,j,l) = finite-size particle shape factor sc ffg(3,k,j,l) = x component of electric field green's function gxc ffg(4,k,j,l) = y component of electric field green's function gyc all for fourier mode (jj-1,k-1), where jj = j + kxp2*(l - 1)c the ffg array is calculated by the subroutine PFORMC2c nx/ny = system length in x/y directionc kstrt = starting data block numberc ny2d = first dimension of field arrays, must be >= 2*nyc kxp2 = number of data values per blockc j2blok = number of data blocksc electric field energy is also calculated and returned in wec ny1d = second dimension of ffg array, must be >= ny+1c kxp2d = third dimension of ffg array, must be >= kxp2+1      implicit none      real ffg      complex q, fx, fy      integer isign, nx, ny, kstrt, ny2d, kxp2, j2blok, ny1d, kxp2d      real we      dimension q(ny2d,kxp2,j2blok)      dimension fx(ny2d,kxp2,j2blok), fy(ny2d,kxp2,j2blok)      dimension ffg(4,ny1d,kxp2d,j2blok)c local data      double precision wp      integer j, k, l, k1, ny22, ks, kx1, joff, ny1      real at1, at2, at3, at4      complex zero, zt1, zt2      if (isign.eq.0) return      ny1 = ny + 1      ny22 = ny + ny + 2      ks = kstrt - 2      kx1 = 1      zero = cmplx(0.,0.)      if (isign.gt.0) go to 70c calculate force/charge and sum field energy      wp = 0.0d0      if (kstrt.gt.nx) go to 60      do 50 l = 1, j2blok      if ((l+ks).gt.0) kx1 = kxp2 + 1c mode numbers kx > 0 and 0 < ky < ny      joff = kxp2*(l + ks) - 1      at3 = -1.0      do 20 j = 1, kxp2      at3 = -at3      if ((j+joff).gt.0) then         at2 = ffg(4,1,j,l)         do 10 k = 2, ny         k1 = ny22 - k         at1 = at3*ffg(3,k,kx1,l)         at2 = -at2         zt1 = cmplx(at1,ffg(3,k,j,l))         zt2 = cmplx(at2,ffg(4,k,j,l))         fx(k,j,l) = zt1*q(k,j,l)         fx(k1,j,l) = zt1*q(k1,j,l)         fy(k,j,l) = zt2*q(k,j,l)         fy(k1,j,l) = conjg(zt2)*q(k1,j,l)         wp = wp + ffg(1,k,j,l)*(q(k,j,l)*conjg(q(k,j,l)) + q(k1,j,l)*co     1njg(q(k1,j,l)))   10    continuec mode number ky = 0         at1 = at3*ffg(3,1,kx1,l)         zt1 = cmplx(at1,ffg(3,1,j,l))         fx(1,j,l) = zt1*q(1,j,l)         fy(1,j,l) = ffg(4,1,j,l)*q(1,j,l)         wp = wp + ffg(1,1,j,l)*(q(1,j,l)*conjg(q(1,j,l)))c mode number ky = ny         at1 = at3*ffg(3,ny1,kx1,l)         zt1 = cmplx(at1,ffg(3,ny1,j,l))         fx(ny1,j,l) = zt1*q(ny1,j,l)         fy(ny1,j,l) = ffg(4,ny1,j,l)*q(ny1,j,l)         wp = wp + ffg(1,ny1,j,l)*(q(ny1,j,l)*conjg(q(ny1,j,l)))      endif   20 continuec mode number kx = 0      if ((l+ks).eq.0) thenc mode number kx = 0         at3 = ffg(4,1,1,l)         do 30 k = 2, ny         at3 = -at3         zt1 = cmplx(at3,ffg(4,k,1,l))         fx(k,1,l) = ffg(3,k,1,l)*q(k,1,l)         fy(k,1,l) = zt1*q(k,1,l)         wp = wp + ffg(1,k,1,l)*(q(k,1,l)*conjg(q(k,1,l)))   30    continuec mode number kx = nx/2         at3 = ffg(4,1,kxp2+1,l)         do 40 k = 2, ny         k1 = ny22 - k         at3 = -at3         zt1 = cmplx(at3,ffg(4,k,kxp2+1,l))         fx(k1,1,l) = ffg(3,k,kxp2+1,l)*q(k1,1,l)         fy(k1,1,l) = zt1*q(k1,1,l)         wp = wp + ffg(1,k,kxp2+1,l)*(q(k1,1,l)*conjg(q(k1,1,l)))   40    continuec mode numbers ky = 0, kx = 0, nx/2         fx(1,1,l) = cmplx(ffg(3,1,1,l)*real(q(1,1,l)),ffg(3,1,kxp2+1,l)     1*aimag(q(1,1,l)))         fy(1,1,l) = cmplx(ffg(4,1,1,l)*real(q(1,1,l)),ffg(4,1,kxp2+1,l)     1*aimag(q(1,1,l)))         wp = wp + .5*(ffg(1,1,1,l)*real(q(1,1,l))**2 + ffg(1,1,kxp2+1,l     1)*aimag(q(1,1,l))**2)c mode numbers ky = ny/2, kx = 0, nx/2         fx(ny1,1,l) = cmplx(ffg(3,ny1,1,l)*real(q(ny1,1,l)),ffg(3,ny1,k     1xp2+1,l)*aimag(q(ny1,1,l)))         fy(ny1,1,l) = cmplx(ffg(4,ny1,1,l)*real(q(ny1,1,l)),ffg(4,ny1,k     1xp2+1,l)*aimag(q(ny1,1,l)))         wp = wp + .5*(ffg(1,ny1,1,l)*real(q(ny1,1,l))**2 + ffg(1,ny1,kx     1p2+1,l)*aimag(q(ny1,1,l))**2)      endif   50 continue   60 continue      we = 4.0*float(nx*ny)*wp      returnc calculate potential and sum field energy   70 if (isign.gt.1) go to 140      wp = 0.0d0      if (kstrt.gt.nx) go to 130      do 120 l = 1, j2blokc mode numbers kx > 0 and 0 < ky < ny      joff = kxp2*(l + ks) - 1      do 90 j = 1, kxp2      if ((j+joff).gt.0) then         do 80 k = 2, ny         k1 = ny22 - k         at2 = ffg(1,k,j,l)         at1 = at2*ffg(2,k,j,l)c        at1 = at2         fx(k,j,l) = at2*q(k,j,l)         fx(k1,j,l) = at2*q(k1,j,l)         wp = wp + at1*(q(k,j,l)*conjg(q(k,j,l)) + q(k1,j,l)*conjg(q(k1,     1j,l)))   80    continuec mode number ky = 0         at2 = ffg(1,1,j,l)         at1 = at2*ffg(2,1,j,l)c        at1 = at2         fx(1,j,l) = at2*q(1,j,l)         wp = wp + at1*(q(1,j,l)*conjg(q(1,j,l)))c mode number ky = ny         at2 = ffg(1,ny1,j,l)         at1 = at2*ffg(2,ny1,j,l)c        at1 = at2         fx(ny1,j,l) = at2*q(ny1,j,l)         wp = wp + at1*(q(ny1,j,l)*conjg(q(ny1,j,l)))      endif   90 continuec mode number kx = 0      if ((l+ks).eq.0) thenc mode number kx = 0         do 100 k = 2, ny         at2 = ffg(1,k,1,l)         at1 = at2*ffg(2,k,1,l)c        at1 = at2         fx(k,1,l) = at2*q(k,1,l)         wp = wp + at1*(q(k,1,l)*conjg(q(k,1,l)))  100    continuec mode number kx = nx/2         do 110 k = 2, ny         k1 = ny22 - k         at2 = ffg(1,k,kxp2+1,l)         at1 = at2*ffg(2,k,kxp2+1,l)c        at1 = at2         fx(k1,1,l) = at2*q(k1,1,l)         wp = wp + at1*(q(k1,1,l)*conjg(q(k1,1,l)))  110    continuec mode numbers ky = 0, kx = 0, nx/2         at2 = ffg(1,1,1,l)         at1 = at2*ffg(2,1,1,l)c        at1 = at2         at4 = ffg(1,1,kxp2+1,l)         at3 = at4*ffg(2,1,kxp2+1,l)c        at3 = at4         fx(1,1,l) = cmplx(at2*real(q(1,1,l)),at4*aimag(q(1,1,l)))         wp = wp + .5*(at1*real(q(1,1,l))**2 + at3*aimag(q(1,1,l))**2)c mode numbers ky = ny/2, kx = 0, nx/2         at2 = ffg(1,ny1,1,l)         at1 = at2*ffg(2,ny1,1,l)c        at1 = at2         at4 = ffg(1,ny1,kxp2+1,l)         at3 = at4*ffg(2,ny1,kxp2+1,l)c        at3 = at4         fx(ny1,1,l) = cmplx(at2*real(q(ny1,1,l)),at4*aimag(q(ny1,1,l)))         wp = wp + .5*(at1*real(q(ny1,1,l))**2 + at3*aimag(q(ny1,1,l))**     12)      endif  120 continue  130 continue      we = 4.0*float(nx*ny)*wp      returnc calculate smoothing  140 if (kstrt.gt.nx) go to 200      do 190 l = 1, j2blokc mode numbers kx > 0 and 0 < ky < ny      joff = kxp2*(l + ks) - 1      do 160 j = 1, kxp2      if ((j+joff).gt.0) then         do 150 k = 2, ny         k1 = ny22 - k         at1 = ffg(2,k,j,l)         fy(k,j,l) = at1*q(k,j,l)         fy(k1,j,l) = at1*q(k1,j,l)  150    continuec mode number ky = 0         fy(1,j,l) = ffg(2,1,j,l)*q(1,j,l)c mode number ky = ny         fy(ny1,j,l) = ffg(2,ny1,j,l)*q(ny1,j,l)      endif  160 continuec mode number kx = 0      if ((l+ks).eq.0) thenc mode number kx = 0         do 170 k = 2, ny         fy(k,1,l) = ffg(2,k,1,l)*q(k,1,l)  170    continuec mode number kx = nx/2         do 180 k = 2, ny         k1 = ny22 - k         fy(k1,1,l) = ffg(2,k,kxp2+1,l)*q(k1,1,l)  180    continuec mode numbers ky = 0, kx = 0, nx/2         at1 = ffg(2,1,1,l)         at3 = ffg(2,1,kxp2+1,l)         fy(1,1,l) = cmplx(at1*real(q(1,1,l)),at3*aimag(q(1,1,l)))c mode numbers ky = ny/2, kx = 0, nx/2         at1 = ffg(2,ny1,1,l)         at3 = ffg(2,ny1,kxp2+1,l)         fy(ny1,1,l) = cmplx(at1*real(q(ny1,1,l)),at3*aimag(q(ny1,1,l)))      endif  190 continue  200 continue      return      endc-----------------------------------------------------------------------      subroutine PPOISC22(q,fxy,ffg,we,nx,ny,kstrt,ny2d,kxp2,j2blok,ny1d     1,kxp2d)c this subroutine solves 2d poisson's equation in fourier space forc force/charge (or convolution of electric field over particle shape)c with open (vacuum) boundary conditions using hockney's method,c for distributed data.c fourier coefficients are constructed so that a real to complex fftc will perform the appropriate convolutionc input: q,ffg,nx,ny,kstrt,ny2d,kxp2,j2blok,ny1d,kxp2dc output: fxy,wec approximate flop count is: 44*nx*ny + 36*(nx + ny)c force/charge is calculated using the equations:c fx(kx,ky) = gx(kx,ky)*s(kx,ky)*q(kx,ky),c fy(kx,ky) = gy(kx,ky)*s(kx,ky)*q(kx,ky),c where kx = pi*j/nx, ky = pi*k/ny, and j,k = fourier mode numbers,c gx(kx,ky) = s(kx,ky)*inverse FFT of (x/r)*Erc gy(kx,ky) = s(kx,ky)*inverse FFT of (y/r)*Erc where Er is the electric field of a single finite-sized particlec s(kx,ky) = inverse FFT of the density of a finite-sized particlec q(k,j,l) = complex charge density for fourier mode (jj-1,k-1)c fxy(1,k,j,l) = x component of complex force/charge,c fxy(2,k,j,l) = y component of complex force/charge,c ffg(1,k,j,l) = potential green's function gc ffg(2,k,j,l) = finite-size particle shape factor sc ffg(3,k,j,l) = x component of electric field green's function gxc ffg(4,k,j,l) = y component of electric field green's function gyc all for fourier mode (jj-1,k-1), where jj = j + kxp2*(l - 1)c the ffg array is calculated by the subroutine PFORMC2c nx/ny = system length in x/y directionc kstrt = starting data block numberc ny2d = first dimension of field arrays, must be >= 2*nyc kxp2 = number of data values per blockc j2blok = number of data blocksc electric field energy is also calculated and returned in wec ny1d = second dimension of ffg array, must be >= ny+1c kxp2d = third dimension of ffg array, must be >= kxp2+1      implicit none      real ffg      complex q, fxy      integer nx, ny, kstrt, ny2d, kxp2, j2blok, ny1d, kxp2d      real we      dimension q(ny2d,kxp2,j2blok), fxy(2,ny2d,kxp2,j2blok)      dimension ffg(4,ny1d,kxp2d,j2blok)c local data      double precision wp      integer j, k, l, k1, ny22, ks, kx1, joff, ny1      real at1, at2, at3      complex zero, zt1, zt2      ny1 = ny + 1      ny22 = ny + ny + 2      ks = kstrt - 2      kx1 = 1      zero = cmplx(0.,0.)c calculate force/charge and sum field energy      wp = 0.0d0      if (kstrt.gt.nx) go to 60      do 50 l = 1, j2blok      if ((l+ks).gt.0) kx1 = kxp2 + 1c mode numbers kx > 0 and 0 < ky < ny      joff = kxp2*(l + ks) - 1      at3 = -1.0      do 20 j = 1, kxp2      at3 = -at3      if ((j+joff).gt.0) then         at2 = ffg(4,1,j,l)         do 10 k = 2, ny         k1 = ny22 - k         at1 = at3*ffg(3,k,kx1,l)         at2 = -at2         zt1 = cmplx(at1,ffg(3,k,j,l))         zt2 = cmplx(at2,ffg(4,k,j,l))         fxy(1,k,j,l) = zt1*q(k,j,l)         fxy(1,k1,j,l) = zt1*q(k1,j,l)         fxy(2,k,j,l) = zt2*q(k,j,l)         fxy(2,k1,j,l) = conjg(zt2)*q(k1,j,l)         wp = wp + ffg(1,k,j,l)*(q(k,j,l)*conjg(q(k,j,l)) + q(k1,j,l)*co     1njg(q(k1,j,l)))   10    continuec mode number ky = 0         at1 = at3*ffg(3,1,kx1,l)         zt1 = cmplx(at1,ffg(3,1,j,l))         fxy(1,1,j,l) = zt1*q(1,j,l)         fxy(2,1,j,l) = ffg(4,1,j,l)*q(1,j,l)         wp = wp + ffg(1,1,j,l)*(q(1,j,l)*conjg(q(1,j,l)))c mode number ky = ny         at1 = at3*ffg(3,ny1,kx1,l)         zt1 = cmplx(at1,ffg(3,ny1,j,l))         fxy(1,ny1,j,l) = zt1*q(ny1,j,l)         fxy(2,ny1,j,l) = ffg(4,ny1,j,l)*q(ny1,j,l)         wp = wp + ffg(1,ny1,j,l)*(q(ny1,j,l)*conjg(q(ny1,j,l)))      endif   20 continuec mode number kx = 0      if ((l+ks).eq.0) thenc mode number kx = 0         at3 = ffg(4,1,1,l)         do 30 k = 2, ny         at3 = -at3         zt1 = cmplx(at3,ffg(4,k,1,l))         fxy(1,k,1,l) = ffg(3,k,1,l)*q(k,1,l)         fxy(2,k,1,l) = zt1*q(k,1,l)         wp = wp + ffg(1,k,1,l)*(q(k,1,l)*conjg(q(k,1,l)))   30    continuec mode number kx = nx/2         at3 = ffg(4,1,kxp2+1,l)         do 40 k = 2, ny         k1 = ny22 - k         at3 = -at3         zt1 = cmplx(at3,ffg(4,k,kxp2+1,l))         fxy(1,k1,1,l) = ffg(3,k,kxp2+1,l)*q(k1,1,l)         fxy(2,k1,1,l) = zt1*q(k1,1,l)         wp = wp + ffg(1,k,kxp2+1,l)*(q(k1,1,l)*conjg(q(k1,1,l)))   40    continuec mode numbers ky = 0, kx = 0, nx/2-         fxy(1,1,1,l) = cmplx(ffg(3,1,1,l)*real(q(1,1,l)),ffg(3,1,kxp2+1     1,l)*aimag(q(1,1,l)))         fxy(2,1,1,l) = cmplx(ffg(4,1,1,l)*real(q(1,1,l)),ffg(4,1,kxp2+1     1,l)*aimag(q(1,1,l)))         wp = wp + .5*(ffg(1,1,1,l)*real(q(1,1,l))**2 + ffg(1,1,kxp2+1,l     1)*aimag(q(1,1,l))**2)c mode numbers ky = ny/2, kx = 0, nx/2         fxy(1,ny1,1,l) = cmplx(ffg(3,ny1,1,l)*real(q(ny1,1,l)),ffg(3,ny     11,kxp2+1,l)*aimag(q(ny1,1,l)))         fxy(2,ny1,1,l) = cmplx(ffg(4,ny1,1,l)*real(q(ny1,1,l)),ffg(4,ny     11,kxp2+1,l)*aimag(q(ny1,1,l)))         wp = wp + .5*(ffg(1,ny1,1,l)*real(q(ny1,1,l))**2 + ffg(1,ny1,kx     1p2+1,l)*aimag(q(ny1,1,l))**2)      endif   50 continue   60 continue      we = 4.0*float(nx*ny)*wp      return      endc-----------------------------------------------------------------------      subroutine P0COPY(f,g,nxp)c this subroutine copies real data f on node 0 to g on other nodesc f/g = data to be sent/receivedc nxp = size of data fc input: f, nxpc output: g      implicit none      integer nxp      real f, g      dimension f(nxp), g(nxp)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=10)c nproc = number of real or virtual processors obtainedc lgrp = current communicatorc mdouble = default double precision type      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer istatus, idproc, i, id, ierr      dimension istatus(lstat)c this segment is used for mpi computersc determine the rank of the calling process in the communicator      call MPI_COMM_RANK(lgrp,idproc,ierr)c node 0 sends messages to other nodes      if (idproc.eq.0) then         do 10 i = 2, nproc            id = i - 1            call MPI_SEND(f,nxp,mreal,id,95,lgrp,ierr)   10    continuec other nodes receive data from node 0      else         call MPI_RECV(g,nxp,mreal,0,95,lgrp,istatus,ierr)      endif      return      endc-----------------------------------------------------------------------      subroutine PZDBL2D(q,q2,nx,ny,kstrt,nxv,kyp,kypd,kyp2,kblok,k2blok     1)c this subroutine creates an odd array q2 from an array q, so thatc a 2d sine transform can be performed with a 2d real to complex fft.c linear interpolation for distributed datac q2 array may be modifiedc nx/ny = system length in x/y directionc kstrt = starting data block numberc nxv = first dimension of input array q, must be >= nxc kyp = number of data values per block in yc kypd = second dimension of input array q, must be >= kypc kyp2 = second dimension of output array q2, must be >= kyp2c kblok = number of data blocks in yc k2blok = number of data blocks in y for doubled data      implicit none      real q, q2      integer nx, ny, kstrt, nxv, kyp, kypd, kyp2, kblok, k2blok      dimension q(nxv,kypd,kblok), q2(2*nxv,kyp2,k2blok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=10)c lgrp = current communicatorc mreal = default datatype for reals      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer istatus, msid, nsid, ierr      integer j, k, l, ny2, kyb, kyb2, ks, koff, moff      integer ll, lm, k1, k2, joff      dimension istatus(lstat)      kyb = ny/kyp      ny2 = ny + ny      kyb2 = ny2/kyp2      ks = kstrt - 2      moff = kypd + kybc copy to double array in x direction      do 70 l = 1, k2blok      koff = kyp2*(l + ks)      ll = koff/kyp + 1      koff = kyp*(l + ks)      lm = koff/kyp2 + 1c special case for one processor      if (kyb2.eq.1) then         do 20 k = 1, ny         do 10 j = 1, nx         q2(j,k,l) = q(j,k,l)         q2(nx+j,k,l) = 0.         q2(j,ny+k,l) =  0.         q2(nx+j,ny+k,l) =  0.   10    continue   20    continue         return      endifc this segment is used for shared memory computersc     if (ll.le.kyb) thenc        do 40 k = 1, kypc        do 30 j = 1, nxc        q2(j,k,l) = q(j,k,ll)c  30    continuec  40    continuec        if (kyp.lt.kyp2) thenc           do 60 k = 1, kypc           do 50 j = 1, nxc           q2(j,k+kyp,l) = q(j,k,ll+1)c  50       continuec  60       continuec        endifc     endifc this segment is used for mpi computers      if (ll.le.kyb) then         call MPI_IRECV(q2(1,1,l),kyp*nxv,mreal,ll-1,moff+1,lgrp,msid,ie     1rr)         if (kyp.lt.kyp2) then            call MPI_IRECV(q2(1,kyp+1,l),kyp*nxv,mreal,ll,moff+1,lgrp,ns     1id,ierr)         endif      endif      if (lm.le.(kyb2/2)) then         call MPI_SEND(q(1,1,l),kyp*nxv,mreal,lm-1,moff+1,lgrp,ierr)      endifc wait for data and unpack it      if (ll.le.kyb) then         call MPI_WAIT(msid,istatus,ierr)         do 40 k = 2, kyp         k1 = kyp - k + 2         k2 = (k1 - 1)/2 + 1         joff = nxv*(k1 - 2*k2 + 1)         do 30 j = 1, nxv         q2(j,k1,l) = q2(j+joff,k2,l)   30    continue   40    continue         if (kyp.lt.kyp2) then            call MPI_WAIT(nsid,istatus,ierr)            do 60 k = 2, kyp            k1 = kyp - k + 2            k2 = (k1 - 1)/2 + 1            joff = nxv*(k1 - 2*k2 + 1)            do 50 j = 1, nxv            q2(j,k1+kyp,l) = q2(j+joff,k2+kyp,l)   50       continue   60       continue         endif      endif   70 continuec zero out remainder of array      do 110 l = 1, k2blok      koff = kyp2*(l + ks)      do 100 k = 1, kyp2      k1 = k + koff      if (k1.le.ny) then         do 80 j = 1, nx         q2(j+nx,k,l) = 0.   80    continue      else         do 90 j = 1, nx         q2(j,k,l) = 0.         q2(j+nx,k,l) = 0.   90    continue      endif  100 continue  110 continue      return      endc-----------------------------------------------------------------------      function POTC3(r,affp,ari,ifun)c this function calculates the fields for finite-size gaussian particlesc in 3D:c if ifun = 1, calculate potential functionc POTC3 = (affp/(4*pi))*erfn(r/(ar*sqrt(2.)))/r, for r > 0.c POTC3 = (affp/(4*pi))*sqrt(2./3.14159265358979)/ar, for r = 0.c if ifun = 2, calculate particle shape functionc POTC3 = exp(-(r/(sqrt(2.)*ar))**2)/(sqrt(2.*pi)*ar)**3, for r > 0.c POTC3 = 1./(sqrt(2.*pi)*ar)**3, for r = 0.c if ifun = 3, calculate radial electric fieldc POTC3 = (affp/(4*pi))*(1/r)*(erf(r/(sqrt(2.)*ar))/r -c exp(-(r/(sqrt(2.)*ar))**2)*sqrt(2./3.14159265358979)/ar, for r > 0.c POTC3 = 0.0, for r = 0.c where erfn is the error functionc and where the finite-size particle density is given by:c rho(r) = exp(-(r/sqrt(2)*ar)**2)/(sqrt(2*pi)*ar)**3c affp = 4*pi*e**2/(me*(omega0**2)*delta**3) = 1/(n0*delta**3)c where n0*delta**3 = number density per gridc r = radial coordinatec affp = normalization constantc ari = 1/ar = inverse of particle size functionc (ari = 0., means use point particle result)c ifun = (1,2,3) = calculate (potential,shape,electric field)      implicit none      real r, affp, ari      integer ifunc local datac pi4i = 1/4*pi, sqt2i = 1./sqrt(2.), sqt2pi = sqrt(2./pi)      real pi4i, sqt2i, sqt2pi      parameter(pi4i=0.5/6.28318530717959)      parameter(sqt2i=0.707106781186548,sqt2pi=0.797884560802865)      real POTC3, erfn      external erfn      real anorm, at1, ri      anorm = affp*pi4ic calculate potential function      if (ifun.eq.1) thenc finite-size particles         if (ari.gt.0.) then            if (r.eq.0.) then               POTC3 = anorm*sqt2pi*ari            else               POTC3 = anorm*erfn(r*sqt2i*ari)/r            endifc point particles         else            if (r.eq.0.) then               POTC3 = 0.0            else               POTC3 = anorm/r            endif         endifc calculate particle shape function      else if (ifun.eq.2) then         anorm = affp*(.5*sqt2pi*ari)**3c finite-size particles         if (ari.gt.0.) then            if (r.eq.0.) then               POTC3 = anorm            else               at1 = amin1(r*sqt2i*ari,8.0)               POTC3 = anorm*exp(-(at1*at1))            endifc point particles         else            if (r.eq.0.) then               POTC3 = affp            else               POTC3 = 0.0            endif         endifc calculate radial electric field      else if (ifun.eq.3) thenc finite-size particles         if (ari.gt.0.) then            if (r.eq.0.) then               POTC3 = 0.0            else               ri = 1.0/r               at1 = amin1(r*sqt2i*ari,8.0)               POTC3 = anorm*ri*(erfn(at1)*ri - sqt2pi*ari*exp(-(at1*at1     1)))            endifc point particles         else            if (r.eq.0.) then               POTC3 = 0.0            else               POTC3 = anorm/(r*r)            endif         endif      endif      return      endc-----------------------------------------------------------------------      function POTC2(r,affp,ari,ifun)c this function calculates the fields for finite-size gaussian particlesc in 2D:c if ifun = 1, calculate potential functionc POTC2 = -(affp/(4*pi))*(e1(r**2/(2*ar**2)) + ln(r**2)), for r > 0.c POTC2 = -(affp/(4*pi))*(ln(2) - gamma + 2*ln(ar), for r = 0.c if ifun = 2, calculate particle shape functionc POTC2 = exp(-(r/(sqrt(2.)*ar))**2)/(sqrt(2.*pi)*ar)**2, for r > 0.c POTC2 = 1./(sqrt(2.*pi)*ar)**2, for r = 0.c if ifun = 3, calculate radial electric fieldc POTC2 = 2*(1 - exp(-(r/(sqrt(2.)*ar))**2)/r, for r > 0.c POTC2 = 0.0, for r = 0.c where e1 is the exponential integralc and where the finite-size particle density is given by:c rho(r) = exp(-(r/sqrt(2)*ar)**2)/(2*pi*ar**2), qm = q/ec affp = 4*pi*e**2/(me*(omega0**2)*delta**2) = 1/(n0*delta**2)c where n0*delta**2 = number density per gridc r = radial coordinatec affp = normalization constantc ari = 1/ar = inverse of particle size functionc (ari = 0., means use point particle result)c ifun = 1 = calculate (potential)      implicit none      real r, affp, ari      integer ifunc local datac pi4i = 1/4*pi, sqt2i = 1./sqrt(2.), sqt2pi = sqrt(2./pi)      real pi4i, sqt2i, sqt2pi      parameter(pi4i=0.5/6.28318530717959)      parameter(sqt2i=0.707106781186548,sqt2pi=0.797884560802865)      real POTC2, e1ln      external e1ln      real anorm, at1c calculate potential function      if (ifun.eq.1) then         anorm = -affp*pi4ic finite-size particles         if (ari.gt.0.) then            POTC2 = anorm*(e1ln((r*sqt2i*ari)**2) - 2.0*alog(sqt2i*ari))c point particles         else            if (r.eq.0.) then               POTC2 = 0.0            else               POTC2 = 2.0*anorm*alog(r)            endif         endifc calculate particle shape function      else if (ifun.eq.2) then         anorm = affp*(.5*sqt2pi*ari)**2c finite-size particles         if (ari.gt.0.) then            if (r.eq.0.) then               POTC2 = anorm            else               at1 = amin1(r*sqt2i*ari,8.0)               POTC2 = anorm*exp(-(at1*at1))            endifc point particles         else            if (r.eq.0.) then               POTC2 = affp            else               POTC2 = 0.0            endif         endifc calculate radial electric field      else if (ifun.eq.3) then         anorm = 2.*affp*pi4ic finite-size particles         if (ari.gt.0.) then            if (r.eq.0.) then               POTC2 = 0.0            else               at1 = amin1(r*sqt2i*ari,8.0)               POTC2 = anorm*(1.0 - exp(-(at1*at1)))/r            endifc point particles         else            if (r.eq.0.) then               POTC2 = 0.0            else               POTC2 = anorm/r            endif         endif      endif      return      endc-----------------------------------------------------------------------      subroutine POTC(f2,fpotc,ifun,affp,ar,ix0,iy0,nx,ny,nxv,ny2v)c test program for calculating fields due to finite-size particles      implicit none      real f2      real affp, ar      integer ifun, nx, ny, nxv, ny2v, ix0, iy0      dimension f2(2*nxv,ny2v)      real fpotc      external fpotcc local data      integer nx2, ny2, j, k, j1, k1, ifn      real ari, at1, at2, x, y, r      real POTC2      external POTC2      nx2 = nx + nx      ny2 = ny + ny      ari = 0.0      if (ar.gt.0.) ari = 1.0/ar      ifn = ifun      if (ifun.eq.4) ifn = 3c calculate potential green's function      do 20 k = 1, ny2      k1 = k - 1      if (k1.gt.ny) k1 = k1 - ny2      y = float(k1 - iy0)      at1 = y*y      do 10 j = 1, nx2      j1 = j - 1      if (j1.gt.nx) j1 = j1 - nx2      x = float(j1 - ix0)      r = sqrt(at1 + x*x)      if (ifun.eq.2) then         at2 = POTC2(r,affp,ari,ifn)      else         at2 = fpotc(r,affp,ari,ifn)      endif      if (ifun.eq.3) then         if (r.gt.0.) at2 = at2*(x/r)      else if (ifun.eq.4) then         if (r.gt.0.) at2 = at2*(y/r)      endif      f2(j,k) = at2   10 continue   20 continue      return      endc-----------------------------------------------------------------------      subroutine FFT2RX(f,isign,mixup,sct,indx,indy,nxhd,nyd,nxhyd,nxyhd     1)c this subroutine performs a two dimensional real to complex fastc fourier transform and its inverse, using complex arithmeticc for isign = 0, input: all except f, output: mixup, sctc for isign = (-1,1), input: all, output: fc for isign = -1, approximate flop count: N*(5*log2(N) + 19/2)c for isign = 1,  approximate flop count: N*(5*log2(N) + 15/2)c where N = (nx/2)*nyc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = 0, the fft tables are preparedc if isign = -1, an inverse fourier transform is performedc f(n,m) = (1/nx*ny)*sum(f(j,k)*c       exp(-sqrt(-1)*2pi*n*j/nx)*exp(-sqrt(-1)*2pi*m*k/ny))c if isign = 1, a forward fourier transform is performedc f(j,k) = sum(f(n,m)*exp(sqrt(-1)*2pi*n*j/nx)*exp(sqrt(-1)*2pi*m*k/ny))c mixup = array of bit reversed addressesc sct = sine/cosine tablec nxhd = first dimension of fc nyd = second dimension of fc nxhyd = maximum of (nx/2,ny)c nxyhd = maximum of (nx,ny)/2c fourier coefficients are stored as follows:c f(2*j-1,k),f(2*j,k) = real, imaginary part of mode j-1,k-1, wherec 1 <= j <= nx/2 and 1 <= k <= ny, except forc f(1,k),f(2,k) = real, imaginary part of mode nx/2,k-1, wherec ny/2+2 <= k <= ny, andc f(2,1) = real part of mode nx/2,0 andc f(2,ny/2+1) = real part of mode nx/2,ny/2c written by viktor k. decyk, ucla      complex f, sct, t1, t2, t3      dimension f(nxhd,nyd), mixup(nxhyd), sct(nxyhd)      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nxh2 = nxh + 2      ny = 2**indy      nyh = ny/2      ny2 = ny + 2      nxy = max0(nx,ny)      nxhy = 2**indx1y      if (isign) 50, 10, 220c prepare fft tablesc bit-reverse index table: mixup(j) = 1 + reversed bits of (j - 1)   10 do 30 j = 1, nxhy      lb = j - 1      ll = 0      do 20 k = 1, indx1y      jb = lb/2      it = lb - 2*jb      lb = jb      ll = 2*ll + it   20 continue      mixup(j) = ll + 1   30 continuec sine/cosine table for the angles 2*n*pi/nxy      nxyh = nxy/2      dnxy = 6.28318530717959/float(nxy)      do 40 j = 1, nxyh      arg = dnxy*float(j - 1)      sct(j) = cmplx(cos(arg),-sin(arg))   40 continue      returnc inverse fourier transformc bit-reverse array elements in x   50 nrx = nxhy/nxh      nry = nxhy/ny      do 70 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 70      do 60 k = 1, ny      t1 = f(j1,k)      f(j1,k) = f(j,k)      f(j,k) = t1   60 continue   70 continuec first transform in x      nrx = nxy/nxh      do 110 l = 1, indx1      ns = 2**(l - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 100 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 90 j = 1, ns      j1 = j + k1      j2 = j + k2      t1 = sct(1+kmr*(j-1))      do 80 i = 1, ny      t2 = t1*f(j2,i)      f(j2,i) = f(j1,i) - t2      f(j1,i) = f(j1,i) + t2   80 continue   90 continue  100 continue  110 continuec unscramble coefficients and normalize      kmr = nxy/nx      ani = 1./float(2*nx*ny)      do 130 j = 2, nxhh      t3 = cmplx(aimag(sct(1+kmr*(j-1))),-real(sct(1+kmr*(j-1))))      do 120 k = 1, ny      t2 = conjg(f(nxh2-j,k))      t1 = f(j,k) + t2      t2 = (f(j,k) - t2)*t3      f(j,k) = ani*(t1 + t2)      f(nxh2-j,k) = ani*conjg(t1 - t2)  120 continue  130 continue      ani = 2.*ani      do 140 k = 1, ny      f(nxhh+1,k) = ani*conjg(f(nxhh+1,k))      f(1,k) = ani*cmplx(real(f(1,k)) + aimag(f(1,k)),real(f(1,k)) - aim     1ag(f(1,k)))  140 continuec bit-reverse array elements in y      do 160 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 160      do 150 j = 1, nxh      t1 = f(j,k1)      f(j,k1) = f(j,k)      f(j,k) = t1  150 continue  160 continuec then transform in y      nry = nxy/ny      do 200 l = 1, indy      ns = 2**(l - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 190 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 180 j = 1, ns      j1 = j + k1      j2 = j + k2      t1 = sct(1+kmr*(j-1))      do 170 i = 1, nxh      t2 = t1*f(i,j2)      f(i,j2) = f(i,j1) - t2      f(i,j1) = f(i,j1) + t2  170 continue  180 continue  190 continue  200 continuec unscramble modes kx = 0, nx/2      do 210 k = 2, nyh      t1 = f(1,ny2-k)      f(1,ny2-k) = .5*cmplx(aimag(f(1,k) + t1),real(f(1,k) - t1))      f(1,k) = .5*cmplx(real(f(1,k) + t1),aimag(f(1,k) - t1))  210 continue      returnc forward fourier transformc scramble modes kx = 0, nx/2  220 do 230 k = 2, nyh      t1 = cmplx(aimag(f(1,ny2-k)),real(f(1,ny2-k)))      f(1,ny2-k) = conjg(f(1,k) - t1)      f(1,k) = f(1,k) + t1  230 continuec bit-reverse array elements in y      nry = nxhy/ny      do 250 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 250      do 240 j = 1, nxh      t1 = f(j,k1)      f(j,k1) = f(j,k)      f(j,k) = t1  240 continue  250 continuec first transform in y      nry = nxy/ny      do 290 l = 1, indy      ns = 2**(l - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 280 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 270 j = 1, ns      j1 = j + k1      j2 = j + k2      t1 = conjg(sct(1+kmr*(j-1)))      do 260 i = 1, nxh      t2 = t1*f(i,j2)      f(i,j2) = f(i,j1) - t2      f(i,j1) = f(i,j1) + t2  260 continue  270 continue  280 continue  290 continuec scramble coefficients      kmr = nxy/nx      do 310 j = 2, nxhh      t3 = cmplx(aimag(sct(1+kmr*(j-1))),real(sct(1+kmr*(j-1))))      do 300 k = 1, ny      t2 = conjg(f(nxh2-j,k))      t1 = f(j,k) + t2      t2 = (f(j,k) - t2)*t3      f(j,k) = t1 + t2      f(nxh2-j,k) = conjg(t1 - t2)  300 continue  310 continue      do 320 k = 1, ny      f(nxhh+1,k) = 2.*conjg(f(nxhh+1,k))      f(1,k) = cmplx(real(f(1,k)) + aimag(f(1,k)),real(f(1,k)) - aimag(f     1(1,k)))  320 continuec bit-reverse array elements in x      nrx = nxhy/nxh      do 340 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 340      do 330 k = 1, ny      t1 = f(j1,k)      f(j1,k) = f(j,k)      f(j,k) = t1  330 continue  340 continuec then transform in x      nrx = nxy/nxh      do 380 l = 1, indx1      ns = 2**(l - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 370 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 360 j = 1, ns      j1 = j + k1      j2 = j + k2      t1 = conjg(sct(1+kmr*(j-1)))      do 350 i = 1, ny      t2 = t1*f(j2,i)      f(j2,i) = f(j1,i) - t2      f(j1,i) = f(j1,i) + t2  350 continue  360 continue  370 continue  380 continue      return      endc-----------------------------------------------------------------------      subroutine POISC2(q,fx,fy,isign,ffg,we,nx,ny,nx2v,ny2d,nx1d,ny1d)c this subroutine solves 2d poisson's equation in fourier space forc force/charge (or convolution of electric field over particle shape)c or for potential, or provides a smoothing functionc with open (vacuum) boundary conditions using hockney's method.c fourier coefficients are constructed so that a real to complex fftc will perform the appropriate convolutionc for isign = -1, input: q,ffg,isign,nx,ny,nx1d,ny1d,nx2v,ny2dc output: fx,fy,wec approximate flop count is: 11*nx*nyc for isign = 1, input: q,ffg,isign,nx,ny,,nx1d,ny1d,nx2v,ny2dc output: fx,wec approximate flop count is: 6*nx*nyc for isign = 2, input: q,ffg,isign,nx,ny,,nx1d,ny1dnx2v,ny2dc output: fyc approximate flop count is: 2*nx*nyc if isign < 0, force/charge is calculated using the equations:c fx(kx,ky) = gx(kx,ky)*s(kx,ky)*q(kx,ky),c fy(kx,ky) = gy(kx,ky)*s(kx,ky)*q(kx,ky),c where kx = pi*j/nx, ky = pi*k/ny, and j,k = fourier mode numbers,c gx(kx,ky) = s(kx,ky)*inverse FFT of (x/r)*Erc gy(kx,ky) = s(kx,ky)*inverse FFT of (y/r)*Erc where Er is the electric field of a single finite-sized particlec s(kx,ky) = inverse FFT of the density of a finite-sized particlec if isign = 1, potential is calculated using the equation:c fx(kx,ky) = g(kx,ky)*q(kx,ky)c where g(kx,ky) = affp*inverse FFT of potrc where potr is the potential of a single finite-sized particlec if isign = 2, smoothing is calculated using the equation:c fy(kx,ky) = q(kx,ky)*s(kx,ky)c cmplx(q(2*j-1,k),q(2*j,k)) = complex charge densityc cmplx(fx(2*j-1,k),fx(2*j,k)) = x component of complex force/charge,c cmplx(fy(2*j-1,k),fy(2*j,k)) = y component of complex force/charge,c ffg(1,j,k) = potential green's function gc ffg(2,j,k) = finite-size particle shape factor sc ffg(3,j,k) = x component of electric field green's function gxc ffg(4,j,k) = y component of electric field green's function gyc all for fourier mode (j-1,k-1)c the ffg array is calculated by the subroutine FORMC2c electric field energy is also calculatedc nx/ny = system length in x/y directionc nx2v = first dimension of field arrays, must be >= 2*nxc ny2d = second dimension of field arrays, must be >= 2*nyc nx1d = second dimension of ffg arrays, must be >= nx+1c ny1d = third dimension of field arrays, must be >= ny+1      implicit none      real ffg, q, fx, fy      integer isign, nx, ny, nx1d, ny1d, nx2v, ny2d      real we      dimension q(nx2v,ny2d), fx(nx2v,ny2d), fy(nx2v,ny2d)      dimension ffg(4,nx1d,ny1d)c local data      double precision wp      integer nx1, ny1, ny22, j, k, k1      real at1, at2, at3, at4, at5      if (isign.eq.0) return      nx1 = nx + 1      ny1 = ny + 1      ny22 = ny + ny + 2       if (isign.gt.0) go to 70c calculate force/charge and sum field energy      wp = 0.0d0c mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      at5 = 1.0      do 20 k = 2, ny      k1 = ny22 - k      at1 = ffg(3,1,k)      at5 = -at5      do 10 j = 2, nx      at1 = -at1      at2 = ffg(3,j,k)      at3 = at5*ffg(4,j,1)      at4 = ffg(4,j,k)      fx(2*j-1,k) = at1*q(2*j-1,k) - at2*q(2*j,k)      fx(2*j,k) = at2*q(2*j-1,k) + at1*q(2*j,k)      fx(2*j-1,k1) = at1*q(2*j-1,k1) - at2*q(2*j,k1)      fx(2*j,k1) = at2*q(2*j-1,k1) + q(2*j,k1)*at1      fy(2*j-1,k) = at3*q(2*j-1,k) - at4*q(2*j,k)      fy(2*j,k) = at4*q(2*j-1,k) + at3*q(2*j,k)      fy(2*j-1,k1) = at3*q(2*j-1,k1) + at4*q(2*j,k1)      fy(2*j,k1) = at3*q(2*j,k1) - at4*q(2*j-1,k1)      wp = wp + ffg(1,j,k)*(q(2*j-1,k)**2 + q(2*j,k)**2 + q(2*j-1,k1)**2     1 + q(2*j,k1)**2)   10 continue   20 continuec mode number kx = 0      at3 = ffg(4,1,1)      do 30 k = 2, ny      at1 = ffg(3,1,k)      at3 = -at3      at4 = ffg(4,1,k)      fx(1,k) = at1*q(1,k)      fx(2,k) = at1*q(2,k)      fy(1,k) = at3*q(1,k) - at4*q(2,k)      fy(2,k) = at4*q(1,k) + at3*q(2,k)      wp = wp + ffg(1,1,k)*(q(1,k)**2 + q(2,k)**2)   30 continuec mode number kx = nx/2      at3 = ffg(4,nx1,1)      do 40 k = 2, ny      k1 = ny22 - k      at1 = ffg(3,nx1,k)      at3 = -at3      at4 = ffg(4,nx1,k)      fx(1,k1) = at1*q(1,k1)      fx(2,k1) = at1*q(2,k1)      fy(1,k1) = at3*q(1,k1) - at4*q(2,k1)      fy(2,k1) = at4*q(1,k1) + at3*q(2,k1)      wp = wp + ffg(1,nx1,k)*(q(1,k1)**2 + q(2,k1)**2)   40 continuec mode number ky = 0      at1 = ffg(3,1,1)      do 50 j = 2, nx      at1 = -at1      at2 = ffg(3,j,1)      at4 = ffg(4,j,1)      fx(2*j-1,1) = at1*q(2*j-1,1) - at2*q(2*j,1)      fx(2*j,1) = at2*q(2*j-1,1) + at1*q(2*j,1)      fy(2*j-1,1) = at4*q(2*j-1,1)      fy(2*j,1) = at4*q(2*j,1)      wp = wp + ffg(1,j,1)*(q(2*j-1,1)**2 + q(2*j,1)**2)   50 continuec mode number ky = ny/2      at1 = ffg(3,1,ny1)      do 60 j = 2, nx      at1 = -at1      at2 = ffg(3,j,ny1)      at4 = ffg(4,j,ny1)      fx(2*j-1,ny1) = at1*q(2*j-1,ny1) - at2*q(2*j,ny1)      fx(2*j,ny1) = at2*q(2*j-1,ny1) + at1*q(2*j,ny1)      fy(2*j-1,ny1) = at4*q(2*j-1,ny1)      fy(2*j,ny1) = at4*q(2*j,ny1)      wp = wp + ffg(1,j,ny1)*(q(2*j-1,ny1)**2 + q(2*j,ny1)**2)   60 continuec mode numbers ky = 0, kx = 0, nx/2      fx(1,1) = ffg(3,1,1)*q(1,1)      fx(2,1) = ffg(3,nx1,1)*q(2,1)      fy(1,1) = ffg(4,1,1)*q(1,1)      fy(2,1) = ffg(4,nx1,1)*q(2,1)      wp = wp + .5*(ffg(1,1,1)*q(1,1)**2 + ffg(1,nx1,1)*q(2,1)**2)c mode numbers ky = ny/2, kx = 0, nx/2      fx(1,ny1) = ffg(3,1,ny1)*q(1,ny1)      fx(2,ny1) = ffg(3,nx1,ny1)*q(2,ny1)      fy(1,ny1) = ffg(4,1,ny1)*q(1,ny1)      fy(2,ny1) = ffg(4,nx1,ny1)*q(2,ny1)      wp = wp + .5*(ffg(1,1,ny1)*q(1,ny1)**2 + ffg(1,nx1,ny1)*q(2,ny1)**     12)      we = 4.0*float(nx*ny)*wp      returnc calculate potential and sum field energy   70 if (isign.gt.1) go to 110      wp = 0.0d0c mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      do 90 k = 2, ny      k1 = ny22 - k      do 80 j = 2, nx      at2 = ffg(1,j,k)      at1 = at2*ffg(2,j,k)c     at1 = at2      fx(2*j-1,k) = at2*q(2*j-1,k)      fx(2*j,k) = at2*q(2*j,k)      fx(2*j-1,k1) = at2*q(2*j-1,k1)      fx(2*j,k1) = at2*q(2*j,k1)      wp = wp + at1*(q(2*j-1,k)**2 + q(2*j,k)**2 + q(2*j-1,k1)**2 + q(2*     1j,k1)**2)   80 continuec mode number kx = 0      at2 = ffg(1,1,k)      at1 = at2*ffg(2,1,k)c     at1 = at2      fx(1,k) = at2*q(1,k)      fx(2,k) = at2*q(2,k)      wp = wp + at1*(q(1,k)**2 + q(2,k)**2)c mode number kx = nx/2      at2 = ffg(1,nx1,k)      at1 = at2*ffg(2,nx1,k)c     at1 = at2      fx(1,k1) = at2*q(1,k1)      fx(2,k1) = at2*q(2,k1)      wp = wp + at1*(q(1,k1)**2 + q(2,k1)**2)   90 continuec mode numbers ky = 0, ny/2      do 100 j = 2, nx      at2 = ffg(1,j,1)      at1 = at2*ffg(2,j,1)c     at1 = at2      fx(2*j-1,1) = at2*q(2*j-1,1)      fx(2*j,1) = at2*q(2*j,1)      wp = wp + at1*(q(2*j-1,1)**2 + q(2*j,1)**2)      at2 = ffg(1,j,ny1)      at1 = at2*ffg(2,j,ny1)c     at1 = at2      fx(2*j-1,ny1) = at2*q(2*j-1,ny1)      fx(2*j,ny1) = at2*q(2*j,ny1)      wp = wp + at1*(q(2*j-1,ny1)**2 + q(2*j,ny1)**2)  100 continuec mode numbers ky = 0, kx = 0      at2 = ffg(1,1,1)      at1 = at2*ffg(2,1,1)c     at1 = at2      fx(1,1) = at2*q(1,1)      wp = wp + .5*at1*q(1,1)**2c mode numbers ky = 0, kx = nx/2      at2 = ffg(1,nx1,1)      at1 = at2*ffg(2,nx1,1)c     at1 = at2      fx(2,1) = at2*q(2,1)      wp = wp + .5*at1*q(2,1)**2c mode numbers ky = ny/2, kx = 0      at2 = ffg(1,1,ny1)      at1 = at2*ffg(2,1,ny1)c     at1 = at2      fx(1,ny1) = at2*q(1,ny1)      wp = wp + .5*at1*q(1,ny1)**2c mode numbers ky = ny/2, kx = nx/2      at2 = ffg(1,nx1,ny1)      at1 = at2*ffg(2,nx1,ny1)c     at1 = at2      fx(2,ny1) = at2*q(2,ny1)      wp = wp + .5*at1*q(2,ny1)**2      we = 4.0*float(nx*ny)*wp      returnc calculate smoothing  110 if (isign.gt.2) go to 150      do 130 k = 2, nyc mode numbers 0 < kx < nx/2 and 0 < ky < ny/2c 110 do 130 k = 2, ny      k1 = ny22 - k      do 120 j = 2, nx      at1 = ffg(2,j,k)      fy(2*j-1,k) = at1*q(2*j-1,k)      fy(2*j,k) = at1*q(2*j,k)      fy(2*j-1,k1) = at1*q(2*j-1,k1)      fy(2*j,k1) = at1*q(2*j,k1)  120 continuec mode number kx = 0      at1 = ffg(2,1,k)      fy(1,k) = at1*q(1,k)      fy(2,k) = at1*q(2,k)c mode number kx = nx/2      at1 = ffg(2,nx1,k)      fy(1,k1) = at1*q(1,k1)      fy(2,k1) = at1*q(2,k1)  130 continuec mode numbers ky = 0, ny/2      do 140 j = 2, nx      at1 = ffg(2,j,1)      fy(2*j-1,1) = at1*q(2*j-1,1)      fy(2*j,1) = at1*q(2*j,1)      at1 = ffg(2,j,ny1)      fy(2*j-1,ny1) = at1*q(2*j-1,ny1)      fy(2*j,ny1) = at1*q(2*j,ny1)  140 continuec mode numbers ky = 0, kx = 0, nx/2      fy(1,1) = ffg(2,1,1)*q(1,1)      fy(2,1) = ffg(2,nx1,1)*q(2,1)c mode numbers ky = ny/2, kx = 0, nx/2      fy(1,ny1) = ffg(2,1,ny1)*q(1,ny1)      fy(2,ny1) = ffg(2,nx1,ny1)*q(2,ny1)      returnc special test case  150 wp = 0.0d0c mode numbers 0 < kx < nx/2 and 0 < ky < ny/2      do 170 k = 2, ny      k1 = ny22 - k      do 160 j = 2, nx      at1 = ffg(2,j,k)      fy(2*j-1,k) = at1*q(2*j-1,k)      fy(2*j,k) = at1*q(2*j,k)      fy(2*j-1,k1) = at1*q(2*j-1,k1)      fy(2*j,k1) = at1*q(2*j,k1)      at2 = ffg(1,j,k)      fx(2*j-1,k) = at2*q(2*j-1,k)      fx(2*j,k) = at2*q(2*j,k)      fx(2*j-1,k1) = at2*q(2*j-1,k1)      fx(2*j,k1) = at2*q(2*j,k1)      wp = wp + (fy(2*j-1,k)*fx(2*j-1,k) + fy(2*j,k)*fx(2*j,k))      wp = wp + (fy(2*j-1,k1)*fx(2*j-1,k1) + fy(2*j,k1)*fx(2*j,k1))  160 continuec mode number kx = 0      at1 = ffg(2,1,k)      fy(1,k) = at1*q(1,k)      fy(2,k) = at1*q(2,k)      at2 = ffg(1,1,k)      fx(1,k) = at2*q(1,k)      fx(2,k) = at2*q(2,k)      wp = wp + (fy(1,k)*fx(1,k) + fy(2,k)*fx(2,k))c mode number kx = nx/2      at1 = ffg(2,nx1,k)      fy(1,k1) = at1*q(1,k1)      fy(2,k1) = at1*q(2,k1)      at2 = ffg(1,nx1,k)      fx(1,k1) = at2*q(1,k1)      fx(2,k1) = at2*q(2,k1)      wp = wp + (fy(1,k1)*fx(1,k1) + fy(2,k1)*fx(2,k1))  170 continuec mode numbers ky = 0, ny/2      do 180 j = 2, nx      at1 = ffg(2,j,1)      fy(2*j-1,1) = at1*q(2*j-1,1)      fy(2*j,1) = at1*q(2*j,1)      at2 = ffg(1,j,1)      fx(2*j-1,1) = at2*q(2*j-1,1)      fx(2*j,1) = at2*q(2*j,1)      wp = wp + (fy(2*j-1,1)*fx(2*j-1,1) + fy(2*j,1)*fx(2*j,1))      at1 = ffg(2,j,ny1)      fy(2*j-1,ny1) = at1*q(2*j-1,ny1)      fy(2*j,ny1) = at1*q(2*j,ny1)      at2 = ffg(1,j,ny1)      fx(2*j-1,ny1) = at2*q(2*j-1,ny1)      fx(2*j,ny1) = at2*q(2*j,ny1)      wp = wp + (fy(2*j-1,ny1)*fx(2*j-1,ny1) + fy(2*j,ny1)*fx(2*j,ny1))  180 continuec mode numbers ky = 0, kx = 0, nx/2      fy(1,1) = ffg(2,1,1)*q(1,1)      fx(1,1) = ffg(1,1,1)*q(1,1)      fy(2,1) = ffg(2,nx1,1)*q(2,1)      fx(2,1) = ffg(1,nx1,1)*q(2,1)      wp = wp + .5*(fy(1,1)*fx(1,1) + fy(2,1)*fx(2,1))c mode numbers ky = ny/2, kx = 0, nx/2      fy(1,ny1) = ffg(2,1,ny1)*q(1,ny1)      fx(1,ny1) = ffg(1,1,ny1)*q(1,ny1)      fy(2,ny1) = ffg(2,nx1,ny1)*q(2,ny1)      fx(2,ny1) = ffg(1,nx1,ny1)*q(2,ny1)      wp = wp + .5*(fy(1,ny1)*fx(1,ny1) + fy(2,ny1)*fx(2,ny1))      we = 4.0*float(nx*ny)*wp      return      endc-----------------------------------------------------------------------      function erfn(x)c this function calculates the real error function, according to thec formulae given in Abramowitz and Stegun, Handbook of Mathematicalc Functions, p. 299.  Error is < 1.5 x 10-7.      implicit none      real xc local data      real erfn, p, a1, a2, a3, a4, a5, t, f      data p, a1, a2 /0.3275911,0.254829592,-0.284496736/      data a3, a4, a5 /1.421413741,-1.453152027,1.061405429/      save p, a1, a2, a3, a4, a5      f = abs(x)      t = 1.0/(1.0 + p*f)      if (f.le.8.) then         erfn = 1.0 - t*(a1 + t*(a2 + t*(a3 + t*(a4 + t*a5))))*exp(-x*x)      else         erfn = 1.0      endif      if (x.lt.0.) erfn = -erfn      return      end      function e1ln(x)c this function calculates the sum of the exponential integral and thec natural logarithm, according to the formulae given in Abramowitz andc Stegun, Handbook of Mathematical Functions, p. 231.c Error is < 2.0 x 10-7.      implicit none      real xc local data      real e1ln, a0, a1, a2, a3, a4, a5, b1, b2, b3, b4, c1, c2, c3, c4      data a0, a1, a2 /-0.57721566,0.99999193,-0.24991055/      data a3, a4, a5 /0.05519968,-0.00976004,0.00107857/      data b1, b2, b3 /8.5733287401,18.0590169730,8.6347608925/      data c1, c2, c3 /9.5733223454,25.6329561486,21.0996530827/      data b4, c4 /0.2677737343,3.9584969228/      save       if (x.le.1.0) then         e1ln = a0 + x*(a1 + x*(a2 + x*(a3 + x*(a4 + x*a5))))      else if (x.lt.50.0) then         e1ln = alog(x) + (exp(-x)/x)*((b4 + x*(b3 + x*(b2 + x*(b1 + x))     1))/(c4 + x*(c3 + x*(c2 + x*(c1 + x)))))      else         e1ln = alog(x)      endif      return      end      function ranorm()c this program calculates a random number y from a gaussian distributionc with zero mean and unit variance, according to the method ofc mueller and box:c    y(k) = (-2*ln(x(k)))**1/2*sin(2*pi*x(k+1))c    y(k+1) = (-2*ln(x(k)))**1/2*cos(2*pi*x(k+1)),c where x is a random number uniformly distributed on (0,1).c written for the ibm by viktor k. decyk, ucla      integer r1,r2,r4,r5      double precision ranorm,h1l,h1u,h2l,r0,r3,asc,bsc,temp      save iflg,r1,r2,r4,r5,h1l,h1u,h2l,r0      data r1,r2,r4,r5 /885098780,1824280461,1396483093,55318673/      data h1l,h1u,h2l /65531.0d0,32767.0d0,65525.0d0/      data iflg,r0 /0,0.0d0/      if (iflg.eq.0) go to 10      ranorm = r0      r0 = 0.0d0      iflg = 0      return   10 isc = 65536      asc = dble(isc)      bsc = asc*asc      i1 = r1 - (r1/isc)*isc      r3 = h1l*dble(r1) + asc*h1u*dble(i1)      i1 = r3/bsc      r3 = r3 - dble(i1)*bsc      bsc = 0.5d0*bsc      i1 = r2/isc      isc = r2 - i1*isc      r0 = h1l*dble(r2) + asc*h1u*dble(isc)      asc = 1.0d0/bsc      isc = r0*asc      r2 = r0 - dble(isc)*bsc      r3 = r3 + (dble(isc) + 2.0d0*h1u*dble(i1))      isc = r3*asc      r1 = r3 - dble(isc)*bsc      temp = dsqrt(-2.0d0*dlog((dble(r1) + dble(r2)*asc)*asc))      isc = 65536      asc = dble(isc)      bsc = asc*asc      i1 = r4 - (r4/isc)*isc      r3 = h2l*dble(r4) + asc*h1u*dble(i1)      i1 = r3/bsc      r3 = r3 - dble(i1)*bsc      bsc = 0.5d0*bsc      i1 = r5/isc      isc = r5 - i1*isc      r0 = h2l*dble(r5) + asc*h1u*dble(isc)      asc = 1.0d0/bsc      isc = r0*asc      r5 = r0 - dble(isc)*bsc      r3 = r3 + (dble(isc) + 2.0d0*h1u*dble(i1))      isc = r3*asc      r4 = r3 - dble(isc)*bsc      r0 = 6.28318530717959d0*((dble(r4) + dble(r5)*asc)*asc)      ranorm = temp*dsin(r0)      r0 = temp*dcos(r0)      iflg = 1      return      endc-----------------------------------------------------------------------      subroutine FORMC2(ffg,f,fpotc,mixup2,sct2,affp,ar,indx1,indy1,nx1d     1,ny1d,nxv,ny2v,nxhy2,nxyh2)c this subroutine calculates the form factor array ffg needed by fieldc solvers with open (vacuum) boundary conditions using hockney's method.c input: isign,ax,ay,affp,nx,ny,nx2v,ny2d, output: ffdc the four green's functions calculated are:c g(kx,ky) = affp*inverse FFT of potrc s(kx,ky) = inverse FFT of the density of a finite-sized particlec gx(kx,ky) = affp*s(kx,ky)*inverse FFT of (x/r)*Erc gy(kx,ky) = affp*s(kx,ky)*inverse FFT of (y/r)*Erc where the fields due to the finite-sized particles are given by fpotcc input: mixup2,sct2,affp,ar,indx1,indy1,nx1d,ny1d,nx2v,ny2v,nxhy2,nxyh2c output: ffg, fc ffg(1,j,k) = potential green's function gc ffg(2,j,k) = finite-size particle shape factor sc ffg(3,j,k) = x component of electric field green's function gxc ffg(4,j,k) = y component of electric field green's function gyc f = scratch array used by FFTc mixup2/sct2 = bit-reverse and sine-cosine table used by FFTc affp = normalization constant = nx*ny/np, where np=number of particlesc ar = half-width of particle in r directionc indx1/indy1 = exponent which determines FFT length in x/y direction,c where 2*nx=2**indx1, 2*ny=2**indy1c nx1d = second dimension of ffg arrays, must be >= nx+1c ny1d = third dimension of field arrays, must be >= ny+1c nxv = half of first dimension of field arrays, must be >= nxc ny2d = second dimension of field arrays, must be >= 2*nyc nxhy2 = maximum of (nx,2*ny)c nxyh2 = maximum of (nx,ny)      implicit none      real ffg, f      integer mixup2      complex sct2      real affp, ar      integer indx1, indy1, nx1d, ny1d, nxv, ny2v, nxhy2, nxyh2      dimension ffg(4,nx1d,ny1d), f(2*nxv,ny2v)      dimension mixup2(nxhy2), sct2(nxyh2)      real fpotc      external fpotcc local data      integer nx, ny, nx1, ny1, nx2, ny2, isign, j, k, j1, k1, ifun      real an, ari, at1, x, y, r      real POTC2, erfn      external POTC2, erfn      nx2 = 2**(indx1)      ny2 = 2**(indy1)      nx = nx2/2      ny = ny2/2      nx1 = nx + 1      ny1 = ny + 1      ari = 0.0      if (ar.gt.0.) ari = 1.0/ar      an = float(nx2*ny2)c calculate potential green's function      ifun = 1      do 20 k = 1, ny2      k1 = k - 1      if (k1.gt.ny) k1 = k1 - ny2      at1 = float(k1)**2      do 10 j = 1, nx2      j1 = j - 1      if (j1.gt.nx) j1 = j1 - nx2      r = sqrt(at1 + float(j1)**2)      f(j,k) = fpotc(r,affp,ari,1)   10 continue   20 continue      isign = -1      call FFT2RX(f,isign,mixup2,sct2,indx1,indy1,nxv,ny2v,nxhy2,nxyh2)      do 40 k = 1, ny1      do 30 j = 1, nx      ffg(ifun,j,k) = an*f(2*j-1,k)   30 continue   40 continue      do 50 k = 2, ny      k1 = ny2 + 2 - k      ffg(ifun,nx1,k) = an*f(1,k1)   50 continue      ffg(ifun,nx1,1) = an*f(2,1)      ffg(ifun,nx1,ny1) = an*f(2,ny1)c calculate particle smoothing function      ifun = ifun + 1      do 70 k = 1, ny2      k1 = k - 1      if (k1.gt.ny) k1 = k1 - ny2      at1 = float(k1)**2      do 60 j = 1, nx2      j1 = j - 1      if (j1.gt.nx) j1 = j1 - nx2      r = sqrt(at1 + float(j1)**2)      f(j,k) = POTC2(r,affp,ari,2)   60 continue   70 continue      isign = -1      call FFT2RX(f,isign,mixup2,sct2,indx1,indy1,nxv,ny2v,nxhy2,nxyh2)      do 90 k = 1, ny1      do 80 j = 1, nx      ffg(ifun,j,k) = an*f(2*j-1,k)   80 continue   90 continue      do 100 k = 2, ny      k1 = ny2 + 2 - k      ffg(ifun,nx1,k) = an*f(1,k1)  100 continue      ffg(ifun,nx1,1) = an*f(2,1)      ffg(ifun,nx1,ny1) = an*f(2,ny1)      ifun = ifun + 1c calculate green's function for x component of electric field      do 120 k = 1, ny2      k1 = k - 1      if (k1.gt.ny) k1 = k1 - ny2      at1 = float(k1)**2      do 110 j = 1, nx2      j1 = j - 1      if (j1.gt.nx) j1 = j1 - nx2      x = float(j1)      r = sqrt(at1 + x*x)      f(j,k) = fpotc(r,affp,ari,3)      if (r.gt.0.) f(j,k) = f(j,k)*(x/r)  110 continue  120 continue      isign = -1      call FFT2RX(f,isign,mixup2,sct2,indx1,indy1,nxv,ny2v,nxhy2,nxyh2)      do 140 k = 1, ny1      do 130 j = 2, nx      ffg(ifun,j,k) = an*f(2*j,k)  130 continue      ffg(ifun,1,k) = an*f(1,k)  140 continue      do 150 k = 2, ny      k1 = ny2 + 2 - k      ffg(ifun,nx1,k) = an*f(1,k1)  150 continue      ffg(ifun,nx1,1) = an*f(2,1)      ffg(ifun,nx1,ny1) = an*f(2,ny1)      ifun = ifun + 1c calculate green's function for y component of electric field      do 170 k = 1, ny2      k1 = k - 1      if (k1.gt.ny) k1 = k1 - ny2      y = float(k1)      at1 = y*y      do 160 j = 1, nx2      j1 = j - 1      if (j1.gt.nx) j1 = j1 - nx2      r = sqrt(at1 + float(j1)**2)      f(j,k) = fpotc(r,affp,ari,3)      if (r.gt.0.) f(j,k) = f(j,k)*(y/r)  160 continue  170 continue      isign = -1      call FFT2RX(f,isign,mixup2,sct2,indx1,indy1,nxv,ny2v,nxhy2,nxyh2)      do 190 k = 2, ny      k1 = ny2 + 2 - k      do 180 j = 1, nx      ffg(ifun,j,k) = an*f(2*j,k)  180 continue      ffg(ifun,nx1,k) = an*f(2,k1)  190 continue      do 200 j = 1, nx      ffg(ifun,j,1) = an*f(2*j-1,1)      ffg(ifun,j,ny1) = an*f(2*j-1,ny1)  200 continue      ffg(ifun,nx1,1) = an*f(2,1)      ffg(ifun,nx1,ny1) = an*f(2,ny1)      return      end