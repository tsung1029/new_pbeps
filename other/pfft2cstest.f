c-----------------------------------------------------------------------      program pfft2cstest      implicit none      integer indx, indy, indnvp, mshare      integer nx, ny, nx1, ny1, nxh, nvp, kyp, kxp2, kblok, jblok      integer nmx, nxy, nmxh, nxhy, nxv, nyv, nxyh, nxvh, nxyh2      integer kyp1, kxp21, ndimc indnvp = exponent which determines number of virtual processorsc mshare = (0,1) = (no,yes) architecture is shared memory      parameter( indx =   7, indy =   8, indnvp =   2, mshare =   0)      parameter(nx=2**indx,ny=2**indy)      parameter(nxh=nx/2,nx1=nx+1,ny1=ny+1)      parameter(nvp=2**indnvp,kyp=(ny-1)/nvp+1,kxp2=(nx-1)/nvp+1)      parameter(kblok=1+mshare*(ny/kyp-1),jblok=1+mshare*(nx/kxp2-1))      parameter(nmx=nx*(ny/nx)+ny*(nx/ny),nxy=nmx/(2-nx/nmx-ny/nmx))      parameter(nmxh=nxh*(ny/nxh)+ny*(nxh/ny))      parameter(nxhy=nmxh/(2-nxh/nmxh-ny/nmxh))      parameter(nxv=nx+2,nyv=ny+2,nxvh=nxv/2,nxyh=nxy/2,nxyh2=2*nxyh)      parameter(kyp1=kyp+1,kxp21=kxp2+1)      parameter(ndim=3)c      integer ntpose, idproc, kstrt, ks, isign      integer i, j, k, l, kk, k1, j1, joff, koff      real epsmax, eps, time, ttp      double precision ranorm      real f, t, g, h, bs, br      real ff, tt, gg, hh      integer mixup      complex sct2      dimension f(nxv,kyp1,kblok), t(nyv,kxp21,jblok)      dimension g(nxv,ny1), h(nyv,nx1)      dimension mixup(nxhy), sct2(nxyh2)      dimension bs(ndim,kxp21,kyp1,kblok), br(ndim,kxp21,kyp1,jblok)      dimension ff(ndim,nxv,kyp1,kblok), tt(ndim,nyv,kxp21,jblok)      dimension gg(ndim,nxv,ny1), hh(ndim,nyv,nx1)c      integer indx1, indy1, nx2, ny2, nx2v, j2blok, kyp2, k2blok, nxhy2      integer mixup2      real t1, f2, cu, g2, g1      complex ft2, bs2, br2, gt2      parameter(indx1=indx+1,indy1=indy+1,nx2=2*nx,ny2=2*ny,nx2v=2*nxv)      parameter(j2blok=1+mshare*(nx/kxp2-1))      parameter(kyp2=(ny2-1)/nvp+1,k2blok=1+mshare*(ny2/kyp2-1))      parameter(nxhy2=2*nxhy)      dimension t1(nyv,kxp21,j2blok)      dimension f2(nx2v,kyp2,k2blok), ft2(ny2,kxp2,j2blok)      dimension mixup2(nxhy2)      dimension bs2(kxp2,kyp2,k2blok), br2(kxp2,kyp2,j2blok)      dimension cu(3,nxv,kyp1,kblok), g2(3,nx2v,kyp2,k2blok)      dimension g1(3,nyv,kxp21,j2blok), gt2(3,ny2,kxp2,j2blok)       complex ffdcc ntpose = (0,1) = (no,yes) input, output data are transposed in pfft2r      data ntpose /0/c initialize for parallel processing      call PPINIT(idproc,nvp)      kstrt = idproc + 1      ks = kstrt - 2c prepare fft tables      call WFST2RINIT(mixup,sct2,indx,indy,nxhy,nxy)      call WPFFT2RINIT(mixup2,sct2,indx1,indy1,nxhy2,nxyh2)c create test function      do 30 k = 1, ny      kk = (k - 1)/kyp      k1 = k - kyp*kk      do 20 j = 1, nx1      g(j,k) = ranorm()      h(k,j) = g(j,k)      do 10 l = 1, kblok      if (kk.eq.(l+ks)) f(j,k1,l) = g(j,k)   10 continue   20 continue   30 continuec last point is special      do 50 j = 1, nx1      g(j,ny1) = ranorm()      h(ny1,j) = g(j,ny1)      do 40 l = 1, kblok      if ((nvp-1).eq.(l+ks)) f(j,kyp1,l) = g(j,ny1)   40 continue   50 continuec create real vector test function      do 45 k = 1, ny      kk = (k - 1)/kyp      k1 = k - kyp*kk      do 35 j = 1, nx1      do 25 i = 1, ndim      gg(i,j,k) = ranorm()      hh(i,k,j) = gg(i,j,k)      do 15 l = 1, kblok      if (kk.eq.(l+ks)) ff(i,j,k1,l) = gg(i,j,k)   15 continue   25 continue   35 continue   45 continuec last point is special      do 75 j = 1, nx1      do 65 i = 1, ndim      gg(i,j,ny1) = ranorm()      hh(i,ny1,j) = gg(i,j,ny1)      do 55 l = 1, kblok      if ((nvp-1).eq.(l+ks)) ff(i,j,kyp1,l) = gg(i,j,ny1)   55 continue   65 continue   75 continue      call TIMERA(-1,'total   ',time)c create doubled array      call PDBLSIN2D(f,f2,nx,ny,kstrt,nxv,kyp,kyp1,kyp2,kblok,k2blok)c     call PDBLCOS2D(f,f2,nx,ny,kstrt,nxv,kyp,kyp1,kyp2,kblok,k2blok)c     cu(2,:,:,:) = fc     call PDBLSIN2B(cu,g2,nx,ny,kstrt,nxv,kyp,kyp1,kyp2,kblok,k2blok)      isign = -1c     f2 = g2(2,:,:,:)      call WPFFT2R(f2,ft2,bs2,br2,isign,ntpose,mixup2,sct2,ttp,indx1,ind     1y1,kstrt,nxv,ny2,kxp2,kyp2,kyp2,j2blok,k2blok,nxhy2,nxyh2)      gt2(2,:,:,:) = ft2      call PDMFIELDD2(ft2,t1,nx,ny,kstrt,ny2,nyv,kxp2,j2blok)c     call PFMFIELDD2(ft2,t1,nx,ny,kstrt,ny2,nyv,kxp2,j2blok)c     call PCMFIELDD2(gt2,g1,nx,ny,kstrt,ny2,nyv,kxp2,j2blok)c     t1 = g1(2,:,:,:)c     gt2 = cmplx(9.,9.)c     g1(3,:,:,:) = t1c-----------------------------------------------------------------------c     call PEMFIELDD2(gt2,g1,ffd,0,nx,ny,kstrt,ny2,nyv,kxp2,j2blok,ny)      call PPMFIELDD2(ft2,t1,nx,ny,kstrt,ny2,nyv,kxp2,j2blok)c     call PBMFIELDD2(gt2,g1,nx,ny,kstrt,ny2,nyv,kxp2,j2blok)c start special test case      isign = -1c-----------------------------------------------------------------------      call WPFSST2R(f,t,bs,br,isign,ntpose,mixup,sct2,ttp,indx,indy,kstr     1t,nxvh,nyv,kxp2,kyp,kyp1,kxp21,jblok,kblok,nxhy,nxy)c     call WPFSCT2R(f,t,bs,br,isign,ntpose,mixup,sct2,ttp,indx,indy,kstrc    1t,nxvh,nyv,kxp2,kyp,kyp1,kxp21,jblok,kblok,nxhy,nxy)c     call WPFCST2R(f,t,bs,br,isign,ntpose,mixup,sct2,ttp,indx,indy,kstrc    1t,nxvh,nyv,kxp2,kyp,kyp1,kxp21,jblok,kblok,nxhy,nxy)c     call WPFCCT2R(f,t,bs,br,isign,ntpose,mixup,sct2,ttp,indx,indy,kstrc    1t,nxvh,nyv,kxp2,kyp,kyp1,kxp21,jblok,kblok,nxhy,nxy)c-----------------------------------------------------------------------c     call PFCT2RXX(f,isign,mixup,sct2,indx,indy,kstrt,kyp,1,kyp,nxvh,kyc    1p1,kblok,nxhy,nxy)c-----------------------------------------------------------------------      call WFSST2RX(g,isign,mixup,sct2,indx,indy,nxvh,nyv,nxhy,nxy)c     call WFSCT2RX(g,isign,mixup,sct2,indx,indy,nxvh,nyv,nxhy,nxy)c     call WFCST2RX(g,isign,mixup,sct2,indx,indy,nxvh,nyv,nxhy,nxy)c     call WFCCT2RX(g,isign,mixup,sct2,indx,indy,nxvh,nyv,nxhy,nxy)c-----------------------------------------------------------------------c     call FCT2RXX(g,isign,mixup,sct2,indx,indy,1,ny1,nxvh,nyv,nxhy,nxy)      do 95 k = 1, ny1      do 85 j = 1, nx1      h(k,j) = g(j,k)   85 continue   95 continuec end special test casec     do 60 i = 1, 100c transform to fourier spacec     isign = -1c     call pfft2r(f,t,sbuff,bbuff,isign,ntpose,mixup,sct,indx,indy,kstrtc    1,nxvh,nyv,kxp,kyp,jblok,kblok,nxhy,nxyh)c     call fft2rx(g,isign,mmixup,ssct,indx,indy,nxvh,nyv,nxhy,nxyh)c transform to real spacec     isign = 1c     call pfft2r(f,t,sbuff,bbuff,isign,ntpose,mixup,sct,indx,indy,kstrtc    1,nxvh,nyv,kxp,kyp,jblok,kblok,nxhy,nxyh)c     call fft2rx(g,isign,mmixup,ssct,indx,indy,nxvh,nyv,nxhy,nxyh)c  60 continue      call TIMERA(1,'total   ',time)      epsmax = 0.0      if (kstrt.gt.ny) go to 100      do 90 l = 1, kblok      koff = kyp*(l + ks)      do 80 k = 1, kyp1      if (((l+ks).lt.(nvp-1)).and.(k.eq.kyp1)) go to 80      k1 = k + koff      do 70 j = 1, nx1      eps = abs(f(j,k,l) - g(j,k1))      if (eps.gt.epsmax) then         write (70+kstrt,*) j,k,k1,f(j,k,l),g(j,k1),eps         epsmax = eps      endif   70 continue   80 continue   90 continue  100 continue      write (70+kstrt,*) 'local epsmax=',epsmax      call PSUM(epsmax,eps,1,1)      write (70+kstrt,*) 'global epsmax=',epsmax      epsmax = 0.0      if (kstrt.gt.nx) go to 140      do 130 l = 1, jblok      joff = kxp2*(l + ks)      do 120 j = 1, kxp21      if (((l+ks).lt.(nvp-1)).and.(j.eq.kxp21)) go to 120      j1 = j + joff      do 110 k = 1, ny1      eps = abs(t(k,j,l) - h(k,j1))      if (eps.gt.epsmax) then         write (70+kstrt,*) k,j,j1,t(k,j,l),h(k,j1),eps         epsmax = eps      endif  110 continue  120 continue  130 continue  140 continue      write (70+kstrt,*) 'local transpose epsmax=',epsmax      call PSUM(epsmax,eps,1,1)      write (70+kstrt,*) 'global transpose epsmax=',epsmaxc compared with doubled arrayc-----------------------------------------------------------------------      epsmax = 0.0      do 930 l = 1, jblok      do 920 j = 1, kxp21c     do 920 j = 1, kxp2      do 910 k = 1, ny1      eps = abs(t(k,j,l) - t1(k,j,l))      if (eps.gt.epsmax) then         write (70+kstrt,*) k,j,t(k,j,l),t1(k,j,l),eps         epsmax = eps      endif  910 continue  920 continue  930 continue      write (70+kstrt,*) 'local doubled f epsmax=',epsmax      call PSUM(epsmax,eps,1,1)      write (70+kstrt,*) 'global doubled f epsmax=',epsmaxc     dimension ft2(ny2,kxp2,j2blok)      epsmax = 0.0      do 960 l = 1, j2blok      do 950 j = 1, kxp2c     do 950 j = 2, kxp2      do 940 k = 1, ny2      eps = abs(ft2(k,j,l) - gt2(2,k,j,l))      if (eps.gt.epsmax) then         write (70+kstrt,*) k,j,ft2(k,j,l),gt2(2,k,j,l),eps         epsmax = eps      endif  940 continue  950 continue  960 continue      write (70+kstrt,*) 'local doubled ft2 epsmax=',epsmax      call PSUM(epsmax,eps,1,1)      write (70+kstrt,*) 'global doubled ft2 epsmax=',epsmaxc verify real vector data      isign = -1c     call WPFCST2R2(ff,tt,bs,br,isign,ntpose,mixup,sct2,ttp,indx,indy,kc    1strt,nxvh,nyv,kxp2,kyp,kyp1,kxp21,jblok,kblok,nxhy,nxy)c     call WPFSCT2R2(ff,tt,bs,br,isign,ntpose,mixup,sct2,ttp,indx,indy,kc    1strt,nxvh,nyv,kxp2,kyp,kyp1,kxp21,jblok,kblok,nxhy,nxy)c     call WFCST2R2(gg,isign,mixup,sct2,indx,indy,nxvh,nyv,nxhy,nxy)c     call WFSCT2R2(gg,isign,mixup,sct2,indx,indy,nxvh,nyv,nxhy,nxy)c      call WPFCST2R3(ff,tt,bs,br,isign,ntpose,mixup,sct2,ttp,indx,indy,k     1strt,nxvh,nyv,kxp2,kyp,kyp1,kxp21,jblok,kblok,nxhy,nxy)c     call WPFSCT2R3(ff,tt,bs,br,isign,ntpose,mixup,sct2,ttp,indx,indy,kc    1strt,nxvh,nyv,kxp2,kyp,kyp1,kxp21,jblok,kblok,nxhy,nxy)      call WFCST2R3(gg,isign,mixup,sct2,indx,indy,nxvh,nyv,nxhy,nxy)c     call WFSCT2R3(gg,isign,mixup,sct2,indx,indy,nxvh,nyv,nxhy,nxy)      epsmax = 0.0      if (kstrt.gt.ny) go to 190      do 180 l = 1, kblok      koff = kyp*(l + ks)      do 170 k = 1, kyp1      if (((l+ks).lt.(nvp-1)).and.(k.eq.kyp1)) go to 170      k1 = k + koff      do 160 j = 1, nx1      do 150 i = 1, ndim      eps = abs(ff(i,j,k,l) - gg(i,j,k1))      if (eps.gt.epsmax) then         write (70+kstrt,*) i,j,k,k1,ff(i,j,k,l),gg(i,j,k1),eps         epsmax = eps      endif  150 continue  160 continue  170 continue  180 continue  190 continue      write (70+kstrt,*) 'local vector epsmax=',epsmax      call PSUM(epsmax,eps,1,1)      write (70+kstrt,*) 'global vector epsmax=',epsmax      call PPEXIT      stop      endc-----------------------------------------------------------------------      subroutine PPINIT(idproc,nvp)c this subroutine initializes parallel processingc input: nvp, output: idprocc idproc = processor idc nvp = number of real or virtual processors requested      implicit none      integer idproc, nvpc get definition of MPI constants      include 'mpif.h'c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=8)c nproc = number of real or virtual processors obtainedc lgrp = current communicatorc mreal = default datatype for realsc mint = default datatype for integersc mcplx = default datatype for complex type      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer ierror, ndprec      save /PPARMS/c ndprec = (0,1) = (no,yes) use (normal,autodouble) precision      data ndprec /1/c this segment is used for shared memory computersc     nproc = nvpc     idproc = 0c this segment is used for mpi computers      if (MPI_STATUS_SIZE.gt.lstat) then         write (2,*) ' status size too small, actual/required = ', lstat     1, MPI_STATUS_SIZE         stop      endifc initialize the MPI execution environment      call MPI_INIT(ierror)      if (ierror.ne.0) stop      lgrp = MPI_COMM_WORLDc determine the rank of the calling process in the communicator      call MPI_COMM_RANK(lgrp,idproc,ierror)c determine the size of the group associated with a communicator      call MPI_COMM_SIZE(lgrp,nproc,ierror)c set default datatypes         mint = MPI_INTEGERc single precision      if (ndprec.eq.0) then         mreal = MPI_REAL         mcplx = MPI_COMPLEXc double precision      else         mreal = MPI_DOUBLE_PRECISION         mcplx = MPI_DOUBLE_COMPLEX      endifc requested number of processors not obtained      if (nproc.ne.nvp) then         write (2,*) ' processor number error: nvp, nproc=', nvp, nproc         call PPEXIT         stop      endif      return      endc-----------------------------------------------------------------------      subroutine PPEXITc this subroutine terminates parallel processing      implicit nonec common block for parallel processing      integer nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc lgrp = current communicator      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworld      integer ierrorc synchronize processes      call MPI_BARRIER(lgrp,ierror)c terminate MPI execution environment      call MPI_FINALIZE(ierror)      return      endc-----------------------------------------------------------------------      subroutine WPFST2RINIT(mixup,sctd,indx,indy,nxhyd,nxyd)c this subroutine calculates tables needed by a two dimensionalc fast real sine and cosine transforms and their inverses.c input: indx, indy, nxhyd, nxydc output: mixup, sctdc mixup = array of bit reversed addressesc sctd = sine/cosine tablec indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc nxhyd = maximum of (nx/2,ny)c nxyd = maximum of (nx,ny)c written by viktor k. decyk, ucla      implicit none      integer indx, indy, nxhyd, nxyd      integer mixup      complex sctd      dimension mixup(nxhyd), sctd(nxyd)c local data      integer indx1, indx1y, nx, ny, nxy, nxhy      integer j, k, lb, ll, jb, it      real dnxy, arg      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      ny = 2**indy      nxy = max0(nx,ny)      nxhy = 2**indx1yc bit-reverse index table: mixup(j) = 1 + reversed bits of (j - 1)      do 20 j = 1, nxhy      lb = j - 1      ll = 0      do 10 k = 1, indx1y      jb = lb/2      it = lb - 2*jb      lb = jb      ll = 2*ll + it   10 continue      mixup(j) = ll + 1   20 continuec sine/cosine table for the angles n*pi/nxy      dnxy = 0.5*6.28318530717959/float(nxy)      do 30 j = 1, nxy      arg = dnxy*float(j - 1)      sctd(j) = cmplx(cos(arg),-sin(arg))   30 continue      return      endc-----------------------------------------------------------------------      subroutine WPFSST2R(f,g,bs,br,isign,ntpose,mixup,sctd,ttp,indx,ind     1y,kstrt,nxvh,nyv,kxp2,kyp,kypd,kxp2d,jblok,kblok,nxhyd,nxyd)c wrapper function for parallel real sine/sine transform      implicit none      integer isign, ntpose, mixup, indx, indy, kstrt, nxvh, nyv      integer kxp2, kyp, kypd, kxp2d, jblok, kblok, nxhyd, nxyd      real f, g, bs, br, ttp      complex sctd      dimension f(2*nxvh,kypd,kblok), g(nyv,kxp2d,jblok)      dimension bs(kxp2+1,kyp+1,kblok), br(kxp2+1,kyp+1,jblok)      dimension mixup(nxhyd), sctd(nxyd)c local data      integer nx, ny, kxpi, kypi      real tf      double precision dtime      data kxpi, kypi /1,1/c calculate range of indices      nx = 2**indx      ny = 2**indyc inverse fourier transform      if (isign.lt.0) thenc perform x sine transform         call PFST2RXX(f,isign,mixup,sctd,indx,indy,kstrt,kyp,kypi,kyp,n     1xvh,kypd,kblok,nxhyd,nxyd)c transpose f array to g         call PWTIMERA(-1,ttp,dtime)         call PRTPOSE(f,g,bs,br,nx,ny,kstrt,2*nxvh,nyv,kxp2,kyp,kxp2d,ky     1pd,jblok,kblok)         call PWTIMERA(1,ttp,dtime)c perform y sine transform         call PFST2RXY(g,isign,mixup,sctd,indx,indy,kstrt,kxp2,kxpi,kxp2     1,nyv,kxp2d,jblok,nxhyd,nxyd)c transpose g array to f         if (ntpose.eq.0) then            call PWTIMERA(-1,tf,dtime)            call PRTPOSE(g,f,br,bs,ny,nx,kstrt,nyv,2*nxvh,kyp,kxp2,kypd,     1kxp2d,kblok,jblok)            call PWTIMERA(1,tf,dtime)         endifc forward fourier transform      else if (isign.gt.0) thenc transpose f array to g         if (ntpose.eq.0) then            call PWTIMERA(-1,tf,dtime)            call PRTPOSE(f,g,bs,br,nx,ny,kstrt,2*nxvh,nyv,kxp2,kyp,kxp2d     1,kypd,jblok,kblok)            call PWTIMERA(1,tf,dtime)         endifc perform y sine transform         call PFST2RXY(g,isign,mixup,sctd,indx,indy,kstrt,kxp2,kxpi,kxp2     1,nyv,kxp2d,jblok,nxhyd,nxyd)c transpose g array to f         call PWTIMERA(-1,ttp,dtime)         call PRTPOSE(g,f,br,bs,ny,nx,kstrt,nyv,2*nxvh,kyp,kxp2,kypd,kxp     12d,kblok,jblok)         call PWTIMERA(1,ttp,dtime)c perform x sine transform         call PFST2RXX(f,isign,mixup,sctd,indx,indy,kstrt,kyp,kypi,kyp,n     1xvh,kypd,kblok,nxhyd,nxyd)      endif      if (ntpose.eq.0) ttp = ttp + tf      return      endc-----------------------------------------------------------------------      subroutine WPFSCT2R(f,g,bs,br,isign,ntpose,mixup,sctd,ttp,indx,ind     1y,kstrt,nxvh,nyv,kxp2,kyp,kypd,kxp2d,jblok,kblok,nxhyd,nxyd)c wrapper function for parallel real sine/cosine transform      implicit none      integer isign, ntpose, mixup, indx, indy, kstrt, nxvh, nyv      integer kxp2, kyp, kypd, kxp2d, jblok, kblok, nxhyd, nxyd      real f, g, bs, br, ttp      complex sctd      dimension f(2*nxvh,kypd,kblok), g(nyv,kxp2d,jblok)      dimension bs(kxp2+1,kyp+1,kblok), br(kxp2+1,kyp+1,jblok)      dimension mixup(nxhyd), sctd(nxyd)c local data      integer nx, ny, kxpi, kypi      real tf      double precision dtime      data kxpi, kypi /1,1/c calculate range of indices      nx = 2**indx      ny = 2**indyc inverse fourier transform      if (isign.lt.0) thenc perform x sine transform         call PFST2RXX(f,isign,mixup,sctd,indx,indy,kstrt,kyp,kypi,kyp,n     1xvh,kypd,kblok,nxhyd,nxyd)c transpose f array to g         call PWTIMERA(-1,ttp,dtime)         call PRTPOSE(f,g,bs,br,nx,ny,kstrt,2*nxvh,nyv,kxp2,kyp,kxp2d,ky     1pd,jblok,kblok)         call PWTIMERA(1,ttp,dtime)c perform y cosine transform         call PFCT2RXY(g,isign,mixup,sctd,indx,indy,kstrt,kxp2,kxpi,kxp2     1,nyv,kxp2d,jblok,nxhyd,nxyd)c transpose g array to f         if (ntpose.eq.0) then            call PWTIMERA(-1,tf,dtime)            call PRTPOSE(g,f,br,bs,ny,nx,kstrt,nyv,2*nxvh,kyp,kxp2,kypd,     1kxp2d,kblok,jblok)            call PWTIMERA(1,tf,dtime)         endifc forward fourier transform      else if (isign.gt.0) thenc transpose f array to g         if (ntpose.eq.0) then            call PWTIMERA(-1,tf,dtime)            call PRTPOSE(f,g,bs,br,nx,ny,kstrt,2*nxvh,nyv,kxp2,kyp,kxp2d     1,kypd,jblok,kblok)            call PWTIMERA(1,tf,dtime)         endifc perform y cosine transform         call PFCT2RXY(g,isign,mixup,sctd,indx,indy,kstrt,kxp2,kxpi,kxp2     1,nyv,kxp2d,jblok,nxhyd,nxyd)c transpose g array to f         call PWTIMERA(-1,ttp,dtime)         call PRTPOSE(g,f,br,bs,ny,nx,kstrt,nyv,2*nxvh,kyp,kxp2,kypd,kxp     12d,kblok,jblok)         call PWTIMERA(1,ttp,dtime)c perform x sine transform         call PFST2RXX(f,isign,mixup,sctd,indx,indy,kstrt,kyp,kypi,kyp,n     1xvh,kypd,kblok,nxhyd,nxyd)      endif      if (ntpose.eq.0) ttp = ttp + tf      return      endc-----------------------------------------------------------------------      subroutine WPFCST2R(f,g,bs,br,isign,ntpose,mixup,sctd,ttp,indx,ind     1y,kstrt,nxvh,nyv,kxp2,kyp,kypd,kxp2d,jblok,kblok,nxhyd,nxyd)c wrapper function for parallel real cosine/sine transform      implicit none      integer isign, ntpose, mixup, indx, indy, kstrt, nxvh, nyv      integer kxp2, kyp, kypd, kxp2d, jblok, kblok, nxhyd, nxyd      real f, g, bs, br, ttp      complex sctd      dimension f(2*nxvh,kypd,kblok), g(nyv,kxp2d,jblok)      dimension bs(kxp2+1,kyp+1,kblok), br(kxp2+1,kyp+1,jblok)      dimension mixup(nxhyd), sctd(nxyd)c local data      integer nx, ny, kxpi, kypi      real tf      double precision dtime      data kxpi, kypi /1,1/c calculate range of indices      nx = 2**indx      ny = 2**indyc inverse fourier transform      if (isign.lt.0) thenc perform x cosine transform         call PFCT2RXX(f,isign,mixup,sctd,indx,indy,kstrt,kyp,kypi,kyp,n     1xvh,kypd,kblok,nxhyd,nxyd)c transpose f array to g         call PWTIMERA(-1,ttp,dtime)         call PRTPOSE(f,g,bs,br,nx,ny,kstrt,2*nxvh,nyv,kxp2,kyp,kxp2d,ky     1pd,jblok,kblok)         call PWTIMERA(1,ttp,dtime)c perform y sine transform         call PFST2RXY(g,isign,mixup,sctd,indx,indy,kstrt,kxp2,kxpi,kxp2     1,nyv,kxp2d,jblok,nxhyd,nxyd)c transpose g array to f         if (ntpose.eq.0) then            call PWTIMERA(-1,tf,dtime)            call PRTPOSE(g,f,br,bs,ny,nx,kstrt,nyv,2*nxvh,kyp,kxp2,kypd,     1kxp2d,kblok,jblok)            call PWTIMERA(1,tf,dtime)         endifc forward fourier transform      else if (isign.gt.0) thenc transpose f array to g         if (ntpose.eq.0) then            call PWTIMERA(-1,tf,dtime)            call PRTPOSE(f,g,bs,br,nx,ny,kstrt,2*nxvh,nyv,kxp2,kyp,kxp2d     1,kypd,jblok,kblok)            call PWTIMERA(1,tf,dtime)         endifc perform y sine transform         call PFST2RXY(g,isign,mixup,sctd,indx,indy,kstrt,kxp2,kxpi,kxp2     1,nyv,kxp2d,jblok,nxhyd,nxyd)c transpose g array to f         call PWTIMERA(-1,ttp,dtime)         call PRTPOSE(g,f,br,bs,ny,nx,kstrt,nyv,2*nxvh,kyp,kxp2,kypd,kxp     12d,kblok,jblok)         call PWTIMERA(1,ttp,dtime)c perform x cosine transform         call PFCT2RXX(f,isign,mixup,sctd,indx,indy,kstrt,kyp,kypi,kyp,n     1xvh,kypd,kblok,nxhyd,nxyd)      endif      if (ntpose.eq.0) ttp = ttp + tf      return      endc-----------------------------------------------------------------------      subroutine WPFCCT2R(f,g,bs,br,isign,ntpose,mixup,sctd,ttp,indx,ind     1y,kstrt,nxvh,nyv,kxp2,kyp,kypd,kxp2d,jblok,kblok,nxhyd,nxyd)c wrapper function for parallel real cosine/cosine transform      implicit none      integer isign, ntpose, mixup, indx, indy, kstrt, nxvh, nyv      integer kxp2, kyp, kypd, kxp2d, jblok, kblok, nxhyd, nxyd      real f, g, bs, br, ttp      complex sctd      dimension f(2*nxvh,kypd,kblok), g(nyv,kxp2d,jblok)      dimension bs(kxp2+1,kyp+1,kblok), br(kxp2+1,kyp+1,jblok)      dimension mixup(nxhyd), sctd(nxyd)c local data      integer nx, ny, kxpi, kypi      real tf      double precision dtime      data kxpi, kypi /1,1/c calculate range of indices      nx = 2**indx      ny = 2**indyc inverse fourier transform      if (isign.lt.0) thenc perform x cosine transform         call PFCT2RXX(f,isign,mixup,sctd,indx,indy,kstrt,kyp,kypi,kyp,n     1xvh,kypd,kblok,nxhyd,nxyd)c transpose f array to g         call PWTIMERA(-1,ttp,dtime)         call PRTPOSE(f,g,bs,br,nx,ny,kstrt,2*nxvh,nyv,kxp2,kyp,kxp2d,ky     1pd,jblok,kblok)         call PWTIMERA(1,ttp,dtime)c perform y cosine transform         call PFCT2RXY(g,isign,mixup,sctd,indx,indy,kstrt,kxp2,kxpi,kxp2     1,nyv,kxp2d,jblok,nxhyd,nxyd)c transpose g array to f         if (ntpose.eq.0) then            call PWTIMERA(-1,tf,dtime)            call PRTPOSE(g,f,br,bs,ny,nx,kstrt,nyv,2*nxvh,kyp,kxp2,kypd,     1kxp2d,kblok,jblok)            call PWTIMERA(1,tf,dtime)         endifc forward fourier transform      else if (isign.gt.0) thenc transpose f array to g         if (ntpose.eq.0) then            call PWTIMERA(-1,tf,dtime)            call PRTPOSE(f,g,bs,br,nx,ny,kstrt,2*nxvh,nyv,kxp2,kyp,kxp2d     1,kypd,jblok,kblok)            call PWTIMERA(1,tf,dtime)         endifc perform y cosine transform         call PFCT2RXY(g,isign,mixup,sctd,indx,indy,kstrt,kxp2,kxpi,kxp2     1,nyv,kxp2d,jblok,nxhyd,nxyd)c transpose g array to f         call PWTIMERA(-1,ttp,dtime)         call PRTPOSE(g,f,br,bs,ny,nx,kstrt,nyv,2*nxvh,kyp,kxp2,kypd,kxp     12d,kblok,jblok)         call PWTIMERA(1,ttp,dtime)c perform x cosine transform         call PFCT2RXX(f,isign,mixup,sctd,indx,indy,kstrt,kyp,kypi,kyp,n     1xvh,kypd,kblok,nxhyd,nxyd)      endif      if (ntpose.eq.0) ttp = ttp + tf      return      endc-----------------------------------------------------------------------      subroutine PFST2RXX(f,isign,mixup,sctd,indx,indy,kstrt,kyp,kypi,ky     1pp,nxvh,kypd,kblok,nxhyd,nxyd)c this subroutine performs the x part of a two dimensional fast realc sine transform and its inverse, for a subset of y,c using real arithmetic, for data which is distributed in blocksc algorithm is described in Numerical Recipies in Fortran, Second Ed.,c by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, c [Cambridge Univ. Press, 1992], p. 508.c for isign = (-1,1), input: all, output: fc approximate flop count: N*(5*log2(N) + 18)/nvpc where N = (nx/2)*nyc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, an inverse sine transform is performedc f(n,k,i) = (1/nx*ny)*sum(f(j,k,i)*sin(pi*n*j/nx))c if isign = 1, a forward sine transform is performedc f(j,k,i) = sum(f(n,k,i)*sin(pi*n*j/nx))c mixup = array of bit reversed addressesc sctd = sine/cosine tablec kstrt = starting data block numberc kyp = number of data values per block in yc kypi = initial y index usedc kypp = number of y indices usedc nxvh = first dimension of f >= nx/2 + 1c kypd = second dimension of f >= kyp + 1c kblok = number of data blocks in yc nxhyd = maximum of (nx/2,ny)c nxyd = maximum of (nx,ny)c written by viktor k. decyk, ucla      implicit none      integer isign, mixup, indx, indy, kstrt, kyp, kypi, kypp      integer nxvh, kypd, kblok, nxhyd, nxyd      real f      complex sctd      dimension f(2*nxvh,kypd,kblok)      dimension mixup(nxhyd), sctd(nxyd)c local data      integer indx1, indx1y, nx, nxh, nxhh, nx3, ny, nxy, nxhy, ks, kypt      integer i, j, k, l, m, km, kmr, nrx, j1, j2, ns, ns2, k1, k2, kyps      real at1, at2, t2, t3, t4, t5, t6, ani, sum1      complex t1      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nx3 = nx + 3      ny = 2**indy      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      kyps = kypi + kypp - 1      if (kstrt.gt.ny) return      if (isign.eq.0) returnc create auxiliary array in x      kmr = nxy/nx      kypt = kyps      do 30 l = 1, kblok      if ((kyps+kyp*(l+ks)).eq.ny) kypt = kyps + 1      do 20 k = kypi, kypt      do 10 j = 2, nxh      j1 = 1 + kmr*(j - 1)      at2 = f(nx+2-j,k,l)      at1 = f(j,k,l) + at2      at2 = f(j,k,l) - at2      at1 = -aimag(sctd(j1))*at1      at2 = .5*at2      f(j,k,l) = at1 + at2      f(nx+2-j,k,l) = at1 - at2   10 continue      f(1,k,l) = 0.0      f(nxh+1,k,l) = 2.0*f(nxh+1,k,l)   20 continue   30 continuec bit-reverse array elements in x      nrx = nxhy/nxh      kypt = kyps      do 60 l = 1, kblok      if ((kyps+kyp*(l+ks)).eq.ny) kypt = kyps + 1      do 50 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 50      do 40 k = kypi, kypt      t2 = f(2*j1-1,k,l)      t3 = f(2*j1,k,l)      f(2*j1-1,k,l) = f(2*j-1,k,l)      f(2*j1,k,l) = f(2*j,k,l)      f(2*j-1,k,l) = t2      f(2*j,k,l) = t3   40 continue   50 continue   60 continuec first transform in x      nrx = nxy/nxh      do 110 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = 2*km*nrx      kypt = kyps      do 100 l = 1, kblok      if ((kyps+kyp*(l+ks)).eq.ny) kypt = kyps + 1      do 90 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 80 j = 1, ns      j1 = j + k1      j2 = j + k2      t1 = sctd(1+kmr*(j-1))      do 70 i = kypi, kypt      t2 = real(t1)*f(2*j2-1,i,l) - aimag(t1)*f(2*j2,i,l)      t3 = aimag(t1)*f(2*j2-1,i,l) + real(t1)*f(2*j2,i,l)      f(2*j2-1,i,l) = f(2*j1-1,i,l) - t2      f(2*j2,i,l) = f(2*j1,i,l) - t3      f(2*j1-1,i,l) = f(2*j1-1,i,l) + t2      f(2*j1,i,l) = f(2*j1,i,l) + t3   70 continue   80 continue   90 continue  100 continue  110 continuec unscramble coefficients and normalizec inverse fourier transform      if (isign.lt.0) then         kmr = nxy/nxh         ani = 1./float(2*nx*ny)         kypt = kyps         do 150 l = 1, kblok         if ((kyps+kyp*(l+ks)).eq.ny) kypt = kyps + 1         do 130 j = 2, nxhh         t1 = cmplx(aimag(sctd(1+kmr*(j-1))),-real(sctd(1+kmr*(j-1))))         do 120 k = kypi, kypt         t4 = f(nx3-2*j,k,l)         t5 = -f(nx3-2*j+1,k,l)         t2 = f(2*j-1,k,l) + t4         t3 = f(2*j,k,l) + t5         t6 = f(2*j-1,k,l) - t4         t5 = f(2*j,k,l) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         f(2*j-1,k,l) = ani*(t2 + t4)         f(2*j,k,l) = ani*(t3 + t5)         f(nx3-2*j,k,l) = ani*(t2 - t4)         f(nx3-2*j+1,k,l) = ani*(t5 - t3)  120    continue  130    continue         ani = 2.*ani         do 140 k = kypi, kypt         f(nxh+1,k,l) = ani*f(nxh+1,k,l)         f(nxh+2,k,l) = -ani*f(nxh+2,k,l)         t2 = ani*(f(1,k,l) + f(2,k,l))         f(2,k,l) = ani*(f(1,k,l) - f(2,k,l))         f(1,k,l) = t2         f(nx+1,k,l) = ani*f(nx+1,k,l)  140    continue  150    continuec forward fourier transform      else if (isign.gt.0) then         kmr = nxy/nxh         kypt = kyps         do 190 l = 1, kblok         if ((kyps+kyp*(l+ks)).eq.ny) kypt = kyps + 1         do 170 j = 2, nxhh         t1 = cmplx(aimag(sctd(1+kmr*(j-1))),-real(sctd(1+kmr*(j-1))))         do 160 k = kypi, kypt         t4 = f(nx3-2*j,k,l)         t5 = -f(nx3-2*j+1,k,l)         t2 = f(2*j-1,k,l) + t4         t3 = f(2*j,k,l) + t5         t6 = f(2*j-1,k,l) - t4         t5 = f(2*j,k,l) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         f(2*j-1,k,l) = t2 + t4         f(2*j,k,l) = t3 + t5         f(nx3-2*j,k,l) = t2 - t4         f(nx3-2*j+1,k,l) = t5 - t3  160    continue  170    continue         do 180 k = kypi, kypt         f(nxh+1,k,l) = 2.0*f(nxh+1,k,l)         f(nxh+2,k,l) = -2.0*f(nxh+2,k,l)         t2 = 2.0*(f(1,k,l) + f(2,k,l))         f(2,k,l) = 2.0*(f(1,k,l) - f(2,k,l))         f(1,k,l) = t2         f(nx+1,k,l) = 2.0*f(nx+1,k,l)  180    continue  190    continue      endifc perform recursion for sine transform      kypt = kyps      do 220 l = 1, kblok      if ((kyps+kyp*(l+ks)).eq.ny) kypt = kyps + 1      do 210 k = kypi, kypt      sum1 = .5*f(1,k,l)      f(1,k,l) = 0.0      f(2,k,l) = sum1      do 200 j = 2, nxh      sum1 = sum1 + f(2*j-1,k,l)      f(2*j-1,k,l) = -f(2*j,k,l)      f(2*j,k,l) = sum1  200 continue      f(nx+1,k,l) = 0.0  210 continue  220 continue      return      endc-----------------------------------------------------------------------      subroutine PFCT2RXX(f,isign,mixup,sctd,indx,indy,kstrt,kyp,kypi,ky     1pp,nxvh,kypd,kblok,nxhyd,nxyd)c this subroutine performs the x part of a two dimensional fast realc cosine transform and its inverse, for a subset of y,c using real arithmetic, for data which is distributed in blocksc algorithm is described in Numerical Recipies in Fortran, Second Ed.,c by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, c [Cambridge Univ. Press, 1992], p. 508.c for isign = (-1,1), input: all, output: fc approximate flop count: N*(5*log2(N) + 18)/nvpc where N = (nx/2)*nyc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, an inverse cosine transform is performedc f(n,k,i) = (1/nx*ny)*(.5*f(1,k,i) + ((-1)**n)*f(nx+1,k,i)c            + sum(f(j,k,i)*cos(pi*n*j/nx)))c if isign = 1, a forward cosine transform is performedc f(j,k,i) = 2*(.5*f(1,k,i) + ((-1)**j)*f(n+1,k,i) + sum(f(n,k,i)*c            cos(pi*n*j/nx))c mixup = array of bit reversed addressesc sctd = sine/cosine tablec kstrt = starting data block numberc kyp = number of data values per block in yc kypi = initial y index usedc kypp = number of y indices usedc nxvh = first dimension of f >= nx/2 + 1c kypd = second dimension of f >= kyp+1c kblok = number of data blocks in yc nxhyd = maximum of (nx/2,ny)c nxyd = maximum of (nx,ny)c written by viktor k. decyk, ucla      implicit none      integer isign, mixup, indx, indy, kstrt, kyp, kypi, kypp      integer nxvh, kypd, kblok, nxhyd, nxyd      real f      complex sctd      dimension f(2*nxvh,kypd,kblok)      dimension mixup(nxhyd), sctd(nxyd)c local data      integer indx1, indx1y, nx, nxh, nxhh, nx3, ny, nxy, nxhy, ks, kypt      integer i, j, k, l, m, km, kmr, nrx, j1, j2, ns, ns2, k1, k2, kyps      real at1, at2, t2, t3, t4, t5, t6, ani, sum1      complex t1      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nx3 = nx + 3      ny = 2**indy      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      kyps = kypi + kypp - 1      if (kstrt.gt.ny) return      if (isign.eq.0) returnc create auxiliary array in x      kmr = nxy/nx      kypt = kyps      do 30 l = 1, kblok      if ((kyps+kyp*(l+ks)).eq.ny) kypt = kyps + 1      do 20 k = kypi, kypt      sum1 = .5*(f(1,k,l) - f(nx+1,k,l))      do 10 j = 2, nxh      j1 = 1 + kmr*(j - 1)      at2 = f(nx+2-j,k,l)      at1 = f(j,k,l) + at2      at2 = f(j,k,l) - at2      sum1 = sum1 + real(sctd(j1))*at2      at2 = -aimag(sctd(j1))*at2      at1 = .5*at1      f(j,k,l) = at1 - at2      f(nx+2-j,k,l) = at1 + at2   10 continue      f(1,k,l) = .5*(f(1,k,l) + f(nx+1,k,l))      f(nx+1,k,l) = sum1   20 continue   30 continuec bit-reverse array elements in x      nrx = nxhy/nxh      kypt = kyps      do 60 l = 1, kblok      if ((kyps+kyp*(l+ks)).eq.ny) kypt = kyps + 1      do 50 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 50      do 40 k = kypi, kypt      t2 = f(2*j1-1,k,l)      t3 = f(2*j1,k,l)      f(2*j1-1,k,l) = f(2*j-1,k,l)      f(2*j1,k,l) = f(2*j,k,l)      f(2*j-1,k,l) = t2      f(2*j,k,l) = t3   40 continue   50 continue   60 continuec first transform in x      nrx = nxy/nxh      do 110 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = 2*km*nrx      kypt = kyps      do 100 l = 1, kblok      if ((kyps+kyp*(l+ks)).eq.ny) kypt = kyps + 1      do 90 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 80 j = 1, ns      j1 = j + k1      j2 = j + k2      t1 = sctd(1+kmr*(j-1))      do 70 i = kypi, kypt      t2 = real(t1)*f(2*j2-1,i,l) - aimag(t1)*f(2*j2,i,l)      t3 = aimag(t1)*f(2*j2-1,i,l) + real(t1)*f(2*j2,i,l)      f(2*j2-1,i,l) = f(2*j1-1,i,l) - t2      f(2*j2,i,l) = f(2*j1,i,l) - t3      f(2*j1-1,i,l) = f(2*j1-1,i,l) + t2      f(2*j1,i,l) = f(2*j1,i,l) + t3   70 continue   80 continue   90 continue  100 continue  110 continuec unscramble coefficients and normalizec inverse fourier transform      if (isign.lt.0) then         kmr = nxy/nxh         ani = 1./float(2*nx*ny)         kypt = kyps         do 150 l = 1, kblok         if ((kyps+kyp*(l+ks)).eq.ny) kypt = kyps + 1         do 130 j = 2, nxhh         t1 = cmplx(aimag(sctd(1+kmr*(j-1))),-real(sctd(1+kmr*(j-1))))         do 120 k = kypi, kypt         t4 = f(nx3-2*j,k,l)         t5 = -f(nx3-2*j+1,k,l)         t2 = f(2*j-1,k,l) + t4         t3 = f(2*j,k,l) + t5         t6 = f(2*j-1,k,l) - t4         t5 = f(2*j,k,l) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         f(2*j-1,k,l) = ani*(t2 + t4)         f(2*j,k,l) = ani*(t3 + t5)         f(nx3-2*j,k,l) = ani*(t2 - t4)         f(nx3-2*j+1,k,l) = ani*(t5 - t3)  120    continue  130    continue         ani = 2.*ani         do 140 k = kypi, kypt         f(nxh+1,k,l) = ani*f(nxh+1,k,l)         f(nxh+2,k,l) = -ani*f(nxh+2,k,l)         t2 = ani*(f(1,k,l) + f(2,k,l))         f(2,k,l) = ani*(f(1,k,l) - f(2,k,l))         f(1,k,l) = t2         f(nx+1,k,l) = ani*f(nx+1,k,l)  140    continue  150    continuec forward fourier transform      else if (isign.gt.0) then         kmr = nxy/nxh         kypt = kyps         do 190 l = 1, kblok         if ((kyps+kyp*(l+ks)).eq.ny) kypt = kyps + 1         do 170 j = 2, nxhh         t1 = cmplx(aimag(sctd(1+kmr*(j-1))),-real(sctd(1+kmr*(j-1))))         do 160 k = kypi, kypt         t4 = f(nx3-2*j,k,l)         t5 = -f(nx3-2*j+1,k,l)         t2 = f(2*j-1,k,l) + t4         t3 = f(2*j,k,l) + t5         t6 = f(2*j-1,k,l) - t4         t5 = f(2*j,k,l) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         f(2*j-1,k,l) = t2 + t4         f(2*j,k,l) = t3 + t5         f(nx3-2*j,k,l) = t2 - t4         f(nx3-2*j+1,k,l) = t5 - t3  160    continue  170    continue         do 180 k = kypi, kypt         f(nxh+1,k,l) = 2.0*f(nxh+1,k,l)         f(nxh+2,k,l) = -2.0*f(nxh+2,k,l)         t2 = 2.0*(f(1,k,l) + f(2,k,l))         f(2,k,l) = 2.0*(f(1,k,l) - f(2,k,l))         f(1,k,l) = t2         f(nx+1,k,l) = 2.0*f(nx+1,k,l)  180    continue  190    continue      endifc perform recursion for cosine transform      kypt = kyps      do 220 l = 1, kblok      if ((kyps+kyp*(l+ks)).eq.ny) kypt = kyps + 1      do 210 k = kypi, kypt      sum1 = f(nx+1,k,l)      f(nx+1,k,l) = f(2,k,l)      f(2,k,l) = sum1      do 200 j = 2, nxh      sum1 = sum1 - f(2*j,k,l)      f(2*j,k,l) = sum1  200 continue  210 continue  220 continue      return      endc-----------------------------------------------------------------------      subroutine PFST2RXY(g,isign,mixup,sctd,indx,indy,kstrt,kxp,kxpi,kx     1pp,nyv,kxpd,jblok,nxhyd,nxyd)c this subroutine performs the y part of a two dimensional fast realc sine transform and its inverse, for a subset of x,c using real arithmetic, for data which is distributed in blocksc algorithm is described in Numerical Recipies in Fortran, Second Ed.,c by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, c [Cambridge Univ. Press, 1992], p. 508.c for isign = (-1,1), input: all, output: fc approximate flop count: N*(5*log2(N) + 18)/nvpc where N = (nx/2)*nyc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, an inverse sine transform is performedc g(m,n,i) = sum(g(k,n,i)*sin(pi*m*k/ny))c if isign = 1, a forward sine transform is performedc g(k,n,i) = sum(g(m,n,i)*sin(pi*m*k/ny))c mixup = array of bit reversed addressesc sctd = sine/cosine tablec kstrt = starting data block numberc kxp = number of data values per block in xc kxpi = initial x index usedc kxpp = number of x indices usedc nyv = first dimension of g >= ny + 1c kxpd = second dimension of f >= kxp + 1c jblok = number of data blocks in xc nxhyd = maximum of (nx/2,ny)c nxyd = maximum of (nx,ny)c written by viktor k. decyk, ucla      implicit none      integer isign, mixup, indx, indy, kstrt, kxp, kxpi, kxpp      integer nyv, kxpd, jblok, nxhyd, nxyd      real g      complex sctd      dimension g(nyv,kxpd,jblok)      dimension mixup(nxhyd), sctd(nxyd)c local data      integer indx1, indy1, indx1y, nx, ny, nyh, nyhh, ny3, nxy, nxhy      integer i, j, k, l, m, ks, km, kmr, nry, j1, j2, ns, ns2, k1, k2      integer kxps, kxpt      real at1, at2, t2, t3, t4, t5, t6, ani, sum1      complex t1      indx1 = indx - 1      indy1 = indy - 1      indx1y = max0(indx1,indy)      nx = 2**indx      ny = 2**indy      nyh = ny/2      nyhh = ny/4      ny3 = ny + 3      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      kxps = kxpi + kxpp - 1      if (kstrt.gt.nx) return      if (isign.eq.0) returnc create auxiliary array in y      kmr = nxy/ny      kxpt = kxps      do 30 l = 1, jblok      if ((kxps+kxp*(l+ks)).eq.nx) kxpt = kxps + 1      do 20 j = kxpi, kxpt      do 10 k = 2, nyh      k1 = 1 + kmr*(k - 1)      at2 = g(ny+2-k,j,l)      at1 = g(k,j,l) + at2      at2 = g(k,j,l) - at2      at1 = -aimag(sctd(k1))*at1      at2 = .5*at2      g(k,j,l) = at1 + at2      g(ny+2-k,j,l) = at1 - at2   10 continue      g(1,j,l) = 0.0      g(nyh+1,j,l) = 2.0*g(nyh+1,j,l)   20 continue   30 continuec bit-reverse array elements in y      nry = nxhy/nyh      kxpt = kxps      do 60 l = 1, jblok      if ((kxps+kxp*(l+ks)).eq.nx) kxpt = kxps + 1      do 50 k = 1, nyh      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 50      do 40 j = kxpi, kxpt      t2 = g(2*k1-1,j,l)      t3 = g(2*k1,j,l)      g(2*k1-1,j,l) = g(2*k-1,j,l)      g(2*k1,j,l) = g(2*k,j,l)      g(2*k-1,j,l) = t2      g(2*k,j,l) = t3   40 continue   50 continue   60 continuec first transform in y      nry = nxy/nyh      do 110 m = 1, indy1      ns = 2**(m - 1)      ns2 = ns + ns      km = nyhh/ns      kmr = 2*km*nry      kxpt = kxps      do 100 l = 1, jblok      if ((kxps+kxp*(l+ks)).eq.nx) kxpt = kxps + 1      do 90 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 80 j = 1, ns      j1 = j + k1      j2 = j + k2      t1 = sctd(1+kmr*(j-1))      do 70 i = kxpi, kxpt      t2 = real(t1)*g(2*j2-1,i,l) - aimag(t1)*g(2*j2,i,l)      t3 = aimag(t1)*g(2*j2-1,i,l) + real(t1)*g(2*j2,i,l)      g(2*j2-1,i,l) = g(2*j1-1,i,l) - t2      g(2*j2,i,l) = g(2*j1,i,l) - t3      g(2*j1-1,i,l) = g(2*j1-1,i,l) + t2      g(2*j1,i,l) = g(2*j1,i,l) + t3   70 continue   80 continue   90 continue  100 continue  110 continuec unscramble coefficients and normalizec inverse fourier transform      if (isign.lt.0) then         kmr = nxy/nyh         ani = 0.5         kxpt = kxps         do 150 l = 1, jblok         if ((kxps+kxp*(l+ks)).eq.nx) kxpt = kxps + 1         do 130 k = 2, nyhh         t1 = cmplx(aimag(sctd(1+kmr*(k-1))),-real(sctd(1+kmr*(k-1))))         do 120 j = kxpi, kxpt         t4 = g(ny3-2*k,j,l)         t5 = -g(ny3-2*k+1,j,l)         t2 = g(2*k-1,j,l) + t4         t3 = g(2*k,j,l) + t5         t6 = g(2*k-1,j,l) - t4         t5 = g(2*k,j,l) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         g(2*k-1,j,l) = ani*(t2 + t4)         g(2*k,j,l) = ani*(t3 + t5)         g(ny3-2*k,j,l) = ani*(t2 - t4)         g(ny3-2*k+1,j,l) = ani*(t5 - t3)  120    continue  130    continue         do 140 j = kxpi, kxpt         g(nyh+1,j,l) = g(nyh+1,j,l)         g(nyh+2,j,l) = -g(nyh+2,j,l)         t2 = g(1,j,l) + g(2,j,l)         g(2,j,l) = g(1,j,l) - g(2,j,l)         g(1,j,l) = t2         g(ny+1,j,l) = g(ny+1,j,l)  140    continue  150    continuec forward fourier transform      else if (isign.gt.0) then         kmr = nxy/nyh         kxpt = kxps         do 190 l = 1, jblok         if ((kxps+kxp*(l+ks)).eq.nx) kxpt = kxps + 1         do 170 k = 2, nyhh         t1 = cmplx(aimag(sctd(1+kmr*(k-1))),-real(sctd(1+kmr*(k-1))))         do 160 j = kxpi, kxpt         t4 = g(ny3-2*k,j,l)         t5 = -g(ny3-2*k+1,j,l)         t2 = g(2*k-1,j,l) + t4         t3 = g(2*k,j,l) + t5         t6 = g(2*k-1,j,l) - t4         t5 = g(2*k,j,l) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         g(2*k-1,j,l) = t2 + t4         g(2*k,j,l) = t3 + t5         g(ny3-2*k,j,l) = t2 - t4         g(ny3-2*k+1,j,l) = t5 - t3  160    continue  170    continue         do 180 j = kxpi, kxpt         g(nyh+1,j,l) = 2.0*g(nyh+1,j,l)         g(nyh+2,j,l) = -2.0*g(nyh+2,j,l)         t2 = 2.0*(g(1,j,l) + g(2,j,l))         g(2,j,l) = 2.0*(g(1,j,l) - g(2,j,l))         g(1,j,l) = t2         g(ny+1,j,l) = 2.0*g(ny+1,j,l)  180    continue  190    continue      endifc perform recursion for sine transform      kxpt = kxps      do 220 l = 1, jblok      if ((kxps+kxp*(l+ks)).eq.nx) kxpt = kxps + 1      do 210 j = kxpi, kxpt      sum1 = .5*g(1,j,l)      g(1,j,l) = 0.0      g(2,j,l) = sum1      do 200 k = 2, nyh      sum1 = sum1 + g(2*k-1,j,l)      g(2*k-1,j,l) = -g(2*k,j,l)      g(2*k,j,l) = sum1  200 continue      g(ny+1,j,l) = 0.0  210 continue  220 continue      return      endc-----------------------------------------------------------------------      subroutine PFCT2RXY(g,isign,mixup,sctd,indx,indy,kstrt,kxp,kxpi,kx     1pp,nyv,kxpd,jblok,nxhyd,nxyd)c this subroutine performs the y part of a two dimensional fast realc cosine transform and its inverse, for a subset of x,c using real arithmetic, for data which is distributed in blocksc algorithm is described in Numerical Recipies in Fortran, Second Ed.,c by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, c [Cambridge Univ. Press, 1992], p. 508.c for isign = (-1,1), input: all, output: fc approximate flop count: N*(5*log2(N) + 18)/nvpc where N = (nx/2)*nyc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, an inverse cosine transform is performedc g(m,n,i) = (.5*g(1,n,i) + ((-1)**m)*g(ny+1,n,i)c            + sum(g(k,n,i)*cos(pi*m*k/ny))c if isign = 1, a forward cosine transform is performedc g(k,n,i) = 2*(.5*g(1,n,i) + ((-1)**m)*g(ny+1,n,i) + sum(g(m,n,i)*c            cos(pi*m*k/ny))c mixup = array of bit reversed addressesc sctd = sine/cosine tablec kstrt = starting data block numberc kxp = number of data values per block in xc kxpi = initial x index usedc kxpp = number of x indices usedc nyv = first dimension of g >= ny + 1c kxpd = second dimension of f >= kxp + 1c jblok = number of data blocks in xc nxhyd = maximum of (nx/2,ny)c nxyd = maximum of (nx,ny)c written by viktor k. decyk, ucla      implicit none      integer isign, mixup, indx, indy, kstrt, kxp, kxpi, kxpp      integer nyv, kxpd, jblok, nxhyd, nxyd      real g      complex sctd      dimension g(nyv,kxpd,jblok)      dimension mixup(nxhyd), sctd(nxyd)c local data      integer indx1, indy1, indx1y, nx, ny, nyh, nyhh, ny3, nxy, nxhy      integer i, j, k, l, m, ks, km, kmr, nry, j1, j2, ns, ns2, k1, k2      integer kxps, kxpt      real at1, at2, t2, t3, t4, t5, t6, ani, sum1      complex t1      indx1 = indx - 1      indy1 = indy - 1      indx1y = max0(indx1,indy)      nx = 2**indx      ny = 2**indy      nyh = ny/2      nyhh = ny/4      ny3 = ny + 3      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      kxps = kxpi + kxpp - 1      if (kstrt.gt.nx) return      if (isign.eq.0) returnc create auxiliary array in y      kmr = nxy/ny      kxpt = kxps      do 30 l = 1, jblok      if ((kxps+kxp*(l+ks)).eq.nx) kxpt = kxps + 1      do 20 j = kxpi, kxpt      sum1 = .5*(g(1,j,l) - g(ny+1,j,l))      do 10 k = 2, nyh      k1 = 1 + kmr*(k - 1)      at2 = g(ny+2-k,j,l)      at1 = g(k,j,l) + at2      at2 = g(k,j,l) - at2      sum1 = sum1 + real(sctd(k1))*at2      at2 = -aimag(sctd(k1))*at2      at1 = .5*at1      g(k,j,l) = at1 - at2      g(ny+2-k,j,l) = at1 + at2   10 continue      g(1,j,l) = .5*(g(1,j,l) + g(ny+1,j,l))      g(ny+1,j,l) = sum1   20 continue   30 continuec bit-reverse array elements in y      nry = nxhy/nyh      kxpt = kxps      do 60 l = 1, jblok      if ((kxps+kxp*(l+ks)).eq.nx) kxpt = kxps + 1      do 50 k = 1, nyh      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 50      do 40 j = kxpi, kxpt      t2 = g(2*k1-1,j,l)      t3 = g(2*k1,j,l)      g(2*k1-1,j,l) = g(2*k-1,j,l)      g(2*k1,j,l) = g(2*k,j,l)      g(2*k-1,j,l) = t2      g(2*k,j,l) = t3   40 continue   50 continue   60 continuec first transform in y      nry = nxy/nyh      do 110 m = 1, indy1      ns = 2**(m - 1)      ns2 = ns + ns      km = nyhh/ns      kmr = 2*km*nry      kxpt = kxps      do 100 l = 1, jblok      if ((kxps+kxp*(l+ks)).eq.nx) kxpt = kxps + 1      do 90 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 80 j = 1, ns      j1 = j + k1      j2 = j + k2      t1 = sctd(1+kmr*(j-1))      do 70 i = kxpi, kxpt      t2 = real(t1)*g(2*j2-1,i,l) - aimag(t1)*g(2*j2,i,l)      t3 = aimag(t1)*g(2*j2-1,i,l) + real(t1)*g(2*j2,i,l)      g(2*j2-1,i,l) = g(2*j1-1,i,l) - t2      g(2*j2,i,l) = g(2*j1,i,l) - t3      g(2*j1-1,i,l) = g(2*j1-1,i,l) + t2      g(2*j1,i,l) = g(2*j1,i,l) + t3   70 continue   80 continue   90 continue  100 continue  110 continuec unscramble coefficients and normalizec inverse fourier transform      if (isign.lt.0) then         kmr = nxy/nyh         ani = 0.5         kxpt = kxps         do 150 l = 1, jblok         if ((kxps+kxp*(l+ks)).eq.nx) kxpt = kxps + 1         do 130 k = 2, nyhh         t1 = cmplx(aimag(sctd(1+kmr*(k-1))),-real(sctd(1+kmr*(k-1))))         do 120 j = kxpi, kxpt         t4 = g(ny3-2*k,j,l)         t5 = -g(ny3-2*k+1,j,l)         t2 = g(2*k-1,j,l) + t4         t3 = g(2*k,j,l) + t5         t6 = g(2*k-1,j,l) - t4         t5 = g(2*k,j,l) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         g(2*k-1,j,l) = ani*(t2 + t4)         g(2*k,j,l) = ani*(t3 + t5)         g(ny3-2*k,j,l) = ani*(t2 - t4)         g(ny3-2*k+1,j,l) = ani*(t5 - t3)  120    continue  130    continue         do 140 j = kxpi, kxpt         g(nyh+1,j,l) = g(nyh+1,j,l)         g(nyh+2,j,l) = -g(nyh+2,j,l)         t2 = g(1,j,l) + g(2,j,l)         g(2,j,l) = g(1,j,l) - g(2,j,l)         g(1,j,l) = t2         g(ny+1,j,l) = g(ny+1,j,l)  140    continue  150    continuec forward fourier transform      else if (isign.gt.0) then         kmr = nxy/nyh         kxpt = kxps         do 190 l = 1, jblok         if ((kxps+kxp*(l+ks)).eq.nx) kxpt = kxps + 1         do 170 k = 2, nyhh         t1 = cmplx(aimag(sctd(1+kmr*(k-1))),-real(sctd(1+kmr*(k-1))))         do 160 j = kxpi, kxpt         t4 = g(ny3-2*k,j,l)         t5 = -g(ny3-2*k+1,j,l)         t2 = g(2*k-1,j,l) + t4         t3 = g(2*k,j,l) + t5         t6 = g(2*k-1,j,l) - t4         t5 = g(2*k,j,l) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         g(2*k-1,j,l) = t2 + t4         g(2*k,j,l) = t3 + t5         g(ny3-2*k,j,l) = t2 - t4         g(ny3-2*k+1,j,l) = t5 - t3  160    continue  170    continue         do 180 j = kxpi, kxpt         g(nyh+1,j,l) = 2.0*g(nyh+1,j,l)         g(nyh+2,j,l) = -2.0*g(nyh+2,j,l)         t2 = 2.0*(g(1,j,l) + g(2,j,l))         g(2,j,l) = 2.0*(g(1,j,l) - g(2,j,l))         g(1,j,l) = t2         g(ny+1,j,l) = 2.0*g(ny+1,j,l)  180    continue  190    continue      endifc perform recursion for cosine transform      kxpt = kxps      do 220 l = 1, jblok      if ((kxps+kxp*(l+ks)).eq.nx) kxpt = kxps + 1      do 210 j = kxpi, kxpt      sum1 = g(ny+1,j,l)      g(ny+1,j,l) = g(2,j,l)      g(2,j,l) = sum1      do 200 k = 2, nyh      sum1 = sum1 - g(2*k,j,l)      g(2*k,j,l) = sum1  200 continue  210 continue  220 continue      return      endc-----------------------------------------------------------------------      subroutine WPFCST2R2(f,g,bs,br,isign,ntpose,mixup,sctd,ttp,indx,in     1dy,kstrt,nxvh,nyv,kxp2,kyp,kypd,kxp2d,jblok,kblok,nxhyd,nxyd)c wrapper function for 2 parallel real sine/sine transformsc for the electric field with dirichlet or magnetic field with neumannc boundary conditions      implicit none      integer isign, ntpose, mixup, indx, indy, kstrt, nxvh, nyv      integer kxp2, kyp, kypd, kxp2d, jblok, kblok, nxhyd, nxyd      real f, g, bs, br, ttp      complex sctd      dimension f(2*nxvh,kypd,kblok), g(nyv,kxp2d,jblok)      dimension bs(kxp2+1,kyp+1,kblok), br(kxp2+1,kyp+1,jblok)      dimension mixup(nxhyd), sctd(nxyd)c local data      integer nx, ny, kxpi, kypi      real tf      double precision dtime      data kxpi, kypi /1,1/c calculate range of indices      nx = 2**indx      ny = 2**indyc inverse fourier transform      if (isign.lt.0) thenc perform x cosine-sine transform         call PFCST2R2X(f,isign,mixup,sctd,indx,indy,kstrt,kyp,kypi,kyp,     1nxvh,kypd,kblok,nxhyd,nxyd)c transpose f array to g         call PWTIMERA(-1,ttp,dtime)         call PR2TPOSE(f,g,bs,br,nx,ny,kstrt,2*nxvh,nyv,kxp2,kyp,kxp2d,k     1ypd,jblok,kblok)         call PWTIMERA(1,ttp,dtime)c perform y sine-cosine transform         call PFSCT2R2Y(g,isign,mixup,sctd,indx,indy,kstrt,kxp2,kxpi,kxp     12,nyv,kxp2d,jblok,nxhyd,nxyd)c transpose g array to f         if (ntpose.eq.0) then            call PWTIMERA(-1,tf,dtime)            call PR2TPOSE(g,f,br,bs,ny,nx,kstrt,nyv,2*nxvh,kyp,kxp2,kypd     1,kxp2d,kblok,jblok)            call PWTIMERA(1,tf,dtime)         endifc forward fourier transform      else if (isign.gt.0) thenc transpose f array to g         if (ntpose.eq.0) then            call PWTIMERA(-1,tf,dtime)            call PR2TPOSE(f,g,bs,br,nx,ny,kstrt,2*nxvh,nyv,kxp2,kyp,kxp2     1d,kypd,jblok,kblok)            call PWTIMERA(1,tf,dtime)         endifc perform y sine-cosine transform         call PFSCT2R2Y(g,isign,mixup,sctd,indx,indy,kstrt,kxp2,kxpi,kxp     12,nyv,kxp2d,jblok,nxhyd,nxyd)c transpose g array to f         call PWTIMERA(-1,ttp,dtime)         call PR2TPOSE(g,f,br,bs,ny,nx,kstrt,nyv,2*nxvh,kyp,kxp2,kypd,kx     1p2d,kblok,jblok)         call PWTIMERA(1,ttp,dtime)c perform x cosine-sine transform         call PFCST2R2X(f,isign,mixup,sctd,indx,indy,kstrt,kyp,kypi,kyp,     1nxvh,kypd,kblok,nxhyd,nxyd)      endif      if (ntpose.eq.0) ttp = ttp + tf      return      endc-----------------------------------------------------------------------      subroutine WPFSCT2R2(f,g,bs,br,isign,ntpose,mixup,sctd,ttp,indx,in     1dy,kstrt,nxvh,nyv,kxp2,kyp,kypd,kxp2d,jblok,kblok,nxhyd,nxyd)c wrapper function for 2 parallel real sine/sine transformsc for the magnetic field with dirichlet or electric field with neumannc boundary conditions      implicit none      integer isign, ntpose, mixup, indx, indy, kstrt, nxvh, nyv      integer kxp2, kyp, kypd, kxp2d, jblok, kblok, nxhyd, nxyd      real f, g, bs, br, ttp      complex sctd      dimension f(2,2*nxvh,kypd,kblok), g(2,nyv,kxp2d,jblok)      dimension bs(2,kxp2+1,kyp+1,kblok), br(2,kxp2+1,kyp+1,jblok)      dimension mixup(nxhyd), sctd(nxyd)c local data      integer nx, ny, kxpi, kypi      real tf      double precision dtime      data kxpi, kypi /1,1/c calculate range of indices      nx = 2**indx      ny = 2**indyc inverse fourier transform      if (isign.lt.0) thenc perform x sine-cosine transform         call PFSCT2R2X(f,isign,mixup,sctd,indx,indy,kstrt,kyp,kypi,kyp,     1nxvh,kypd,kblok,nxhyd,nxyd)c transpose f array to g         call PWTIMERA(-1,ttp,dtime)         call PR2TPOSE(f,g,bs,br,nx,ny,kstrt,2*nxvh,nyv,kxp2,kyp,kxp2d,k     1ypd,jblok,kblok)         call PWTIMERA(1,ttp,dtime)c perform y cosine-sine transform         call PFCST2R2Y(g,isign,mixup,sctd,indx,indy,kstrt,kxp2,kxpi,kxp     12,nyv,kxp2d,jblok,nxhyd,nxyd)c transpose g array to f         if (ntpose.eq.0) then            call PWTIMERA(-1,tf,dtime)            call PR2TPOSE(g,f,br,bs,ny,nx,kstrt,nyv,2*nxvh,kyp,kxp2,kypd     1,kxp2d,kblok,jblok)            call PWTIMERA(1,tf,dtime)         endifc forward fourier transform      else if (isign.gt.0) thenc transpose f array to g         if (ntpose.eq.0) then            call PWTIMERA(-1,tf,dtime)            call PR2TPOSE(f,g,bs,br,nx,ny,kstrt,2*nxvh,nyv,kxp2,kyp,kxp2     1d,kypd,jblok,kblok)            call PWTIMERA(1,tf,dtime)         endifc perform y cosine-sine transform         call PFCST2R2Y(g,isign,mixup,sctd,indx,indy,kstrt,kxp2,kxpi,kxp     12,nyv,kxp2d,jblok,nxhyd,nxyd)c transpose g array to f         call PWTIMERA(-1,ttp,dtime)         call PR2TPOSE(g,f,br,bs,ny,nx,kstrt,nyv,2*nxvh,kyp,kxp2,kypd,kx     1p2d,kblok,jblok)         call PWTIMERA(1,ttp,dtime)c perform x sine-cosine transform         call PFSCT2R2X(f,isign,mixup,sctd,indx,indy,kstrt,kyp,kypi,kyp,     1nxvh,kypd,kblok,nxhyd,nxyd)      endif      if (ntpose.eq.0) ttp = ttp + tf      return      endc-----------------------------------------------------------------------      subroutine PFCST2R2X(f,isign,mixup,sctd,indx,indy,kstrt,kyp,kypi,k     1ypp,nxvh,kypd,kblok,nxhyd,nxyd)c this subroutine performs the x part of 2 two dimensional fast realc sine and cosine transforms and their inverses, for a subset of y,c using real arithmetic, for data which is distributed in blocksc algorithm is described in Numerical Recipies in Fortran, Second Ed.,c by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, c [Cambridge Univ. Press, 1992], p. 508.c for isign = (-1,1), input: all, output: fc approximate flop count: N*(5*log2(N) + 18)/nvpc where N = (nx/2)*nyc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, inverse sine-cosine transforms are performedc f(1,n,k,i) = (1/nx*ny)*(.5*f(1,1,k,i) + ((-1)**n)*f(1,nx+1,k,i)c              + sum(f(1,j,k,i)*cos(pi*n*j/nx)))c f(2,n,k,i) = (1/nx*ny)*sum(f(2,j,k,i)*sin(pi*n*j/nx))c if isign = 1, forward sine transforms are performedc f(1,j,k,i) = 2*(.5*f(1,1,k,i) + ((-1)**j)*f(1,n+1,k,i)c              + sum(f(1,n,k,i)*cos(pi*n*j/nx))c f(2,j,k,i) = sum(f(2,n,k,i)*sin(pi*n*j/nx))c mixup = array of bit reversed addressesc sctd = sine/cosine tablec kstrt = starting data block numberc kyp = number of data values per block in yc kypi = initial y index usedc kypp = number of y indices usedc nxvh = first dimension of f >= nx/2 + 1c kypd = second dimension of f >= kyp + 1c kblok = number of data blocks in yc nxhyd = maximum of (nx/2,ny)c nxyd = maximum of (nx,ny)c written by viktor k. decyk, ucla      implicit none      integer isign, mixup, indx, indy, kstrt, kyp, kypi, kypp      integer nxvh, kypd, kblok, nxhyd, nxyd      real f      complex sctd      dimension f(2,2*nxvh,kypd,kblok)      dimension mixup(nxhyd), sctd(nxyd)c local data      integer indx1, indx1y, nx, nxh, nxhh, nx3, ny, nxy, nxhy, ks, kypt      integer i, j, k, l, m, km, kmr, nrx, j1, j2, ns, ns2, k1, k2, kyps      integer jj      real at1, at2, at3, t2, t3, t4, t5, t6, ani, sum1, sum2      complex t1      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nx3 = nx + 3      ny = 2**indy      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      kyps = kypi + kypp - 1      if (kstrt.gt.ny) return      if (isign.eq.0) returnc create auxiliary array in x      kmr = nxy/nx      kypt = kyps      do 30 l = 1, kblok      if ((kyps+kyp*(l+ks)).eq.ny) kypt = kyps + 1      do 20 k = kypi, kypt      sum1 = .5*(f(1,1,k,l) - f(1,nx+1,k,l))      do 10 j = 2, nxh      j1 = 1 + kmr*(j - 1)      at3 = -aimag(sctd(j1))      at2 = f(1,nx+2-j,k,l)      at1 = f(1,j,k,l) + at2      at2 = f(1,j,k,l) - at2      sum1 = sum1 + real(sctd(j1))*at2      at2 = at3*at2      at1 = .5*at1      f(1,j,k,l) = at1 - at2      f(1,nx+2-j,k,l) = at1 + at2      at2 = f(2,nx+2-j,k,l)      at1 = f(2,j,k,l) + at2      at2 = f(2,j,k,l) - at2      at1 = at3*at1      at2 = .5*at2      f(2,j,k,l) = at1 + at2      f(2,nx+2-j,k,l) = at1 - at2   10 continue      f(1,1,k,l) = .5*(f(1,1,k,l) + f(1,nx+1,k,l))      f(1,nx+1,k,l) = sum1      f(2,1,k,l) = 0.0      f(2,nxh+1,k,l) = 2.0*f(2,nxh+1,k,l)   20 continue   30 continuec bit-reverse array elements in x      nrx = nxhy/nxh      kypt = kyps      do 70 l = 1, kblok      if ((kyps+kyp*(l+ks)).eq.ny) kypt = kyps + 1      do 60 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 60      do 50 k = kypi, kypt      do 40 jj = 1, 2      t2 = f(jj,2*j1-1,k,l)      t3 = f(jj,2*j1,k,l)      f(jj,2*j1-1,k,l) = f(jj,2*j-1,k,l)      f(jj,2*j1,k,l) = f(jj,2*j,k,l)      f(jj,2*j-1,k,l) = t2      f(jj,2*j,k,l) = t3   40 continue   50 continue   60 continue   70 continuec first transform in x      nrx = nxy/nxh      do 130 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = 2*km*nrx      kypt = kyps      do 120 l = 1, kblok      if ((kyps+kyp*(l+ks)).eq.ny) kypt = kyps + 1      do 110 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 100 j = 1, ns      j1 = j + k1      j2 = j + k2      t1 = sctd(1+kmr*(j-1))      do 90 i = kypi, kypt      do 80 jj = 1, 2      t2 = real(t1)*f(jj,2*j2-1,i,l) - aimag(t1)*f(jj,2*j2,i,l)      t3 = aimag(t1)*f(jj,2*j2-1,i,l) + real(t1)*f(jj,2*j2,i,l)      f(jj,2*j2-1,i,l) = f(jj,2*j1-1,i,l) - t2      f(jj,2*j2,i,l) = f(jj,2*j1,i,l) - t3      f(jj,2*j1-1,i,l) = f(jj,2*j1-1,i,l) + t2      f(jj,2*j1,i,l) = f(jj,2*j1,i,l) + t3   80 continue   90 continue  100 continue  110 continue  120 continue  130 continuec unscramble coefficients and normalizec inverse fourier transform      if (isign.lt.0) then         kmr = nxy/nxh         ani = 1./float(2*nx*ny)         kypt = kyps         do 190 l = 1, kblok         if ((kyps+kyp*(l+ks)).eq.ny) kypt = kyps + 1         do 160 j = 2, nxhh         t1 = cmplx(aimag(sctd(1+kmr*(j-1))),-real(sctd(1+kmr*(j-1))))         do 150 k = kypi, kypt         do 140 jj = 1, 2         t4 = f(jj,nx3-2*j,k,l)         t5 = -f(jj,nx3-2*j+1,k,l)         t2 = f(jj,2*j-1,k,l) + t4         t3 = f(jj,2*j,k,l) + t5         t6 = f(jj,2*j-1,k,l) - t4         t5 = f(jj,2*j,k,l) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         f(jj,2*j-1,k,l) = ani*(t2 + t4)         f(jj,2*j,k,l) = ani*(t3 + t5)         f(jj,nx3-2*j,k,l) = ani*(t2 - t4)         f(jj,nx3-2*j+1,k,l) = ani*(t5 - t3)  140    continue  150    continue  160    continue         ani = 2.*ani         do 180 k = kypi, kypt         do 170 jj = 1, 2         f(jj,nxh+1,k,l) = ani*f(jj,nxh+1,k,l)         f(jj,nxh+2,k,l) = -ani*f(jj,nxh+2,k,l)         t2 = ani*(f(jj,1,k,l) + f(jj,2,k,l))         f(jj,2,k,l) = ani*(f(jj,1,k,l) - f(jj,2,k,l))         f(jj,1,k,l) = t2         f(jj,nx+1,k,l) = ani*f(jj,nx+1,k,l)  170    continue  180    continue  190    continuec forward fourier transform      else if (isign.gt.0) then         kmr = nxy/nxh         kypt = kyps         do 250 l = 1, kblok         if ((kyps+kyp*(l+ks)).eq.ny) kypt = kyps + 1         do 220 j = 2, nxhh         t1 = cmplx(aimag(sctd(1+kmr*(j-1))),-real(sctd(1+kmr*(j-1))))         do 210 k = kypi, kypt         do 200 jj = 1, 2         t4 = f(jj,nx3-2*j,k,l)         t5 = -f(jj,nx3-2*j+1,k,l)         t2 = f(jj,2*j-1,k,l) + t4         t3 = f(jj,2*j,k,l) + t5         t6 = f(jj,2*j-1,k,l) - t4         t5 = f(jj,2*j,k,l) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         f(jj,2*j-1,k,l) = t2 + t4         f(jj,2*j,k,l) = t3 + t5         f(jj,nx3-2*j,k,l) = t2 - t4         f(jj,nx3-2*j+1,k,l) = t5 - t3  200    continue  210    continue  220    continue         do 240 k = kypi, kypt         do 230 jj = 1, 2         f(jj,nxh+1,k,l) = 2.0*f(jj,nxh+1,k,l)         f(jj,nxh+2,k,l) = -2.0*f(jj,nxh+2,k,l)         t2 = 2.0*(f(jj,1,k,l) + f(jj,2,k,l))         f(jj,2,k,l) = 2.0*(f(jj,1,k,l) - f(jj,2,k,l))         f(jj,1,k,l) = t2         f(jj,nx+1,k,l) = 2.0*f(jj,nx+1,k,l)  230    continue  240    continue  250    continue      endifc perform recursion for cosine-sine transform      kypt = kyps      do 280 l = 1, kblok      if ((kyps+kyp*(l+ks)).eq.ny) kypt = kyps + 1      do 270 k = kypi, kypt      sum1 = f(1,nx+1,k,l)      f(1,nx+1,k,l) = f(1,2,k,l)      f(1,2,k,l) = sum1      sum2 = .5*f(2,1,k,l)      f(2,1,k,l) = 0.0      f(2,2,k,l) = sum2      do 260 j = 2, nxh      sum1 = sum1 - f(1,2*j,k,l)      f(1,2*j,k,l) = sum1      sum2 = sum2 + f(2,2*j-1,k,l)      f(2,2*j-1,k,l) = -f(2,2*j,k,l)      f(2,2*j,k,l) = sum2  260 continue      f(2,nx+1,k,l) = 0.0  270 continue  280 continue      return      endc-----------------------------------------------------------------------      subroutine PFSCT2R2X(f,isign,mixup,sctd,indx,indy,kstrt,kyp,kypi,k     1ypp,nxvh,kypd,kblok,nxhyd,nxyd)c this subroutine performs the x part of 2 two dimensional fast realc sine and cosine transforms and their inverses, for a subset of y,c using real arithmetic, for data which is distributed in blocksc algorithm is described in Numerical Recipies in Fortran, Second Ed.,c by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, c [Cambridge Univ. Press, 1992], p. 508.c for isign = (-1,1), input: all, output: fc approximate flop count: N*(5*log2(N) + 18)/nvpc where N = (nx/2)*nyc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, inverse sine-cosine transforms are performedc f(1,n,k,i) = (1/nx*ny)*sum(f(1,j,k,i)*sin(pi*n*j/nx))c f(2,n,k,i) = (1/nx*ny)*(.5*f(2,1,k,i) + ((-1)**n)*f(2,nx+1,k,i)c              + sum(f(2,j,k,i)*cos(pi*n*j/nx)))c if isign = 1, forward sine transforms are performedc f(1,j,k,i) = sum(f(1,n,k,i)*sin(pi*n*j/nx))c f(2,j,k,i) = 2*(.5*f(2,1,k,i) + ((-1)**j)*f(2,n+1,k,i)c              + sum(f(2,n,k,i)*cos(pi*n*j/nx))c mixup = array of bit reversed addressesc sctd = sine/cosine tablec kstrt = starting data block numberc kyp = number of data values per block in yc kypi = initial y index usedc kypp = number of y indices usedc nxvh = first dimension of f >= nx/2 + 1c kypd = second dimension of f >= kyp + 1c kblok = number of data blocks in yc nxhyd = maximum of (nx/2,ny)c nxyd = maximum of (nx,ny)c written by viktor k. decyk, ucla      implicit none      integer isign, mixup, indx, indy, kstrt, kyp, kypi, kypp      integer nxvh, kypd, kblok, nxhyd, nxyd      real f      complex sctd      dimension f(2,2*nxvh,kypd,kblok)      dimension mixup(nxhyd), sctd(nxyd)c local data      integer indx1, indx1y, nx, nxh, nxhh, nx3, ny, nxy, nxhy, ks, kypt      integer i, j, k, l, m, km, kmr, nrx, j1, j2, ns, ns2, k1, k2, kyps      integer jj      real at1, at2, at3, t2, t3, t4, t5, t6, ani, sum1, sum2      complex t1      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nx3 = nx + 3      ny = 2**indy      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      kyps = kypi + kypp - 1      if (kstrt.gt.ny) return      if (isign.eq.0) returnc create auxiliary array in x      kmr = nxy/nx      kypt = kyps      do 30 l = 1, kblok      if ((kyps+kyp*(l+ks)).eq.ny) kypt = kyps + 1      do 20 k = kypi, kypt      sum1 = .5*(f(2,1,k,l) - f(2,nx+1,k,l))      do 10 j = 2, nxh      j1 = 1 + kmr*(j - 1)      at3 = -aimag(sctd(j1))      at2 = f(1,nx+2-j,k,l)      at1 = f(1,j,k,l) + at2      at2 = f(1,j,k,l) - at2      at1 = at3*at1      at2 = .5*at2      f(1,j,k,l) = at1 + at2      f(1,nx+2-j,k,l) = at1 - at2      at2 = f(2,nx+2-j,k,l)      at1 = f(2,j,k,l) + at2      at2 = f(2,j,k,l) - at2      sum1 = sum1 + real(sctd(j1))*at2      at2 = at3*at2      at1 = .5*at1      f(2,j,k,l) = at1 - at2      f(2,nx+2-j,k,l) = at1 + at2   10 continue      f(1,1,k,l) = 0.0      f(1,nxh+1,k,l) = 2.0*f(1,nxh+1,k,l)      f(2,1,k,l) = .5*(f(2,1,k,l) + f(2,nx+1,k,l))      f(2,nx+1,k,l) = sum1   20 continue   30 continuec bit-reverse array elements in x      nrx = nxhy/nxh      kypt = kyps      do 70 l = 1, kblok      if ((kyps+kyp*(l+ks)).eq.ny) kypt = kyps + 1      do 60 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 60      do 50 k = kypi, kypt      do 40 jj = 1, 2      t2 = f(jj,2*j1-1,k,l)      t3 = f(jj,2*j1,k,l)      f(jj,2*j1-1,k,l) = f(jj,2*j-1,k,l)      f(jj,2*j1,k,l) = f(jj,2*j,k,l)      f(jj,2*j-1,k,l) = t2      f(jj,2*j,k,l) = t3   40 continue   50 continue   60 continue   70 continuec first transform in x      nrx = nxy/nxh      do 130 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = 2*km*nrx      kypt = kyps      do 120 l = 1, kblok      if ((kyps+kyp*(l+ks)).eq.ny) kypt = kyps + 1      do 110 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 100 j = 1, ns      j1 = j + k1      j2 = j + k2      t1 = sctd(1+kmr*(j-1))      do 90 i = kypi, kypt      do 80 jj = 1, 2      t2 = real(t1)*f(jj,2*j2-1,i,l) - aimag(t1)*f(jj,2*j2,i,l)      t3 = aimag(t1)*f(jj,2*j2-1,i,l) + real(t1)*f(jj,2*j2,i,l)      f(jj,2*j2-1,i,l) = f(jj,2*j1-1,i,l) - t2      f(jj,2*j2,i,l) = f(jj,2*j1,i,l) - t3      f(jj,2*j1-1,i,l) = f(jj,2*j1-1,i,l) + t2      f(jj,2*j1,i,l) = f(jj,2*j1,i,l) + t3   80 continue   90 continue  100 continue  110 continue  120 continue  130 continuec unscramble coefficients and normalizec inverse fourier transform      if (isign.lt.0) then         kmr = nxy/nxh         ani = 1./float(2*nx*ny)         kypt = kyps         do 190 l = 1, kblok         if ((kyps+kyp*(l+ks)).eq.ny) kypt = kyps + 1         do 160 j = 2, nxhh         t1 = cmplx(aimag(sctd(1+kmr*(j-1))),-real(sctd(1+kmr*(j-1))))         do 150 k = kypi, kypt         do 140 jj = 1, 2         t4 = f(jj,nx3-2*j,k,l)         t5 = -f(jj,nx3-2*j+1,k,l)         t2 = f(jj,2*j-1,k,l) + t4         t3 = f(jj,2*j,k,l) + t5         t6 = f(jj,2*j-1,k,l) - t4         t5 = f(jj,2*j,k,l) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         f(jj,2*j-1,k,l) = ani*(t2 + t4)         f(jj,2*j,k,l) = ani*(t3 + t5)         f(jj,nx3-2*j,k,l) = ani*(t2 - t4)         f(jj,nx3-2*j+1,k,l) = ani*(t5 - t3)  140    continue  150    continue  160    continue         ani = 2.*ani         do 180 k = kypi, kypt         do 170 jj = 1, 2         f(jj,nxh+1,k,l) = ani*f(jj,nxh+1,k,l)         f(jj,nxh+2,k,l) = -ani*f(jj,nxh+2,k,l)         t2 = ani*(f(jj,1,k,l) + f(jj,2,k,l))         f(jj,2,k,l) = ani*(f(jj,1,k,l) - f(jj,2,k,l))         f(jj,1,k,l) = t2         f(jj,nx+1,k,l) = ani*f(jj,nx+1,k,l)  170    continue  180    continue  190    continuec forward fourier transform      else if (isign.gt.0) then         kmr = nxy/nxh         kypt = kyps         do 250 l = 1, kblok         if ((kyps+kyp*(l+ks)).eq.ny) kypt = kyps + 1         do 220 j = 2, nxhh         t1 = cmplx(aimag(sctd(1+kmr*(j-1))),-real(sctd(1+kmr*(j-1))))         do 210 k = kypi, kypt         do 200 jj = 1, 2         t4 = f(jj,nx3-2*j,k,l)         t5 = -f(jj,nx3-2*j+1,k,l)         t2 = f(jj,2*j-1,k,l) + t4         t3 = f(jj,2*j,k,l) + t5         t6 = f(jj,2*j-1,k,l) - t4         t5 = f(jj,2*j,k,l) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         f(jj,2*j-1,k,l) = t2 + t4         f(jj,2*j,k,l) = t3 + t5         f(jj,nx3-2*j,k,l) = t2 - t4         f(jj,nx3-2*j+1,k,l) = t5 - t3  200    continue  210    continue  220    continue         do 240 k = kypi, kypt         do 230 jj = 1, 2         f(jj,nxh+1,k,l) = 2.0*f(jj,nxh+1,k,l)         f(jj,nxh+2,k,l) = -2.0*f(jj,nxh+2,k,l)         t2 = 2.0*(f(jj,1,k,l) + f(jj,2,k,l))         f(jj,2,k,l) = 2.0*(f(jj,1,k,l) - f(jj,2,k,l))         f(jj,1,k,l) = t2         f(jj,nx+1,k,l) = 2.0*f(jj,nx+1,k,l)  230    continue  240    continue  250    continue      endifc perform recursion for cosine-sine transform      kypt = kyps      do 280 l = 1, kblok      if ((kyps+kyp*(l+ks)).eq.ny) kypt = kyps + 1      do 270 k = kypi, kypt      sum1 = .5*f(1,1,k,l)      f(1,1,k,l) = 0.0      f(1,2,k,l) = sum1      sum2 = f(2,nx+1,k,l)      f(2,nx+1,k,l) = f(2,2,k,l)      f(2,2,k,l) = sum2      do 260 j = 2, nxh      sum1 = sum1 + f(1,2*j-1,k,l)      f(1,2*j-1,k,l) = -f(1,2*j,k,l)      f(1,2*j,k,l) = sum1      sum2 = sum2 - f(2,2*j,k,l)      f(2,2*j,k,l) = sum2  260 continue      f(1,nx+1,k,l) = 0.0  270 continue  280 continue      return      endc-----------------------------------------------------------------------      subroutine PFSCT2R2Y(g,isign,mixup,sctd,indx,indy,kstrt,kxp,kxpi,k     1xpp,nyv,kxpd,jblok,nxhyd,nxyd)c this subroutine performs the y part of 2 two dimensional fast realc sine and cosine transforms and their inverses, for a subset of x,c using real arithmetic, for data which is distributed in blocksc algorithm is described in Numerical Recipies in Fortran, Second Ed.,c by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, c [Cambridge Univ. Press, 1992], p. 508.c for isign = (-1,1), input: all, output: fc approximate flop count: N*(5*log2(N) + 18)/nvpc where N = (nx/2)*nyc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, inverse sine-cosine transform are performedc g(1,m,n,i) = sum(g(1,k,n,i)*sin(pi*m*k/ny))c g(2,m,n,i) = (.5*g(2,1,n,i) + ((-1)**m)*g(2,ny+1,n,i)c              + sum(g(2,k,n,i)*cos(pi*m*k/ny))c if isign = 1, a forward sine-cosine transforms are performedc g(1,k,n,i) = sum(g(1,m,n,i)*sin(pi*m*k/ny))c g(2,k,n,i) = 2*(.5*g(2,1,n,i) + ((-1)**m)*g(2,ny+1,n,i)c              + sum(g(2,m,n,i)*cos(pi*m*k/ny))c mixup = array of bit reversed addressesc sctd = sine/cosine tablec kstrt = starting data block numberc kxp = number of data values per block in xc kxpi = initial x index usedc kxpp = number of x indices usedc nyv = first dimension of g >= ny + 1c kxpd = second dimension of f >= kxp + 1c jblok = number of data blocks in xc nxhyd = maximum of (nx/2,ny)c nxyd = maximum of (nx,ny)c written by viktor k. decyk, ucla      implicit none      integer isign, mixup, indx, indy, kstrt, kxp, kxpi, kxpp      integer nyv, kxpd, jblok, nxhyd, nxyd      real g      complex sctd      dimension g(2,nyv,kxpd,jblok)      dimension mixup(nxhyd), sctd(nxyd)c local data      integer indx1, indy1, indx1y, nx, ny, nyh, nyhh, ny3, nxy, nxhy      integer i, j, k, l, m, ks, km, kmr, nry, j1, j2, ns, ns2, k1, k2      integer kxps, kxpt, jj      real at1, at2, at3, t2, t3, t4, t5, t6, ani, sum1, sum2      complex t1      indx1 = indx - 1      indy1 = indy - 1      indx1y = max0(indx1,indy)      nx = 2**indx      ny = 2**indy      nyh = ny/2      nyhh = ny/4      ny3 = ny + 3      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      kxps = kxpi + kxpp - 1      if (kstrt.gt.nx) return      if (isign.eq.0) returnc create auxiliary array in y      kmr = nxy/ny      kxpt = kxps      do 30 l = 1, jblok      if ((kxps+kxp*(l+ks)).eq.nx) kxpt = kxps + 1      do 20 j = kxpi, kxpt      sum1 = .5*(g(2,1,j,l) - g(2,ny+1,j,l))      do 10 k = 2, nyh      k1 = 1 + kmr*(k - 1)      at3 = -aimag(sctd(k1))      at2 = g(1,ny+2-k,j,l)      at1 = g(1,k,j,l) + at2      at2 = g(1,k,j,l) - at2      at1 = at3*at1      at2 = .5*at2      g(1,k,j,l) = at1 + at2      g(1,ny+2-k,j,l) = at1 - at2      at2 = g(2,ny+2-k,j,l)      at1 = g(2,k,j,l) + at2      at2 = g(2,k,j,l) - at2      sum1 = sum1 + real(sctd(k1))*at2      at2 = at3*at2      at1 = .5*at1      g(2,k,j,l) = at1 - at2      g(2,ny+2-k,j,l) = at1 + at2   10 continue      g(1,1,j,l) = 0.0      g(1,nyh+1,j,l) = 2.0*g(1,nyh+1,j,l)      g(2,1,j,l) = .5*(g(2,1,j,l) + g(2,ny+1,j,l))      g(2,ny+1,j,l) = sum1   20 continue   30 continuec bit-reverse array elements in y      nry = nxhy/nyh      kxpt = kxps      do 70 l = 1, jblok      if ((kxps+kxp*(l+ks)).eq.nx) kxpt = kxps + 1      do 60 k = 1, nyh      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 60      do 50 j = kxpi, kxpt      do 40 jj = 1, 2      t2 = g(jj,2*k1-1,j,l)      t3 = g(jj,2*k1,j,l)      g(jj,2*k1-1,j,l) = g(jj,2*k-1,j,l)      g(jj,2*k1,j,l) = g(jj,2*k,j,l)      g(jj,2*k-1,j,l) = t2      g(jj,2*k,j,l) = t3   40 continue   50 continue   60 continue   70 continuec first transform in y      nry = nxy/nyh      do 130 m = 1, indy1      ns = 2**(m - 1)      ns2 = ns + ns      km = nyhh/ns      kmr = 2*km*nry      kxpt = kxps      do 120 l = 1, jblok      if ((kxps+kxp*(l+ks)).eq.nx) kxpt = kxps + 1      do 110 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 100 j = 1, ns      j1 = j + k1      j2 = j + k2      t1 = sctd(1+kmr*(j-1))      do 90 i = kxpi, kxpt      do 80 jj = 1, 2      t2 = real(t1)*g(jj,2*j2-1,i,l) - aimag(t1)*g(jj,2*j2,i,l)      t3 = aimag(t1)*g(jj,2*j2-1,i,l) + real(t1)*g(jj,2*j2,i,l)      g(jj,2*j2-1,i,l) = g(jj,2*j1-1,i,l) - t2      g(jj,2*j2,i,l) = g(jj,2*j1,i,l) - t3      g(jj,2*j1-1,i,l) = g(jj,2*j1-1,i,l) + t2      g(jj,2*j1,i,l) = g(jj,2*j1,i,l) + t3   80 continue   90 continue  100 continue  110 continue  120 continue  130 continuec unscramble coefficients and normalizec inverse fourier transform      if (isign.lt.0) then         kmr = nxy/nyh         ani = 0.5         kxpt = kxps         do 190 l = 1, jblok         if ((kxps+kxp*(l+ks)).eq.nx) kxpt = kxps + 1         do 160 k = 2, nyhh         t1 = cmplx(aimag(sctd(1+kmr*(k-1))),-real(sctd(1+kmr*(k-1))))         do 150 j = kxpi, kxpt         do 140 jj = 1, 2         t4 = g(jj,ny3-2*k,j,l)         t5 = -g(jj,ny3-2*k+1,j,l)         t2 = g(jj,2*k-1,j,l) + t4         t3 = g(jj,2*k,j,l) + t5         t6 = g(jj,2*k-1,j,l) - t4         t5 = g(jj,2*k,j,l) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         g(jj,2*k-1,j,l) = ani*(t2 + t4)         g(jj,2*k,j,l) = ani*(t3 + t5)         g(jj,ny3-2*k,j,l) = ani*(t2 - t4)         g(jj,ny3-2*k+1,j,l) = ani*(t5 - t3)  140    continue  150    continue  160    continue         do 180 j = kxpi, kxpt         do 170 jj = 1, 2         g(jj,nyh+1,j,l) = g(jj,nyh+1,j,l)         g(jj,nyh+2,j,l) = -g(jj,nyh+2,j,l)         t2 = g(jj,1,j,l) + g(jj,2,j,l)         g(jj,2,j,l) = g(jj,1,j,l) - g(jj,2,j,l)         g(jj,1,j,l) = t2         g(jj,ny+1,j,l) = g(jj,ny+1,j,l)  170    continue  180    continue  190    continuec forward fourier transform      else if (isign.gt.0) then         kmr = nxy/nyh         kxpt = kxps         do 250 l = 1, jblok         if ((kxps+kxp*(l+ks)).eq.nx) kxpt = kxps + 1         do 220 k = 2, nyhh         t1 = cmplx(aimag(sctd(1+kmr*(k-1))),-real(sctd(1+kmr*(k-1))))         do 210 j = kxpi, kxpt         do 200 jj = 1, 2         t4 = g(jj,ny3-2*k,j,l)         t5 = -g(jj,ny3-2*k+1,j,l)         t2 = g(jj,2*k-1,j,l) + t4         t3 = g(jj,2*k,j,l) + t5         t6 = g(jj,2*k-1,j,l) - t4         t5 = g(jj,2*k,j,l) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         g(jj,2*k-1,j,l) = t2 + t4         g(jj,2*k,j,l) = t3 + t5         g(jj,ny3-2*k,j,l) = t2 - t4         g(jj,ny3-2*k+1,j,l) = t5 - t3  200    continue  210    continue  220    continue         do 240 j = kxpi, kxpt         do 230 jj = 1, 2         g(jj,nyh+1,j,l) = 2.0*g(jj,nyh+1,j,l)         g(jj,nyh+2,j,l) = -2.0*g(jj,nyh+2,j,l)         t2 = 2.0*(g(jj,1,j,l) + g(jj,2,j,l))         g(jj,2,j,l) = 2.0*(g(jj,1,j,l) - g(jj,2,j,l))         g(jj,1,j,l) = t2         g(jj,ny+1,j,l) = 2.0*g(jj,ny+1,j,l)  230    continue  240    continue  250    continue      endifc perform recursion for sine-cosine transform      kxpt = kxps      do 280 l = 1, jblok      if ((kxps+kxp*(l+ks)).eq.nx) kxpt = kxps + 1      do 270 j = kxpi, kxpt      sum1 = .5*g(1,1,j,l)      g(1,1,j,l) = 0.0      g(1,2,j,l) = sum1      sum2 = g(2,ny+1,j,l)      g(2,ny+1,j,l) = g(2,2,j,l)      g(2,2,j,l) = sum2      do 260 k = 2, nyh      sum1 = sum1 + g(1,2*k-1,j,l)      g(1,2*k-1,j,l) = -g(1,2*k,j,l)      g(1,2*k,j,l) = sum1      sum2 = sum2 - g(2,2*k,j,l)      g(2,2*k,j,l) = sum2  260 continue      g(1,ny+1,j,l) = 0.0  270 continue  280 continue      return      endc-----------------------------------------------------------------------      subroutine PFCST2R2Y(g,isign,mixup,sctd,indx,indy,kstrt,kxp,kxpi,k     1xpp,nyv,kxpd,jblok,nxhyd,nxyd)c this subroutine performs the y part of 2 two dimensional fast realc sine and cosine transforms and their inverses, for a subset of x,c using real arithmetic, for data which is distributed in blocksc algorithm is described in Numerical Recipies in Fortran, Second Ed.,c by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, c [Cambridge Univ. Press, 1992], p. 508.c for isign = (-1,1), input: all, output: fc approximate flop count: N*(5*log2(N) + 18)/nvpc where N = (nx/2)*nyc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, inverse sine-cosine transform are performedc g(1,m,n,i) = (.5*g(1,1,n,i) + ((-1)**m)*g(1,ny+1,n,i)c              + sum(g(1,k,n,i)*cos(pi*m*k/ny))c g(2,m,n,i) = sum(g(2,k,n,i)*sin(pi*m*k/ny))c if isign = 1, a forward sine-cosine transforms are performedc g(1,k,n,i) = 2*(.5*g(1,1,n,i) + ((-1)**m)*g(1,ny+1,n,i)c              + sum(g(1,m,n,i)*cos(pi*m*k/ny))c g(2,k,n,i) = sum(g(2,m,n,i)*sin(pi*m*k/ny))c mixup = array of bit reversed addressesc sctd = sine/cosine tablec kstrt = starting data block numberc kxp = number of data values per block in xc kxpi = initial x index usedc kxpp = number of x indices usedc nyv = first dimension of g >= ny + 1c kxpd = second dimension of f >= kxp + 1c jblok = number of data blocks in xc nxhyd = maximum of (nx/2,ny)c nxyd = maximum of (nx,ny)c written by viktor k. decyk, ucla      implicit none      integer isign, mixup, indx, indy, kstrt, kxp, kxpi, kxpp      integer nyv, kxpd, jblok, nxhyd, nxyd      real g      complex sctd      dimension g(2,nyv,kxpd,jblok)      dimension mixup(nxhyd), sctd(nxyd)c local data      integer indx1, indy1, indx1y, nx, ny, nyh, nyhh, ny3, nxy, nxhy      integer i, j, k, l, m, ks, km, kmr, nry, j1, j2, ns, ns2, k1, k2      integer kxps, kxpt, jj      real at1, at2, at3, t2, t3, t4, t5, t6, ani, sum1, sum2      complex t1      indx1 = indx - 1      indy1 = indy - 1      indx1y = max0(indx1,indy)      nx = 2**indx      ny = 2**indy      nyh = ny/2      nyhh = ny/4      ny3 = ny + 3      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      kxps = kxpi + kxpp - 1      if (kstrt.gt.nx) return      if (isign.eq.0) returnc create auxiliary array in y      kmr = nxy/ny      kxpt = kxps      do 30 l = 1, jblok      if ((kxps+kxp*(l+ks)).eq.nx) kxpt = kxps + 1      do 20 j = kxpi, kxpt      sum1 = .5*(g(1,1,j,l) - g(1,ny+1,j,l))      do 10 k = 2, nyh      k1 = 1 + kmr*(k - 1)      at3 = -aimag(sctd(k1))      at2 = g(1,ny+2-k,j,l)      at1 = g(1,k,j,l) + at2      at2 = g(1,k,j,l) - at2      sum1 = sum1 + real(sctd(k1))*at2      at2 = at3*at2      at1 = .5*at1      g(1,k,j,l) = at1 - at2      g(1,ny+2-k,j,l) = at1 + at2      at2 = g(2,ny+2-k,j,l)      at1 = g(2,k,j,l) + at2      at2 = g(2,k,j,l) - at2      at1 = at3*at1      at2 = .5*at2      g(2,k,j,l) = at1 + at2      g(2,ny+2-k,j,l) = at1 - at2   10 continue      g(1,1,j,l) = .5*(g(1,1,j,l) + g(1,ny+1,j,l))      g(1,ny+1,j,l) = sum1      g(2,1,j,l) = 0.0      g(2,nyh+1,j,l) = 2.0*g(2,nyh+1,j,l)   20 continue   30 continuec bit-reverse array elements in y      nry = nxhy/nyh      kxpt = kxps      do 70 l = 1, jblok      if ((kxps+kxp*(l+ks)).eq.nx) kxpt = kxps + 1      do 60 k = 1, nyh      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 60      do 50 j = kxpi, kxpt      do 40 jj = 1, 2      t2 = g(jj,2*k1-1,j,l)      t3 = g(jj,2*k1,j,l)      g(jj,2*k1-1,j,l) = g(jj,2*k-1,j,l)      g(jj,2*k1,j,l) = g(jj,2*k,j,l)      g(jj,2*k-1,j,l) = t2      g(jj,2*k,j,l) = t3   40 continue   50 continue   60 continue   70 continuec first transform in y      nry = nxy/nyh      do 130 m = 1, indy1      ns = 2**(m - 1)      ns2 = ns + ns      km = nyhh/ns      kmr = 2*km*nry      kxpt = kxps      do 120 l = 1, jblok      if ((kxps+kxp*(l+ks)).eq.nx) kxpt = kxps + 1      do 110 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 100 j = 1, ns      j1 = j + k1      j2 = j + k2      t1 = sctd(1+kmr*(j-1))      do 90 i = kxpi, kxpt      do 80 jj = 1, 2      t2 = real(t1)*g(jj,2*j2-1,i,l) - aimag(t1)*g(jj,2*j2,i,l)      t3 = aimag(t1)*g(jj,2*j2-1,i,l) + real(t1)*g(jj,2*j2,i,l)      g(jj,2*j2-1,i,l) = g(jj,2*j1-1,i,l) - t2      g(jj,2*j2,i,l) = g(jj,2*j1,i,l) - t3      g(jj,2*j1-1,i,l) = g(jj,2*j1-1,i,l) + t2      g(jj,2*j1,i,l) = g(jj,2*j1,i,l) + t3   80 continue   90 continue  100 continue  110 continue  120 continue  130 continuec unscramble coefficients and normalizec inverse fourier transform      if (isign.lt.0) then         kmr = nxy/nyh         ani = 0.5         kxpt = kxps         do 190 l = 1, jblok         if ((kxps+kxp*(l+ks)).eq.nx) kxpt = kxps + 1         do 160 k = 2, nyhh         t1 = cmplx(aimag(sctd(1+kmr*(k-1))),-real(sctd(1+kmr*(k-1))))         do 150 j = kxpi, kxpt         do 140 jj = 1, 2         t4 = g(jj,ny3-2*k,j,l)         t5 = -g(jj,ny3-2*k+1,j,l)         t2 = g(jj,2*k-1,j,l) + t4         t3 = g(jj,2*k,j,l) + t5         t6 = g(jj,2*k-1,j,l) - t4         t5 = g(jj,2*k,j,l) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         g(jj,2*k-1,j,l) = ani*(t2 + t4)         g(jj,2*k,j,l) = ani*(t3 + t5)         g(jj,ny3-2*k,j,l) = ani*(t2 - t4)         g(jj,ny3-2*k+1,j,l) = ani*(t5 - t3)  140    continue  150    continue  160    continue         do 180 j = kxpi, kxpt         do 170 jj = 1, 2         g(jj,nyh+1,j,l) = g(jj,nyh+1,j,l)         g(jj,nyh+2,j,l) = -g(jj,nyh+2,j,l)         t2 = g(jj,1,j,l) + g(jj,2,j,l)         g(jj,2,j,l) = g(jj,1,j,l) - g(jj,2,j,l)         g(jj,1,j,l) = t2         g(jj,ny+1,j,l) = g(jj,ny+1,j,l)  170    continue  180    continue  190    continuec forward fourier transform      else if (isign.gt.0) then         kmr = nxy/nyh         kxpt = kxps         do 250 l = 1, jblok         if ((kxps+kxp*(l+ks)).eq.nx) kxpt = kxps + 1         do 220 k = 2, nyhh         t1 = cmplx(aimag(sctd(1+kmr*(k-1))),-real(sctd(1+kmr*(k-1))))         do 210 j = kxpi, kxpt         do 200 jj = 1, 2         t4 = g(jj,ny3-2*k,j,l)         t5 = -g(jj,ny3-2*k+1,j,l)         t2 = g(jj,2*k-1,j,l) + t4         t3 = g(jj,2*k,j,l) + t5         t6 = g(jj,2*k-1,j,l) - t4         t5 = g(jj,2*k,j,l) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         g(jj,2*k-1,j,l) = t2 + t4         g(jj,2*k,j,l) = t3 + t5         g(jj,ny3-2*k,j,l) = t2 - t4         g(jj,ny3-2*k+1,j,l) = t5 - t3  200    continue  210    continue  220    continue         do 240 j = kxpi, kxpt         do 230 jj = 1, 2         g(jj,nyh+1,j,l) = 2.0*g(jj,nyh+1,j,l)         g(jj,nyh+2,j,l) = -2.0*g(jj,nyh+2,j,l)         t2 = 2.0*(g(jj,1,j,l) + g(jj,2,j,l))         g(jj,2,j,l) = 2.0*(g(jj,1,j,l) - g(jj,2,j,l))         g(jj,1,j,l) = t2         g(jj,ny+1,j,l) = 2.0*g(jj,ny+1,j,l)  230    continue  240    continue  250    continue      endifc perform recursion for sine-cosine transform      kxpt = kxps      do 280 l = 1, jblok      if ((kxps+kxp*(l+ks)).eq.nx) kxpt = kxps + 1      do 270 j = kxpi, kxpt      sum1 = g(1,ny+1,j,l)      g(1,ny+1,j,l) = g(1,2,j,l)      g(1,2,j,l) = sum1      sum2 = .5*g(2,1,j,l)      g(2,1,j,l) = 0.0      g(2,2,j,l) = sum2      do 260 k = 2, nyh      sum1 = sum1 - g(1,2*k,j,l)      g(1,2*k,j,l) = sum1      sum2 = sum2 + g(2,2*k-1,j,l)      g(2,2*k-1,j,l) = -g(2,2*k,j,l)      g(2,2*k,j,l) = sum2  260 continue      g(2,ny+1,j,l) = 0.0  270 continue  280 continue      return      endc-----------------------------------------------------------------------      subroutine WPFCST2R3(f,g,bs,br,isign,ntpose,mixup,sctd,ttp,indx,in     1dy,kstrt,nxvh,nyv,kxp2,kyp,kypd,kxp2d,jblok,kblok,nxhyd,nxyd)c wrapper function for 3 parallel real sine/sine transformsc for the electric field with dirichlet or magnetic field with neumannc boundary conditions      implicit none      integer isign, ntpose, mixup, indx, indy, kstrt, nxvh, nyv      integer kxp2, kyp, kypd, kxp2d, jblok, kblok, nxhyd, nxyd      real f, g, bs, br, ttp      complex sctd      dimension f(3,2*nxvh,kypd,kblok), g(3,nyv,kxp2d,jblok)      dimension bs(3,kxp2+1,kyp+1,kblok), br(3,kxp2+1,kyp+1,jblok)      dimension mixup(nxhyd), sctd(nxyd)c local data      integer nx, ny, kxpi, kypi      real tf      double precision dtime      data kxpi, kypi /1,1/c calculate range of indices      nx = 2**indx      ny = 2**indyc inverse fourier transform      if (isign.lt.0) thenc perform x cosine-sine transform         call PFCSST2R3X(f,isign,mixup,sctd,indx,indy,kstrt,kyp,kypi,kyp     1,nxvh,kypd,kblok,nxhyd,nxyd)c transpose f array to g         call PWTIMERA(-1,ttp,dtime)         call PR3TPOSE(f,g,bs,br,nx,ny,kstrt,2*nxvh,nyv,kxp2,kyp,kxp2d,k     1ypd,jblok,kblok)         call PWTIMERA(1,ttp,dtime)c perform y sine-cosine transform         call PFSCST2R3Y(g,isign,mixup,sctd,indx,indy,kstrt,kxp2,kxpi,kx     1p2,nyv,kxp2d,jblok,nxhyd,nxyd)c transpose g array to f         if (ntpose.eq.0) then            call PWTIMERA(-1,tf,dtime)            call PR3TPOSE(g,f,br,bs,ny,nx,kstrt,nyv,2*nxvh,kyp,kxp2,kypd     1,kxp2d,kblok,jblok)            call PWTIMERA(1,tf,dtime)         endifc forward fourier transform      else if (isign.gt.0) thenc transpose f array to g         if (ntpose.eq.0) then            call PWTIMERA(-1,tf,dtime)            call PR3TPOSE(f,g,bs,br,nx,ny,kstrt,2*nxvh,nyv,kxp2,kyp,kxp2     1d,kypd,jblok,kblok)            call PWTIMERA(1,tf,dtime)         endifc perform y sine-cosine transform         call PFSCST2R3Y(g,isign,mixup,sctd,indx,indy,kstrt,kxp2,kxpi,kx     1p2,nyv,kxp2d,jblok,nxhyd,nxyd)c transpose g array to f         call PWTIMERA(-1,ttp,dtime)         call PR3TPOSE(g,f,br,bs,ny,nx,kstrt,nyv,2*nxvh,kyp,kxp2,kypd,kx     1p2d,kblok,jblok)         call PWTIMERA(1,ttp,dtime)c perform x cosine-sine transform         call PFCSST2R3X(f,isign,mixup,sctd,indx,indy,kstrt,kyp,kypi,kyp     1,nxvh,kypd,kblok,nxhyd,nxyd)      endif      if (ntpose.eq.0) ttp = ttp + tf      return      endc-----------------------------------------------------------------------      subroutine WPFSCT2R3(f,g,bs,br,isign,ntpose,mixup,sctd,ttp,indx,in     1dy,kstrt,nxvh,nyv,kxp2,kyp,kypd,kxp2d,jblok,kblok,nxhyd,nxyd)c wrapper function for 3 parallel real sine/sine transformsc for the magnetic field with dirichlet or electric field with neumannc boundary conditions      implicit none      integer isign, ntpose, mixup, indx, indy, kstrt, nxvh, nyv      integer kxp2, kyp, kypd, kxp2d, jblok, kblok, nxhyd, nxyd      real f, g, bs, br, ttp      complex sctd      dimension f(3,2*nxvh,kypd,kblok), g(3,nyv,kxp2d,jblok)      dimension bs(3,kxp2+1,kyp+1,kblok), br(3,kxp2+1,kyp+1,jblok)      dimension mixup(nxhyd), sctd(nxyd)c local data      integer nx, ny, kxpi, kypi      real tf      double precision dtime      data kxpi, kypi /1,1/c calculate range of indices      nx = 2**indx      ny = 2**indyc inverse fourier transform      if (isign.lt.0) thenc perform x sine-cosine transform         call PFSCCT2R3X(f,isign,mixup,sctd,indx,indy,kstrt,kyp,kypi,kyp     1,nxvh,kypd,kblok,nxhyd,nxyd)c transpose f array to g         call PWTIMERA(-1,ttp,dtime)         call PR3TPOSE(f,g,bs,br,nx,ny,kstrt,2*nxvh,nyv,kxp2,kyp,kxp2d,k     1ypd,jblok,kblok)         call PWTIMERA(1,ttp,dtime)c perform y cosine-sine transform         call PFCSCT2R3Y(g,isign,mixup,sctd,indx,indy,kstrt,kxp2,kxpi,kx     1p2,nyv,kxp2d,jblok,nxhyd,nxyd)c transpose g array to f         if (ntpose.eq.0) then            call PWTIMERA(-1,tf,dtime)            call PR3TPOSE(g,f,br,bs,ny,nx,kstrt,nyv,2*nxvh,kyp,kxp2,kypd     1,kxp2d,kblok,jblok)            call PWTIMERA(1,tf,dtime)         endifc forward fourier transform      else if (isign.gt.0) thenc transpose f array to g         if (ntpose.eq.0) then            call PWTIMERA(-1,tf,dtime)            call PR3TPOSE(f,g,bs,br,nx,ny,kstrt,2*nxvh,nyv,kxp2,kyp,kxp2     1d,kypd,jblok,kblok)            call PWTIMERA(1,tf,dtime)         endifc perform y cosine-sine transform         call PFCSCT2R3Y(g,isign,mixup,sctd,indx,indy,kstrt,kxp2,kxpi,kx     1p2,nyv,kxp2d,jblok,nxhyd,nxyd)c transpose g array to f         call PWTIMERA(-1,ttp,dtime)         call PR3TPOSE(g,f,br,bs,ny,nx,kstrt,nyv,2*nxvh,kyp,kxp2,kypd,kx     1p2d,kblok,jblok)         call PWTIMERA(1,ttp,dtime)c perform x sine-cosine transform         call PFSCCT2R3X(f,isign,mixup,sctd,indx,indy,kstrt,kyp,kypi,kyp     1,nxvh,kypd,kblok,nxhyd,nxyd)      endif      if (ntpose.eq.0) ttp = ttp + tf      return      endc-----------------------------------------------------------------------      subroutine PFCSST2R3X(f,isign,mixup,sctd,indx,indy,kstrt,kyp,kypi,     1kypp,nxvh,kypd,kblok,nxhyd,nxyd)c this subroutine performs the x part of 2 two dimensional fast realc sine and cosine transforms and their inverses, for a subset of y,c using real arithmetic, for data which is distributed in blocksc algorithm is described in Numerical Recipies in Fortran, Second Ed.,c by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, c [Cambridge Univ. Press, 1992], p. 508.c for isign = (-1,1), input: all, output: fc approximate flop count: N*(5*log2(N) + 18)/nvpc where N = (nx/2)*nyc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, inverse sine-cosine transforms are performedc f(1,n,k,i) = (1/nx*ny)*(.5*f(1,1,k,i) + ((-1)**n)*f(1,nx+1,k,i)c              + sum(f(1,j,k,i)*cos(pi*n*j/nx)))c f(2:3,n,k,i) = (1/nx*ny)*sum(f(2:3,j,k,i)*sin(pi*n*j/nx))c if isign = 1, forward sine transforms are performedc f(1,j,k,i) = 2*(.5*f(1,1,k,i) + ((-1)**j)*f(1,n+1,k,i)c              + sum(f(1,n,k,i)*cos(pi*n*j/nx))c f(2:3,j,k,i) = sum(f(2:3,n,k,i)*sin(pi*n*j/nx))c mixup = array of bit reversed addressesc sctd = sine/cosine tablec kstrt = starting data block numberc kyp = number of data values per block in yc kypi = initial y index usedc kypp = number of y indices usedc nxvh = first dimension of f >= nx/2 + 1c kypd = second dimension of f >= kyp + 1c kblok = number of data blocks in yc nxhyd = maximum of (nx/2,ny)c nxyd = maximum of (nx,ny)c written by viktor k. decyk, ucla      implicit none      integer isign, mixup, indx, indy, kstrt, kyp, kypi, kypp      integer nxvh, kypd, kblok, nxhyd, nxyd      real f      complex sctd      dimension f(3,2*nxvh,kypd,kblok)      dimension mixup(nxhyd), sctd(nxyd)c local data      integer indx1, indx1y, nx, nxh, nxhh, nx3, ny, nxy, nxhy, ks, kypt      integer i, j, k, l, m, km, kmr, nrx, j1, j2, ns, ns2, k1, k2, kyps      integer jj      real at1, at2, at3, t2, t3, t4, t5, t6, ani, sum1, sum2, sum3      complex t1      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nx3 = nx + 3      ny = 2**indy      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      kyps = kypi + kypp - 1      if (kstrt.gt.ny) return      if (isign.eq.0) returnc create auxiliary array in x      kmr = nxy/nx      kypt = kyps      do 30 l = 1, kblok      if ((kyps+kyp*(l+ks)).eq.ny) kypt = kyps + 1      do 20 k = kypi, kypt      sum1 = .5*(f(1,1,k,l) - f(1,nx+1,k,l))      do 10 j = 2, nxh      j1 = 1 + kmr*(j - 1)      at3 = -aimag(sctd(j1))      at2 = f(1,nx+2-j,k,l)      at1 = f(1,j,k,l) + at2      at2 = f(1,j,k,l) - at2      sum1 = sum1 + real(sctd(j1))*at2      at2 = at3*at2      at1 = .5*at1      f(1,j,k,l) = at1 - at2      f(1,nx+2-j,k,l) = at1 + at2      at2 = f(2,nx+2-j,k,l)      at1 = f(2,j,k,l) + at2      at2 = f(2,j,k,l) - at2      at1 = at3*at1      at2 = .5*at2      f(2,j,k,l) = at1 + at2      f(2,nx+2-j,k,l) = at1 - at2      at2 = f(3,nx+2-j,k,l)      at1 = f(3,j,k,l) + at2      at2 = f(3,j,k,l) - at2      at1 = at3*at1      at2 = .5*at2      f(3,j,k,l) = at1 + at2      f(3,nx+2-j,k,l) = at1 - at2   10 continue      f(1,1,k,l) = .5*(f(1,1,k,l) + f(1,nx+1,k,l))      f(1,nx+1,k,l) = sum1      f(2,1,k,l) = 0.0      f(2,nxh+1,k,l) = 2.0*f(2,nxh+1,k,l)      f(3,1,k,l) = 0.0      f(3,nxh+1,k,l) = 2.0*f(3,nxh+1,k,l)   20 continue   30 continuec bit-reverse array elements in x      nrx = nxhy/nxh      kypt = kyps      do 70 l = 1, kblok      if ((kyps+kyp*(l+ks)).eq.ny) kypt = kyps + 1      do 60 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 60      do 50 k = kypi, kypt      do 40 jj = 1, 3      t2 = f(jj,2*j1-1,k,l)      t3 = f(jj,2*j1,k,l)      f(jj,2*j1-1,k,l) = f(jj,2*j-1,k,l)      f(jj,2*j1,k,l) = f(jj,2*j,k,l)      f(jj,2*j-1,k,l) = t2      f(jj,2*j,k,l) = t3   40 continue   50 continue   60 continue   70 continuec first transform in x      nrx = nxy/nxh      do 130 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = 2*km*nrx      kypt = kyps      do 120 l = 1, kblok      if ((kyps+kyp*(l+ks)).eq.ny) kypt = kyps + 1      do 110 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 100 j = 1, ns      j1 = j + k1      j2 = j + k2      t1 = sctd(1+kmr*(j-1))      do 90 i = kypi, kypt      do 80 jj = 1, 3      t2 = real(t1)*f(jj,2*j2-1,i,l) - aimag(t1)*f(jj,2*j2,i,l)      t3 = aimag(t1)*f(jj,2*j2-1,i,l) + real(t1)*f(jj,2*j2,i,l)      f(jj,2*j2-1,i,l) = f(jj,2*j1-1,i,l) - t2      f(jj,2*j2,i,l) = f(jj,2*j1,i,l) - t3      f(jj,2*j1-1,i,l) = f(jj,2*j1-1,i,l) + t2      f(jj,2*j1,i,l) = f(jj,2*j1,i,l) + t3   80 continue   90 continue  100 continue  110 continue  120 continue  130 continuec unscramble coefficients and normalizec inverse fourier transform      if (isign.lt.0) then         kmr = nxy/nxh         ani = 1./float(2*nx*ny)         kypt = kyps         do 190 l = 1, kblok         if ((kyps+kyp*(l+ks)).eq.ny) kypt = kyps + 1         do 160 j = 2, nxhh         t1 = cmplx(aimag(sctd(1+kmr*(j-1))),-real(sctd(1+kmr*(j-1))))         do 150 k = kypi, kypt         do 140 jj = 1, 3         t4 = f(jj,nx3-2*j,k,l)         t5 = -f(jj,nx3-2*j+1,k,l)         t2 = f(jj,2*j-1,k,l) + t4         t3 = f(jj,2*j,k,l) + t5         t6 = f(jj,2*j-1,k,l) - t4         t5 = f(jj,2*j,k,l) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         f(jj,2*j-1,k,l) = ani*(t2 + t4)         f(jj,2*j,k,l) = ani*(t3 + t5)         f(jj,nx3-2*j,k,l) = ani*(t2 - t4)         f(jj,nx3-2*j+1,k,l) = ani*(t5 - t3)  140    continue  150    continue  160    continue         ani = 2.*ani         do 180 k = kypi, kypt         do 170 jj = 1, 3         f(jj,nxh+1,k,l) = ani*f(jj,nxh+1,k,l)         f(jj,nxh+2,k,l) = -ani*f(jj,nxh+2,k,l)         t2 = ani*(f(jj,1,k,l) + f(jj,2,k,l))         f(jj,2,k,l) = ani*(f(jj,1,k,l) - f(jj,2,k,l))         f(jj,1,k,l) = t2         f(jj,nx+1,k,l) = ani*f(jj,nx+1,k,l)  170    continue  180    continue  190    continuec forward fourier transform      else if (isign.gt.0) then         kmr = nxy/nxh         kypt = kyps         do 250 l = 1, kblok         if ((kyps+kyp*(l+ks)).eq.ny) kypt = kyps + 1         do 220 j = 2, nxhh         t1 = cmplx(aimag(sctd(1+kmr*(j-1))),-real(sctd(1+kmr*(j-1))))         do 210 k = kypi, kypt         do 200 jj = 1, 3         t4 = f(jj,nx3-2*j,k,l)         t5 = -f(jj,nx3-2*j+1,k,l)         t2 = f(jj,2*j-1,k,l) + t4         t3 = f(jj,2*j,k,l) + t5         t6 = f(jj,2*j-1,k,l) - t4         t5 = f(jj,2*j,k,l) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         f(jj,2*j-1,k,l) = t2 + t4         f(jj,2*j,k,l) = t3 + t5         f(jj,nx3-2*j,k,l) = t2 - t4         f(jj,nx3-2*j+1,k,l) = t5 - t3  200    continue  210    continue  220    continue         do 240 k = kypi, kypt         do 230 jj = 1, 3         f(jj,nxh+1,k,l) = 2.0*f(jj,nxh+1,k,l)         f(jj,nxh+2,k,l) = -2.0*f(jj,nxh+2,k,l)         t2 = 2.0*(f(jj,1,k,l) + f(jj,2,k,l))         f(jj,2,k,l) = 2.0*(f(jj,1,k,l) - f(jj,2,k,l))         f(jj,1,k,l) = t2         f(jj,nx+1,k,l) = 2.0*f(jj,nx+1,k,l)  230    continue  240    continue  250    continue      endifc perform recursion for cosine-sine transform      kypt = kyps      do 280 l = 1, kblok      if ((kyps+kyp*(l+ks)).eq.ny) kypt = kyps + 1      do 270 k = kypi, kypt      sum1 = f(1,nx+1,k,l)      f(1,nx+1,k,l) = f(1,2,k,l)      f(1,2,k,l) = sum1      sum2 = .5*f(2,1,k,l)      f(2,1,k,l) = 0.0      f(2,2,k,l) = sum2      sum3 = .5*f(3,1,k,l)      f(3,1,k,l) = 0.0      f(3,2,k,l) = sum3      do 260 j = 2, nxh      sum1 = sum1 - f(1,2*j,k,l)      f(1,2*j,k,l) = sum1      sum2 = sum2 + f(2,2*j-1,k,l)      f(2,2*j-1,k,l) = -f(2,2*j,k,l)      f(2,2*j,k,l) = sum2      sum3 = sum3 + f(3,2*j-1,k,l)      f(3,2*j-1,k,l) = -f(3,2*j,k,l)      f(3,2*j,k,l) = sum3  260 continue      f(2,nx+1,k,l) = 0.0      f(3,nx+1,k,l) = 0.0  270 continue  280 continue      return      endc-----------------------------------------------------------------------      subroutine PFSCCT2R3X(f,isign,mixup,sctd,indx,indy,kstrt,kyp,kypi,     1kypp,nxvh,kypd,kblok,nxhyd,nxyd)c this subroutine performs the x part of 3 two dimensional fast realc sine and cosine transforms and their inverses, for a subset of y,c using real arithmetic, for data which is distributed in blocksc algorithm is described in Numerical Recipies in Fortran, Second Ed.,c by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, c [Cambridge Univ. Press, 1992], p. 508.c for isign = (-1,1), input: all, output: fc approximate flop count: N*(5*log2(N) + 18)/nvpc where N = (nx/2)*nyc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, inverse sine-cosine transforms are performedc f(1,n,k,i) = (1/nx*ny)*sum(f(1,j,k,i)*sin(pi*n*j/nx))c f(2:3,n,k,i) = (1/nx*ny)*(.5*f(2:3,1,k,i) + ((-1)**n)*f(2:3,nx+1,k,i)c              + sum(f(2:3,j,k,i)*cos(pi*n*j/nx)))c if isign = 1, forward sine transforms are performedc f(1,j,k,i) = sum(f(1,n,k,i)*sin(pi*n*j/nx))c f(2:3,j,k,i) = 2*(.5*f(2:3,1,k,i) + ((-1)**j)*f(2:3,n+1,k,i)c              + sum(f(2:3,n,k,i)*cos(pi*n*j/nx))c mixup = array of bit reversed addressesc sctd = sine/cosine tablec kstrt = starting data block numberc kyp = number of data values per block in yc kypi = initial y index usedc kypp = number of y indices usedc nxvh = first dimension of f >= nx/2 + 1c kypd = second dimension of f >= kyp + 1c kblok = number of data blocks in yc nxhyd = maximum of (nx/2,ny)c nxyd = maximum of (nx,ny)c written by viktor k. decyk, ucla      implicit none      integer isign, mixup, indx, indy, kstrt, kyp, kypi, kypp      integer nxvh, kypd, kblok, nxhyd, nxyd      real f      complex sctd      dimension f(3,2*nxvh,kypd,kblok)      dimension mixup(nxhyd), sctd(nxyd)c local data      integer indx1, indx1y, nx, nxh, nxhh, nx3, ny, nxy, nxhy, ks, kypt      integer i, j, k, l, m, km, kmr, nrx, j1, j2, ns, ns2, k1, k2, kyps      integer jj      real at1, at2, at3, t2, t3, t4, t5, t6, ani, sum1, sum2, sum3      complex t1      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nx3 = nx + 3      ny = 2**indy      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      kyps = kypi + kypp - 1      if (kstrt.gt.ny) return      if (isign.eq.0) returnc create auxiliary array in x      kmr = nxy/nx      kypt = kyps      do 30 l = 1, kblok      if ((kyps+kyp*(l+ks)).eq.ny) kypt = kyps + 1      do 20 k = kypi, kypt      sum1 = .5*(f(2,1,k,l) - f(2,nx+1,k,l))      sum2 = .5*(f(3,1,k,l) - f(3,nx+1,k,l))      do 10 j = 2, nxh      j1 = 1 + kmr*(j - 1)      at3 = -aimag(sctd(j1))      at2 = f(1,nx+2-j,k,l)      at1 = f(1,j,k,l) + at2      at2 = f(1,j,k,l) - at2      at1 = at3*at1      at2 = .5*at2      f(1,j,k,l) = at1 + at2      f(1,nx+2-j,k,l) = at1 - at2      at2 = f(2,nx+2-j,k,l)      at1 = f(2,j,k,l) + at2      at2 = f(2,j,k,l) - at2      sum1 = sum1 + real(sctd(j1))*at2      at2 = at3*at2      at1 = .5*at1      f(2,j,k,l) = at1 - at2      f(2,nx+2-j,k,l) = at1 + at2      at2 = f(3,nx+2-j,k,l)      at1 = f(3,j,k,l) + at2      at2 = f(3,j,k,l) - at2      sum2 = sum2 + real(sctd(j1))*at2      at2 = at3*at2      at1 = .5*at1      f(3,j,k,l) = at1 - at2      f(3,nx+2-j,k,l) = at1 + at2   10 continue      f(1,1,k,l) = 0.0      f(1,nxh+1,k,l) = 2.0*f(1,nxh+1,k,l)      f(2,1,k,l) = .5*(f(2,1,k,l) + f(2,nx+1,k,l))      f(2,nx+1,k,l) = sum1      f(3,1,k,l) = .5*(f(3,1,k,l) + f(3,nx+1,k,l))      f(3,nx+1,k,l) = sum2   20 continue   30 continuec bit-reverse array elements in x      nrx = nxhy/nxh      kypt = kyps      do 70 l = 1, kblok      if ((kyps+kyp*(l+ks)).eq.ny) kypt = kyps + 1      do 60 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 60      do 50 k = kypi, kypt      do 40 jj = 1, 3      t2 = f(jj,2*j1-1,k,l)      t3 = f(jj,2*j1,k,l)      f(jj,2*j1-1,k,l) = f(jj,2*j-1,k,l)      f(jj,2*j1,k,l) = f(jj,2*j,k,l)      f(jj,2*j-1,k,l) = t2      f(jj,2*j,k,l) = t3   40 continue   50 continue   60 continue   70 continuec first transform in x      nrx = nxy/nxh      do 130 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = 2*km*nrx      kypt = kyps      do 120 l = 1, kblok      if ((kyps+kyp*(l+ks)).eq.ny) kypt = kyps + 1      do 110 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 100 j = 1, ns      j1 = j + k1      j2 = j + k2      t1 = sctd(1+kmr*(j-1))      do 90 i = kypi, kypt      do 80 jj = 1, 3      t2 = real(t1)*f(jj,2*j2-1,i,l) - aimag(t1)*f(jj,2*j2,i,l)      t3 = aimag(t1)*f(jj,2*j2-1,i,l) + real(t1)*f(jj,2*j2,i,l)      f(jj,2*j2-1,i,l) = f(jj,2*j1-1,i,l) - t2      f(jj,2*j2,i,l) = f(jj,2*j1,i,l) - t3      f(jj,2*j1-1,i,l) = f(jj,2*j1-1,i,l) + t2      f(jj,2*j1,i,l) = f(jj,2*j1,i,l) + t3   80 continue   90 continue  100 continue  110 continue  120 continue  130 continuec unscramble coefficients and normalizec inverse fourier transform      if (isign.lt.0) then         kmr = nxy/nxh         ani = 1./float(2*nx*ny)         kypt = kyps         do 190 l = 1, kblok         if ((kyps+kyp*(l+ks)).eq.ny) kypt = kyps + 1         do 160 j = 2, nxhh         t1 = cmplx(aimag(sctd(1+kmr*(j-1))),-real(sctd(1+kmr*(j-1))))         do 150 k = kypi, kypt         do 140 jj = 1, 3         t4 = f(jj,nx3-2*j,k,l)         t5 = -f(jj,nx3-2*j+1,k,l)         t2 = f(jj,2*j-1,k,l) + t4         t3 = f(jj,2*j,k,l) + t5         t6 = f(jj,2*j-1,k,l) - t4         t5 = f(jj,2*j,k,l) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         f(jj,2*j-1,k,l) = ani*(t2 + t4)         f(jj,2*j,k,l) = ani*(t3 + t5)         f(jj,nx3-2*j,k,l) = ani*(t2 - t4)         f(jj,nx3-2*j+1,k,l) = ani*(t5 - t3)  140    continue  150    continue  160    continue         ani = 2.*ani         do 180 k = kypi, kypt         do 170 jj = 1, 3         f(jj,nxh+1,k,l) = ani*f(jj,nxh+1,k,l)         f(jj,nxh+2,k,l) = -ani*f(jj,nxh+2,k,l)         t2 = ani*(f(jj,1,k,l) + f(jj,2,k,l))         f(jj,2,k,l) = ani*(f(jj,1,k,l) - f(jj,2,k,l))         f(jj,1,k,l) = t2         f(jj,nx+1,k,l) = ani*f(jj,nx+1,k,l)  170    continue  180    continue  190    continuec forward fourier transform      else if (isign.gt.0) then         kmr = nxy/nxh         kypt = kyps         do 250 l = 1, kblok         if ((kyps+kyp*(l+ks)).eq.ny) kypt = kyps + 1         do 220 j = 2, nxhh         t1 = cmplx(aimag(sctd(1+kmr*(j-1))),-real(sctd(1+kmr*(j-1))))         do 210 k = kypi, kypt         do 200 jj = 1, 3         t4 = f(jj,nx3-2*j,k,l)         t5 = -f(jj,nx3-2*j+1,k,l)         t2 = f(jj,2*j-1,k,l) + t4         t3 = f(jj,2*j,k,l) + t5         t6 = f(jj,2*j-1,k,l) - t4         t5 = f(jj,2*j,k,l) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         f(jj,2*j-1,k,l) = t2 + t4         f(jj,2*j,k,l) = t3 + t5         f(jj,nx3-2*j,k,l) = t2 - t4         f(jj,nx3-2*j+1,k,l) = t5 - t3  200    continue  210    continue  220    continue         do 240 k = kypi, kypt         do 230 jj = 1, 3         f(jj,nxh+1,k,l) = 2.0*f(jj,nxh+1,k,l)         f(jj,nxh+2,k,l) = -2.0*f(jj,nxh+2,k,l)         t2 = 2.0*(f(jj,1,k,l) + f(jj,2,k,l))         f(jj,2,k,l) = 2.0*(f(jj,1,k,l) - f(jj,2,k,l))         f(jj,1,k,l) = t2         f(jj,nx+1,k,l) = 2.0*f(jj,nx+1,k,l)  230    continue  240    continue  250    continue      endifc perform recursion for cosine-sine transform      kypt = kyps      do 280 l = 1, kblok      if ((kyps+kyp*(l+ks)).eq.ny) kypt = kyps + 1      do 270 k = kypi, kypt      sum1 = .5*f(1,1,k,l)      f(1,1,k,l) = 0.0      f(1,2,k,l) = sum1      sum2 = f(2,nx+1,k,l)      f(2,nx+1,k,l) = f(2,2,k,l)      f(2,2,k,l) = sum2      sum3 = f(3,nx+1,k,l)      f(3,nx+1,k,l) = f(3,2,k,l)      f(3,2,k,l) = sum3      do 260 j = 2, nxh      sum1 = sum1 + f(1,2*j-1,k,l)      f(1,2*j-1,k,l) = -f(1,2*j,k,l)      f(1,2*j,k,l) = sum1      sum2 = sum2 - f(2,2*j,k,l)      f(2,2*j,k,l) = sum2      sum3 = sum3 - f(3,2*j,k,l)      f(3,2*j,k,l) = sum3  260 continue      f(1,nx+1,k,l) = 0.0  270 continue  280 continue      return      endc-----------------------------------------------------------------------      subroutine PFSCST2R3Y(g,isign,mixup,sctd,indx,indy,kstrt,kxp,kxpi,     1kxpp,nyv,kxpd,jblok,nxhyd,nxyd)c this subroutine performs the y part of 3 two dimensional fast realc sine and cosine transforms and their inverses, for a subset of x,c using real arithmetic, for data which is distributed in blocksc algorithm is described in Numerical Recipies in Fortran, Second Ed.,c by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, c [Cambridge Univ. Press, 1992], p. 508.c for isign = (-1,1), input: all, output: fc approximate flop count: N*(5*log2(N) + 18)/nvpc where N = (nx/2)*nyc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, inverse sine-cosine transform are performedc g(1,m,n,i) = sum(g(1,k,n,i)*sin(pi*m*k/ny))c g(2,m,n,i) = (.5*g(2,1,n,i) + ((-1)**m)*g(2,ny+1,n,i)c              + sum(g(2,k,n,i)*cos(pi*m*k/ny))c g(3,m,n,i) = sum(g(3,k,n,i)*sin(pi*m*k/ny))c if isign = 1, a forward sine-cosine transforms are performedc g(1,k,n,i) = sum(g(1,m,n,i)*sin(pi*m*k/ny))c g(2,k,n,i) = 2*(.5*g(2,1,n,i) + ((-1)**m)*g(2,ny+1,n,i)c              + sum(g(2,m,n,i)*cos(pi*m*k/ny))c g(3,k,n,i) = sum(g(3,m,n,i)*sin(pi*m*k/ny))c mixup = array of bit reversed addressesc sctd = sine/cosine tablec kstrt = starting data block numberc kxp = number of data values per block in xc kxpi = initial x index usedc kxpp = number of x indices usedc nyv = first dimension of g >= ny + 1c kxpd = second dimension of f >= kxp + 1c jblok = number of data blocks in xc nxhyd = maximum of (nx/2,ny)c nxyd = maximum of (nx,ny)c written by viktor k. decyk, ucla      implicit none      integer isign, mixup, indx, indy, kstrt, kxp, kxpi, kxpp      integer nyv, kxpd, jblok, nxhyd, nxyd      real g      complex sctd      dimension g(3,nyv,kxpd,jblok)      dimension mixup(nxhyd), sctd(nxyd)c local data      integer indx1, indy1, indx1y, nx, ny, nyh, nyhh, ny3, nxy, nxhy      integer i, j, k, l, m, ks, km, kmr, nry, j1, j2, ns, ns2, k1, k2      integer kxps, kxpt, jj      real at1, at2, at3, t2, t3, t4, t5, t6, ani, sum1, sum2, sum3      complex t1      indx1 = indx - 1      indy1 = indy - 1      indx1y = max0(indx1,indy)      nx = 2**indx      ny = 2**indy      nyh = ny/2      nyhh = ny/4      ny3 = ny + 3      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      kxps = kxpi + kxpp - 1      if (kstrt.gt.nx) return      if (isign.eq.0) returnc create auxiliary array in y      kmr = nxy/ny      kxpt = kxps      do 30 l = 1, jblok      if ((kxps+kxp*(l+ks)).eq.nx) kxpt = kxps + 1      do 20 j = kxpi, kxpt      sum1 = .5*(g(2,1,j,l) - g(2,ny+1,j,l))      do 10 k = 2, nyh      k1 = 1 + kmr*(k - 1)      at3 = -aimag(sctd(k1))      at2 = g(1,ny+2-k,j,l)      at1 = g(1,k,j,l) + at2      at2 = g(1,k,j,l) - at2      at1 = at3*at1      at2 = .5*at2      g(1,k,j,l) = at1 + at2      g(1,ny+2-k,j,l) = at1 - at2      at2 = g(2,ny+2-k,j,l)      at1 = g(2,k,j,l) + at2      at2 = g(2,k,j,l) - at2      sum1 = sum1 + real(sctd(k1))*at2      at2 = at3*at2      at1 = .5*at1      g(2,k,j,l) = at1 - at2      g(2,ny+2-k,j,l) = at1 + at2      at2 = g(3,ny+2-k,j,l)      at1 = g(3,k,j,l) + at2      at2 = g(3,k,j,l) - at2      at1 = at3*at1      at2 = .5*at2      g(3,k,j,l) = at1 + at2      g(3,ny+2-k,j,l) = at1 - at2   10 continue      g(1,1,j,l) = 0.0      g(1,nyh+1,j,l) = 2.0*g(1,nyh+1,j,l)      g(2,1,j,l) = .5*(g(2,1,j,l) + g(2,ny+1,j,l))      g(2,ny+1,j,l) = sum1      g(3,1,j,l) = 0.0      g(3,nyh+1,j,l) = 2.0*g(3,nyh+1,j,l)   20 continue   30 continuec bit-reverse array elements in y      nry = nxhy/nyh      kxpt = kxps      do 70 l = 1, jblok      if ((kxps+kxp*(l+ks)).eq.nx) kxpt = kxps + 1      do 60 k = 1, nyh      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 60      do 50 j = kxpi, kxpt      do 40 jj = 1, 3      t2 = g(jj,2*k1-1,j,l)      t3 = g(jj,2*k1,j,l)      g(jj,2*k1-1,j,l) = g(jj,2*k-1,j,l)      g(jj,2*k1,j,l) = g(jj,2*k,j,l)      g(jj,2*k-1,j,l) = t2      g(jj,2*k,j,l) = t3   40 continue   50 continue   60 continue   70 continuec first transform in y      nry = nxy/nyh      do 130 m = 1, indy1      ns = 2**(m - 1)      ns2 = ns + ns      km = nyhh/ns      kmr = 2*km*nry      kxpt = kxps      do 120 l = 1, jblok      if ((kxps+kxp*(l+ks)).eq.nx) kxpt = kxps + 1      do 110 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 100 j = 1, ns      j1 = j + k1      j2 = j + k2      t1 = sctd(1+kmr*(j-1))      do 90 i = kxpi, kxpt      do 80 jj = 1, 3      t2 = real(t1)*g(jj,2*j2-1,i,l) - aimag(t1)*g(jj,2*j2,i,l)      t3 = aimag(t1)*g(jj,2*j2-1,i,l) + real(t1)*g(jj,2*j2,i,l)      g(jj,2*j2-1,i,l) = g(jj,2*j1-1,i,l) - t2      g(jj,2*j2,i,l) = g(jj,2*j1,i,l) - t3      g(jj,2*j1-1,i,l) = g(jj,2*j1-1,i,l) + t2      g(jj,2*j1,i,l) = g(jj,2*j1,i,l) + t3   80 continue   90 continue  100 continue  110 continue  120 continue  130 continuec unscramble coefficients and normalizec inverse fourier transform      if (isign.lt.0) then         kmr = nxy/nyh         ani = 0.5         kxpt = kxps         do 190 l = 1, jblok         if ((kxps+kxp*(l+ks)).eq.nx) kxpt = kxps + 1         do 160 k = 2, nyhh         t1 = cmplx(aimag(sctd(1+kmr*(k-1))),-real(sctd(1+kmr*(k-1))))         do 150 j = kxpi, kxpt         do 140 jj = 1, 3         t4 = g(jj,ny3-2*k,j,l)         t5 = -g(jj,ny3-2*k+1,j,l)         t2 = g(jj,2*k-1,j,l) + t4         t3 = g(jj,2*k,j,l) + t5         t6 = g(jj,2*k-1,j,l) - t4         t5 = g(jj,2*k,j,l) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         g(jj,2*k-1,j,l) = ani*(t2 + t4)         g(jj,2*k,j,l) = ani*(t3 + t5)         g(jj,ny3-2*k,j,l) = ani*(t2 - t4)         g(jj,ny3-2*k+1,j,l) = ani*(t5 - t3)  140    continue  150    continue  160    continue         do 180 j = kxpi, kxpt         do 170 jj = 1, 3         g(jj,nyh+1,j,l) = g(jj,nyh+1,j,l)         g(jj,nyh+2,j,l) = -g(jj,nyh+2,j,l)         t2 = g(jj,1,j,l) + g(jj,2,j,l)         g(jj,2,j,l) = g(jj,1,j,l) - g(jj,2,j,l)         g(jj,1,j,l) = t2         g(jj,ny+1,j,l) = g(jj,ny+1,j,l)  170    continue  180    continue  190    continuec forward fourier transform      else if (isign.gt.0) then         kmr = nxy/nyh         kxpt = kxps         do 250 l = 1, jblok         if ((kxps+kxp*(l+ks)).eq.nx) kxpt = kxps + 1         do 220 k = 2, nyhh         t1 = cmplx(aimag(sctd(1+kmr*(k-1))),-real(sctd(1+kmr*(k-1))))         do 210 j = kxpi, kxpt         do 200 jj = 1, 3         t4 = g(jj,ny3-2*k,j,l)         t5 = -g(jj,ny3-2*k+1,j,l)         t2 = g(jj,2*k-1,j,l) + t4         t3 = g(jj,2*k,j,l) + t5         t6 = g(jj,2*k-1,j,l) - t4         t5 = g(jj,2*k,j,l) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         g(jj,2*k-1,j,l) = t2 + t4         g(jj,2*k,j,l) = t3 + t5         g(jj,ny3-2*k,j,l) = t2 - t4         g(jj,ny3-2*k+1,j,l) = t5 - t3  200    continue  210    continue  220    continue         do 240 j = kxpi, kxpt         do 230 jj = 1, 3         g(jj,nyh+1,j,l) = 2.0*g(jj,nyh+1,j,l)         g(jj,nyh+2,j,l) = -2.0*g(jj,nyh+2,j,l)         t2 = 2.0*(g(jj,1,j,l) + g(jj,2,j,l))         g(jj,2,j,l) = 2.0*(g(jj,1,j,l) - g(jj,2,j,l))         g(jj,1,j,l) = t2         g(jj,ny+1,j,l) = 2.0*g(jj,ny+1,j,l)  230    continue  240    continue  250    continue      endifc perform recursion for sine-cosine transform      kxpt = kxps      do 280 l = 1, jblok      if ((kxps+kxp*(l+ks)).eq.nx) kxpt = kxps + 1      do 270 j = kxpi, kxpt      sum1 = .5*g(1,1,j,l)      g(1,1,j,l) = 0.0      g(1,2,j,l) = sum1      sum2 = g(2,ny+1,j,l)      g(2,ny+1,j,l) = g(2,2,j,l)      g(2,2,j,l) = sum2      sum3 = .5*g(3,1,j,l)      g(3,1,j,l) = 0.0      g(3,2,j,l) = sum3      do 260 k = 2, nyh      sum1 = sum1 + g(1,2*k-1,j,l)      g(1,2*k-1,j,l) = -g(1,2*k,j,l)      g(1,2*k,j,l) = sum1      sum2 = sum2 - g(2,2*k,j,l)      g(2,2*k,j,l) = sum2      sum3 = sum3 + g(3,2*k-1,j,l)      g(3,2*k-1,j,l) = -g(3,2*k,j,l)      g(3,2*k,j,l) = sum3  260 continue      g(1,ny+1,j,l) = 0.0      g(3,ny+1,j,l) = 0.0  270 continue  280 continue      return      endc-----------------------------------------------------------------------      subroutine PFCSCT2R3Y(g,isign,mixup,sctd,indx,indy,kstrt,kxp,kxpi,     1kxpp,nyv,kxpd,jblok,nxhyd,nxyd)c this subroutine performs the y part of 3 two dimensional fast realc sine and cosine transforms and their inverses, for a subset of x,c using real arithmetic, for data which is distributed in blocksc algorithm is described in Numerical Recipies in Fortran, Second Ed.,c by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, c [Cambridge Univ. Press, 1992], p. 508.c for isign = (-1,1), input: all, output: fc approximate flop count: N*(5*log2(N) + 18)/nvpc where N = (nx/2)*nyc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, inverse sine-cosine transform are performedc g(1,m,n,i) = (.5*g(1,1,n,i) + ((-1)**m)*g(1,ny+1,n,i)c              + sum(g(1,k,n,i)*cos(pi*m*k/ny))c g(2,m,n,i) = sum(g(2,k,n,i)*sin(pi*m*k/ny))c g(3,m,n,i) = (.5*g(3,1,n,i) + ((-1)**m)*g(3,ny+1,n,i)c              + sum(g(3,k,n,i)*cos(pi*m*k/ny))c if isign = 1, a forward sine-cosine transforms are performedc g(1,k,n,i) = 2*(.5*g(1,1,n,i) + ((-1)**m)*g(1,ny+1,n,i)c              + sum(g(1,m,n,i)*cos(pi*m*k/ny))c g(2,k,n,i) = sum(g(2,m,n,i)*sin(pi*m*k/ny))c g(3,k,n,i) = 2*(.5*g(3,1,n,i) + ((-1)**m)*g(3,ny+1,n,i)c              + sum(g(3,m,n,i)*cos(pi*m*k/ny))c mixup = array of bit reversed addressesc sctd = sine/cosine tablec kstrt = starting data block numberc kxp = number of data values per block in xc kxpi = initial x index usedc kxpp = number of x indices usedc nyv = first dimension of g >= ny + 1c kxpd = second dimension of f >= kxp + 1c jblok = number of data blocks in xc nxhyd = maximum of (nx/2,ny)c nxyd = maximum of (nx,ny)c written by viktor k. decyk, ucla      implicit none      integer isign, mixup, indx, indy, kstrt, kxp, kxpi, kxpp      integer nyv, kxpd, jblok, nxhyd, nxyd      real g      complex sctd      dimension g(3,nyv,kxpd,jblok)      dimension mixup(nxhyd), sctd(nxyd)c local data      integer indx1, indy1, indx1y, nx, ny, nyh, nyhh, ny3, nxy, nxhy      integer i, j, k, l, m, ks, km, kmr, nry, j1, j2, ns, ns2, k1, k2      integer kxps, kxpt, jj      real at1, at2, at3, t2, t3, t4, t5, t6, ani, sum1, sum2, sum3      complex t1      indx1 = indx - 1      indy1 = indy - 1      indx1y = max0(indx1,indy)      nx = 2**indx      ny = 2**indy      nyh = ny/2      nyhh = ny/4      ny3 = ny + 3      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      kxps = kxpi + kxpp - 1      if (kstrt.gt.nx) return      if (isign.eq.0) returnc create auxiliary array in y      kmr = nxy/ny      kxpt = kxps      do 30 l = 1, jblok      if ((kxps+kxp*(l+ks)).eq.nx) kxpt = kxps + 1      do 20 j = kxpi, kxpt      sum1 = .5*(g(1,1,j,l) - g(1,ny+1,j,l))      sum2 = .5*(g(3,1,j,l) - g(3,ny+1,j,l))      do 10 k = 2, nyh      k1 = 1 + kmr*(k - 1)      at3 = -aimag(sctd(k1))      at2 = g(1,ny+2-k,j,l)      at1 = g(1,k,j,l) + at2      at2 = g(1,k,j,l) - at2      sum1 = sum1 + real(sctd(k1))*at2      at2 = at3*at2      at1 = .5*at1      g(1,k,j,l) = at1 - at2      g(1,ny+2-k,j,l) = at1 + at2      at2 = g(2,ny+2-k,j,l)      at1 = g(2,k,j,l) + at2      at2 = g(2,k,j,l) - at2      at1 = at3*at1      at2 = .5*at2      g(2,k,j,l) = at1 + at2      g(2,ny+2-k,j,l) = at1 - at2      at2 = g(3,ny+2-k,j,l)      at1 = g(3,k,j,l) + at2      at2 = g(3,k,j,l) - at2      sum2 = sum2 + real(sctd(k1))*at2      at2 = at3*at2      at1 = .5*at1      g(3,k,j,l) = at1 - at2      g(3,ny+2-k,j,l) = at1 + at2   10 continue      g(1,1,j,l) = .5*(g(1,1,j,l) + g(1,ny+1,j,l))      g(1,ny+1,j,l) = sum1      g(2,1,j,l) = 0.0      g(2,nyh+1,j,l) = 2.0*g(2,nyh+1,j,l)      g(3,1,j,l) = .5*(g(3,1,j,l) + g(3,ny+1,j,l))      g(3,ny+1,j,l) = sum2   20 continue   30 continuec bit-reverse array elements in y      nry = nxhy/nyh      kxpt = kxps      do 70 l = 1, jblok      if ((kxps+kxp*(l+ks)).eq.nx) kxpt = kxps + 1      do 60 k = 1, nyh      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 60      do 50 j = kxpi, kxpt      do 40 jj = 1, 3      t2 = g(jj,2*k1-1,j,l)      t3 = g(jj,2*k1,j,l)      g(jj,2*k1-1,j,l) = g(jj,2*k-1,j,l)      g(jj,2*k1,j,l) = g(jj,2*k,j,l)      g(jj,2*k-1,j,l) = t2      g(jj,2*k,j,l) = t3   40 continue   50 continue   60 continue   70 continuec first transform in y      nry = nxy/nyh      do 130 m = 1, indy1      ns = 2**(m - 1)      ns2 = ns + ns      km = nyhh/ns      kmr = 2*km*nry      kxpt = kxps      do 120 l = 1, jblok      if ((kxps+kxp*(l+ks)).eq.nx) kxpt = kxps + 1      do 110 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 100 j = 1, ns      j1 = j + k1      j2 = j + k2      t1 = sctd(1+kmr*(j-1))      do 90 i = kxpi, kxpt      do 80 jj = 1, 3      t2 = real(t1)*g(jj,2*j2-1,i,l) - aimag(t1)*g(jj,2*j2,i,l)      t3 = aimag(t1)*g(jj,2*j2-1,i,l) + real(t1)*g(jj,2*j2,i,l)      g(jj,2*j2-1,i,l) = g(jj,2*j1-1,i,l) - t2      g(jj,2*j2,i,l) = g(jj,2*j1,i,l) - t3      g(jj,2*j1-1,i,l) = g(jj,2*j1-1,i,l) + t2      g(jj,2*j1,i,l) = g(jj,2*j1,i,l) + t3   80 continue   90 continue  100 continue  110 continue  120 continue  130 continuec unscramble coefficients and normalizec inverse fourier transform      if (isign.lt.0) then         kmr = nxy/nyh         ani = 0.5         kxpt = kxps         do 190 l = 1, jblok         if ((kxps+kxp*(l+ks)).eq.nx) kxpt = kxps + 1         do 160 k = 2, nyhh         t1 = cmplx(aimag(sctd(1+kmr*(k-1))),-real(sctd(1+kmr*(k-1))))         do 150 j = kxpi, kxpt         do 140 jj = 1, 3         t4 = g(jj,ny3-2*k,j,l)         t5 = -g(jj,ny3-2*k+1,j,l)         t2 = g(jj,2*k-1,j,l) + t4         t3 = g(jj,2*k,j,l) + t5         t6 = g(jj,2*k-1,j,l) - t4         t5 = g(jj,2*k,j,l) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         g(jj,2*k-1,j,l) = ani*(t2 + t4)         g(jj,2*k,j,l) = ani*(t3 + t5)         g(jj,ny3-2*k,j,l) = ani*(t2 - t4)         g(jj,ny3-2*k+1,j,l) = ani*(t5 - t3)  140    continue  150    continue  160    continue         do 180 j = kxpi, kxpt         do 170 jj = 1, 3         g(jj,nyh+1,j,l) = g(jj,nyh+1,j,l)         g(jj,nyh+2,j,l) = -g(jj,nyh+2,j,l)         t2 = g(jj,1,j,l) + g(jj,2,j,l)         g(jj,2,j,l) = g(jj,1,j,l) - g(jj,2,j,l)         g(jj,1,j,l) = t2         g(jj,ny+1,j,l) = g(jj,ny+1,j,l)  170    continue  180    continue  190    continuec forward fourier transform      else if (isign.gt.0) then         kmr = nxy/nyh         kxpt = kxps         do 250 l = 1, jblok         if ((kxps+kxp*(l+ks)).eq.nx) kxpt = kxps + 1         do 220 k = 2, nyhh         t1 = cmplx(aimag(sctd(1+kmr*(k-1))),-real(sctd(1+kmr*(k-1))))         do 210 j = kxpi, kxpt         do 200 jj = 1, 3         t4 = g(jj,ny3-2*k,j,l)         t5 = -g(jj,ny3-2*k+1,j,l)         t2 = g(jj,2*k-1,j,l) + t4         t3 = g(jj,2*k,j,l) + t5         t6 = g(jj,2*k-1,j,l) - t4         t5 = g(jj,2*k,j,l) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         g(jj,2*k-1,j,l) = t2 + t4         g(jj,2*k,j,l) = t3 + t5         g(jj,ny3-2*k,j,l) = t2 - t4         g(jj,ny3-2*k+1,j,l) = t5 - t3  200    continue  210    continue  220    continue         do 240 j = kxpi, kxpt         do 230 jj = 1, 3         g(jj,nyh+1,j,l) = 2.0*g(jj,nyh+1,j,l)         g(jj,nyh+2,j,l) = -2.0*g(jj,nyh+2,j,l)         t2 = 2.0*(g(jj,1,j,l) + g(jj,2,j,l))         g(jj,2,j,l) = 2.0*(g(jj,1,j,l) - g(jj,2,j,l))         g(jj,1,j,l) = t2         g(jj,ny+1,j,l) = 2.0*g(jj,ny+1,j,l)  230    continue  240    continue  250    continue      endifc perform recursion for sine-cosine transform      kxpt = kxps      do 280 l = 1, jblok      if ((kxps+kxp*(l+ks)).eq.nx) kxpt = kxps + 1      do 270 j = kxpi, kxpt      sum1 = g(1,ny+1,j,l)      g(1,ny+1,j,l) = g(1,2,j,l)      g(1,2,j,l) = sum1      sum2 = .5*g(2,1,j,l)      g(2,1,j,l) = 0.0      g(2,2,j,l) = sum2      sum3 = g(3,ny+1,j,l)      g(3,ny+1,j,l) = g(3,2,j,l)      g(3,2,j,l) = sum3      do 260 k = 2, nyh      sum1 = sum1 - g(1,2*k,j,l)      g(1,2*k,j,l) = sum1      sum2 = sum2 + g(2,2*k-1,j,l)      g(2,2*k-1,j,l) = -g(2,2*k,j,l)      g(2,2*k,j,l) = sum2      sum3 = sum3 - g(3,2*k,j,l)      g(3,2*k,j,l) = sum3  260 continue      g(2,ny+1,j,l) = 0.0  270 continue  280 continue      return      endc-----------------------------------------------------------------------      subroutine WFST2RINIT(mixup,sctd,indx,indy,nxhyd,nxyd)c this subroutine calculates tables needed by a two dimensionalc fast real sine and cosine transforms and their inverses.c input: indx, indy, nxhyd, nxydc output: mixup, sctdc mixup = array of bit reversed addressesc sctd = sine/cosine tablec indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc nxhyd = maximum of (nx/2,ny)c nxyd = maximum of (nx,ny)c written by viktor k. decyk, ucla      implicit none      integer indx, indy, nxhyd, nxyd      integer mixup      complex sctd      dimension mixup(nxhyd), sctd(nxyd)c local data      integer indx1, indx1y, nx, ny, nxy, nxhy      integer j, k, lb, ll, jb, it      real dnxy, arg      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      ny = 2**indy      nxy = max0(nx,ny)      nxhy = 2**indx1yc bit-reverse index table: mixup(j) = 1 + reversed bits of (j - 1)      do 20 j = 1, nxhy      lb = j - 1      ll = 0      do 10 k = 1, indx1y      jb = lb/2      it = lb - 2*jb      lb = jb      ll = 2*ll + it   10 continue      mixup(j) = ll + 1   20 continuec sine/cosine table for the angles n*pi/nxy      dnxy = 0.5*6.28318530717959/float(nxy)      do 30 j = 1, nxy      arg = dnxy*float(j - 1)      sctd(j) = cmplx(cos(arg),-sin(arg))   30 continue      return      endc-----------------------------------------------------------------------      subroutine WFSST2RX(f,isign,mixup,sctd,indx,indy,nxhd,nyd,nxhyd,nx     1yd)c wrapper function for real sine/sine transform      implicit none      real f      complex sctd      integer mixup      integer isign, indx, indy, nxhd, nyd, nxhyd, nxyd      dimension f(2*nxhd,nyd), mixup(nxhyd), sctd(nxyd)c local data      integer nx, ny, nxi, nyi, nxt, nyt      data nxi, nyi /1,1/c calculate range of indices      nx = 2**indx      ny = 2**indy      nxt = nx + 1      nyt = ny + 1c inverse fourier transform      if (isign.lt.0) thenc perform x sine transform         call FST2RXX(f,isign,mixup,sctd,indx,indy,nyi,nyt,nxhd,nyd,nxhy     1d,nxyd)c perform y sine transform         call FST2RXY(f,isign,mixup,sctd,indx,indy,nxi,nxt,nxhd,nyd,nxhy     1d,nxyd)c forward fourier transform      else if (isign.gt.0) thenc perform y sine transform         call FST2RXY(f,isign,mixup,sctd,indx,indy,nxi,nxt,nxhd,nyd,nxhy     1d,nxyd)c perform x sine transform         call FST2RXX(f,isign,mixup,sctd,indx,indy,nyi,nyt,nxhd,nyd,nxhy     1d,nxyd)      endif      return      endc-----------------------------------------------------------------------      subroutine WFSCT2RX(f,isign,mixup,sctd,indx,indy,nxhd,nyd,nxhyd,nx     1yd)c wrapper function for real mixed sine/cosine transform      implicit none      real f      complex sctd      integer mixup      integer isign, indx, indy, nxhd, nyd, nxhyd, nxyd      dimension f(2*nxhd,nyd), mixup(nxhyd), sctd(nxyd)c local data      integer nx, ny, nxi, nyi, nxt, nyt      data nxi, nyi /1,1/c calculate range of indices      nx = 2**indx      ny = 2**indy      nxt = nx + 1      nyt = ny + 1c inverse fourier transform      if (isign.lt.0) thenc perform x sine transform         call FST2RXX(f,isign,mixup,sctd,indx,indy,nyi,nyt,nxhd,nyd,nxhy     1d,nxyd)c perform y cosine transform         call FCT2RXY(f,isign,mixup,sctd,indx,indy,nxi,nxt,nxhd,nyd,nxhy     1d,nxyd)c forward fourier transform      else if (isign.gt.0) thenc perform y cosine transform         call FCT2RXY(f,isign,mixup,sctd,indx,indy,nxi,nxt,nxhd,nyd,nxhy     1d,nxyd)c perform x sine transform         call FST2RXX(f,isign,mixup,sctd,indx,indy,nyi,nyt,nxhd,nyd,nxhy     1d,nxyd)      endif      return      endc-----------------------------------------------------------------------      subroutine WFCST2RX(f,isign,mixup,sctd,indx,indy,nxhd,nyd,nxhyd,nx     1yd)c wrapper function for real mixed cosine/sine transform      implicit none      real f      complex sctd      integer mixup      integer isign, indx, indy, nxhd, nyd, nxhyd, nxyd      dimension f(2*nxhd,nyd), mixup(nxhyd), sctd(nxyd)c local data      integer nx, ny, nxi, nyi, nxt, nyt      data nxi, nyi /1,1/c calculate range of indices      nx = 2**indx      ny = 2**indy      nxt = nx + 1      nyt = ny + 1c inverse fourier transform      if (isign.lt.0) thenc perform x cosine transform         call FCT2RXX(f,isign,mixup,sctd,indx,indy,nyi,nyt,nxhd,nyd,nxhy     1d,nxyd)c perform y cosine transform         call FST2RXY(f,isign,mixup,sctd,indx,indy,nxi,nxt,nxhd,nyd,nxhy     1d,nxyd)c forward fourier transform      else if (isign.gt.0) thenc perform y cosine transform         call FST2RXY(f,isign,mixup,sctd,indx,indy,nxi,nxt,nxhd,nyd,nxhy     1d,nxyd)c perform x cosine transform         call FCT2RXX(f,isign,mixup,sctd,indx,indy,nyi,nyt,nxhd,nyd,nxhy     1d,nxyd)      endif      return      endc-----------------------------------------------------------------------      subroutine WFCCT2RX(f,isign,mixup,sctd,indx,indy,nxhd,nyd,nxhyd,nx     1yd)c wrapper function for real cosine/cosine transform      implicit none      real f      complex sctd      integer mixup      integer isign, indx, indy, nxhd, nyd, nxhyd, nxyd      dimension f(2*nxhd,nyd), mixup(nxhyd), sctd(nxyd)c local data      integer nx, ny, nxi, nyi, nxt, nyt      data nxi, nyi /1,1/c calculate range of indices      nx = 2**indx      ny = 2**indy      nxt = nx + 1      nyt = ny + 1c inverse fourier transform      if (isign.lt.0) thenc perform x cosine transform         call FCT2RXX(f,isign,mixup,sctd,indx,indy,nyi,nyt,nxhd,nyd,nxhy     1d,nxyd)c perform y cosine transform         call FCT2RXY(f,isign,mixup,sctd,indx,indy,nxi,nxt,nxhd,nyd,nxhy     1d,nxyd)c forward fourier transform      else if (isign.gt.0) thenc perform y cosine transform         call FCT2RXY(f,isign,mixup,sctd,indx,indy,nxi,nxt,nxhd,nyd,nxhy     1d,nxyd)c perform x cosine transform         call FCT2RXX(f,isign,mixup,sctd,indx,indy,nyi,nyt,nxhd,nyd,nxhy     1d,nxyd)      endif      return      endc-----------------------------------------------------------------------      subroutine FST2RXX(f,isign,mixup,sctd,indx,indy,nyi,nyp,nxhd,nyd,n     1xhyd,nxyd)c this subroutine performs the x part of a two dimensional fast realc sine transform and its inverse, for a subset of y,c using real arithmeticc algorithm is described in Numerical Recipies in Fortran, Second Ed.,c by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, c [Cambridge Univ. Press, 1992], p. 508.c for isign = (-1,1), input: all, output: fc approximate flop count: N*(5*log2(N) + 18)c where N = (nx/2)*nyc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, an inverse sine transform is performedc f(n,k) = (1/nx*ny)*sum(f(j,k)*sin(pi*n*j/nx))c if isign = 1, a forward sine transform is performedc f(j,k) = sum(f(n,k)*sin(pi*n*j/nx))c mixup = array of bit reversed addressesc sctd = sine/cosine tablec nyi = initial y index usedc nyp = number of y indices usedc nxhd = first dimension of f => nx/2 + 1c nyd = second dimension of fc nxhyd = maximum of (nx/2,ny)c nxyd = maximum of (nx,ny)c written by viktor k. decyk, ucla      complex sctd, t1      dimension f(2*nxhd,nyd), mixup(nxhyd), sctd(nxyd)      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nx3 = nx + 3      ny = 2**indy      nxy = max0(nx,ny)      nxhy = 2**indx1y      nyt = nyi + nyp - 1      if (isign.eq.0) returnc create auxiliary array in x      kmr = nxy/nx      do 20 k = nyi, nyt      do 10 j = 2, nxh      j1 = 1 + kmr*(j - 1)      at2 = f(nx+2-j,k)      at1 = f(j,k) + at2      at2 = f(j,k) - at2      at1 = -aimag(sctd(j1))*at1      at2 = .5*at2      f(j,k) = at1 + at2      f(nx+2-j,k) = at1 - at2   10 continue      f(1,k) = 0.0      f(nxh+1,k) = 2.0*f(nxh+1,k)   20 continuec bit-reverse array elements in x      nrx = nxhy/nxh      do 40 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 40      do 30 k = nyi, nyt      t2 = f(2*j1-1,k)      t3 = f(2*j1,k)      f(2*j1-1,k) = f(2*j-1,k)      f(2*j1,k) = f(2*j,k)      f(2*j-1,k) = t2      f(2*j,k) = t3   30 continue   40 continuec first transform in x      nrx = nxy/nxh      do 80 l = 1, indx1      ns = 2**(l - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = 2*km*nrx      do 70 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 60 j = 1, ns      j1 = j + k1      j2 = j + k2      t1 = sctd(1+kmr*(j-1))      do 50 i = nyi, nyt      t2 = real(t1)*f(2*j2-1,i) - aimag(t1)*f(2*j2,i)      t3 = aimag(t1)*f(2*j2-1,i) + real(t1)*f(2*j2,i)      f(2*j2-1,i) = f(2*j1-1,i) - t2      f(2*j2,i) = f(2*j1,i) - t3      f(2*j1-1,i) = f(2*j1-1,i) + t2      f(2*j1,i) = f(2*j1,i) + t3   50 continue   60 continue   70 continue   80 continuec unscramble coefficients and normalizec inverse fourier transform      if (isign.lt.0) then         kmr = nxy/nxh         ani = 1./float(2*nx*ny)         do 100 j = 2, nxhh         t1 = cmplx(aimag(sctd(1+kmr*(j-1))),-real(sctd(1+kmr*(j-1))))         do 90 k = nyi, nyt         t4 = f(nx3-2*j,k)         t5 = -f(nx3-2*j+1,k)         t2 = f(2*j-1,k) + t4         t3 = f(2*j,k) + t5         t6 = f(2*j-1,k) - t4         t5 = f(2*j,k) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         f(2*j-1,k) = ani*(t2 + t4)         f(2*j,k) = ani*(t3 + t5)         f(nx3-2*j,k) = ani*(t2 - t4)         f(nx3-2*j+1,k) = ani*(t5 - t3)   90    continue  100    continue         ani = 2.*ani         do 110 k = nyi, nyt         f(nxh+1,k) = ani*f(nxh+1,k)         f(nxh+2,k) = -ani*f(nxh+2,k)         t2 = ani*(f(1,k) + f(2,k))         f(2,k) = ani*(f(1,k) - f(2,k))         f(1,k) = t2         f(nx+1,k) = ani*f(nx+1,k)  110    continuec forward fourier transform      else if (isign.gt.0) then         kmr = nxy/nxh         do 130 j = 2, nxhh         t1 = cmplx(aimag(sctd(1+kmr*(j-1))),-real(sctd(1+kmr*(j-1))))         do 120 k = nyi, nyt         t4 = f(nx3-2*j,k)         t5 = -f(nx3-2*j+1,k)         t2 = f(2*j-1,k) + t4         t3 = f(2*j,k) + t5         t6 = f(2*j-1,k) - t4         t5 = f(2*j,k) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         f(2*j-1,k) = t2 + t4         f(2*j,k) = t3 + t5         f(nx3-2*j,k) = t2 - t4         f(nx3-2*j+1,k) = t5 - t3  120    continue  130    continue         do 140 k = nyi, nyt         f(nxh+1,k) = 2.0*f(nxh+1,k)         f(nxh+2,k) = -2.0*f(nxh+2,k)         t2 = 2.0*(f(1,k) + f(2,k))         f(2,k) = 2.0*(f(1,k) - f(2,k))         f(1,k) = t2         f(nx+1,k) = 2.0*f(nx+1,k)  140    continue      endifc perform recursion for sine transform      do 160 k = nyi, nyt      sum1 = .5*f(1,k)      f(1,k) = 0.0      f(2,k) = sum1      do 150 j = 2, nxh      sum1 = sum1 + f(2*j-1,k)      f(2*j-1,k) = -f(2*j,k)      f(2*j,k) = sum1  150 continue      f(nx+1,k) = 0.0  160 continue      return      endc-----------------------------------------------------------------------      subroutine FCT2RXX(f,isign,mixup,sctd,indx,indy,nyi,nyp,nxhd,nyd,n     1xhyd,nxyd)c this subroutine performs the x part of a two dimensional fast realc cosine transform and its inverse, for a subset of y,c using real arithmeticc algorithm is described in Numerical Recipies in Fortran, Second Ed.,c by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, c [Cambridge Univ. Press, 1992], p. 508.c for isign = (-1,1), input: all, output: fc approximate flop count: N*(5*log2(N) + 18)c where N = (nx/2)*nyc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, an inverse cosine transform is performedc f(n,k) = (1/nx*ny)*(.5*f(1,k) + ((-1)**n)*f(nx+1,k) + sum(f(j,k)*c       cos(pi*n*j/nx)))c if isign = 1, a forward cosine transform is performedc f(j,k) = 2*(.5*f(1,k) + ((-1)**j)*f(n+1,k) + sum(f(n,k)*c       cos(pi*n*j/nx))c mixup = array of bit reversed addressesc sctd = sine/cosine tablec nyi = initial y index usedc nyp = number of y indices usedc nxhd = first dimension of f >= nx/2 + 1c nyd = second dimension of fc nxhyd = maximum of (nx/2,ny)c nxyd = maximum of (nx,ny)c written by viktor k. decyk, ucla      complex sctd, t1      dimension f(2*nxhd,nyd), mixup(nxhyd), sctd(nxyd)      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nx3 = nx + 3      ny = 2**indy      nxy = max0(nx,ny)      nxhy = 2**indx1y      nyt = nyi + nyp - 1      if (isign.eq.0) returnc create auxiliary array in x      kmr = nxy/nx      do 20 k = nyi, nyt      sum1 = .5*(f(1,k) - f(nx+1,k))      do 10 j = 2, nxh      j1 = 1 + kmr*(j - 1)      at2 = f(nx+2-j,k)      at1 = f(j,k) + at2      at2 = f(j,k) - at2      sum1 = sum1 + real(sctd(j1))*at2      at2 = -aimag(sctd(j1))*at2      at1 = .5*at1      f(j,k) = at1 - at2      f(nx+2-j,k) = at1 + at2   10 continue      f(1,k) = .5*(f(1,k) + f(nx+1,k))      f(nx+1,k) = sum1   20 continuec bit-reverse array elements in x      nrx = nxhy/nxh      do 40 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 40      do 30 k = nyi, nyt      t2 = f(2*j1-1,k)      t3 = f(2*j1,k)      f(2*j1-1,k) = f(2*j-1,k)      f(2*j1,k) = f(2*j,k)      f(2*j-1,k) = t2      f(2*j,k) = t3   30 continue   40 continuec first transform in x      nrx = nxy/nxh      do 80 l = 1, indx1      ns = 2**(l - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = 2*km*nrx      do 70 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 60 j = 1, ns      j1 = j + k1      j2 = j + k2      t1 = sctd(1+kmr*(j-1))      do 50 i = nyi, nyt      t2 = real(t1)*f(2*j2-1,i) - aimag(t1)*f(2*j2,i)      t3 = aimag(t1)*f(2*j2-1,i) + real(t1)*f(2*j2,i)      f(2*j2-1,i) = f(2*j1-1,i) - t2      f(2*j2,i) = f(2*j1,i) - t3      f(2*j1-1,i) = f(2*j1-1,i) + t2      f(2*j1,i) = f(2*j1,i) + t3   50 continue   60 continue   70 continue   80 continuec unscramble coefficients and normalizec inverse fourier transform      if (isign.lt.0) then         kmr = nxy/nxh         ani = 1./float(2*nx*ny)         do 100 j = 2, nxhh         t1 = cmplx(aimag(sctd(1+kmr*(j-1))),-real(sctd(1+kmr*(j-1))))         do 90 k = nyi, nyt         t4 = f(nx3-2*j,k)         t5 = -f(nx3-2*j+1,k)         t2 = f(2*j-1,k) + t4         t3 = f(2*j,k) + t5         t6 = f(2*j-1,k) - t4         t5 = f(2*j,k) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         f(2*j-1,k) = ani*(t2 + t4)         f(2*j,k) = ani*(t3 + t5)         f(nx3-2*j,k) = ani*(t2 - t4)         f(nx3-2*j+1,k) = ani*(t5 - t3)   90    continue  100    continue         ani = 2.*ani         do 110 k = nyi, nyt         f(nxh+1,k) = ani*f(nxh+1,k)         f(nxh+2,k) = -ani*f(nxh+2,k)         t2 = ani*(f(1,k) + f(2,k))         f(2,k) = ani*(f(1,k) - f(2,k))         f(1,k) = t2         f(nx+1,k) = ani*f(nx+1,k)  110    continuec forward fourier transform      else if (isign.gt.0) then         kmr = nxy/nxh         do 130 j = 2, nxhh         t1 = cmplx(aimag(sctd(1+kmr*(j-1))),-real(sctd(1+kmr*(j-1))))         do 120 k = nyi, nyt         t4 = f(nx3-2*j,k)         t5 = -f(nx3-2*j+1,k)         t2 = f(2*j-1,k) + t4         t3 = f(2*j,k) + t5         t6 = f(2*j-1,k) - t4         t5 = f(2*j,k) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         f(2*j-1,k) = t2 + t4         f(2*j,k) = t3 + t5         f(nx3-2*j,k) = t2 - t4         f(nx3-2*j+1,k) = t5 - t3  120    continue  130    continue         do 140 k = nyi, nyt         f(nxh+1,k) = 2.0*f(nxh+1,k)         f(nxh+2,k) = -2.0*f(nxh+2,k)         t2 = 2.0*(f(1,k) + f(2,k))         f(2,k) = 2.0*(f(1,k) - f(2,k))         f(1,k) = t2         f(nx+1,k) = 2.0*f(nx+1,k)  140    continue      endifc perform recursion for cosine transform      do 160 k = nyi, nyt      sum1 = f(nx+1,k)      f(nx+1,k) = f(2,k)      f(2,k) = sum1      do 150 j = 2, nxh      sum1 = sum1 - f(2*j,k)      f(2*j,k) = sum1  150 continue  160 continue      return      endc-----------------------------------------------------------------------      subroutine FST2RXY(f,isign,mixup,sctd,indx,indy,nxi,nxp,nxhd,nyd,n     1xhyd,nxyd)c this subroutine performs the y part of a two dimensional fast realc sine transform and its inverse, for a subset of x,c using real arithmeticc algorithm is described in Numerical Recipies in Fortran, Second Ed.,c by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, c [Cambridge Univ. Press, 1992], p. 508.c for isign = (-1,1), input: all, output: fc approximate flop count: N*(5*log2(N) + 19)c where N = (nx/2)*nyc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, an inverse sine transform is performedc f(n,m) = sum(f(n,k)*sin(pi*m*k/ny))c if isign = 1, a forward sine transform is performedc f(n,k) = 2*sum(f(n,m)*sin(pi*m*k/ny)c mixup = array of bit reversed addressesc sctd = sine/cosine tablec nxi = initial x index usedc nxp = number of x indices usedc nxhd = first dimension of f >= nx/2 + 1c nyd = second dimension of f >= ny + 1c nxhyd = maximum of (nx/2,ny)c nxyd = maximum of (nx,ny)c written by viktor k. decyk, ucla      complex sctd, t1      dimension f(2*nxhd,nyd), mixup(nxhyd), sctd(nxyd)      indx1 = indx - 1      indy1 = indy - 1      indx1y = max0(indx1,indy)      nx = 2**indx      ny = 2**indy      nyh = ny/2      nyhh = ny/4      ny2 = ny + 2      nxy = max0(nx,ny)      nxhy = 2**indx1y      nxt = nxi + nxp - 1      if (isign.eq.0) returnc create auxiliary array in y      kmr = nxy/ny      do 20 j = nxi, nxt      do 10 k = 2, nyh      k1 = 1 + kmr*(k - 1)      at2 = f(j,ny2-k)      at1 = f(j,k) + at2      at2 = f(j,k) - at2      at1 = -aimag(sctd(k1))*at1      at2 = .5*at2      f(j,k) = at1 + at2      f(j,ny2-k) = at1 - at2   10 continue      f(j,1) = 0.0      f(j,nyh+1) = 2.0*f(j,nyh+1)   20 continue      nry = nxhy/nyhc bit-reverse array elements in y      do 40 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 40      do 30 j = nxi, nxt      t2 = f(j,2*k1-1)      t3 = f(j,2*k1)      f(j,2*k1-1) = f(j,2*k-1)      f(j,2*k1) = f(j,2*k)      f(j,2*k-1) = t2      f(j,2*k) = t3   30 continue   40 continuec then transform in y      nry = nxy/nyh      do 80 l = 1, indy1      ns = 2**(l - 1)      ns2 = ns + ns      km = nyhh/ns      kmr = 2*km*nry      do 70 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 60 j = 1, ns      j1 = j + k1      j2 = j + k2      t1 = sctd(1+kmr*(j-1))      do 50 i = nxi, nxt      t2 = real(t1)*f(i,2*j2-1) - aimag(t1)*f(i,2*j2)      t3 = aimag(t1)*f(i,2*j2-1) + real(t1)*f(i,2*j2)      f(i,2*j2-1) = f(i,2*j1-1) - t2      f(i,2*j2) = f(i,2*j1) - t3      f(i,2*j1-1) = f(i,2*j1-1) + t2      f(i,2*j1) = f(i,2*j1) + t3   50 continue   60 continue   70 continue   80 continuec unscramble coefficients and normalizec inverse fourier transform      if (isign.lt.0) then         kmr = nxy/nyh         ani = 0.5         do 100 k = 2, nyhh         t1 = cmplx(aimag(sctd(1+kmr*(k-1))),-real(sctd(1+kmr*(k-1))))         do 90 j = nxi, nxt         t4 = f(j,ny+3-2*k)         t5 = -f(j,ny+3-2*k+1)         t2 = f(j,2*k-1) + t4         t3 = f(j,2*k) + t5         t6 = f(j,2*k-1) - t4         t5 = f(j,2*k) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         f(j,2*k-1) = ani*(t2 + t4)         f(j,2*k) = ani*(t3 + t5)         f(j,ny+3-2*k) = ani*(t2 - t4)         f(j,ny+3-2*k+1) = ani*(t5 - t3)   90    continue  100    continue         do 110 j = nxi, nxt         f(j,nyh+2) = -f(j,nyh+2)         t2 = f(j,1) + f(j,2)         f(j,2) = f(j,1) - f(j,2)         f(j,1) = t2  110    continuec forward fourier transform      else if (isign.gt.0) then         kmr = nxy/nyh         do 130 k = 2, nyhh         t1 = cmplx(aimag(sctd(1+kmr*(k-1))),-real(sctd(1+kmr*(k-1))))         do 120 j = nxi, nxt         t4 = f(j,ny+3-2*k)         t5 = -f(j,ny+3-2*k+1)         t2 = f(j,2*k-1) + t4         t3 = f(j,2*k) + t5         t6 = f(j,2*k-1) - t4         t5 = f(j,2*k) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         f(j,2*k-1) = t2 + t4         f(j,2*k) = t3 + t5         f(j,ny+3-2*k) = t2 - t4         f(j,ny+3-2*k+1) = t5 - t3  120    continue  130    continue         do 140 j = nxi, nxt         f(j,nyh+1) = 2.0*f(j,nyh+1)         f(j,nyh+2) = -2.0*f(j,nyh+2)         t2 = 2.0*(f(j,1) + f(j,2))         f(j,2) = 2.0*(f(j,1) - f(j,2))         f(j,1) = t2         f(j,ny+1) = 2.0*f(j,ny+1)  140    continue      endifc perform recursion for sine transform      do 160 j = nxi, nxt      sum1 = .5*f(j,1)      f(j,1) = 0.      f(j,2) = sum1      do 150 k = 2, nyh      sum1 = sum1 + f(j,2*k-1)      f(j,2*k-1) = -f(j,2*k)      f(j,2*k) = sum1  150 continue      f(j,ny+1) = 0.0  160 continue      return      endc-----------------------------------------------------------------------      subroutine FCT2RXY(f,isign,mixup,sctd,indx,indy,nxi,nxp,nxhd,nyd,n     1xhyd,nxyd)c this subroutine performs the y part of a two dimensional fast realc cosine transform and its inverse, for a subset of x,c using real arithmeticc algorithm is described in Numerical Recipies in Fortran, Second Ed.,c by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, c [Cambridge Univ. Press, 1992], p. 508.c for isign = (-1,1), input: all, output: fc approximate flop count: N*(5*log2(N) + 20)c where N = (nx/2)*nyc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, an inverse cosine transform is performedc f(n,m) = (.5*f(n,1) + ((-1)**m)*f(n,ny+1) + sum(f(n,k)*cos(pi*m*k/ny))c if isign = 1, a forward cosine transform is performedc f(n,k) = 2*(.5*f(n,1) + ((-1)**m)*f(n,ny+1) + sum(f(n,m)*c       cos(pi*m*k/ny))c mixup = array of bit reversed addressesc sctd = sine/cosine tablec nxi = initial x index usedc nxp = number of x indices usedc nxhd = half of the first dimension of f >= nx/2 + 1c nyd = second dimension of f >= ny + 1c nxhyd = maximum of (nx/2,ny)c nxyd = maximum of (nx,ny)c written by viktor k. decyk, ucla      complex sctd, t1      dimension f(2*nxhd,nyd), mixup(nxhyd), sctd(nxyd)      indx1 = indx - 1      indy1 = indy - 1      indx1y = max0(indx1,indy)      nx = 2**indx      ny = 2**indy      nyh = ny/2      nyhh = ny/4      ny2 = ny + 2      nxy = max0(nx,ny)      nxhy = 2**indx1y      nxt = nxi + nxp - 1      if (isign.eq.0) returnc create auxiliary array in y      kmr = nxy/ny      do 20 j = nxi, nxt      sum1 = .5*(f(j,1) - f(j,ny+1))      do 10 k = 2, nyh      k1 = 1 + kmr*(k - 1)      at2 = f(j,ny2-k)      at1 = f(j,k) + at2      at2 = f(j,k) - at2      sum1 = sum1 + real(sctd(k1))*at2      at2 = -aimag(sctd(k1))*at2      at1 = .5*at1      f(j,k) = at1 - at2      f(j,ny2-k) = at1 + at2   10 continue      f(j,1) = .5*(f(j,1) + f(j,ny+1))      f(j,ny+1) = sum1   20 continue      nry = nxhy/nyhc bit-reverse array elements in y      do 40 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 40      do 30 j = nxi, nxt      t2 = f(j,2*k1-1)      t3 = f(j,2*k1)      f(j,2*k1-1) = f(j,2*k-1)      f(j,2*k1) = f(j,2*k)      f(j,2*k-1) = t2      f(j,2*k) = t3   30 continue   40 continuec then transform in y      nry = nxy/nyh      do 80 l = 1, indy1      ns = 2**(l - 1)      ns2 = ns + ns      km = nyhh/ns      kmr = 2*km*nry      do 70 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 60 j = 1, ns      j1 = j + k1      j2 = j + k2      t1 = sctd(1+kmr*(j-1))      do 50 i = nxi, nxt      t2 = real(t1)*f(i,2*j2-1) - aimag(t1)*f(i,2*j2)      t3 = aimag(t1)*f(i,2*j2-1) + real(t1)*f(i,2*j2)      f(i,2*j2-1) = f(i,2*j1-1) - t2      f(i,2*j2) = f(i,2*j1) - t3      f(i,2*j1-1) = f(i,2*j1-1) + t2      f(i,2*j1) = f(i,2*j1) + t3   50 continue   60 continue   70 continue   80 continuec unscramble coefficients and normalizec inverse fourier transform      if (isign.lt.0) then         kmr = nxy/nyh         ani = 0.5         do 100 k = 2, nyhh         t1 = cmplx(aimag(sctd(1+kmr*(k-1))),-real(sctd(1+kmr*(k-1))))         do 90 j = nxi, nxt         t4 = f(j,ny+3-2*k)         t5 = -f(j,ny+3-2*k+1)         t2 = f(j,2*k-1) + t4         t3 = f(j,2*k) + t5         t6 = f(j,2*k-1) - t4         t5 = f(j,2*k) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         f(j,2*k-1) = ani*(t2 + t4)         f(j,2*k) = ani*(t3 + t5)         f(j,ny+3-2*k) = ani*(t2 - t4)         f(j,ny+3-2*k+1) = ani*(t5 - t3)   90    continue  100    continue         do 110 j = nxi, nxt         f(j,nyh+2) = -f(j,nyh+2)         t2 = f(j,1) + f(j,2)         f(j,2) = f(j,1) - f(j,2)         f(j,1) = t2  110    continuec forward fourier transform      else if (isign.gt.0) then         kmr = nxy/nyh         do 130 k = 2, nyhh         t1 = cmplx(aimag(sctd(1+kmr*(k-1))),-real(sctd(1+kmr*(k-1))))         do 120 j = nxi, nxt         t4 = f(j,ny+3-2*k)         t5 = -f(j,ny+3-2*k+1)         t2 = f(j,2*k-1) + t4         t3 = f(j,2*k) + t5         t6 = f(j,2*k-1) - t4         t5 = f(j,2*k) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         f(j,2*k-1) = t2 + t4         f(j,2*k) = t3 + t5         f(j,ny+3-2*k) = t2 - t4         f(j,ny+3-2*k+1) = t5 - t3  120    continue  130    continue         do 140 j = nxi, nxt         f(j,nyh+1) = 2.0*f(j,nyh+1)         f(j,nyh+2) = -2.0*f(j,nyh+2)         t2 = 2.0*(f(j,1) + f(j,2))         f(j,2) = 2.0*(f(j,1) - f(j,2))         f(j,1) = t2         f(j,ny+1) = 2.0*f(j,ny+1)  140    continue      endifc perform recursion for cosine transform      do 160 j = nxi, nxt      sum1 = f(j,ny+1)      f(j,ny+1) = f(j,2)      f(j,2) = sum1      do 150 k = 2, nyh      sum1 = sum1 - f(j,2*k)      f(j,2*k) = sum1  150 continue  160 continue      return      endc-----------------------------------------------------------------------      subroutine WFCST2R2(f,isign,mixup,sctd,indx,indy,nxhd,nyd,nxhyd,nx     1yd)c wrapper function for 2 real sine-cosine transformsc for the electric field with dirichlet or magnetic field with neumannc boundary conditions      implicit none      real f      complex sctd      integer mixup      integer isign, indx, indy, nxhd, nyd, nxhyd, nxyd      dimension f(2,2*nxhd,nyd), mixup(nxhyd), sctd(nxyd)c local data      integer nx, ny, nxi, nyi, nxt, nyt      data nxi, nyi /1,1/c calculate range of indices      nx = 2**indx      ny = 2**indy      nxt = nx + 1      nyt = ny + 1c inverse fourier transform      if (isign.lt.0) thenc perform x sine-cosine transforms         call FCST2R2X(f,isign,mixup,sctd,indx,indy,nyi,nyt,nxhd,nyd,nxh     1yd,nxyd)c perform y sine-cosine transforms         call FSCT2R2Y(f,isign,mixup,sctd,indx,indy,nxi,nxt,nxhd,nyd,nxh     1yd,nxyd)c forward fourier transform      else if (isign.gt.0) thenc perform y sine-cosine transforms         call FSCT2R2Y(f,isign,mixup,sctd,indx,indy,nxi,nxt,nxhd,nyd,nxh     1yd,nxyd)c perform x sine-cosine transforms         call FCST2R2X(f,isign,mixup,sctd,indx,indy,nyi,nyt,nxhd,nyd,nxh     1yd,nxyd)      endif      return      endc-----------------------------------------------------------------------      subroutine WFSCT2R2(f,isign,mixup,sctd,indx,indy,nxhd,nyd,nxhyd,nx     1yd)c wrapper function for 2 real sine-cosine transformsc for the magnetic field with dirichlet or electric field with neumannc boundary conditions      implicit none      real f      complex sctd      integer mixup      integer isign, indx, indy, nxhd, nyd, nxhyd, nxyd      dimension f(2,2*nxhd,nyd), mixup(nxhyd), sctd(nxyd)c local data      integer nx, ny, nxi, nyi, nxt, nyt      data nxi, nyi /1,1/c calculate range of indices      nx = 2**indx      ny = 2**indy      nxt = nx + 1      nyt = ny + 1c inverse fourier transform      if (isign.lt.0) thenc perform x sine-cosine transforms         call FSCT2R2X(f,isign,mixup,sctd,indx,indy,nyi,nyt,nxhd,nyd,nxh     1yd,nxyd)c perform y sine-cosine transforms         call FCST2R2Y(f,isign,mixup,sctd,indx,indy,nxi,nxt,nxhd,nyd,nxh     1yd,nxyd)c forward fourier transform      else if (isign.gt.0) thenc perform y sine-cosine transforms         call FCST2R2Y(f,isign,mixup,sctd,indx,indy,nxi,nxt,nxhd,nyd,nxh     1yd,nxyd)c perform x sine-cosine transforms         call FSCT2R2X(f,isign,mixup,sctd,indx,indy,nyi,nyt,nxhd,nyd,nxh     1yd,nxyd)      endif      return      endc-----------------------------------------------------------------------      subroutine FCST2R2X(f,isign,mixup,sctd,indx,indy,nyi,nyp,nxhd,nyd,     1nxhyd,nxyd)c this subroutine performs the x part of 2 two dimensional fast realc sine and cosine transforms and their inverses, for a subset of y,c for the electric field with dirichlet or magnetic field with neumannc boundary conditions, using real arithmeticc algorithm is described in Numerical Recipies in Fortran, Second Ed.,c by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, c [Cambridge Univ. Press, 1992], p. 508.c for isign = (-1,1), input: all, output: fc approximate flop count: N*(5*log2(N) + 18)c where N = (nx/2)*nyc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, inverse sine-cosine transforms are performedc f(1,n,k) = (1/nx*ny)*(.5*f(1,1,k) + ((-1)**n)*f(1,nx+1,k)c             + sum(f(1,j,k)*cos(pi*n*j/nx)))c f(2,n,k) = (1/nx*ny)*sum(f(2,j,k)*sin(pi*n*j/nx))c if isign = 1, forward sine-cosine transforms are performedc f(1,j,k) = 2*(.5*f(1,1,k) + ((-1)**j)*f(1,n+1,k) + sum(f(1,n,k)*c       cos(pi*n*j/nx))c f(2,j,k) = sum(f(2,n,k)*sin(pi*n*j/nx))c mixup = array of bit reversed addressesc sctd = sine/cosine tablec nyi = initial y index usedc nyp = number of y indices usedc nxhd = first dimension of f >= nx/2 + 1c nyd = second dimension of fc nxhyd = maximum of (nx/2,ny)c nxyd = maximum of (nx,ny)c written by viktor k. decyk, ucla      complex sctd, t1      dimension f(2,2*nxhd,nyd), mixup(nxhyd), sctd(nxyd)      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nx3 = nx + 3      ny = 2**indy      nxy = max0(nx,ny)      nxhy = 2**indx1y      nyt = nyi + nyp - 1      if (isign.eq.0) returnc create auxiliary array in x      kmr = nxy/nx      do 20 k = nyi, nyt      sum1 = .5*(f(1,1,k) - f(1,nx+1,k))      do 10 j = 2, nxh      j1 = 1 + kmr*(j - 1)      at3 = -aimag(sctd(j1))      at2 = f(1,nx+2-j,k)      at1 = f(1,j,k) + at2      at2 = f(1,j,k) - at2      sum1 = sum1 + real(sctd(j1))*at2      at2 = at3*at2      at1 = .5*at1      f(1,j,k) = at1 - at2      f(1,nx+2-j,k) = at1 + at2      at2 = f(2,nx+2-j,k)      at1 = f(2,j,k) + at2      at2 = f(2,j,k) - at2      at1 = at3*at1      at2 = .5*at2      f(2,j,k) = at1 + at2      f(2,nx+2-j,k) = at1 - at2   10 continue      f(1,1,k) = .5*(f(1,1,k) + f(1,nx+1,k))      f(1,nx+1,k) = sum1      f(2,1,k) = 0.0      f(2,nxh+1,k) = 2.0*f(2,nxh+1,k)      20 continuec bit-reverse array elements in x      nrx = nxhy/nxh      do 50 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 50      do 40 k = nyi, nyt      do 30 jj = 1, 2      t2 = f(jj,2*j1-1,k)      t3 = f(jj,2*j1,k)      f(jj,2*j1-1,k) = f(jj,2*j-1,k)      f(jj,2*j1,k) = f(jj,2*j,k)      f(jj,2*j-1,k) = t2      f(jj,2*j,k) = t3   30 continue   40 continue   50 continuec first transform in x      nrx = nxy/nxh      do 100 l = 1, indx1      ns = 2**(l - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = 2*km*nrx      do 90 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 80 j = 1, ns      j1 = j + k1      j2 = j + k2      t1 = sctd(1+kmr*(j-1))      do 70 i = nyi, nyt      do 60 jj = 1, 2      t2 = real(t1)*f(jj,2*j2-1,i) - aimag(t1)*f(jj,2*j2,i)      t3 = aimag(t1)*f(jj,2*j2-1,i) + real(t1)*f(jj,2*j2,i)      f(jj,2*j2-1,i) = f(jj,2*j1-1,i) - t2      f(jj,2*j2,i) = f(jj,2*j1,i) - t3      f(jj,2*j1-1,i) = f(jj,2*j1-1,i) + t2      f(jj,2*j1,i) = f(jj,2*j1,i) + t3   60 continue   70 continue   80 continue   90 continue  100 continuec unscramble coefficients and normalizec inverse fourier transform      if (isign.lt.0) then         kmr = nxy/nxh         ani = 1./float(2*nx*ny)         do 130 j = 2, nxhh         t1 = cmplx(aimag(sctd(1+kmr*(j-1))),-real(sctd(1+kmr*(j-1))))         do 120 k = nyi, nyt         do 110 jj = 1, 2         t4 = f(jj,nx3-2*j,k)         t5 = -f(jj,nx3-2*j+1,k)         t2 = f(jj,2*j-1,k) + t4         t3 = f(jj,2*j,k) + t5         t6 = f(jj,2*j-1,k) - t4         t5 = f(jj,2*j,k) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         f(jj,2*j-1,k) = ani*(t2 + t4)         f(jj,2*j,k) = ani*(t3 + t5)         f(jj,nx3-2*j,k) = ani*(t2 - t4)         f(jj,nx3-2*j+1,k) = ani*(t5 - t3)  110    continue  120    continue  130    continue         ani = 2.*ani         do 150 k = nyi, nyt         do 140 jj = 1, 2         f(jj,nxh+1,k) = ani*f(jj,nxh+1,k)         f(jj,nxh+2,k) = -ani*f(jj,nxh+2,k)         t2 = ani*(f(jj,1,k) + f(jj,2,k))         f(jj,2,k) = ani*(f(jj,1,k) - f(jj,2,k))         f(jj,1,k) = t2         f(jj,nx+1,k) = ani*f(jj,nx+1,k)  140    continue  150    continuec forward fourier transform      else if (isign.gt.0) then         kmr = nxy/nxh         do 180 j = 2, nxhh         t1 = cmplx(aimag(sctd(1+kmr*(j-1))),-real(sctd(1+kmr*(j-1))))         do 170 k = nyi, nyt         do 160 jj = 1, 2         t4 = f(jj,nx3-2*j,k)         t5 = -f(jj,nx3-2*j+1,k)         t2 = f(jj,2*j-1,k) + t4         t3 = f(jj,2*j,k) + t5         t6 = f(jj,2*j-1,k) - t4         t5 = f(jj,2*j,k) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         f(jj,2*j-1,k) = t2 + t4         f(jj,2*j,k) = t3 + t5         f(jj,nx3-2*j,k) = t2 - t4         f(jj,nx3-2*j+1,k) = t5 - t3  160    continue  170    continue  180    continue         do 200 k = nyi, nyt         do 190 jj = 1, 2         f(jj,nxh+1,k) = 2.0*f(jj,nxh+1,k)         f(jj,nxh+2,k) = -2.0*f(jj,nxh+2,k)         t2 = 2.0*(f(jj,1,k) + f(jj,2,k))         f(jj,2,k) = 2.0*(f(jj,1,k) - f(jj,2,k))         f(jj,1,k) = t2         f(jj,nx+1,k) = 2.0*f(jj,nx+1,k)  190    continue  200    continue      endifc perform recursion for cosine transform      do 220 k = nyi, nyt      sum1 = f(1,nx+1,k)      f(1,nx+1,k) = f(1,2,k)      f(1,2,k) = sum1      sum2 = .5*f(2,1,k)      f(2,1,k) = 0.0      f(2,2,k) = sum2      do 210 j = 2, nxh      sum1 = sum1 - f(1,2*j,k)      f(1,2*j,k) = sum1      sum2 = sum2 + f(2,2*j-1,k)      f(2,2*j-1,k) = -f(2,2*j,k)      f(2,2*j,k) = sum2  210 continue      f(2,nx+1,k) = 0.0  220 continue      return      endc-----------------------------------------------------------------------      subroutine FSCT2R2X(f,isign,mixup,sctd,indx,indy,nyi,nyp,nxhd,nyd,     1nxhyd,nxyd)c this subroutine performs the x part of 2 two dimensional fast realc sine and cosine transforms and their inverses, for a subset of y,c for the magnetic field with dirichlet or electric field with neumannc boundary conditions, using real arithmeticc algorithm is described in Numerical Recipies in Fortran, Second Ed.,c by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, c [Cambridge Univ. Press, 1992], p. 508.c for isign = (-1,1), input: all, output: fc approximate flop count: N*(5*log2(N) + 18)c where N = (nx/2)*nyc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, inverse sine-cosine transforms are performedc f(1,n,k) = (1/nx*ny)*sum(f(1,j,k)*sin(pi*n*j/nx))c f(2,n,k) = (1/nx*ny)*(.5*f(2,1,k) + ((-1)**n)*f(2,nx+1,k)c             + sum(f(2,j,k)*cos(pi*n*j/nx)))c if isign = 1, forward sine-cosine transforms are performedc f(1,j,k) = sum(f(1,n,k)*sin(pi*n*j/nx))c f(2,j,k) = 2*(.5*f(2,1,k) + ((-1)**j)*f(2,n+1,k)c             + sum(f(2,n,k)*cos(pi*n*j/nx))c mixup = array of bit reversed addressesc sctd = sine/cosine tablec nyi = initial y index usedc nyp = number of y indices usedc nxhd = first dimension of f >= nx/2 + 1c nyd = second dimension of fc nxhyd = maximum of (nx/2,ny)c nxyd = maximum of (nx,ny)c written by viktor k. decyk, ucla      complex sctd, t1      dimension f(2,2*nxhd,nyd), mixup(nxhyd), sctd(nxyd)      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nx3 = nx + 3      ny = 2**indy      nxy = max0(nx,ny)      nxhy = 2**indx1y      nyt = nyi + nyp - 1      if (isign.eq.0) returnc create auxiliary array in x      kmr = nxy/nx      do 20 k = nyi, nyt      sum1 = .5*(f(2,1,k) - f(2,nx+1,k))      do 10 j = 2, nxh      j1 = 1 + kmr*(j - 1)      at3 = -aimag(sctd(j1))      at2 = f(1,nx+2-j,k)      at1 = f(1,j,k) + at2      at2 = f(1,j,k) - at2      at1 = at3*at1      at2 = .5*at2      f(1,j,k) = at1 + at2      f(1,nx+2-j,k) = at1 - at2      at2 = f(2,nx+2-j,k)      at1 = f(2,j,k) + at2      at2 = f(2,j,k) - at2      sum1 = sum1 + real(sctd(j1))*at2      at2 = at3*at2      at1 = .5*at1      f(2,j,k) = at1 - at2      f(2,nx+2-j,k) = at1 + at2   10 continue      f(1,1,k) = 0.0      f(1,nxh+1,k) = 2.0*f(1,nxh+1,k)      f(2,1,k) = .5*(f(2,1,k) + f(2,nx+1,k))      f(2,nx+1,k) = sum1   20 continuec bit-reverse array elements in x      nrx = nxhy/nxh      do 50 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 50      do 40 k = nyi, nyt      do 30 jj = 1, 2      t2 = f(jj,2*j1-1,k)      t3 = f(jj,2*j1,k)      f(jj,2*j1-1,k) = f(jj,2*j-1,k)      f(jj,2*j1,k) = f(jj,2*j,k)      f(jj,2*j-1,k) = t2      f(jj,2*j,k) = t3   30 continue   40 continue   50 continuec first transform in x      nrx = nxy/nxh      do 100 l = 1, indx1      ns = 2**(l - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = 2*km*nrx      do 90 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 80 j = 1, ns      j1 = j + k1      j2 = j + k2      t1 = sctd(1+kmr*(j-1))      do 70 i = nyi, nyt      do 60 jj = 1, 2      t2 = real(t1)*f(jj,2*j2-1,i) - aimag(t1)*f(jj,2*j2,i)      t3 = aimag(t1)*f(jj,2*j2-1,i) + real(t1)*f(jj,2*j2,i)      f(jj,2*j2-1,i) = f(jj,2*j1-1,i) - t2      f(jj,2*j2,i) = f(jj,2*j1,i) - t3      f(jj,2*j1-1,i) = f(jj,2*j1-1,i) + t2      f(jj,2*j1,i) = f(jj,2*j1,i) + t3   60 continue   70 continue   80 continue   90 continue  100 continuec unscramble coefficients and normalizec inverse fourier transform      if (isign.lt.0) then         kmr = nxy/nxh         ani = 1./float(2*nx*ny)         do 130 j = 2, nxhh         t1 = cmplx(aimag(sctd(1+kmr*(j-1))),-real(sctd(1+kmr*(j-1))))         do 120 k = nyi, nyt         do 110 jj = 1, 2         t4 = f(jj,nx3-2*j,k)         t5 = -f(jj,nx3-2*j+1,k)         t2 = f(jj,2*j-1,k) + t4         t3 = f(jj,2*j,k) + t5         t6 = f(jj,2*j-1,k) - t4         t5 = f(jj,2*j,k) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         f(jj,2*j-1,k) = ani*(t2 + t4)         f(jj,2*j,k) = ani*(t3 + t5)         f(jj,nx3-2*j,k) = ani*(t2 - t4)         f(jj,nx3-2*j+1,k) = ani*(t5 - t3)  110    continue  120    continue  130    continue         ani = 2.*ani         do 150 k = nyi, nyt         do 140 jj = 1, 2         f(jj,nxh+1,k) = ani*f(jj,nxh+1,k)         f(jj,nxh+2,k) = -ani*f(jj,nxh+2,k)         t2 = ani*(f(jj,1,k) + f(jj,2,k))         f(jj,2,k) = ani*(f(jj,1,k) - f(jj,2,k))         f(jj,1,k) = t2         f(jj,nx+1,k) = ani*f(jj,nx+1,k)  140    continue  150    continuec forward fourier transform      else if (isign.gt.0) then         kmr = nxy/nxh         do 180 j = 2, nxhh         t1 = cmplx(aimag(sctd(1+kmr*(j-1))),-real(sctd(1+kmr*(j-1))))         do 170 k = nyi, nyt         do 160 jj = 1, 2         t4 = f(jj,nx3-2*j,k)         t5 = -f(jj,nx3-2*j+1,k)         t2 = f(jj,2*j-1,k) + t4         t3 = f(jj,2*j,k) + t5         t6 = f(jj,2*j-1,k) - t4         t5 = f(jj,2*j,k) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         f(jj,2*j-1,k) = t2 + t4         f(jj,2*j,k) = t3 + t5         f(jj,nx3-2*j,k) = t2 - t4         f(jj,nx3-2*j+1,k) = t5 - t3  160    continue  170    continue  180    continue         do 200 k = nyi, nyt         do 190 jj = 1, 2         f(jj,nxh+1,k) = 2.0*f(jj,nxh+1,k)         f(jj,nxh+2,k) = -2.0*f(jj,nxh+2,k)         t2 = 2.0*(f(jj,1,k) + f(jj,2,k))         f(jj,2,k) = 2.0*(f(jj,1,k) - f(jj,2,k))         f(jj,1,k) = t2         f(jj,nx+1,k) = 2.0*f(jj,nx+1,k)  190    continue  200    continue      endifc perform recursion for cosine transform      do 220 k = nyi, nyt      sum1 = .5*f(1,1,k)      f(1,1,k) = 0.0      f(1,2,k) = sum1      sum2 = f(2,nx+1,k)      f(2,nx+1,k) = f(2,2,k)      f(2,2,k) = sum2      do 210 j = 2, nxh      sum1 = sum1 + f(1,2*j-1,k)      f(1,2*j-1,k) = -f(1,2*j,k)      f(1,2*j,k) = sum1      sum2 = sum2 - f(2,2*j,k)      f(2,2*j,k) = sum2  210 continue      f(1,nx+1,k) = 0.0  220 continue      return      endc-----------------------------------------------------------------------      subroutine FSCT2R2Y(f,isign,mixup,sctd,indx,indy,nxi,nxp,nxhd,nyd,     1nxhyd,nxyd)c this subroutine performs the y part of 2 two dimensional fast realc sine and cosine transforms and their inverses, for a subset of x,c for the electric field with dirichlet or magnetic field with neumannc boundary conditions, using real arithmeticc algorithm is described in Numerical Recipies in Fortran, Second Ed.,c by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, c [Cambridge Univ. Press, 1992], p. 508.c for isign = (-1,1), input: all, output: fc approximate flop count: N*(5*log2(N) + 20)c where N = (nx/2)*nyc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, inverse sine-cosine transforms are performedc f(1,n,m) = sum(f(1,n,k)*sin(pi*m*k/ny))c f(2,n,m) = (.5*f(2,n,1) + ((-1)**m)*f(2,n,ny+1) + sum(f(2,n,k)*c            cos(pi*m*k/ny))c if isign = 1, forward sine-cosine transforms are performedc f(1,n,k) = 2*sum(f(1,n,m)*sin(pi*m*k/ny)c f(2,n,k) = 2*(.5*f(2,n,1) + ((-1)**m)*f(2,n,ny+1) + sum(f(2,n,m)*c       cos(pi*m*k/ny))c mixup = array of bit reversed addressesc sctd = sine/cosine tablec nxi = initial x index usedc nxp = number of x indices usedc nxhd = half of the first dimension of f >= nx/2 + 1c nyd = second dimension of f >= ny + 1c nxhyd = maximum of (nx/2,ny)c nxyd = maximum of (nx,ny)c written by viktor k. decyk, ucla      complex sctd, t1      dimension f(2,2*nxhd,nyd), mixup(nxhyd), sctd(nxyd)      indx1 = indx - 1      indy1 = indy - 1      indx1y = max0(indx1,indy)      nx = 2**indx      ny = 2**indy      nyh = ny/2      nyhh = ny/4      ny2 = ny + 2      nxy = max0(nx,ny)      nxhy = 2**indx1y      nxt = nxi + nxp - 1      if (isign.eq.0) returnc create auxiliary array in y      kmr = nxy/ny      do 20 j = nxi, nxt      sum1 = .5*(f(2,j,1) - f(2,j,ny+1))      do 10 k = 2, nyh      k1 = 1 + kmr*(k - 1)      at3 = -aimag(sctd(k1))      at2 = f(1,j,ny2-k)      at1 = f(1,j,k) + at2      at2 = f(1,j,k) - at2      at1 = at3*at1      at2 = .5*at2      f(1,j,k) = at1 + at2      f(1,j,ny2-k) = at1 - at2      at2 = f(2,j,ny2-k)      at1 = f(2,j,k) + at2      at2 = f(2,j,k) - at2      sum1 = sum1 + real(sctd(k1))*at2      at2 = at3*at2      at1 = .5*at1      f(2,j,k) = at1 - at2      f(2,j,ny2-k) = at1 + at2   10 continue      f(1,j,1) = 0.0      f(1,j,nyh+1) = 2.0*f(1,j,nyh+1)      f(2,j,1) = .5*(f(2,j,1) + f(2,j,ny+1))      f(2,j,ny+1) = sum1   20 continue      nry = nxhy/nyhc bit-reverse array elements in y      do 50 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 50      do 40 j = nxi, nxt      do 30 jj = 1, 2      t2 = f(jj,j,2*k1-1)      t3 = f(jj,j,2*k1)      f(jj,j,2*k1-1) = f(jj,j,2*k-1)      f(jj,j,2*k1) = f(jj,j,2*k)      f(jj,j,2*k-1) = t2      f(jj,j,2*k) = t3   30 continue   40 continue   50 continuec then transform in y      nry = nxy/nyh      do 100 l = 1, indy1      ns = 2**(l - 1)      ns2 = ns + ns      km = nyhh/ns      kmr = 2*km*nry      do 90 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 80 j = 1, ns      j1 = j + k1      j2 = j + k2      t1 = sctd(1+kmr*(j-1))      do 70 i = nxi, nxt      do 60 jj = 1, 2      t2 = real(t1)*f(jj,i,2*j2-1) - aimag(t1)*f(jj,i,2*j2)      t3 = aimag(t1)*f(jj,i,2*j2-1) + real(t1)*f(jj,i,2*j2)      f(jj,i,2*j2-1) = f(jj,i,2*j1-1) - t2      f(jj,i,2*j2) = f(jj,i,2*j1) - t3      f(jj,i,2*j1-1) = f(jj,i,2*j1-1) + t2      f(jj,i,2*j1) = f(jj,i,2*j1) + t3   60 continue   70 continue   80 continue   90 continue  100 continuec unscramble coefficients and normalizec inverse fourier transform      if (isign.lt.0) then         kmr = nxy/nyh         ani = 0.5         do 130 k = 2, nyhh         t1 = cmplx(aimag(sctd(1+kmr*(k-1))),-real(sctd(1+kmr*(k-1))))         do 120 j = nxi, nxt         do 110 jj = 1, 2         t4 = f(jj,j,ny+3-2*k)         t5 = -f(jj,j,ny+3-2*k+1)         t2 = f(jj,j,2*k-1) + t4         t3 = f(jj,j,2*k) + t5         t6 = f(jj,j,2*k-1) - t4         t5 = f(jj,j,2*k) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         f(jj,j,2*k-1) = ani*(t2 + t4)         f(jj,j,2*k) = ani*(t3 + t5)         f(jj,j,ny+3-2*k) = ani*(t2 - t4)         f(jj,j,ny+3-2*k+1) = ani*(t5 - t3)  110    continue  120    continue  130    continue         do 150 j = nxi, nxt         do 140 jj = 1, 2         f(jj,j,nyh+2) = -f(jj,j,nyh+2)         t2 = f(jj,j,1) + f(jj,j,2)         f(jj,j,2) = f(jj,j,1) - f(jj,j,2)         f(jj,j,1) = t2  140    continue  150    continuec forward fourier transform      else if (isign.gt.0) then         kmr = nxy/nyh         do 180 k = 2, nyhh         t1 = cmplx(aimag(sctd(1+kmr*(k-1))),-real(sctd(1+kmr*(k-1))))         do 170 j = nxi, nxt         do 160 jj = 1, 2         t4 = f(jj,j,ny+3-2*k)         t5 = -f(jj,j,ny+3-2*k+1)         t2 = f(jj,j,2*k-1) + t4         t3 = f(jj,j,2*k) + t5         t6 = f(jj,j,2*k-1) - t4         t5 = f(jj,j,2*k) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         f(jj,j,2*k-1) = t2 + t4         f(jj,j,2*k) = t3 + t5         f(jj,j,ny+3-2*k) = t2 - t4         f(jj,j,ny+3-2*k+1) = t5 - t3  160    continue  170    continue  180    continue         do 200 j = nxi, nxt         do 190 jj = 1, 2         f(jj,j,nyh+1) = 2.0*f(jj,j,nyh+1)         f(jj,j,nyh+2) = -2.0*f(jj,j,nyh+2)         t2 = 2.0*(f(jj,j,1) + f(jj,j,2))         f(jj,j,2) = 2.0*(f(jj,j,1) - f(jj,j,2))         f(jj,j,1) = t2         f(jj,j,ny+1) = 2.0*f(jj,j,ny+1)  190    continue  200    continue      endifc perform recursion for cosine transform      do 220 j = nxi, nxt      sum1 = .5*f(1,j,1)      f(1,j,1) = 0.      f(1,j,2) = sum1      sum2 = f(2,j,ny+1)      f(2,j,ny+1) = f(2,j,2)      f(2,j,2) = sum2      do 210 k = 2, nyh      sum1 = sum1 + f(1,j,2*k-1)      f(1,j,2*k-1) = -f(1,j,2*k)      f(1,j,2*k) = sum1      sum2 = sum2 - f(2,j,2*k)      f(2,j,2*k) = sum2  210 continue      f(1,j,ny+1) = 0.0  220 continue      return      endc-----------------------------------------------------------------------      subroutine FCST2R2Y(f,isign,mixup,sctd,indx,indy,nxi,nxp,nxhd,nyd,     1nxhyd,nxyd)c this subroutine performs the y part of 2 two dimensional fast realc sine and cosine transforms and their inverses, for a subset of x,c for the magnetic field with dirichlet or electric field with neumannc boundary conditions, using real arithmeticc algorithm is described in Numerical Recipies in Fortran, Second Ed.,c by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, c [Cambridge Univ. Press, 1992], p. 508.c for isign = (-1,1), input: all, output: fc approximate flop count: N*(5*log2(N) + 20)c where N = (nx/2)*nyc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, inverse sine-cosine transforms are performedc f(1,n,m) = (.5*f(1,n,1) + ((-1)**m)*f(1,n,ny+1) + sum(f(1,n,k)*c            cos(pi*m*k/ny))c f(2,n,m) = sum(f(2,n,k)*sin(pi*m*k/ny))c if isign = 1, forward sine-cosine transforms are performedc f(1,n,k) = 2*(.5*f(1,n,1) + ((-1)**m)*f(1,n,ny+1) + sum(f(1,n,m)*c       cos(pi*m*k/ny))c f(3,n,k) = 2*sum(f(3,n,m)*sin(pi*m*k/ny)c mixup = array of bit reversed addressesc sctd = sine/cosine tablec nxi = initial x index usedc nxp = number of x indices usedc nxhd = half of the first dimension of f >= nx/2 + 1c nyd = second dimension of f >= ny + 1c nxhyd = maximum of (nx/2,ny)c nxyd = maximum of (nx,ny)c written by viktor k. decyk, ucla      complex sctd, t1      dimension f(2,2*nxhd,nyd), mixup(nxhyd), sctd(nxyd)      indx1 = indx - 1      indy1 = indy - 1      indx1y = max0(indx1,indy)      nx = 2**indx      ny = 2**indy      nyh = ny/2      nyhh = ny/4      ny2 = ny + 2      nxy = max0(nx,ny)      nxhy = 2**indx1y      nxt = nxi + nxp - 1      if (isign.eq.0) returnc create auxiliary array in y      kmr = nxy/ny      do 20 j = nxi, nxt      sum1 = .5*(f(1,j,1) - f(1,j,ny+1))      do 10 k = 2, nyh      k1 = 1 + kmr*(k - 1)      at3 = -aimag(sctd(k1))      at2 = f(1,j,ny2-k)      at1 = f(1,j,k) + at2      at2 = f(1,j,k) - at2      sum1 = sum1 + real(sctd(k1))*at2      at2 = at3*at2      at1 = .5*at1      f(1,j,k) = at1 - at2      f(1,j,ny2-k) = at1 + at2      at2 = f(2,j,ny2-k)      at1 = f(2,j,k) + at2      at2 = f(2,j,k) - at2      at1 = at3*at1      at2 = .5*at2      f(2,j,k) = at1 + at2      f(2,j,ny2-k) = at1 - at2   10 continue      f(1,j,1) = .5*(f(1,j,1) + f(1,j,ny+1))      f(1,j,ny+1) = sum1      f(2,j,1) = 0.0      f(2,j,nyh+1) = 2.0*f(2,j,nyh+1)   20 continue      nry = nxhy/nyhc bit-reverse array elements in y      do 50 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 50      do 40 j = nxi, nxt      do 30 jj = 1, 2      t2 = f(jj,j,2*k1-1)      t3 = f(jj,j,2*k1)      f(jj,j,2*k1-1) = f(jj,j,2*k-1)      f(jj,j,2*k1) = f(jj,j,2*k)      f(jj,j,2*k-1) = t2      f(jj,j,2*k) = t3   30 continue   40 continue   50 continuec then transform in y      nry = nxy/nyh      do 100 l = 1, indy1      ns = 2**(l - 1)      ns2 = ns + ns      km = nyhh/ns      kmr = 2*km*nry      do 90 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 80 j = 1, ns      j1 = j + k1      j2 = j + k2      t1 = sctd(1+kmr*(j-1))      do 70 i = nxi, nxt      do 60 jj = 1, 2      t2 = real(t1)*f(jj,i,2*j2-1) - aimag(t1)*f(jj,i,2*j2)      t3 = aimag(t1)*f(jj,i,2*j2-1) + real(t1)*f(jj,i,2*j2)      f(jj,i,2*j2-1) = f(jj,i,2*j1-1) - t2      f(jj,i,2*j2) = f(jj,i,2*j1) - t3      f(jj,i,2*j1-1) = f(jj,i,2*j1-1) + t2      f(jj,i,2*j1) = f(jj,i,2*j1) + t3   60 continue   70 continue   80 continue   90 continue  100 continuec unscramble coefficients and normalizec inverse fourier transform      if (isign.lt.0) then         kmr = nxy/nyh         ani = 0.5         do 130 k = 2, nyhh         t1 = cmplx(aimag(sctd(1+kmr*(k-1))),-real(sctd(1+kmr*(k-1))))         do 120 j = nxi, nxt         do 110 jj = 1, 2         t4 = f(jj,j,ny+3-2*k)         t5 = -f(jj,j,ny+3-2*k+1)         t2 = f(jj,j,2*k-1) + t4         t3 = f(jj,j,2*k) + t5         t6 = f(jj,j,2*k-1) - t4         t5 = f(jj,j,2*k) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         f(jj,j,2*k-1) = ani*(t2 + t4)         f(jj,j,2*k) = ani*(t3 + t5)         f(jj,j,ny+3-2*k) = ani*(t2 - t4)         f(jj,j,ny+3-2*k+1) = ani*(t5 - t3)  110    continue  120    continue  130    continue         do 150 j = nxi, nxt         do 140 jj = 1, 2         f(jj,j,nyh+2) = -f(jj,j,nyh+2)         t2 = f(jj,j,1) + f(jj,j,2)         f(jj,j,2) = f(jj,j,1) - f(jj,j,2)         f(jj,j,1) = t2  140    continue  150    continuec forward fourier transform      else if (isign.gt.0) then         kmr = nxy/nyh         do 180 k = 2, nyhh         t1 = cmplx(aimag(sctd(1+kmr*(k-1))),-real(sctd(1+kmr*(k-1))))         do 170 j = nxi, nxt         do 160 jj = 1, 2         t4 = f(jj,j,ny+3-2*k)         t5 = -f(jj,j,ny+3-2*k+1)         t2 = f(jj,j,2*k-1) + t4         t3 = f(jj,j,2*k) + t5         t6 = f(jj,j,2*k-1) - t4         t5 = f(jj,j,2*k) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         f(jj,j,2*k-1) = t2 + t4         f(jj,j,2*k) = t3 + t5         f(jj,j,ny+3-2*k) = t2 - t4         f(jj,j,ny+3-2*k+1) = t5 - t3  160    continue  170    continue  180    continue         do 200 j = nxi, nxt         do 190 jj = 1, 2         f(jj,j,nyh+1) = 2.0*f(jj,j,nyh+1)         f(jj,j,nyh+2) = -2.0*f(jj,j,nyh+2)         t2 = 2.0*(f(jj,j,1) + f(jj,j,2))         f(jj,j,2) = 2.0*(f(jj,j,1) - f(jj,j,2))         f(jj,j,1) = t2         f(jj,j,ny+1) = 2.0*f(jj,j,ny+1)  190    continue  200    continue      endifc perform recursion for cosine transform      do 220 j = nxi, nxt      sum1 = f(1,j,ny+1)      f(1,j,ny+1) = f(1,j,2)      f(1,j,2) = sum1      sum2 = .5*f(2,j,1)      f(2,j,1) = 0.      f(2,j,2) = sum2      do 210 k = 2, nyh      sum1 = sum1 - f(1,j,2*k)      f(1,j,2*k) = sum1      sum2 = sum2 + f(2,j,2*k-1)      f(2,j,2*k-1) = -f(2,j,2*k)      f(2,j,2*k) = sum2  210 continue      f(2,j,ny+1) = 0.0  220 continue      return      endc-----------------------------------------------------------------------      subroutine WFCST2R3(f,isign,mixup,sctd,indx,indy,nxhd,nyd,nxhyd,nx     1yd)c wrapper function for 3 real sine-cosine transformsc for the electric field with dirichlet or magnetic field with neumannc boundary conditions      implicit none      real f      complex sctd      integer mixup      integer isign, indx, indy, nxhd, nyd, nxhyd, nxyd      dimension f(3,2*nxhd,nyd), mixup(nxhyd), sctd(nxyd)c local data      integer nx, ny, nxi, nyi, nxt, nyt      data nxi, nyi /1,1/c calculate range of indices      nx = 2**indx      ny = 2**indy      nxt = nx + 1      nyt = ny + 1c inverse fourier transform      if (isign.lt.0) thenc perform x sine-cosine transforms         call FCSST2R3X(f,isign,mixup,sctd,indx,indy,nyi,nyt,nxhd,nyd,nx     1hyd,nxyd)c perform y sine-cosine transforms         call FSCST2R3Y(f,isign,mixup,sctd,indx,indy,nxi,nxt,nxhd,nyd,nx     1hyd,nxyd)c forward fourier transform      else if (isign.gt.0) thenc perform y sine-cosine transforms         call FSCST2R3Y(f,isign,mixup,sctd,indx,indy,nxi,nxt,nxhd,nyd,nx     1hyd,nxyd)c perform x sine-cosine transforms         call FCSST2R3X(f,isign,mixup,sctd,indx,indy,nyi,nyt,nxhd,nyd,nx     1hyd,nxyd)      endif      return      endc-----------------------------------------------------------------------      subroutine WFSCT2R3(f,isign,mixup,sctd,indx,indy,nxhd,nyd,nxhyd,nx     1yd)c wrapper function for 3 real sine-cosine transformsc for the magnetic field with dirichlet or electric field with neumannc boundary conditions      implicit none      real f      complex sctd      integer mixup      integer isign, indx, indy, nxhd, nyd, nxhyd, nxyd      dimension f(3,2*nxhd,nyd), mixup(nxhyd), sctd(nxyd)c local data      integer nx, ny, nxi, nyi, nxt, nyt      data nxi, nyi /1,1/c calculate range of indices      nx = 2**indx      ny = 2**indy      nxt = nx + 1      nyt = ny + 1c inverse fourier transform      if (isign.lt.0) thenc perform x sine-cosine transforms         call FSCCT2R3X(f,isign,mixup,sctd,indx,indy,nyi,nyt,nxhd,nyd,nx     1hyd,nxyd)c perform y sine-cosine transforms         call FCSCT2R3Y(f,isign,mixup,sctd,indx,indy,nxi,nxt,nxhd,nyd,nx     1hyd,nxyd)c forward fourier transform      else if (isign.gt.0) thenc perform y sine-cosine transforms         call FCSCT2R3Y(f,isign,mixup,sctd,indx,indy,nxi,nxt,nxhd,nyd,nx     1hyd,nxyd)c perform x sine-cosine transforms         call FSCCT2R3X(f,isign,mixup,sctd,indx,indy,nyi,nyt,nxhd,nyd,nx     1hyd,nxyd)      endif      return      endc-----------------------------------------------------------------------      subroutine FCSST2R3X(f,isign,mixup,sctd,indx,indy,nyi,nyp,nxhd,nyd     1,nxhyd,nxyd)c this subroutine performs the x part of 3 two dimensional fast realc sine and cosine transforms and their inverses, for a subset of y,c for the electric field with dirichlet or magnetic field with neumannc boundary conditions, using real arithmeticc algorithm is described in Numerical Recipies in Fortran, Second Ed.,c by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, c [Cambridge Univ. Press, 1992], p. 508.c for isign = (-1,1), input: all, output: fc approximate flop count: N*(5*log2(N) + 18)c where N = (nx/2)*nyc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, inverse sine-cosine transforms are performedc f(1,n,k) = (1/nx*ny)*(.5*f(1,1,k) + ((-1)**n)*f(1,nx+1,k)c             + sum(f(1,j,k)*cos(pi*n*j/nx)))c f(2:3,n,k) = (1/nx*ny)*sum(f(2:3,j,k)*sin(pi*n*j/nx))c if isign = 1, forward sine-cosine transforms are performedc f(1,j,k) = 2*(.5*f(1,1,k) + ((-1)**j)*f(1,n+1,k) + sum(f(1,n,k)*c       cos(pi*n*j/nx))c f(2:3,j,k) = sum(f(2:3,n,k)*sin(pi*n*j/nx))c mixup = array of bit reversed addressesc sctd = sine/cosine tablec nyi = initial y index usedc nyp = number of y indices usedc nxhd = first dimension of f >= nx/2 + 1c nyd = second dimension of fc nxhyd = maximum of (nx/2,ny)c nxyd = maximum of (nx,ny)c written by viktor k. decyk, ucla      complex sctd, t1      dimension f(3,2*nxhd,nyd), mixup(nxhyd), sctd(nxyd)      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nx3 = nx + 3      ny = 2**indy      nxy = max0(nx,ny)      nxhy = 2**indx1y      nyt = nyi + nyp - 1      if (isign.eq.0) returnc create auxiliary array in x      kmr = nxy/nx      do 20 k = nyi, nyt      sum1 = .5*(f(1,1,k) - f(1,nx+1,k))      do 10 j = 2, nxh      j1 = 1 + kmr*(j - 1)      at3 = -aimag(sctd(j1))      at2 = f(1,nx+2-j,k)      at1 = f(1,j,k) + at2      at2 = f(1,j,k) - at2      sum1 = sum1 + real(sctd(j1))*at2      at2 = at3*at2      at1 = .5*at1      f(1,j,k) = at1 - at2      f(1,nx+2-j,k) = at1 + at2      at2 = f(2,nx+2-j,k)      at1 = f(2,j,k) + at2      at2 = f(2,j,k) - at2      at1 = at3*at1      at2 = .5*at2      f(2,j,k) = at1 + at2      f(2,nx+2-j,k) = at1 - at2      at2 = f(3,nx+2-j,k)      at1 = f(3,j,k) + at2      at2 = f(3,j,k) - at2      at1 = at3*at1      at2 = .5*at2      f(3,j,k) = at1 + at2      f(3,nx+2-j,k) = at1 - at2   10 continue      f(1,1,k) = .5*(f(1,1,k) + f(1,nx+1,k))      f(1,nx+1,k) = sum1      f(2,1,k) = 0.0      f(2,nxh+1,k) = 2.0*f(2,nxh+1,k)         f(3,1,k) = 0.0      f(3,nxh+1,k) = 2.0*f(3,nxh+1,k)   20 continuec bit-reverse array elements in x      nrx = nxhy/nxh      do 50 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 50      do 40 k = nyi, nyt      do 30 jj = 1, 3      t2 = f(jj,2*j1-1,k)      t3 = f(jj,2*j1,k)      f(jj,2*j1-1,k) = f(jj,2*j-1,k)      f(jj,2*j1,k) = f(jj,2*j,k)      f(jj,2*j-1,k) = t2      f(jj,2*j,k) = t3   30 continue   40 continue   50 continuec first transform in x      nrx = nxy/nxh      do 100 l = 1, indx1      ns = 2**(l - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = 2*km*nrx      do 90 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 80 j = 1, ns      j1 = j + k1      j2 = j + k2      t1 = sctd(1+kmr*(j-1))      do 70 i = nyi, nyt      do 60 jj = 1, 3      t2 = real(t1)*f(jj,2*j2-1,i) - aimag(t1)*f(jj,2*j2,i)      t3 = aimag(t1)*f(jj,2*j2-1,i) + real(t1)*f(jj,2*j2,i)      f(jj,2*j2-1,i) = f(jj,2*j1-1,i) - t2      f(jj,2*j2,i) = f(jj,2*j1,i) - t3      f(jj,2*j1-1,i) = f(jj,2*j1-1,i) + t2      f(jj,2*j1,i) = f(jj,2*j1,i) + t3   60 continue   70 continue   80 continue   90 continue  100 continuec unscramble coefficients and normalizec inverse fourier transform      if (isign.lt.0) then         kmr = nxy/nxh         ani = 1./float(2*nx*ny)         do 130 j = 2, nxhh         t1 = cmplx(aimag(sctd(1+kmr*(j-1))),-real(sctd(1+kmr*(j-1))))         do 120 k = nyi, nyt         do 110 jj = 1, 3         t4 = f(jj,nx3-2*j,k)         t5 = -f(jj,nx3-2*j+1,k)         t2 = f(jj,2*j-1,k) + t4         t3 = f(jj,2*j,k) + t5         t6 = f(jj,2*j-1,k) - t4         t5 = f(jj,2*j,k) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         f(jj,2*j-1,k) = ani*(t2 + t4)         f(jj,2*j,k) = ani*(t3 + t5)         f(jj,nx3-2*j,k) = ani*(t2 - t4)         f(jj,nx3-2*j+1,k) = ani*(t5 - t3)  110    continue  120    continue  130    continue         ani = 2.*ani         do 150 k = nyi, nyt         do 140 jj = 1, 3         f(jj,nxh+1,k) = ani*f(jj,nxh+1,k)         f(jj,nxh+2,k) = -ani*f(jj,nxh+2,k)         t2 = ani*(f(jj,1,k) + f(jj,2,k))         f(jj,2,k) = ani*(f(jj,1,k) - f(jj,2,k))         f(jj,1,k) = t2         f(jj,nx+1,k) = ani*f(jj,nx+1,k)  140    continue  150    continuec forward fourier transform      else if (isign.gt.0) then         kmr = nxy/nxh         do 180 j = 2, nxhh         t1 = cmplx(aimag(sctd(1+kmr*(j-1))),-real(sctd(1+kmr*(j-1))))         do 170 k = nyi, nyt         do 160 jj = 1, 3         t4 = f(jj,nx3-2*j,k)         t5 = -f(jj,nx3-2*j+1,k)         t2 = f(jj,2*j-1,k) + t4         t3 = f(jj,2*j,k) + t5         t6 = f(jj,2*j-1,k) - t4         t5 = f(jj,2*j,k) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         f(jj,2*j-1,k) = t2 + t4         f(jj,2*j,k) = t3 + t5         f(jj,nx3-2*j,k) = t2 - t4         f(jj,nx3-2*j+1,k) = t5 - t3  160    continue  170    continue  180    continue         do 200 k = nyi, nyt         do 190 jj = 1, 3         f(jj,nxh+1,k) = 2.0*f(jj,nxh+1,k)         f(jj,nxh+2,k) = -2.0*f(jj,nxh+2,k)         t2 = 2.0*(f(jj,1,k) + f(jj,2,k))         f(jj,2,k) = 2.0*(f(jj,1,k) - f(jj,2,k))         f(jj,1,k) = t2         f(jj,nx+1,k) = 2.0*f(jj,nx+1,k)  190    continue  200    continue      endifc perform recursion for cosine transform      do 220 k = nyi, nyt      sum1 = f(1,nx+1,k)      f(1,nx+1,k) = f(1,2,k)      f(1,2,k) = sum1      sum2 = .5*f(2,1,k)      f(2,1,k) = 0.0      f(2,2,k) = sum2      sum3 = .5*f(3,1,k)      f(3,1,k) = 0.0      f(3,2,k) = sum3      do 210 j = 2, nxh      sum1 = sum1 - f(1,2*j,k)      f(1,2*j,k) = sum1      sum2 = sum2 + f(2,2*j-1,k)      f(2,2*j-1,k) = -f(2,2*j,k)      f(2,2*j,k) = sum2      sum3 = sum3 + f(3,2*j-1,k)      f(3,2*j-1,k) = -f(3,2*j,k)      f(3,2*j,k) = sum3  210 continue      f(2,nx+1,k) = 0.0      f(3,nx+1,k) = 0.0  220 continue      return      endc-----------------------------------------------------------------------      subroutine FSCCT2R3X(f,isign,mixup,sctd,indx,indy,nyi,nyp,nxhd,nyd     1,nxhyd,nxyd)c this subroutine performs the x part of 3 two dimensional fast realc sine and cosine transforms and their inverses, for a subset of y,c for the magnetic field with dirichlet or electric field with neumannc boundary conditions, using real arithmeticc algorithm is described in Numerical Recipies in Fortran, Second Ed.,c by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, c [Cambridge Univ. Press, 1992], p. 508.c for isign = (-1,1), input: all, output: fc approximate flop count: N*(5*log2(N) + 18)c where N = (nx/2)*nyc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, inverse sine-cosine transforms are performedc f(1,n,k) = (1/nx*ny)*sum(f(1,j,k)*sin(pi*n*j/nx))c f(2:3,n,k) = (1/nx*ny)*(.5*f(2:3,1,k) + ((-1)**n)*f(2:3,nx+1,k)c             + sum(f(2:3,j,k)*cos(pi*n*j/nx)))c if isign = 1, forward sine-cosine transforms are performedc f(1,j,k) = sum(f(1,n,k)*sin(pi*n*j/nx))c f(2:3,j,k) = 2*(.5*f(2:3,1,k) + ((-1)**j)*f(2:3,n+1,k)c             + sum(f(2:3,n,k)*cos(pi*n*j/nx))c mixup = array of bit reversed addressesc sctd = sine/cosine tablec nyi = initial y index usedc nyp = number of y indices usedc nxhd = first dimension of f >= nx/2 + 1c nyd = second dimension of fc nxhyd = maximum of (nx/2,ny)c nxyd = maximum of (nx,ny)c written by viktor k. decyk, ucla      complex sctd, t1      dimension f(3,2*nxhd,nyd), mixup(nxhyd), sctd(nxyd)      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nx3 = nx + 3      ny = 2**indy      nxy = max0(nx,ny)      nxhy = 2**indx1y      nyt = nyi + nyp - 1      if (isign.eq.0) returnc create auxiliary array in x      kmr = nxy/nx      do 20 k = nyi, nyt      sum1 = .5*(f(2,1,k) - f(2,nx+1,k))      sum2 = .5*(f(3,1,k) - f(3,nx+1,k))      do 10 j = 2, nxh      j1 = 1 + kmr*(j - 1)      at3 = -aimag(sctd(j1))      at4 = real(sctd(j1))      at2 = f(1,nx+2-j,k)      at1 = f(1,j,k) + at2      at2 = f(1,j,k) - at2      at1 = at3*at1      at2 = .5*at2      f(1,j,k) = at1 + at2      f(1,nx+2-j,k) = at1 - at2      at2 = f(2,nx+2-j,k)      at1 = f(2,j,k) + at2      at2 = f(2,j,k) - at2      sum1 = sum1 + at4*at2      at2 = at3*at2      at1 = .5*at1      f(2,j,k) = at1 - at2      f(2,nx+2-j,k) = at1 + at2      at2 = f(3,nx+2-j,k)      at1 = f(3,j,k) + at2      at2 = f(3,j,k) - at2      sum2 = sum2 + at4*at2      at2 = at3*at2      at1 = .5*at1      f(3,j,k) = at1 - at2      f(3,nx+2-j,k) = at1 + at2   10 continue      f(1,1,k) = 0.0      f(1,nxh+1,k) = 2.0*f(1,nxh+1,k)      f(2,1,k) = .5*(f(2,1,k) + f(2,nx+1,k))      f(2,nx+1,k) = sum1      f(3,1,k) = .5*(f(3,1,k) + f(3,nx+1,k))      f(3,nx+1,k) = sum2   20 continuec bit-reverse array elements in x      nrx = nxhy/nxh      do 50 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 50      do 40 k = nyi, nyt      do 30 jj = 1, 3      t2 = f(jj,2*j1-1,k)      t3 = f(jj,2*j1,k)      f(jj,2*j1-1,k) = f(jj,2*j-1,k)      f(jj,2*j1,k) = f(jj,2*j,k)      f(jj,2*j-1,k) = t2      f(jj,2*j,k) = t3   30 continue   40 continue   50 continuec first transform in x      nrx = nxy/nxh      do 100 l = 1, indx1      ns = 2**(l - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = 2*km*nrx      do 90 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 80 j = 1, ns      j1 = j + k1      j2 = j + k2      t1 = sctd(1+kmr*(j-1))      do 70 i = nyi, nyt      do 60 jj = 1, 3      t2 = real(t1)*f(jj,2*j2-1,i) - aimag(t1)*f(jj,2*j2,i)      t3 = aimag(t1)*f(jj,2*j2-1,i) + real(t1)*f(jj,2*j2,i)      f(jj,2*j2-1,i) = f(jj,2*j1-1,i) - t2      f(jj,2*j2,i) = f(jj,2*j1,i) - t3      f(jj,2*j1-1,i) = f(jj,2*j1-1,i) + t2      f(jj,2*j1,i) = f(jj,2*j1,i) + t3   60 continue   70 continue   80 continue   90 continue  100 continuec unscramble coefficients and normalizec inverse fourier transform      if (isign.lt.0) then         kmr = nxy/nxh         ani = 1./float(2*nx*ny)         do 130 j = 2, nxhh         t1 = cmplx(aimag(sctd(1+kmr*(j-1))),-real(sctd(1+kmr*(j-1))))         do 120 k = nyi, nyt         do 110 jj = 1, 3         t4 = f(jj,nx3-2*j,k)         t5 = -f(jj,nx3-2*j+1,k)         t2 = f(jj,2*j-1,k) + t4         t3 = f(jj,2*j,k) + t5         t6 = f(jj,2*j-1,k) - t4         t5 = f(jj,2*j,k) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         f(jj,2*j-1,k) = ani*(t2 + t4)         f(jj,2*j,k) = ani*(t3 + t5)         f(jj,nx3-2*j,k) = ani*(t2 - t4)         f(jj,nx3-2*j+1,k) = ani*(t5 - t3)  110    continue  120    continue  130    continue         ani = 2.*ani         do 150 k = nyi, nyt         do 140 jj = 1, 3         f(jj,nxh+1,k) = ani*f(jj,nxh+1,k)         f(jj,nxh+2,k) = -ani*f(jj,nxh+2,k)         t2 = ani*(f(jj,1,k) + f(jj,2,k))         f(jj,2,k) = ani*(f(jj,1,k) - f(jj,2,k))         f(jj,1,k) = t2         f(jj,nx+1,k) = ani*f(jj,nx+1,k)  140    continue  150    continuec forward fourier transform      else if (isign.gt.0) then         kmr = nxy/nxh         do 180 j = 2, nxhh         t1 = cmplx(aimag(sctd(1+kmr*(j-1))),-real(sctd(1+kmr*(j-1))))         do 170 k = nyi, nyt         do 160 jj = 1, 3         t4 = f(jj,nx3-2*j,k)         t5 = -f(jj,nx3-2*j+1,k)         t2 = f(jj,2*j-1,k) + t4         t3 = f(jj,2*j,k) + t5         t6 = f(jj,2*j-1,k) - t4         t5 = f(jj,2*j,k) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         f(jj,2*j-1,k) = t2 + t4         f(jj,2*j,k) = t3 + t5         f(jj,nx3-2*j,k) = t2 - t4         f(jj,nx3-2*j+1,k) = t5 - t3  160    continue  170    continue  180    continue         do 200 k = nyi, nyt         do 190 jj = 1, 3         f(jj,nxh+1,k) = 2.0*f(jj,nxh+1,k)         f(jj,nxh+2,k) = -2.0*f(jj,nxh+2,k)         t2 = 2.0*(f(jj,1,k) + f(jj,2,k))         f(jj,2,k) = 2.0*(f(jj,1,k) - f(jj,2,k))         f(jj,1,k) = t2         f(jj,nx+1,k) = 2.0*f(jj,nx+1,k)  190    continue  200    continue      endifc perform recursion for cosine transform      do 220 k = nyi, nyt      sum1 = .5*f(1,1,k)      f(1,1,k) = 0.0      f(1,2,k) = sum1      sum2 = f(2,nx+1,k)      f(2,nx+1,k) = f(2,2,k)      f(2,2,k) = sum2      sum3 = f(3,nx+1,k)      f(3,nx+1,k) = f(3,2,k)      f(3,2,k) = sum3      do 210 j = 2, nxh      sum1 = sum1 + f(1,2*j-1,k)      f(1,2*j-1,k) = -f(1,2*j,k)      f(1,2*j,k) = sum1      sum2 = sum2 - f(2,2*j,k)      f(2,2*j,k) = sum2      sum3 = sum3 - f(3,2*j,k)      f(3,2*j,k) = sum3  210 continue      f(1,nx+1,k) = 0.0  220 continue      return      endc-----------------------------------------------------------------------      subroutine FSCST2R3Y(f,isign,mixup,sctd,indx,indy,nxi,nxp,nxhd,nyd     1,nxhyd,nxyd)c this subroutine performs the y part of 3 two dimensional fast realc sine and cosine transforms and their inverses, for a subset of x,c for the electric field with dirichlet or magnetic field with neumannc boundary conditions, using real arithmeticc algorithm is described in Numerical Recipies in Fortran, Second Ed.,c by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, c [Cambridge Univ. Press, 1992], p. 508.c for isign = (-1,1), input: all, output: fc approximate flop count: N*(5*log2(N) + 20)c where N = (nx/2)*nyc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, inverse sine-cosine transforms are performedc f(1,n,m) = sum(f(1,n,k)*sin(pi*m*k/ny))c f(2,n,m) = (.5*f(2,n,1) + ((-1)**m)*f(2,n,ny+1) + sum(f(2,n,k)*c            cos(pi*m*k/ny))c f(3,n,m) = sum(f(3,n,k)*sin(pi*m*k/ny))c if isign = 1, forward sine-cosine transforms are performedc f(1,n,k) = 2*sum(f(1,n,m)*sin(pi*m*k/ny)c f(2,n,k) = 2*(.5*f(2,n,1) + ((-1)**m)*f(2,n,ny+1) + sum(f(2,n,m)*c       cos(pi*m*k/ny))c f(3,n,k) = 2*sum(f(3,n,m)*sin(pi*m*k/ny)c mixup = array of bit reversed addressesc sctd = sine/cosine tablec nxi = initial x index usedc nxp = number of x indices usedc nxhd = half of the first dimension of f >= nx/2 + 1c nyd = second dimension of f >= ny + 1c nxhyd = maximum of (nx/2,ny)c nxyd = maximum of (nx,ny)c written by viktor k. decyk, ucla      complex sctd, t1      dimension f(3,2*nxhd,nyd), mixup(nxhyd), sctd(nxyd)      indx1 = indx - 1      indy1 = indy - 1      indx1y = max0(indx1,indy)      nx = 2**indx      ny = 2**indy      nyh = ny/2      nyhh = ny/4      ny2 = ny + 2      nxy = max0(nx,ny)      nxhy = 2**indx1y      nxt = nxi + nxp - 1      if (isign.eq.0) returnc create auxiliary array in y      kmr = nxy/ny      do 20 j = nxi, nxt      sum1 = .5*(f(2,j,1) - f(2,j,ny+1))      do 10 k = 2, nyh      k1 = 1 + kmr*(k - 1)      at3 = -aimag(sctd(k1))      at2 = f(1,j,ny2-k)      at1 = f(1,j,k) + at2      at2 = f(1,j,k) - at2      at1 = at3*at1      at2 = .5*at2      f(1,j,k) = at1 + at2      f(1,j,ny2-k) = at1 - at2      at2 = f(2,j,ny2-k)      at1 = f(2,j,k) + at2      at2 = f(2,j,k) - at2      sum1 = sum1 + real(sctd(k1))*at2      at2 = at3*at2      at1 = .5*at1      f(2,j,k) = at1 - at2      f(2,j,ny2-k) = at1 + at2      at2 = f(3,j,ny2-k)      at1 = f(3,j,k) + at2      at2 = f(3,j,k) - at2      at1 = at3*at1      at2 = .5*at2      f(3,j,k) = at1 + at2      f(3,j,ny2-k) = at1 - at2   10 continue      f(1,j,1) = 0.0      f(1,j,nyh+1) = 2.0*f(1,j,nyh+1)      f(2,j,1) = .5*(f(2,j,1) + f(2,j,ny+1))      f(2,j,ny+1) = sum1      f(3,j,1) = 0.0      f(3,j,nyh+1) = 2.0*f(3,j,nyh+1)   20 continue      nry = nxhy/nyhc bit-reverse array elements in y      do 50 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 50      do 40 j = nxi, nxt      do 30 jj = 1, 3      t2 = f(jj,j,2*k1-1)      t3 = f(jj,j,2*k1)      f(jj,j,2*k1-1) = f(jj,j,2*k-1)      f(jj,j,2*k1) = f(jj,j,2*k)      f(jj,j,2*k-1) = t2      f(jj,j,2*k) = t3   30 continue   40 continue   50 continuec then transform in y      nry = nxy/nyh      do 100 l = 1, indy1      ns = 2**(l - 1)      ns2 = ns + ns      km = nyhh/ns      kmr = 2*km*nry      do 90 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 80 j = 1, ns      j1 = j + k1      j2 = j + k2      t1 = sctd(1+kmr*(j-1))      do 70 i = nxi, nxt      do 60 jj = 1, 3      t2 = real(t1)*f(jj,i,2*j2-1) - aimag(t1)*f(jj,i,2*j2)      t3 = aimag(t1)*f(jj,i,2*j2-1) + real(t1)*f(jj,i,2*j2)      f(jj,i,2*j2-1) = f(jj,i,2*j1-1) - t2      f(jj,i,2*j2) = f(jj,i,2*j1) - t3      f(jj,i,2*j1-1) = f(jj,i,2*j1-1) + t2      f(jj,i,2*j1) = f(jj,i,2*j1) + t3   60 continue   70 continue   80 continue   90 continue  100 continuec unscramble coefficients and normalizec inverse fourier transform      if (isign.lt.0) then         kmr = nxy/nyh         ani = 0.5         do 130 k = 2, nyhh         t1 = cmplx(aimag(sctd(1+kmr*(k-1))),-real(sctd(1+kmr*(k-1))))         do 120 j = nxi, nxt         do 110 jj = 1, 3         t4 = f(jj,j,ny+3-2*k)         t5 = -f(jj,j,ny+3-2*k+1)         t2 = f(jj,j,2*k-1) + t4         t3 = f(jj,j,2*k) + t5         t6 = f(jj,j,2*k-1) - t4         t5 = f(jj,j,2*k) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         f(jj,j,2*k-1) = ani*(t2 + t4)         f(jj,j,2*k) = ani*(t3 + t5)         f(jj,j,ny+3-2*k) = ani*(t2 - t4)         f(jj,j,ny+3-2*k+1) = ani*(t5 - t3)  110    continue  120    continue  130    continue         do 150 j = nxi, nxt         do 140 jj = 1, 3         f(jj,j,nyh+2) = -f(jj,j,nyh+2)         t2 = f(jj,j,1) + f(jj,j,2)         f(jj,j,2) = f(jj,j,1) - f(jj,j,2)         f(jj,j,1) = t2  140    continue  150    continuec forward fourier transform      else if (isign.gt.0) then         kmr = nxy/nyh         do 180 k = 2, nyhh         t1 = cmplx(aimag(sctd(1+kmr*(k-1))),-real(sctd(1+kmr*(k-1))))         do 170 j = nxi, nxt         do 160 jj = 1, 3         t4 = f(jj,j,ny+3-2*k)         t5 = -f(jj,j,ny+3-2*k+1)         t2 = f(jj,j,2*k-1) + t4         t3 = f(jj,j,2*k) + t5         t6 = f(jj,j,2*k-1) - t4         t5 = f(jj,j,2*k) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         f(jj,j,2*k-1) = t2 + t4         f(jj,j,2*k) = t3 + t5         f(jj,j,ny+3-2*k) = t2 - t4         f(jj,j,ny+3-2*k+1) = t5 - t3  160    continue  170    continue  180    continue         do 200 j = nxi, nxt         do 190 jj = 1, 3         f(jj,j,nyh+1) = 2.0*f(jj,j,nyh+1)         f(jj,j,nyh+2) = -2.0*f(jj,j,nyh+2)         t2 = 2.0*(f(jj,j,1) + f(jj,j,2))         f(jj,j,2) = 2.0*(f(jj,j,1) - f(jj,j,2))         f(jj,j,1) = t2         f(jj,j,ny+1) = 2.0*f(jj,j,ny+1)  190    continue  200    continue      endifc perform recursion for cosine transform      do 220 j = nxi, nxt      sum1 = .5*f(1,j,1)      f(1,j,1) = 0.      f(1,j,2) = sum1      sum2 = f(2,j,ny+1)      f(2,j,ny+1) = f(2,j,2)      f(2,j,2) = sum2      sum3 = .5*f(3,j,1)      f(3,j,1) = 0.      f(3,j,2) = sum3      do 210 k = 2, nyh      sum1 = sum1 + f(1,j,2*k-1)      f(1,j,2*k-1) = -f(1,j,2*k)      f(1,j,2*k) = sum1      sum2 = sum2 - f(2,j,2*k)      f(2,j,2*k) = sum2      sum3 = sum3 + f(3,j,2*k-1)      f(3,j,2*k-1) = -f(3,j,2*k)      f(3,j,2*k) = sum3  210 continue      f(1,j,ny+1) = 0.0      f(3,j,ny+1) = 0.0  220 continue      return      endc-----------------------------------------------------------------------      subroutine FCSCT2R3Y(f,isign,mixup,sctd,indx,indy,nxi,nxp,nxhd,nyd     1,nxhyd,nxyd)c this subroutine performs the y part of 3 two dimensional fast realc sine and cosine transforms and their inverses, for a subset of x,c for the magnetic field with dirichlet or electric field with neumannc boundary conditions, using real arithmeticc algorithm is described in Numerical Recipies in Fortran, Second Ed.,c by W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling, c [Cambridge Univ. Press, 1992], p. 508.c for isign = (-1,1), input: all, output: fc approximate flop count: N*(5*log2(N) + 20)c where N = (nx/2)*nyc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, inverse sine-cosine transforms are performedc f(1,n,m) = (.5*f(1,n,1) + ((-1)**m)*f(1,n,ny+1) + sum(f(1,n,k)*c            cos(pi*m*k/ny))c f(2,n,m) = sum(f(2,n,k)*sin(pi*m*k/ny))c f(3,n,m) = (.5*f(3,n,1) + ((-1)**m)*f(3,n,ny+1) + sum(f(3,n,k)*c            cos(pi*m*k/ny))c if isign = 1, forward sine-cosine transforms are performedc f(1,n,k) = 2*(.5*f(1,n,1) + ((-1)**m)*f(1,n,ny+1) + sum(f(1,n,m)*c       cos(pi*m*k/ny))c f(3,n,k) = 2*sum(f(3,n,m)*sin(pi*m*k/ny)c f(3,n,k) = 2*(.5*f(3,n,1) + ((-1)**m)*f(3,n,ny+1) + sum(f(3,n,m)*c       cos(pi*m*k/ny))c mixup = array of bit reversed addressesc sctd = sine/cosine tablec nxi = initial x index usedc nxp = number of x indices usedc nxhd = half of the first dimension of f >= nx/2 + 1c nyd = second dimension of f >= ny + 1c nxhyd = maximum of (nx/2,ny)c nxyd = maximum of (nx,ny)c written by viktor k. decyk, ucla      complex sctd, t1      dimension f(3,2*nxhd,nyd), mixup(nxhyd), sctd(nxyd)      indx1 = indx - 1      indy1 = indy - 1      indx1y = max0(indx1,indy)      nx = 2**indx      ny = 2**indy      nyh = ny/2      nyhh = ny/4      ny2 = ny + 2      nxy = max0(nx,ny)      nxhy = 2**indx1y      nxt = nxi + nxp - 1      if (isign.eq.0) returnc create auxiliary array in y      kmr = nxy/ny      do 20 j = nxi, nxt      sum1 = .5*(f(1,j,1) - f(1,j,ny+1))      sum2 = .5*(f(3,j,1) - f(3,j,ny+1))      do 10 k = 2, nyh      k1 = 1 + kmr*(k - 1)      at3 = -aimag(sctd(k1))      at4 = real(sctd(k1))      at2 = f(1,j,ny2-k)      at1 = f(1,j,k) + at2      at2 = f(1,j,k) - at2      sum1 = sum1 + at4*at2      at2 = at3*at2      at1 = .5*at1      f(1,j,k) = at1 - at2      f(1,j,ny2-k) = at1 + at2      at2 = f(2,j,ny2-k)      at1 = f(2,j,k) + at2      at2 = f(2,j,k) - at2      at1 = at3*at1      at2 = .5*at2      f(2,j,k) = at1 + at2      f(2,j,ny2-k) = at1 - at2      at2 = f(3,j,ny2-k)      at1 = f(3,j,k) + at2      at2 = f(3,j,k) - at2      sum2 = sum2 + at4*at2      at2 = at3*at2      at1 = .5*at1      f(3,j,k) = at1 - at2      f(3,j,ny2-k) = at1 + at2   10 continue      f(1,j,1) = .5*(f(1,j,1) + f(1,j,ny+1))      f(1,j,ny+1) = sum1      f(2,j,1) = 0.0      f(2,j,nyh+1) = 2.0*f(2,j,nyh+1)      f(3,j,1) = .5*(f(3,j,1) + f(3,j,ny+1))      f(3,j,ny+1) = sum2   20 continue      nry = nxhy/nyhc bit-reverse array elements in y      do 50 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 50      do 40 j = nxi, nxt      do 30 jj = 1, 3      t2 = f(jj,j,2*k1-1)      t3 = f(jj,j,2*k1)      f(jj,j,2*k1-1) = f(jj,j,2*k-1)      f(jj,j,2*k1) = f(jj,j,2*k)      f(jj,j,2*k-1) = t2      f(jj,j,2*k) = t3   30 continue   40 continue   50 continuec then transform in y      nry = nxy/nyh      do 100 l = 1, indy1      ns = 2**(l - 1)      ns2 = ns + ns      km = nyhh/ns      kmr = 2*km*nry      do 90 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 80 j = 1, ns      j1 = j + k1      j2 = j + k2      t1 = sctd(1+kmr*(j-1))      do 70 i = nxi, nxt      do 60 jj = 1, 3      t2 = real(t1)*f(jj,i,2*j2-1) - aimag(t1)*f(jj,i,2*j2)      t3 = aimag(t1)*f(jj,i,2*j2-1) + real(t1)*f(jj,i,2*j2)      f(jj,i,2*j2-1) = f(jj,i,2*j1-1) - t2      f(jj,i,2*j2) = f(jj,i,2*j1) - t3      f(jj,i,2*j1-1) = f(jj,i,2*j1-1) + t2      f(jj,i,2*j1) = f(jj,i,2*j1) + t3   60 continue   70 continue   80 continue   90 continue  100 continuec unscramble coefficients and normalizec inverse fourier transform      if (isign.lt.0) then         kmr = nxy/nyh         ani = 0.5         do 130 k = 2, nyhh         t1 = cmplx(aimag(sctd(1+kmr*(k-1))),-real(sctd(1+kmr*(k-1))))         do 120 j = nxi, nxt         do 110 jj = 1, 3         t4 = f(jj,j,ny+3-2*k)         t5 = -f(jj,j,ny+3-2*k+1)         t2 = f(jj,j,2*k-1) + t4         t3 = f(jj,j,2*k) + t5         t6 = f(jj,j,2*k-1) - t4         t5 = f(jj,j,2*k) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         f(jj,j,2*k-1) = ani*(t2 + t4)         f(jj,j,2*k) = ani*(t3 + t5)         f(jj,j,ny+3-2*k) = ani*(t2 - t4)         f(jj,j,ny+3-2*k+1) = ani*(t5 - t3)  110    continue  120    continue  130    continue         do 150 j = nxi, nxt         do 140 jj = 1, 3         f(jj,j,nyh+2) = -f(jj,j,nyh+2)         t2 = f(jj,j,1) + f(jj,j,2)         f(jj,j,2) = f(jj,j,1) - f(jj,j,2)         f(jj,j,1) = t2  140    continue  150    continuec forward fourier transform      else if (isign.gt.0) then         kmr = nxy/nyh         do 180 k = 2, nyhh         t1 = cmplx(aimag(sctd(1+kmr*(k-1))),-real(sctd(1+kmr*(k-1))))         do 170 j = nxi, nxt         do 160 jj = 1, 3         t4 = f(jj,j,ny+3-2*k)         t5 = -f(jj,j,ny+3-2*k+1)         t2 = f(jj,j,2*k-1) + t4         t3 = f(jj,j,2*k) + t5         t6 = f(jj,j,2*k-1) - t4         t5 = f(jj,j,2*k) - t5         t4 = t6*real(t1) - t5*aimag(t1)         t5 = t6*aimag(t1) + t5*real(t1)         f(jj,j,2*k-1) = t2 + t4         f(jj,j,2*k) = t3 + t5         f(jj,j,ny+3-2*k) = t2 - t4         f(jj,j,ny+3-2*k+1) = t5 - t3  160    continue  170    continue  180    continue         do 200 j = nxi, nxt         do 190 jj = 1, 3         f(jj,j,nyh+1) = 2.0*f(jj,j,nyh+1)         f(jj,j,nyh+2) = -2.0*f(jj,j,nyh+2)         t2 = 2.0*(f(jj,j,1) + f(jj,j,2))         f(jj,j,2) = 2.0*(f(jj,j,1) - f(jj,j,2))         f(jj,j,1) = t2         f(jj,j,ny+1) = 2.0*f(jj,j,ny+1)  190    continue  200    continue      endifc perform recursion for cosine transform      do 220 j = nxi, nxt      sum1 = f(1,j,ny+1)      f(1,j,ny+1) = f(1,j,2)      f(1,j,2) = sum1      sum2 = .5*f(2,j,1)      f(2,j,1) = 0.      f(2,j,2) = sum2      sum3 = f(3,j,ny+1)      f(3,j,ny+1) = f(3,j,2)      f(3,j,2) = sum3      do 210 k = 2, nyh      sum1 = sum1 - f(1,j,2*k)      f(1,j,2*k) = sum1      sum2 = sum2 + f(2,j,2*k-1)      f(2,j,2*k-1) = -f(2,j,2*k)      f(2,j,2*k) = sum2      sum3 = sum3 - f(3,j,2*k)      f(3,j,2*k) = sum3  210 continue      f(2,j,ny+1) = 0.0  220 continue      return      endc-----------------------------------------------------------------------      function ranorm()c this program calculates a random number y from a gaussian distributionc with zero mean and unit variance, according to the method ofc mueller and box:c    y(k) = (-2*ln(x(k)))**1/2*sin(2*pi*x(k+1))c    y(k+1) = (-2*ln(x(k)))**1/2*cos(2*pi*x(k+1)),c where x is a random number uniformly distributed on (0,1).c written for the ibm by viktor k. decyk, ucla      integer r1,r2,r4,r5      double precision ranorm,h1l,h1u,h2l,r0,r3,asc,bsc,temp      save iflg,r1,r2,r4,r5,h1l,h1u,h2l,r0      data r1,r2,r4,r5 /885098780,1824280461,1396483093,55318673/      data h1l,h1u,h2l /65531.0d0,32767.0d0,65525.0d0/      data iflg,r0 /0,0.0d0/      if (iflg.eq.0) go to 10      ranorm = r0      r0 = 0.0d0      iflg = 0      return   10 isc = 65536      asc = dble(isc)      bsc = asc*asc      i1 = r1 - (r1/isc)*isc      r3 = h1l*dble(r1) + asc*h1u*dble(i1)      i1 = r3/bsc      r3 = r3 - dble(i1)*bsc      bsc = 0.5d0*bsc      i1 = r2/isc      isc = r2 - i1*isc      r0 = h1l*dble(r2) + asc*h1u*dble(isc)      asc = 1.0d0/bsc      isc = r0*asc      r2 = r0 - dble(isc)*bsc      r3 = r3 + (dble(isc) + 2.0d0*h1u*dble(i1))      isc = r3*asc      r1 = r3 - dble(isc)*bsc      temp = dsqrt(-2.0d0*dlog((dble(r1) + dble(r2)*asc)*asc))      isc = 65536      asc = dble(isc)      bsc = asc*asc      i1 = r4 - (r4/isc)*isc      r3 = h2l*dble(r4) + asc*h1u*dble(i1)      i1 = r3/bsc      r3 = r3 - dble(i1)*bsc      bsc = 0.5d0*bsc      i1 = r5/isc      isc = r5 - i1*isc      r0 = h2l*dble(r5) + asc*h1u*dble(isc)      asc = 1.0d0/bsc      isc = r0*asc      r5 = r0 - dble(isc)*bsc      r3 = r3 + (dble(isc) + 2.0d0*h1u*dble(i1))      isc = r3*asc      r4 = r3 - dble(isc)*bsc      r0 = 6.28318530717959d0*((dble(r4) + dble(r5)*asc)*asc)      ranorm = temp*dsin(r0)      r0 = temp*dcos(r0)      iflg = 1      return      endc-----------------------------------------------------------------------      subroutine TIMERA(icntrl,chr,time)c this subroutine performs timingc input: icntrl, chrc icntrl = (-1,0,1) = (initialize,ignore,read) clockc clock should be initialized before it is read!c chr = character variable for labeling timingsc time = elapsed time in secondsc written for mpi      implicit none      integer icntrl      character*8 chr      real timec get definition of MPI constants      include 'mpif.h'c common block for parallel processing      integer nproc, lgrp, mreal, mint, mcplxc lgrp = current communicatorc mreal = default datatype for reals      common /pparms/ nproc, lgrp, mreal, mint, mcplxc local data      integer idproc, ierr      real nclock, mclock      double precision jclock      save jclock   91 format (1x,a8,1x,'max/min real time = ',e14.7,1x,e14.7,1x,'sec')      data jclock /0.0d0/      if (icntrl.eq.0) return      if (icntrl.eq.1) go to 10c initialize clock      call MPI_BARRIER(lgrp,ierr)      jclock = MPI_WTIME()      returnc read clock and write time difference from last clock initialization   10 nclock = real(MPI_WTIME() - jclock)      call MPI_ALLREDUCE(nclock,time,1,mreal,MPI_MIN,lgrp,ierr)      mclock = time      call MPI_ALLREDUCE(nclock,time,1,mreal,MPI_MAX,lgrp,ierr)      call MPI_COMM_RANK(lgrp,idproc,ierr)      if (idproc.eq.0) write (6,91) chr, time, mclock      return      endc-----------------------------------------------------------------------      subroutine PSUM(f,g,nxp,nblok)c this subroutine performs a parallel sum of a vector, that is:c f(j,k) = sum over k of f(j,k)c assumes the number of processors nproc is a power of two.c the algorithm performs partial sums in binary pairs, as follows:c first, adjacent processors exchange vectors and sum them.  next,c processors separated by 2 exchange the new vectors and sum them, thenc those separated by 4, up to processors separated by nproc/2.  at thec end, all processors contain the same summation.c f = input and output datac g = scratch arrayc nxp = number of data values in vectorc nblok = number of data blocksc written by viktor k. decyk, ucla      implicit none      real f, g      integer nxp, nblok      dimension f(nxp,nblok), g(nxp,nblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplxc lstat = length of status array      parameter(lstat=8)c nproc = number of real or virtual processors obtainedc lgrp = current communicatorc mreal = default datatype for reals      common /pparms/ nproc, lgrp, mreal, mint, mcplxc local data      integer istatus      integer idproc, ierr, kstrt, ks, l, kxs, k, kb, lb, msid, j      dimension istatus(lstat)c find processor idc this line is used for shared memory computersc     idproc = 0c this line is used for mpi computers      call MPI_COMM_RANK(lgrp,idproc,ierr)      kstrt = idproc + 1      if (kstrt.gt.nproc) return      ks = kstrt - 2      l = 1      kxs = 1c main iteration loop   10 if (kxs.ge.nproc) go to 60c shift data      do 30 k = 1, nblok      kb = k + ks      lb = kb/kxs      kb = kb + 1      lb = lb - 2*(lb/2)c this loop is used for shared memory computersc     do 20 j = 1, nxpc     if (lb.eq.0) thenc        g(j,k) = f(j,kb+kxs)c     elsec        g(j,k) = f(j,kb-kxs)c     endifc  20 continuec this segment is used for mpi computers      if (lb.eq.0) then         call MPI_IRECV(g,nxp,mreal,kb+kxs-1,l+nxp,lgrp,msid,ierr)         call MPI_SEND(f,nxp,mreal,kb+kxs-1,l+nxp,lgrp,ierr)      else         call MPI_IRECV(g,nxp,mreal,kb-kxs-1,l+nxp,lgrp,msid,ierr)         call MPI_SEND(f,nxp,mreal,kb-kxs-1,l+nxp,lgrp,ierr)      endif      call MPI_WAIT(msid,istatus,ierr)   30 continuec perform sum      do 50 k = 1, nblok      do 40 j = 1, nxp      f(j,k) = f(j,k) + g(j,k)   40 continue   50 continue      l = l + 1      kxs = kxs + kxs      go to 10   60 return      endc-----------------------------------------------------------------------      subroutine PWTIMERA(icntrl,time,dtime)c this subroutine performs local wall clock timingc input: icntrl, dtimec icntrl = (-1,0,1) = (initialize,ignore,read) clockc clock should be initialized before it is read!c time = elapsed time in secondsc dtime = current timec written for mpi      implicit none      integer icntrl      real time      double precision dtimec local data      double precision jclock      double precision MPI_WTIME      external MPI_WTIMEc initialize clock      if (icntrl.eq.(-1)) then         dtime = MPI_WTIME()c read clock and write time difference from last clock initialization      else if (icntrl.eq.1) then         jclock = dtime         dtime = MPI_WTIME()         time = real(dtime - jclock)      endif      return      endc-----------------------------------------------------------------------      subroutine PRTPOSE(f,g,s,t,nx,ny,kstrt,nxv,nyv,kxp,kyp,kxpd,kypd,j     1blok,kblok)c this subroutine performs a transpose of a matrix f, distributed in y,c to a matrix g, distributed in x, that is,c g(k+kyp*(m-1),j,l) = f(j+kxp*(l-1),k,m), wherec 1 <= j <= kxp, 1 <= k <= kyp, 1 <= l <= nx/kxp, 1 <= m <= ny/kypc and where indices l and m can be distributed across processors.c includes an extra guard cell for each row and columnc this subroutine sends and receives one message at a time, eitherc synchronously or asynchronously. it uses a minimum of system resourcesc f = complex input arrayc g = complex output arrayc s, t = complex scratch arraysc nx/ny = number of points in x/yc kstrt = starting data block numberc nxv = first dimension of f >= nx+1c nyv = first dimension of g >= ny+1c kypd = second dimension of f >= kyp+1c kxpd = second dimension of g >= kxp+1c kxp/kyp = number of data values per block in x/yc jblok/kblok = number of data blocks in x/y      implicit none      integer nx, ny, kstrt, nxv, nyv, kxp, kyp, kxpd, kypd      integer jblok, kblok      real f, g, s, t      dimension f(nxv,kypd,kblok), g(nyv,kxpd,jblok)      dimension s(kxp+1,kyp+1,kblok), t(kxp+1,kyp+1,jblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=10)c lgrp = current communicatorc mreal = default datatype for reals      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer ks, kxb, kyb, kxp1, kyp1, kxpt, kypt      integer jkblok, kxym, mtr, ntr, mntr      integer l, i, joff, koff, k, j      integer ir0, is0, ii, ir, is, ierr, msid, istatus      dimension istatus(lstat)      ks = kstrt - 2      kxb = nx/kxp      kyb = ny/kypc set constants to receive extra guard cells      kxp1 = kxp + 1      kyp1 = kyp + 1      kxpt = kxp      if (kstrt.eq.kxb) kxpt = kxp1c this segment is used for shared memory computersc     if (kstrt.gt.nx) returnc     do 40 l = 1, jblokc     joff = kxp*(l + ks)c     do 30 i = 1, kybc     koff = kyp*(i - 1)c     do 20 k = 1, kyp1c     do 10 j = 1, kxp1c     g(k+koff,j,l) = f(j+joff,k,i)c  10 continuec  20 continuec  30 continuec  40 continuec this segment is used for mpi computers      jkblok = max0(jblok,kblok)      kxym = min0(kxb,kyb)      mtr = kyb/kxym      ntr = kxb/kxym      mntr = max0(mtr,ntr)      do 70 l = 1, jkblok      do 60 i = 1, kxym      ir0 = iand(kxym-1,ieor(l+ks,i-1)) + 1      is0 = ir0      do 50 ii = 1, mntrc post receive      if ((kstrt.le.nx).and.(ii.le.mtr)) then         ir = ir0 + kxym*(ii - 1)         kypt = kyp         if (ir.eq.kyb) kypt = kyp1         call MPI_IRECV(t(1,1,l),kxp1*kyp1,mreal,ir-1,ir+kxym+1,lgrp,msi     1d,ierr)      endifc send data      if ((kstrt.le.ny).and.(ii.le.ntr)) then         is = is0 + kxym*(ii - 1)         joff = kxp*(is - 1)         do 20 k = 1, kyp1         do 10 j = 1, kxp1         s(j,k,l) = f(j+joff,k,l)   10    continue   20    continue         call MPI_SEND(s(1,1,l),kxp1*kyp1,mreal,is-1,l+ks+kxym+2,lgrp,ie     1rr)      endifc receive data      if ((kstrt.le.nx).and.(ii.le.mtr)) then         koff = kyp*(ir - 1)         call MPI_WAIT(msid,istatus,ierr)         do 40 k = 1, kypt         do 30 j = 1, kxpt         g(k+koff,j,l) = t(j,k,l)   30    continue   40    continue      endif   50 continue   60 continue   70 continue      return      endc-----------------------------------------------------------------------      subroutine PR2TPOSE(f,g,s,t,nx,ny,kstrt,nxv,nyv,kxp,kyp,kxpd,kypd,     1jblok,kblok)c this subroutine performs a transpose of a matrix f, distributed in y,c to a matrix g, distributed in x, that is,c g(1:2,k+kyp*(m-1),j,l) = f(1:2,j+kxp*(l-1),k,m), wherec 1 <= j <= kxp, 1 <= k <= kyp, 1 <= l <= nx/kxp, 1 <= m <= ny/kypc and where indices l and m can be distributed across processors.c includes an extra guard cell for last row and columnc this subroutine sends and receives one message at a time, eitherc synchronously or asynchronously. it uses a minimum of system resourcesc f = real input arrayc g = real output arrayc s, t = real scratch arraysc nx/ny = number of points in x/yc kstrt = starting data block numberc nxv = first dimension of f >= nx+1c nyv = first dimension of g >= ny+1c kypd = second dimension of f >= kyp+1c kxpd = second dimension of g >= kxp+1c kxp/kyp = number of data values per block in x/yc jblok/kblok = number of data blocks in x/y      implicit none      integer nx, ny, kstrt, nxv, nyv, kxp, kyp, kxpd, kypd      integer jblok, kblok      real f, g, s, t      dimension f(2,nxv,kypd,kblok), g(2,nyv,kxpd,jblok)      dimension s(2,kxp+1,kyp+1,kblok), t(2,kxp+1,kyp+1,jblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=10)c lgrp = current communicatorc mreal = default datatype for reals      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer ks, kxb, kyb, kxp1, kyp1, kxpt, kypt      integer jkblok, kxym, mtr, ntr, mntr      integer l, i, joff, koff, k, j      integer ir0, is0, ii, ir, is, ierr, msid, istatus      dimension istatus(lstat)      ks = kstrt - 2      kxb = nx/kxp      kyb = ny/kypc set constants to receive extra guard cells      kxp1 = kxp + 1      kyp1 = kyp + 1      kxpt = kxp      if (kstrt.eq.kxb) kxpt = kxp1c this segment is used for shared memory computersc     if (kstrt.gt.nx) returnc     kypt = kypc     do 40 l = 1, jblokc     joff = kxp*(l + ks)c     if ((l+ks).eq.(kxb-1)) kxpt = kxp1c     do 30 i = 1, kybc     koff = kyp*(i - 1)c     if (i.eq.kyb) kypt = kyp1c     do 20 k = 1, kyptc     do 10 j = 1, kxptc     g(1,k+koff,j,l) = f(1,j+joff,k,i)c     g(2,k+koff,j,l) = f(2,j+joff,k,i)c  10 continuec  20 continuec  30 continuec  40 continuec this segment is used for mpi computers      jkblok = max0(jblok,kblok)      kxym = min0(kxb,kyb)      mtr = kyb/kxym      ntr = kxb/kxym      mntr = max0(mtr,ntr)      do 70 l = 1, jkblok      do 60 i = 1, kxym      ir0 = iand(kxym-1,ieor(l+ks,i-1)) + 1      is0 = ir0      do 50 ii = 1, mntrc post receive      if ((kstrt.le.nx).and.(ii.le.mtr)) then         ir = ir0 + kxym*(ii - 1)         kypt = kyp         if (ir.eq.kyb) kypt = kyp1         call MPI_IRECV(t(1,1,1,l),2*kxp1*kyp1,mreal,ir-1,ir+kxym+1,lgrp     1,msid,ierr)      endifc send data      if ((kstrt.le.ny).and.(ii.le.ntr)) then         is = is0 + kxym*(ii - 1)         joff = kxp*(is - 1)         do 20 k = 1, kyp1         do 10 j = 1, kxp1         s(1,j,k,l) = f(1,j+joff,k,l)         s(2,j,k,l) = f(2,j+joff,k,l)   10    continue   20    continue         call MPI_SEND(s(1,1,1,l),2*kxp1*kyp1,mreal,is-1,l+ks+kxym+2,lgr     1p,ierr)      endifc receive data      if ((kstrt.le.nx).and.(ii.le.mtr)) then         koff = kyp*(ir - 1)         call MPI_WAIT(msid,istatus,ierr)         do 40 k = 1, kypt         do 30 j = 1, kxpt         g(1,k+koff,j,l) = t(1,j,k,l)         g(2,k+koff,j,l) = t(2,j,k,l)   30    continue   40    continue      endif   50 continue   60 continue   70 continue      return      endc-----------------------------------------------------------------------      subroutine PR3TPOSE(f,g,s,t,nx,ny,kstrt,nxv,nyv,kxp,kyp,kxpd,kypd,     1jblok,kblok)c this subroutine performs a transpose of a matrix f, distributed in y,c to a matrix g, distributed in x, that is,c g(1:3,k+kyp*(m-1),j,l) = f(1:3,j+kxp*(l-1),k,m), wherec 1 <= j <= kxp, 1 <= k <= kyp, 1 <= l <= nx/kxp, 1 <= m <= ny/kypc and where indices l and m can be distributed across processors.c includes an extra guard cell for last row and columnc this subroutine sends and receives one message at a time, eitherc synchronously or asynchronously. it uses a minimum of system resourcesc f = real input arrayc g = real output arrayc s, t = real scratch arraysc nx/ny = number of points in x/yc kstrt = starting data block numberc nxv = first dimension of f >= nx+1c nyv = first dimension of g >= ny+1c kypd = second dimension of f >= kyp+1c kxpd = second dimension of g >= kxp+1c kxp/kyp = number of data values per block in x/yc jblok/kblok = number of data blocks in x/y      implicit none      integer nx, ny, kstrt, nxv, nyv, kxp, kyp, kxpd, kypd      integer jblok, kblok      real f, g, s, t      dimension f(3,nxv,kypd,kblok), g(3,nyv,kxpd,jblok)      dimension s(3,kxp+1,kyp+1,kblok), t(3,kxp+1,kyp+1,jblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=10)c lgrp = current communicatorc mreal = default datatype for reals      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer ks, kxb, kyb, kxp1, kyp1, kxpt, kypt      integer jkblok, kxym, mtr, ntr, mntr      integer l, i, joff, koff, k, j      integer ir0, is0, ii, ir, is, ierr, msid, istatus      dimension istatus(lstat)      ks = kstrt - 2      kxb = nx/kxp      kyb = ny/kypc set constants to receive extra guard cells      kxp1 = kxp + 1      kyp1 = kyp + 1      kxpt = kxp      if (kstrt.eq.kxb) kxpt = kxp1c this segment is used for shared memory computersc     if (kstrt.gt.nx) returnc     kypt = kypc     do 40 l = 1, jblokc     joff = kxp*(l + ks)c     if ((l+ks).eq.(kxb-1)) kxpt = kxp1c     do 30 i = 1, kybc     koff = kyp*(i - 1)c     if (i.eq.kyb) kypt = kyp1c     do 20 k = 1, kyptc     do 10 j = 1, kxptc     g(1,k+koff,j,l) = f(1,j+joff,k,i)c     g(2,k+koff,j,l) = f(2,j+joff,k,i)c     g(3,k+koff,j,l) = f(3,j+joff,k,i)c  10 continuec  20 continuec  30 continuec  40 continuec this segment is used for mpi computers      jkblok = max0(jblok,kblok)      kxym = min0(kxb,kyb)      mtr = kyb/kxym      ntr = kxb/kxym      mntr = max0(mtr,ntr)      do 70 l = 1, jkblok      do 60 i = 1, kxym      ir0 = iand(kxym-1,ieor(l+ks,i-1)) + 1      is0 = ir0      do 50 ii = 1, mntrc post receive      if ((kstrt.le.nx).and.(ii.le.mtr)) then         ir = ir0 + kxym*(ii - 1)         kypt = kyp         if (ir.eq.kyb) kypt = kyp1         call MPI_IRECV(t(1,1,1,l),3*kxp1*kyp1,mreal,ir-1,ir+kxym+1,lgrp     1,msid,ierr)      endifc send data      if ((kstrt.le.ny).and.(ii.le.ntr)) then         is = is0 + kxym*(ii - 1)         joff = kxp*(is - 1)         do 20 k = 1, kyp1         do 10 j = 1, kxp1         s(1,j,k,l) = f(1,j+joff,k,l)         s(2,j,k,l) = f(2,j+joff,k,l)         s(3,j,k,l) = f(3,j+joff,k,l)   10    continue   20    continue         call MPI_SEND(s(1,1,1,l),3*kxp1*kyp1,mreal,is-1,l+ks+kxym+2,lgr     1p,ierr)      endifc receive data      if ((kstrt.le.nx).and.(ii.le.mtr)) then         koff = kyp*(ir - 1)         call MPI_WAIT(msid,istatus,ierr)         do 40 k = 1, kypt         do 30 j = 1, kxpt         g(1,k+koff,j,l) = t(1,j,k,l)         g(2,k+koff,j,l) = t(2,j,k,l)         g(3,k+koff,j,l) = t(3,j,k,l)   30    continue   40    continue      endif   50 continue   60 continue   70 continue      return      endc-----------------------------------------------------------------------      subroutine PDMFIELDD2(q2,q,nx,ny,kstrt,ny2d,nyv,kxp2,j2blok)c this subroutine copies the charge density into a smaller arrayc which would have been created by a fast sine transform in x and y      implicit none      integer nx, ny, kstrt, nyv, ny2d, kxp2, j2blok      complex q2      real q      dimension q2(ny2d,kxp2,j2blok), q(nyv,kxp2+1,j2blok)      integer j, k, l, ny1      if (kstrt.gt.nx) return      ny1 = ny + 1      do 40 l = 1, j2blokc mode numbers kx > 0 and 0 < ky < ny      do 20 j = 1, kxp2      do 10 k = 1, ny1      q(k,j,l) = -real(q2(k,j,l))   10 continue   20 continuec mode number kx = nx/2 is zero.      do 30 k = 1, ny1      q(k,kxp2+1,l) = 0.   30 continue   40 continue      return      endc-----------------------------------------------------------------------      subroutine PFMFIELDD2(q2,q,nx,ny,kstrt,ny2d,nyv,kxp2,j2blok)c this subroutine copies the charge density into a smaller arrayc which would have been created by a fast cosine transform in x and y      implicit none      integer nx, ny, kstrt, nyv, ny2d, kxp2, j2blok      complex q2      real q      dimension q2(ny2d,kxp2,j2blok), q(nyv,kxp2+1,j2blok)      integer j, k, l, ny1      if (kstrt.gt.nx) return      ny1 = ny + 1      do 40 l = 1, j2blokc mode numbers kx > 0 and 0 < ky < ny      do 20 j = 1, kxp2      do 10 k = 1, ny1      q(k,j,l) = real(q2(k,j,l))   10 continue   20 continuec mode number kx = nx/2 is assumed to be zero.c if not zero, it is actually on the wrong processor      do 30 k = 1, ny1      q(k,kxp2+1,l) = 0.   30 continue   40 continue      return      endc-----------------------------------------------------------------------      subroutine PCMFIELDD2(cu2,cu,nx,ny,kstrt,ny2d,nyv,kxp2,j2blok)c this subroutine copies the current into a smaller array      implicit none      integer nx, ny, kstrt, nyv, ny2d, kxp2, j2blok      complex cu2      real cu      dimension cu2(3,ny2d,kxp2,j2blok), cu(3,nyv,kxp2+1,j2blok)      integer j, k, l, ny1      if (kstrt.gt.nx) return      ny1 = ny + 1      do 40 l = 1, j2blok      do 20 j = 1, kxp2      do 10 k = 1, ny1      cu(1,k,j,l) = -aimag(cu2(1,k,j,l))      cu(2,k,j,l) = -aimag(cu2(2,k,j,l))      cu(3,k,j,l) = -real(cu2(3,k,j,l))   10 continue   20 continuec mode number kx = nx/2 is assumed to be zero for cu(1)c if not zero, it is actually on the wrong processor      do 30 k = 1, ny1      cu(1,k,kxp2+1,l) = 0.      cu(2,k,kxp2+1,l) = 0.      cu(3,k,kxp2+1,l) = 0.   30 continue   40 continue      return      endc-----------------------------------------------------------------------      subroutine PEMFIELDD2(fxy,exy,ffd,isign,nx,ny,kstrt,ny2d,nyv,kxp2,     1j2blok,nyd)c this subroutine either adds complex vector fields if isign > 0c or copies complex vector fields if isign <= 0c adds image charges appropriate for electric field if isign >= 0c or appropriate for magnetic field if isign < 0c includes additional smoothing for isign /= 0      implicit none      integer isign, nx, ny, kstrt, ny2d, nyv, kxp2, j2blok, nyd      complex fxy, ffd      real exy      dimension fxy(3,ny2d,kxp2,j2blok), exy(3,nyv,kxp2+1,j2blok)      dimension ffd(nyd,kxp2,j2blok)      integer j, k, l, ny2, ks, joff, k1      real at1      complex zero      ny2 = 2*ny + 2      ks = kstrt - 2      zero = cmplx(0.,0.)      if (kstrt.gt.nx) returnc add the fields      if (isign.gt.0) then         do 40 l = 1, j2blok         do 20 j = 1, kxp2         joff = kxp2*(l + ks) - 1         if ((j+joff).gt.0) then            do 10 k = 2, ny            k1 = ny2 - k            at1 = aimag(ffd(k,j,l))            fxy(1,k,j,l) = fxy(1,k,j,l) + cmplx(0.,-exy(1,k,j,l)*at1)            fxy(2,k,j,l) = fxy(2,k,j,l) + cmplx(0.,-exy(2,k,j,l)*at1)            fxy(3,k,j,l) = fxy(3,k,j,l) + cmplx(-exy(3,k,j,l)*at1,0.)            fxy(1,k1,j,l) = fxy(1,k1,j,l) + cmplx(0.,exy(1,k,j,l)*at1)            fxy(2,k1,j,l) = fxy(2,k1,j,l) + cmplx(0.,-exy(2,k,j,l)*at1)            fxy(3,k1,j,l) = fxy(3,k1,j,l) + cmplx(exy(3,k,j,l)*at1,0.)   10       continue            at1 = aimag(ffd(1,j,l))            fxy(1,1,j,l) = fxy(1,1,j,l) + cmplx(0.,-exy(1,1,j,l)*at1)            fxy(2,1,j,l) = fxy(2,1,j,l) + cmplx(0.,-exy(2,1,j,l)*at1)            fxy(3,1,j,l) = fxy(3,1,j,l) + cmplx(-exy(3,1,j,l)*at1,0.)         endif   20    continue         if ((l+ks).eq.0) then            do 30 k = 1, ny            at1 = aimag(ffd(k,1,l))            fxy(1,k,1,l) = fxy(1,k,1,l) + cmplx(0.,-exy(1,k,1,l)*at1)            fxy(2,k,1,l) = fxy(2,k,1,l) + cmplx(0.,-exy(2,k,1,l)*at1)            fxy(3,k,1,l) = fxy(3,k,1,l) + cmplx(-exy(3,k,1,l)*at1,0.)   30       continue         endif   40    continuec copy the magnetic fields      else if (isign.lt.0) then         do 80 l = 1, j2blok         do 60 j = 1, kxp2         joff = kxp2*(l + ks) - 1         if ((j+joff).gt.0) then            do 50 k = 2, ny            k1 = ny2 - k            at1 = aimag(ffd(k,j,l))            fxy(1,k,j,l) = cmplx(0.,-exy(1,k,j,l)*at1)            fxy(2,k,j,l) = cmplx(0.,-exy(2,k,j,l)*at1)            fxy(3,k,j,l) = cmplx(exy(3,k,j,l)*at1,0.)            fxy(1,k1,j,l) = cmplx(0.,-exy(1,k,j,l)*at1)            fxy(2,k1,j,l) = cmplx(0.,exy(2,k,j,l)*at1)            fxy(3,k1,j,l) = cmplx(exy(3,k,j,l)*at1,0.)   50       continue            k1 = ny + 1            at1 = aimag(ffd(1,j,l))            fxy(1,1,j,l) = cmplx(0.,-exy(1,1,j,l)*at1)            fxy(2,1,j,l) = cmplx(0.,-exy(2,1,j,l)*at1)            fxy(3,1,j,l) = cmplx(exy(3,1,j,l)*at1,0.)            fxy(1,k1,j,l) = zero            fxy(2,k1,j,l) = zero            fxy(3,k1,j,l) = zero         endif   60    continue         if ((l+ks).eq.0) then            do 70 k = 2, ny            k1 = ny2 - k            at1 = aimag(ffd(k,1,l))            fxy(1,k,1,l) = cmplx(0.,-exy(1,k,1,l)*at1)            fxy(2,k,1,l) = cmplx(0.,-exy(2,k,1,l)*at1)            fxy(3,k,1,l) = cmplx(exy(3,k,1,l)*at1,0.)            fxy(1,k1,1,l) = zero            fxy(2,k1,1,l) = zero            fxy(3,k1,1,l) = zero   70       continue            k1 = ny + 1            at1 = aimag(ffd(1,1,l))            fxy(1,1,1,l) = cmplx(-exy(1,1,1,l)*at1,0.)            fxy(2,1,1,l) = cmplx(-exy(2,1,1,l)*at1,0.)            fxy(3,1,1,l) = cmplx(exy(3,1,1,l)*at1,0.)            fxy(1,k1,1,l) = zero            fxy(2,k1,1,l) = zero            fxy(3,k1,1,l) = zero         endif   80    continuec copy the electric fields      else         do 120 l = 1, j2blok         do 100 j = 1, kxp2         joff = kxp2*(l + ks) - 1         if ((j+joff).gt.0) then            do 90 k = 2, ny            k1 = ny2 - k            fxy(1,k,j,l) = cmplx(0.,-exy(1,k,j,l))            fxy(2,k,j,l) = cmplx(0.,-exy(2,k,j,l))            fxy(3,k,j,l) = cmplx(-exy(3,k,j,l),0.)            fxy(1,k1,j,l) = cmplx(0.,exy(1,k,j,l))            fxy(2,k1,j,l) = cmplx(0.,-exy(2,k,j,l))            fxy(3,k1,j,l) = cmplx(exy(3,k,j,l),0.)   90       continue            k1 = ny + 1            fxy(1,1,j,l) = cmplx(0.,-exy(1,1,j,l))            fxy(2,1,j,l) = cmplx(0.,-exy(2,1,j,l))            fxy(3,1,j,l) = cmplx(-exy(3,1,j,l),0.)            fxy(1,k1,j,l) = cmplx(0.,-exy(1,k1,j,l))            fxy(2,k1,j,l) = cmplx(0.,-exy(2,k1,j,l))            fxy(3,k1,j,l) = cmplx(-exy(3,k1,j,l),0.)         endif  100    continue         if ((l+ks).eq.0) then            do 110 k = 2, ny            k1 = ny2 - k            fxy(1,k,1,l) = cmplx(0.,-exy(1,k,1,l))            fxy(2,k,1,l) = cmplx(0.,-exy(2,k,1,l))            fxy(3,k,1,l) = cmplx(-exy(3,k,1,l),0.)c mode number kx = nx/2 is assumed to be zero for fxy(1)c if not zero, it is actually on the wrong processor            fxy(1,k1,1,l) = zero            fxy(2,k1,1,l) = zero            fxy(3,k1,1,l) = zero  110       continue            k1 = ny + 1            fxy(1,1,1,l) = cmplx(-exy(1,1,1,l),0.)            fxy(2,1,1,l) = cmplx(-exy(2,1,1,l),0.)            fxy(3,1,1,l) = cmplx(-exy(3,1,1,l),0.)            fxy(1,k1,1,l) = cmplx(-exy(1,k1,1,l),0.)            fxy(2,k1,1,l) = cmplx(-exy(2,k1,1,l),0.)            fxy(3,k1,1,l) = cmplx(-exy(3,k1,1,l),0.)         endif  120    continue      endif      return      endc-----------------------------------------------------------------------      subroutine PPMFIELDD2(pot2,pot,nx,ny,kstrt,ny2d,nyv,kxp2,j2blok)c copies image charges appropriate for potential      implicit none      integer nx, ny, kstrt, ny2d, nyv, kxp2, j2blok      complex pot2      real pot      dimension pot2(ny2d,kxp2,j2blok), pot(nyv,kxp2+1,j2blok)      integer j, k, l, ny2, ks, joff, k1      complex zero      ny2 = 2*ny + 2      ks = kstrt - 2      zero = cmplx(0.,0.)      if (kstrt.gt.nx) return      do 40 l = 1, j2blok      do 20 j = 1, kxp2      joff = kxp2*(l + ks) - 1      if ((j+joff).gt.0) then         do 10 k = 2, ny         k1 = ny2 - k         pot2(k,j,l) = cmplx(-pot(k,j,l),0.)         pot2(k1,j,l) = cmplx(pot(k,j,l),0.)   10    continue         k1 = ny + 1         pot2(1,j,l) = cmplx(-pot(1,j,l),0.)         pot2(k1,j,l) = cmplx(-pot(k1,j,l),0.)      endif   20 continue      if ((l+ks).eq.0) then         do 30 k = 2, ny         k1 = ny2 - k         pot2(k,1,l) = cmplx(-pot(k,1,l),0.)         pot2(k1,1,l) = zero   30    continue         k1 = ny + 1         pot2(1,1,l) = cmplx(-pot(1,1,l),0.)         pot2(k1,1,l) = cmplx(-pot(k1,1,l),0.)         endif   40 continue      return      endc-----------------------------------------------------------------------      subroutine PBMFIELDD2(fxy,bxy,nx,ny,kstrt,ny2d,nyv,kxp2,j2blok)c copies image charges appropriate for magnetic field      implicit none      integer nx, ny, kstrt, ny2d, nyv, kxp2, j2blok      complex fxy      real bxy      dimension fxy(3,ny2d,kxp2,j2blok), bxy(3,nyv,kxp2+1,j2blok)      integer j, k, l, ny2, ks, joff, k1      complex zero      ny2 = 2*ny + 2      ks = kstrt - 2      zero = cmplx(0.,0.)      if (kstrt.gt.nx) returnc copy the magnetic fields         do 40 l = 1, j2blok         do 20 j = 1, kxp2         joff = kxp2*(l + ks) - 1         if ((j+joff).gt.0) then         do 10 k = 2, ny         k1 = ny2 - k         fxy(1,k,j,l) = cmplx(0.,-bxy(1,k,j,l))         fxy(2,k,j,l) = cmplx(0.,-bxy(2,k,j,l))         fxy(3,k,j,l) = cmplx(bxy(3,k,j,l),0.)         fxy(1,k1,j,l) = cmplx(0.,-bxy(1,k,j,l))         fxy(2,k1,j,l) = cmplx(0.,bxy(2,k,j,l))         fxy(3,k1,j,l) = cmplx(bxy(3,k,j,l),0.)   10    continue         k1 = ny + 1         fxy(1,1,j,l) = cmplx(0.,-bxy(1,1,j,l))         fxy(2,1,j,l) = cmplx(0.,-bxy(2,1,j,l))         fxy(3,1,j,l) = cmplx(bxy(3,1,j,l),0.)         fxy(1,k1,j,l) = cmplx(0.,-bxy(1,k1,j,l))         fxy(2,k1,j,l) = cmplx(0.,-bxy(2,k1,j,l))         fxy(3,k1,j,l) = cmplx(bxy(3,k1,j,l),0.)      endif   20 continue      if ((l+ks).eq.0) then         do 30 k = 2, ny         k1 = ny2 - k         fxy(1,k,1,l) = cmplx(0.,-bxy(1,k,1,l))         fxy(2,k,1,l) = cmplx(0.,-bxy(2,k,1,l))         fxy(3,k,1,l) = cmplx(bxy(3,k,1,l),0.)c mode number kx = nx/2 is assumed to be zero for fxy(2,3)c if not zero, it is actually on the wrong processor         fxy(1,k1,1,l) = zero         fxy(2,k1,1,l) = zero         fxy(3,k1,1,l) = zero   30    continue         k1 = ny + 1         fxy(1,1,1,l) = cmplx(-bxy(1,1,1,l),0.)         fxy(2,1,1,l) = cmplx(-bxy(2,1,1,l),0.)         fxy(3,1,1,l) = cmplx(bxy(3,1,1,l),0.)         fxy(1,k1,1,l) = cmplx(-bxy(1,k1,1,l),0.)         fxy(2,k1,1,l) = cmplx(-bxy(2,k1,1,l),0.)         fxy(3,k1,1,l) = cmplx(bxy(3,k1,1,l),0.)      endif   40 continue      return      endc-----------------------------------------------------------------------      subroutine WPFFT2RINIT(mixup,sct,indx,indy,nxhyd,nxyhd)c this subroutine calculates tables needed by a two dimensionalc real to complex fast fourier transform and its inverse.c input: indx, indy, nxhyd, nxyhdc output: mixup, sctc mixup = array of bit reversed addressesc sct = sine/cosine tablec indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc nxhyd = maximum of (nx/2,ny)c nxyhd = one half of maximum of (nx,ny)c written by viktor k. decyk, ucla      implicit none      integer indx, indy, nxhyd, nxyhd      integer mixup      complex sct      dimension mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, ny, nxy, nxhy, nxyh      integer j, k, lb, ll, jb, it      real dnxy, arg      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      ny = 2**indy      nxy = max0(nx,ny)      nxhy = 2**indx1yc bit-reverse index table: mixup(j) = 1 + reversed bits of (j - 1)      do 20 j = 1, nxhy      lb = j - 1      ll = 0      do 10 k = 1, indx1y      jb = lb/2      it = lb - 2*jb      lb = jb      ll = 2*ll + it   10 continue      mixup(j) = ll + 1   20 continuec sine/cosine table for the angles 2*n*pi/nxy      nxyh = nxy/2      dnxy = 6.28318530717959/float(nxy)      do 30 j = 1, nxyh      arg = dnxy*float(j - 1)      sct(j) = cmplx(cos(arg),-sin(arg))   30 continue      return      endc-----------------------------------------------------------------------      subroutine WPFFT2R(f,g,bs,br,isign,ntpose,mixup,sct,ttp,indx,indy,     1kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)c wrapper function for parallel real to complex fft      implicit none      integer isign, ntpose, indx, indy, kstrt, nxvh, nyv, kxp, kyp      integer kypd, jblok, kblok, nxhyd, nxyhd, mixup      real ttp      complex f, g, bs, br, sct      dimension f(nxvh,kypd,kblok), g(nyv,kxp,jblok)      dimension bs(kxp,kyp,kblok), br(kxp,kyp,jblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer nxh, ny, kxpi, kypi      real tf      double precision dtime      data kxpi, kypi /1,1/c calculate range of indices      nxh = 2**(indx - 1)      ny = 2**indyc inverse fourier transform      if (isign.lt.0) thenc perform x fft         call PFFT2RXX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kyp,nxvh,k     1ypd,kblok,nxhyd,nxyhd)c transpose f array to g         call PWTIMERA(-1,ttp,dtime)         call PTPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kypd,jb     1lok,kblok)         call PWTIMERA(1,ttp,dtime)c perform y fft         call PFFT2RXY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxp,nyv,kx     1p,jblok,nxhyd,nxyhd)c transpose g array to f         if (ntpose.eq.0) then            call PWTIMERA(-1,tf,dtime)            call PTPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kxp     1,kblok,jblok)            call PWTIMERA(1,tf,dtime)         endifc forward fourier transform      else if (isign.gt.0) thenc transpose f array to g         if (ntpose.eq.0) then            call PWTIMERA(-1,tf,dtime)            call PTPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kypd     1,jblok,kblok)            call PWTIMERA(1,tf,dtime)         endifc perform y fft         call PFFT2RXY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxp,nyv,kx     1p,jblok,nxhyd,nxyhd)c transpose g array to f         call PWTIMERA(-1,ttp,dtime)         call PTPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kxp,kb     1lok,jblok)         call PWTIMERA(1,ttp,dtime)c perform x fft         call PFFT2RXX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kyp,nxvh,k     1ypd,kblok,nxhyd,nxyhd)      endif      if (ntpose.eq.0) ttp = ttp + tf      return      endc-----------------------------------------------------------------------      subroutine PFFT2RXX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kypp,nx     1vh,kypd,kblok,nxhyd,nxyhd)c this subroutine performs the x part of a two dimensional real toc complex fast fourier transform and its inverse, for a subset of y,c using complex arithmetic, for data which is distributed in blocksc for isign = (-1,1), input: all, output: fc for isign = -1, approximate flop count: N*(5*log2(N) + 10)/nvpc for isign = 1,  approximate flop count: N*(5*log2(N) + 8)/nvpc where N = (nx/2)*ny, and nvp = number of procsc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, an inverse fourier transform is performedc f(n,m,i) = (1/nx*ny)*sum(f(j,k,i)*exp(-sqrt(-1)*2pi*n*j/nx)c if isign = 1, a forward fourier transform is performedc f(j,k,i) = sum(f(n,m,i)*exp(sqrt(-1)*2pi*n*j/nx)*c kstrt = starting data block numberc kypi = initial y index usedc kypp = number of y indices usedc nxvh = first dimension of fc kypd = second dimension of fc kblok = number of data blocks in yc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxhyd = maximum of (nx/2,ny)c nxyhd = one half of maximum of (nx,ny)c the real data is stored in a complex array of length nx/2, nyc with the odd/even x points stored in the real/imaginary parts.c in complex notation, fourier coefficients are stored as follows:c f(j,k,i) = mode j-1,kk-1, where kk = k + kyp*(i - 1)c 1 <= j <= nx/2 and 1 <= kk <= ny, except forc f(1,k,i) = mode nx/2,kk-1, where ny/2+2 <= kk <= ny, andc imaginary part of f(1,1,1) = real part of mode nx/2,0 andc imaginary part of f(1,1,(ny/2)/kyp+1) = real part of mode nx/2,ny/2c written by viktor k. decyk, uclac parallel, RISC optimized version      implicit none      integer isign, mixup, indx, indy, kstrt, nxvh, kypi, kypp      integer kypd, kblok, nxhyd, nxyhd      complex f, sct      dimension f(nxvh,kypd,kblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, nxh, nxhh, nxh2, ny      integer nxy, nxhy, ks, kypt, j, k, nrx      integer l, i, m, ns, ns2, km, kmr, k1, k2, j1, j2      real ani      complex s, t, t1      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nxh2 = nxh + 2      ny = 2**indy      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      kypt = kypi + kypp - 1      if (kstrt.gt.ny) return      if (isign.gt.0) go to 130c inverse fourier transform      ani = 1./float(2*nx*ny)      nrx = nxhy/nxh      do 30 l = 1, kblokc bit-reverse array elements in x      do 20 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 20      do 10 k = kypi, kypt      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = t   10 continue   20 continue   30 continuec first transform in x      nrx = nxy/nxh      do 80 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 70 l = 1, kblok      do 60 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 50 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 40 i = kypi, kypt      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t   40 continue   50 continue   60 continue   70 continue   80 continuec unscramble coefficients and normalize      kmr = nxy/nx      do 120 l = 1, kblok      do 100 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),-real(sct(1+kmr*(j-1))))      do 90 k = kypi, kypt      t = conjg(f(nxh2-j,k,l))      s = f(j,k,l) + t      t = (f(j,k,l) - t)*t1      f(j,k,l) = ani*(s + t)      f(nxh2-j,k,l) = ani*conjg(s - t)   90 continue  100 continue      do 110 k = kypi, kypt      f(nxhh+1,k,l) = 2.*ani*conjg(f(nxhh+1,k,l))      f(1,k,l) = 2.*ani*cmplx(real(f(1,k,l)) + aimag(f(1,k,l)),real(f(1,     1k,l)) - aimag(f(1,k,l)))  110 continue  120 continue      returnc forward fourier transform  130 kmr = nxy/nx      do 190 l = 1, kblokc scramble coefficients      do 150 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),real(sct(1+kmr*(j-1))))      do 140 k = kypi, kypt      t = conjg(f(nxh2-j,k,l))      s = f(j,k,l) + t      t = (f(j,k,l) - t)*t1      f(j,k,l) = s + t      f(nxh2-j,k,l) = conjg(s - t)  140 continue  150 continue      do 160 k = kypi, kypt      f(nxhh+1,k,l) = 2.*conjg(f(nxhh+1,k,l))      f(1,k,l) = cmplx(real(f(1,k,l)) + aimag(f(1,k,l)),real(f(1,k,l)) -     1 aimag(f(1,k,l)))  160 continue      nrx = nxhy/nxhc bit-reverse array elements in x      do 180 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 180      do 170 k = kypi, kypt      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = t  170 continue  180 continue  190 continuec then transform in x      nrx = nxy/nxh      do 240 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 230 l = 1, kblok      do 220 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 210 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 200 i = kypi, kypt      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t  200 continue  210 continue  220 continue  230 continue  240 continue      return      endc-----------------------------------------------------------------------      subroutine PFFT2RXY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxpp,ny     1v,kxp,jblok,nxhyd,nxyhd)c this subroutine performs the y part of a two dimensional real toc complex fast fourier transform and its inverse, for a subset of x,c using complex arithmetic, for data which is distributed in blocksc for isign = (-1,1), input: all, output: f, gc for isign = -1, approximate flop count: N*(5*log2(N) + 10)/nvpc for isign = 1,  approximate flop count: N*(5*log2(N) + 8)/nvpc where N = (nx/2)*ny, and nvp = number of procsc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, an inverse fourier transform is performedc g(m,n,i) = sum(g(k,j,i)*exp(-sqrt(-1)*2pi*m*k/ny))c if isign = 1, a forward fourier transform is performedc g(k,j,i) = sum(g(m,n,i)*exp(sqrt(-1)*2pi*m*k/ny))c kstrt = starting data block numberc kxpi = initial x index usedc kxpp = number of   indices usedc nyv = first dimension of gc kxp = number of data values per block in xc jblok = number of data blocks in xc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxhyd = maximum of (nx/2,ny)c nxyhd = one half of maximum of (nx,ny)c the real data is stored in a complex array of length nx/2, nyc with the odd/even x points stored in the real/imaginary parts.c in complex notation, fourier coefficients are stored as follows:c g(k,j,i) = mode jj-1,k-1, where jj = j + kxp*(i - 1)c 1 <= jj <= nx/2 and 1 <= k <= ny, except forc g(k,1,1) = mode nx/2,k-1, where ny/2+2 <= k <= ny, andc imaginary part of g(1,1,1) = real part of mode nx/2,0 andc imaginary part of g(ny/2+1,1,1) = real part of mode nx/2,ny/2c written by viktor k. decyk, uclac parallel, RISC optimized version      implicit none      integer isign, mixup, indx, indy, kstrt, kxpi, kxpp, nyv      integer kxp, jblok, nxhyd, nxyhd      complex g, sct      dimension g(nyv,kxp,jblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, nxh, ny, nyh, ny2      integer nxy, nxhy, ks, kxpt, j, k, nry      integer l, i, m, ns, ns2, km, kmr, k1, k2, j1, j2      complex s, t      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      ny = 2**indy      nyh = ny/2      ny2 = ny + 2      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      kxpt = kxpi + kxpp - 1      if (kstrt.gt.nxh) return      if (isign.gt.0) go to 110c inverse fourier transform      nry = nxhy/ny      do 30 l = 1, jblokc bit-reverse array elements in y      do 20 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 20      do 10 j = kxpi, kxpt      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = t   10 continue   20 continue   30 continuec then transform in y      nry = nxy/ny      do 80 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 70 l = 1, jblok      do 60 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 50 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 40 i = kxpi, kxpt      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t   40 continue   50 continue   60 continue   70 continue   80 continuec unscramble modes kx = 0, nx/2      do 100 l = 1, jblok      if ((l+ks).gt.0) go to 100      do 90 k = 2, nyh      if (kxpi.eq.1) then         s = g(ny2-k,1,l)         g(ny2-k,1,l) = .5*cmplx(aimag(g(k,1,l) + s),real(g(k,1,l) - s))         g(k,1,l) = .5*cmplx(real(g(k,1,l) + s),aimag(g(k,1,l) - s))      endif   90 continue  100 continue      returnc forward fourier transformc scramble modes kx = 0, nx/2  110 nry = nxhy/ny      do 160 l = 1, jblok      if ((l+ks).gt.0) go to 130      do 120 k = 2, nyh      if (kxpi.eq.1) then         s = cmplx(aimag(g(ny2-k,1,l)),real(g(ny2-k,1,l)))         g(ny2-k,1,l) = conjg(g(k,1,l) - s)         g(k,1,l) = g(k,1,l) + s      endif  120 continuec bit-reverse array elements in y  130 do 150 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 150      do 140 j = kxpi, kxpt      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = t  140 continue  150 continue  160 continuec first transform in y      nry = nxy/ny      do 210 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 200 l = 1, jblok      do 190 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 180 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 170 i = kxpi, kxpt      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t  170 continue  180 continue  190 continue  200 continue  210 continue      return      endc-----------------------------------------------------------------------      subroutine PTPOSE(f,g,s,t,nx,ny,kstrt,nxv,nyv,kxp,kyp,kxpd,kypd,jb     1lok,kblok)c this subroutine performs a transpose of a matrix f, distributed in y,c to a matrix g, distributed in x, that is,c g(k+kyp*(m-1),j,l) = f(j+kxp*(l-1),k,m), wherec 1 <= j <= kxp, 1 <= k <= kyp, 1 <= l <= nx/kxp, 1 <= m <= ny/kypc and where indices l and m can be distributed across processors.c this subroutine sends and receives one message at a time, eitherc synchronously or asynchronously. it uses a minimum of system resourcesc f = complex input arrayc g = complex output arrayc s, t = complex scratch arraysc nx/ny = number of points in x/yc kstrt = starting data block numberc nxv/nyv = first dimension of f/gc kypd/kxpd = second dimension of f/gc kxp/kyp = number of data values per block in x/yc jblok/kblok = number of data blocks in x/y      implicit none      integer nx, ny, kstrt, nxv, nyv, kxp, kyp, kxpd, kypd      integer jblok, kblok      complex f, g, s, t      dimension f(nxv,kypd,kblok), g(nyv,kxpd,jblok)      dimension s(kxp,kyp,kblok), t(kxp,kyp,jblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=10)c lgrp = current communicatorc mcplx = default datatype for complex      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer ks, kxb, kyb      integer jkblok, kxym, mtr, ntr, mntr      integer l, i, joff, koff, k, j      integer ir0, is0, ii, ir, is, ierr, msid, istatus      dimension istatus(lstat)      ks = kstrt - 2      kxb = nx/kxp      kyb = ny/kypc this segment is used for shared memory computersc     if (kstrt.gt.nx) returnc     do 40 l = 1, jblokc     joff = kxp*(l + ks)c     do 30 i = 1, kybc     koff = kyp*(i - 1)c     do 20 k = 1, kypc     do 10 j = 1, kxpc     g(k+koff,j,l) = f(j+joff,k,i)c  10 continuec  20 continuec  30 continuec  40 continuec this segment is used for mpi computers      jkblok = max0(jblok,kblok)      kxym = min0(kxb,kyb)      mtr = kyb/kxym      ntr = kxb/kxym      mntr = max0(mtr,ntr)      do 70 l = 1, jkblok      do 60 i = 1, kxym      ir0 = iand(kxym-1,ieor(l+ks,i-1)) + 1      is0 = ir0      do 50 ii = 1, mntrc post receive      if ((kstrt.le.nx).and.(ii.le.mtr)) then         ir = ir0 + kxym*(ii - 1)         call MPI_IRECV(t(1,1,l),kxp*kyp,mcplx,ir-1,ir+kxym+1,lgrp,msid,     1ierr)      endifc send data      if ((kstrt.le.ny).and.(ii.le.ntr)) then         is = is0 + kxym*(ii - 1)         joff = kxp*(is - 1)         do 20 k = 1, kyp         do 10 j = 1, kxp         s(j,k,l) = f(j+joff,k,l)   10    continue   20    continue         call MPI_SEND(s(1,1,l),kxp*kyp,mcplx,is-1,l+ks+kxym+2,lgrp,ierr     1)      endifc receive data      if ((kstrt.le.nx).and.(ii.le.mtr)) then         koff = kyp*(ir - 1)         call MPI_WAIT(msid,istatus,ierr)         do 40 k = 1, kyp         do 30 j = 1, kxp         g(k+koff,j,l) = t(j,k,l)   30    continue   40    continue      endif   50 continue   60 continue   70 continue      return      endc-----------------------------------------------------------------------      subroutine PDBLSIN2D(q,q2,nx,ny,kstrt,nxv,kyp,kypd,kyp2,kblok,k2bl     1ok)c this subroutine creates an odd array q2 from an array q, so thatc a 2d sine transform can be performed with a 2d real to complex fft.c linear interpolation for distributed datac q2 array may be modifiedc nx/ny = system length in x/y directionc kstrt = starting data block numberc nxv = first dimension of input array q, must be >= nx+1c kyp = number of data values per block in yc kypd = second dimension of input array q, must be >= kyp+1c kyp2 = second dimension of output array q2, must be >= kyp2c kblok = number of data blocks in yc k2blok = number of data blocks in y for doubled data      implicit none      real q, q2      integer nx, ny, kstrt, nxv, kyp, kypd, kyp2, kblok, k2blok      dimension q(nxv,kypd,kblok), q2(2*nxv,kyp2,k2blok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=10)c lgrp = current communicatorc mreal = default datatype for reals      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer istatus, lsid, msid, nsid, ierr      integer j, k, l, nxs, nys, ny2, kyb, kyb2, ks, koff, moff      integer kk, ll, lm, k1, k2, joff      dimension istatus(lstat)      nxs = nx - 1      nys = ny - 1      kyb = ny/kyp      ny2 = ny + ny      kyb2 = ny2/kyp2      ks = kstrt - 2      moff = kypd + kybc copy to double array in x direction      do 80 l = 1, k2blok      koff = kyp2*(l + ks)      ll = koff/kyp + 1      koff = kyp*(l + ks)      lm = koff/kyp2 + 1c special case for one processor      if (kyb2.eq.1) then         do 20 k = 1, nys         do 10 j = 1, nxs         q2(j+1,k+1,l) = q(j+1,k+1,l)         q2(nx+j+1,k+1,l) = -q(nx-j+1,k+1,l)         q2(j+1,ny+k+1,l) = -q(j+1,ny-k+1,l)         q2(nx+j+1,ny+k+1,l) = q(nx-j+1,ny-k+1,l)   10    continue         q2(1,k+1,l) = 0.         q2(nx+1,k+1,l) = 0.         q2(1,k+ny+1,l) = 0.         q2(nx+1,k+ny+1,l) = 0.   20    continue         do 30 j = 1, nx         q2(j,1,l) = 0.         q2(j+nx,1,l) = 0.         q2(j,ny+1,l) = 0.         q2(j+nx,ny+1,l) = 0.   30    continue         return      endifc this segment is used for shared memory computersc     if (ll.le.kyb) thenc        do 50 k = 1, kypc        do 40 j = 1, nxc        q2(j,k,l) = q(j,k,ll)c  40    continuec  50    continuec        if (kyp.lt.kyp2) thenc           do 70 k = 1, kypc           do 60 j = 1, nxc           q2(j,k+kyp,l) = q(j,k,ll+1)c  60       continuec  70       continuec        endifc     endifc this segment is used for mpi computers      if (ll.le.kyb) then         call MPI_IRECV(q2(1,1,l),kyp*nxv,mreal,ll-1,moff+1,lgrp,msid,ie     1rr)         if (kyp.lt.kyp2) then            call MPI_IRECV(q2(1,kyp+1,l),kyp*nxv,mreal,ll,moff+1,lgrp,ns     1id,ierr)         endif      endif      if (lm.le.(kyb2/2)) then         call MPI_SEND(q(1,1,l),kyp*nxv,mreal,lm-1,moff+1,lgrp,ierr)      endifc wait for data and unpack it      if (ll.le.kyb) then         call MPI_WAIT(msid,istatus,ierr)         do 50 k = 2, kyp         k1 = kyp - k + 2         k2 = (k1 - 1)/2 + 1         joff = nxv*(k1 - 2*k2 + 1)         do 40 j = 1, nxv         q2(j,k1,l) = q2(j+joff,k2,l)   40    continue   50    continue         if (kyp.lt.kyp2) then            call MPI_WAIT(nsid,istatus,ierr)            do 70 k = 2, kyp            k1 = kyp - k + 2            k2 = (k1 - 1)/2 + 1            joff = nxv*(k1 - 2*k2 + 1)            do 60 j = 1, nxv            q2(j,k1+kyp,l) = q2(j+joff,k2+kyp,l)   60       continue   70       continue         endif      endif   80 continuec copy to double array in y direction      do 140 l = 1, k2blok      koff = kyp2*(l + ks)      ll = (ny2 - koff - 1)/kyp + 1      koff = kyp*(l + ks)      lm = (ny2 - koff - 1)/kyp2 + 1      koff = koff + kyp2*lm - ny2c this segment is used for shared memory computersc     if (ll.le.kyb) thenc        if ((ll+1).le.kyb) thenc           do 90 j = 1, nxc           q2(j,1,l) = q(j,1,ll+1)c  90       continuec        endifc        if (kyp.lt.kyp2) thenc           do 110 k = 1, kypc           do 100 j = 1, nxc           q2(j,k+kyp,l) = q(j,k,ll)c 100       continuec 110       continuec        endifc        if (kyp.gt.1) thenc           do 130 k = 2, kypc           do 120 j = 1, nxc           q2(j,k,l) = q(j,k,ll-1)c 120       continuec 130       continuec        endifc     endifc this segment is used for mpi computers      if (ll.le.kyb) then         if ((ll+1).le.kyb) then            call MPI_IRECV(q2(1,1,l),nxv,mreal,ll,moff+2,lgrp,lsid,ierr)         endif         if (kyp.lt.kyp2) then            call MPI_IRECV(q2(1,kyp+1,l),kyp*nxv,mreal,ll-1,moff+2,lgrp,     1msid,ierr)         endif         if (kyp.gt.1) then            call MPI_IRECV(q2(1,2,l),(kyp-1)*nxv,mreal,ll-2,moff+2,lgrp,     1nsid,ierr)         endif      endif      if ((lm.gt.(kyb2/2)).and.(lm.le.kyb2)) then         if (koff.eq.0) then            if ((lm+1).le.kyb2) then               call MPI_SEND(q(1,1,l),nxv,mreal,lm,moff+2,lgrp,ierr)            endif            if (kyp.gt.1) then               call MPI_SEND(q(1,2,l),(kyp-1)*nxv,mreal,lm-1,moff+2,lgrp     1,ierr)            endif         else            call MPI_SEND(q(1,1,l),kyp*nxv,mreal,lm-1,moff+2,lgrp,ierr)         endif      endifc wait for data and unpack it      if (ll.le.kyb) then         if ((ll+1).le.kyb) then            call MPI_WAIT(lsid,istatus,ierr)         endif         if (kyp.lt.kyp2) then            call MPI_WAIT(msid,istatus,ierr)            do 100 k = 2, kyp            k1 = kyp - k + 2            k2 = (k1 - 1)/2 + 1            joff = nxv*(k1 - 2*k2 + 1)            do 90 j = 1, nxv            q2(j,k1+kyp,l) = q2(j+joff,k2+kyp,l)   90       continue  100       continue         endif         if (kyp.gt.1) then            call MPI_WAIT(nsid,istatus,ierr)            do 120 k = 3, kyp            k1 = kyp - k + 3            k2 = k1/2 + 1            joff = nxv*(k1 - 2*k2 + 2)            do 110 j = 1, nxv            q2(j,k1,l) = q2(j+joff,k2,l)  110       continue  120       continue         endif      endif  140 continuec create odd array      do 200 l = 1, k2blok      koff = kyp2*(l + ks)      do 190 k = 1, kyp2      kk = k + koff      if ((kk.eq.1).or.(kk.eq.(ny+1))) then         do 150 j = 1, nx         q2(j,k,l) = 0.         q2(j+nx,k,l) = 0.  150    continue      else if (kk.le.ny) then         do 160 j = 1, nxs         q2(nx+j+1,k,l) = -q2(nx-j+1,k,l)  160    continue         q2(1,k,l) = 0.         q2(nx+1,k,l) = 0.      else if (kk.gt.(ny+1)) then         if (k.eq.1) then            do 170 j = 1, nxs            q2(nx+j+1,k,l) = q2(nx-j+1,k,l)  170       continue         else            do 180 j = 1, nxs            q2(nx+j+1,kyp2-k+2,l) = q2(nx-j+1,k,l)  180       continue         endif         q2(1,k,l) = 0.         q2(nx+1,k,l) = 0.      endif  190 continue  200 continuec finish odd array      do 230 l = 1, k2blok      koff = kyp2*(l + ks)      do 220 k = 1, kyp2      kk = k + koff      if (kk.gt.(ny+1)) then         do 210 j = 1, nxs         q2(nx-j+1,k,l) = -q2(nx+j+1,k,l)  210    continue         q2(nx+1,k,l) = -q2(nx+1,k,l)      endif  220 continue  230 continue      return      endc-----------------------------------------------------------------------      subroutine PDBLCOS2D(q,q2,nx,ny,kstrt,nxv,kyp,kypd,kyp2,kblok,k2bl     1ok)c this subroutine creates an even array q2 from an array q, so thatc a 2d cosine transform can be performed with a 2d real to complex fft.c linear interpolation for distributed datac q2 array may be modifiedc nx/ny = system length in x/y directionc kstrt = starting data block numberc nxv = first dimension of input array q, must be >= nx+1c kyp = number of data values per block in yc kypd = second dimension of input array q, must be >= kyp+1c kyp2 = second dimension of output array q2, must be >= kyp2c kblok = number of data blocks in yc k2blok = number of data blocks in y for doubled data      implicit none      real q, q2      integer nx, ny, kstrt, nxv, kyp, kypd, kyp2, kblok, k2blok      dimension q(nxv,kypd,kblok), q2(2*nxv,kyp2,k2blok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=10)c lgrp = current communicatorc mreal = default datatype for reals      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer istatus, lsid, msid, nsid, ierr      integer j, k, l, nxs, nys, ny2, kyb, kyb2, ks, koff, moff      integer kk, ll, lm, k1, k2, joff      real at1, at2      dimension istatus(lstat)      nxs = nx - 1      nys = ny - 1      kyb = ny/kyp      ny2 = ny + ny      kyb2 = ny2/kyp2      ks = kstrt - 2      moff = kypd + kybc copy to double array in x direction      do 80 l = 1, k2blok      koff = kyp2*(l + ks)      ll = koff/kyp + 1      koff = kyp*(l + ks)      lm = koff/kyp2 + 1c special case for one processor      if (kyb2.eq.1) then         do 20 k = 1, nys         do 10 j = 1, nxs         q2(j+1,k+1,l) = q(j+1,k+1,l)         q2(nx+j+1,k+1,l) = q(nx-j+1,k+1,l)         q2(j+1,ny+k+1,l) = q(j+1,ny-k+1,l)         q2(nx+j+1,ny+k+1,l) = q(nx-j+1,ny-k+1,l)   10    continue         q2(1,k+1,l) = q(1,k+1,l)         q2(nx+1,k+1,l) = q(nx+1,k+1,l)         q2(1,k+ny+1,l) = q(1,ny-k+1,l)         q2(nx+1,k+ny+1,l) = q(nx+1,ny-k+1,l)   20    continue         do 30 j = 1, nxs         q2(j+1,1,l) = q(j+1,1,l)         q2(j+nx+1,1,l) = q(nx-j+1,1,l)         q2(j+1,ny+1,l) = q(j+1,ny+1,l)         q2(j+nx+1,ny+1,l) = q(nx-j+1,ny+1,l)   30    continue         q2(1,1,l) = q(1,1,l)         q2(nx+1,1,l) = q(nx+1,1,l)         q2(1,ny+1,l) = q(1,ny+1,l)         q2(nx+1,ny+1,l) = q(nx+1,ny+1,l)         return      endifc this segment is used for shared memory computersc     if (ll.le.kyb) thenc        do 50 k = 1, kypc        do 40 j = 1, nxc        q2(j,k,l) = q(j,k,ll)c  40    continuec  50    continuec        if (kyp.lt.kyp2) thenc           do 70 k = 1, kypc           do 60 j = 1, nxc           q2(j,k+kyp,l) = q(j,k,ll+1)c  60       continuec  70       continuec        endifc     endifc this segment is used for mpi computers      if (ll.le.kyb) then         call MPI_IRECV(q2(1,1,l),kyp*nxv,mreal,ll-1,moff+1,lgrp,msid,ie     1rr)         if (kyp.lt.kyp2) then            call MPI_IRECV(q2(1,kyp+1,l),kyp*nxv,mreal,ll,moff+1,lgrp,ns     1id,ierr)         endif      endif      if (lm.le.(kyb2/2)) then         call MPI_SEND(q(1,1,l),kyp*nxv,mreal,lm-1,moff+1,lgrp,ierr)      endifc wait for data and unpack it      if (ll.le.kyb) then         call MPI_WAIT(msid,istatus,ierr)         do 50 k = 2, kyp         k1 = kyp - k + 2         k2 = (k1 - 1)/2 + 1         joff = nxv*(k1 - 2*k2 + 1)         do 40 j = 1, nxv         q2(j,k1,l) = q2(j+joff,k2,l)   40    continue   50    continue         if (kyp.lt.kyp2) then            call MPI_WAIT(nsid,istatus,ierr)            do 70 k = 2, kyp            k1 = kyp - k + 2            k2 = (k1 - 1)/2 + 1            joff = nxv*(k1 - 2*k2 + 1)            do 60 j = 1, nxv            q2(j,k1+kyp,l) = q2(j+joff,k2+kyp,l)   60       continue   70       continue         endif      endif   80 continuec copy to double array in y direction      do 140 l = 1, k2blok      koff = kyp2*(l + ks)      ll = (ny2 - koff - 1)/kyp + 1      koff = kyp*(l + ks)      lm = (ny2 - koff - 1)/kyp2 + 1      koff = koff + kyp2*lm - ny2c this segment is used for shared memory computersc     if (ll.le.kyb) thenc        if ((ll+1).le.kyb) thenc           do 90 j = 1, nxc           q2(j,1,l) = q(j,1,ll+1)c  90       continuec        endifc        if (kyp.lt.kyp2) thenc           do 110 k = 1, kypc           do 100 j = 1, nxc           q2(j,k+kyp,l) = q(j,k,ll)c 100       continuec 110       continuec        endifc        if (kyp.gt.1) thenc           do 130 k = 2, kypc           do 120 j = 1, nxc           q2(j,k,l) = q(j,k,ll-1)c 120       continuec 130       continuec        endifc     endifc ny+1 point is specialc     if (kyp2*(l+ks).eq.ny) thenc        do 135 j = 1, nx+1c        q2(j,1,l) = q(j,kyp+1,kyb)c 135    continuec     endifc this segment is used for mpi computers      if (ll.le.kyb) then         if ((ll+1).le.kyb) then            call MPI_IRECV(q2(1,1,l),nxv,mreal,ll,moff+2,lgrp,lsid,ierr)         endif         if (kyp.lt.kyp2) then            call MPI_IRECV(q2(1,kyp+1,l),kyp*nxv,mreal,ll-1,moff+2,lgrp,     1msid,ierr)         endif         if (kyp.gt.1) then            call MPI_IRECV(q2(1,2,l),(kyp-1)*nxv,mreal,ll-2,moff+2,lgrp,     1nsid,ierr)         endif      endif      if ((lm.gt.(kyb2/2)).and.(lm.le.kyb2)) then         if (koff.eq.0) then            if ((lm+1).le.kyb2) then               call MPI_SEND(q(1,1,l),nxv,mreal,lm,moff+2,lgrp,ierr)            endif            if (kyp.gt.1) then               call MPI_SEND(q(1,2,l),(kyp-1)*nxv,mreal,lm-1,moff+2,lgrp     1,ierr)            endif         else            call MPI_SEND(q(1,1,l),kyp*nxv,mreal,lm-1,moff+2,lgrp,ierr)         endif      endifc wait for data and unpack it      if (ll.le.kyb) then         if ((ll+1).le.kyb) then            call MPI_WAIT(lsid,istatus,ierr)         endif         if (kyp.lt.kyp2) then            call MPI_WAIT(msid,istatus,ierr)            do 100 k = 2, kyp            k1 = kyp - k + 2            k2 = (k1 - 1)/2 + 1            joff = nxv*(k1 - 2*k2 + 1)            do 90 j = 1, nxv            q2(j,k1+kyp,l) = q2(j+joff,k2+kyp,l)   90       continue  100       continue         endif         if (kyp.gt.1) then            call MPI_WAIT(nsid,istatus,ierr)            do 120 k = 3, kyp            k1 = kyp - k + 3            k2 = k1/2 + 1            joff = nxv*(k1 - 2*k2 + 2)            do 110 j = 1, nxv            q2(j,k1,l) = q2(j+joff,k2,l)  110       continue  120       continue         endif      endifc ny+1 point is special      if (kyp2*(l+ks).eq.ny) then         call MPI_IRECV(q2(1,1,l),nxv,mreal,kyb-1,moff+3,lgrp,msid,ierr)      endif      if (kyp*(l+ks+1).eq.ny) then         kk = ny/kyp2         call MPI_SEND(q(1,kyp+1,l),nxv,mreal,kk,moff+3,lgrp,ierr)      endif      if (kyp2*(l+ks).eq.ny) then         call MPI_WAIT(msid,istatus,ierr)      endif  140 continuec create even array      do 200 l = 1, k2blok      koff = kyp2*(l + ks)      do 190 k = 1, kyp2      kk = k + koff      if ((kk.eq.1).or.(kk.eq.(ny+1))) then         do 150 j = 1, nxs         q2(j+1,k,l) = q2(j+1,k,l)         q2(j+nx+1,k,l) = q2(nx-j+1,k,l)  150    continue         q2(1,k,l) = q2(1,k,l)         q2(nx+1,k,l) = q2(nx+1,k,l)      else if (kk.le.ny) then         do 160 j = 1, nxs         q2(nx+j+1,k,l) = q2(nx-j+1,k,l)  160    continue         q2(1,k,l) = q2(1,k,l)         q2(nx+1,k,l) = q2(nx+1,k,l)      else if (kk.gt.(ny+1)) then         if (k.eq.1) then            do 170 j = 1, nxs            q2(nx+j+1,k,l) = q2(nx-j+1,k,l)  170       continue            q2(1,k,l) = q2(1,k,l)            q2(nx+1,k,l) = q2(nx+1,k,l)         else            do 180 j = 1, nxs            q2(nx+j+1,kyp2-k+2,l) = q2(nx-j+1,k,l)  180       continue            if (k.le.(kyp2/2+1)) then               at1 = q2(1,kyp2-k+2,l)               at2 = q2(nx+1,kyp2-k+2,l)               q2(1,kyp2-k+2,l) = q2(1,k,l)               q2(nx+1,kyp2-k+2,l) = q2(nx+1,k,l)               q2(1,k,l) = at1               q2(nx+1,k,l) = at2            endif         endif      endif  190 continue  200 continuec finish even array      do 230 l = 1, k2blok      koff = kyp2*(l + ks)      do 220 k = 1, kyp2      kk = k + koff      if (kk.gt.(ny+1)) then         do 210 j = 1, nxs         q2(nx-j+1,k,l) = q2(nx+j+1,k,l)  210    continue      endif  220 continue  230 continue      return      endc-----------------------------------------------------------------------      subroutine PDBLSIN2B(cu,cu2,nx,ny,kstrt,nxv,kyp,kypd,kyp2,kblok,k2     1blok)c this subroutine creates a doubled vector array cu2 from a vector arrayc cu, so that various 2d sine/cosine transforms can be performed with ac 2d real to complex fft.  the x component is an odd function in y,c y component is an odd function in x, and the z component is an oddc function in both x and y.c linear interpolation for distributed datac cu2 array may be modifiedc nx/ny = system length in x/y directionc kstrt = starting data block numberc nxv = first dimension of input array q, must be >= nx+1c kyp = number of data values per block in yc kypd = second dimension of input array q, must be >= kyp+1c kyp2 = second dimension of output array q2, must be >= kyp2c kblok = number of data blocks in yc k2blok = number of data blocks in y for doubled data      implicit none      real cu, cu2      integer nx, ny, kstrt, nxv, kyp, kypd, kyp2, kblok, k2blok      dimension cu(3,nxv,kypd,kblok), cu2(3,2*nxv,kyp2,k2blok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=10)c lgrp = current communicatorc mreal = default datatype for reals      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer istatus, lsid, msid, nsid, ierr      integer i, j, k, l, nxs, nys, ny2, kyb, kyb2, ks, koff, moff      integer kk, ll, lm, k1, k2, joff      real at1, at2      dimension istatus(lstat)      nxs = nx - 1      nys = ny - 1      kyb = ny/kyp      ny2 = ny + ny      kyb2 = ny2/kyp2      ks = kstrt - 2      moff = kypd + kybc copy to double array in x direction      do 80 l = 1, k2blok      koff = kyp2*(l + ks)      ll = koff/kyp + 1      koff = kyp*(l + ks)      lm = koff/kyp2 + 1c special case for one processor      if (kyb2.eq.1) then         do 20 k = 1, nys         do 10 j = 1, nxs         cu2(1,j+1,k+1,l) = cu(1,j+1,k+1,l)         cu2(2,j+1,k+1,l) = cu(2,j+1,k+1,l)         cu2(3,j+1,k+1,l) = cu(3,j+1,k+1,l)         cu2(1,nx+j+1,k+1,l) = cu(1,nx-j+1,k+1,l)         cu2(2,nx+j+1,k+1,l) = -cu(2,nx-j+1,k+1,l)         cu2(3,nx+j+1,k+1,l) = -cu(3,nx-j+1,k+1,l)         cu2(1,j+1,ny+k+1,l) = -cu(1,j+1,ny-k+1,l)         cu2(2,j+1,ny+k+1,l) = cu(2,j+1,ny-k+1,l)         cu2(3,j+1,ny+k+1,l) = -cu(3,j+1,ny-k+1,l)         cu2(1,nx+j+1,ny+k+1,l) = -cu(1,nx-j+1,ny-k+1,l)         cu2(2,nx+j+1,ny+k+1,l) = -cu(2,nx-j+1,ny-k+1,l)         cu2(3,nx+j+1,ny+k+1,l) = cu(3,nx-j+1,ny-k+1,l)   10    continue         cu2(1,1,k+1,l) = cu(1,1,k+1,l)         cu2(2,1,k+1,l) = 0.         cu2(3,1,k+1,l) = 0.         cu2(1,nx+1,k+1,l) = cu(1,nx+1,k+1,l)         cu2(2,nx+1,k+1,l) = 0.         cu2(3,nx+1,k+1,l) = 0.         cu2(1,1,k+ny+1,l) = -cu(1,1,ny-k+1,l)         cu2(2,1,k+ny+1,l) = 0.         cu2(3,1,k+ny+1,l) = 0.         cu2(1,nx+1,k+ny+1,l) = -cu(1,nx+1,ny-k+1,l)         cu2(2,nx+1,k+ny+1,l) = 0.         cu2(3,nx+1,k+ny+1,l) = 0.   20    continue         do 30 j = 1, nxs         cu2(1,j+1,1,l) = 0.         cu2(2,j+1,1,l) = cu(2,j+1,1,l)         cu2(3,j+1,1,l) = 0.         cu2(1,j+nx+1,1,l) = 0.         cu2(2,j+nx+1,1,l) = -cu(2,nx-j+1,1,l)         cu2(3,j+nx+1,1,l) = 0.         cu2(1,j+1,ny+1,l) = 0.         cu2(2,j+1,ny+1,l) = cu(2,j+1,ny+1,l)         cu2(3,j+1,ny+1,l) = 0.         cu2(1,j+nx+1,ny+1,l) = 0.         cu2(2,j+nx+1,ny+1,l) = -cu(2,nx-j+1,ny+1,l)         cu2(3,j+nx+1,ny+1,l) = 0.   30    continue         cu2(1,1,1,l) = 0.         cu2(2,1,1,l) = 0.         cu2(3,1,1,l) = 0.         cu2(1,nx+1,1,l) = 0.         cu2(2,nx+1,1,l) = 0.         cu2(3,nx+1,1,l) = 0.         cu2(1,1,ny+1,l) = 0.         cu2(2,1,ny+1,l) = 0.         cu2(3,1,ny+1,l) = 0.         cu2(1,nx+1,ny+1,l) = 0.         cu2(2,nx+1,ny+1,l) = 0.         cu2(3,nx+1,ny+1,l) = 0.         return      endifc this segment is used for shared memory computersc     if (ll.le.kyb) thenc        do 50 k = 1, kypc        do 40 j = 1, nx+1c        do 35 i = 1, 3c        cu2(i,j,k,l) = cu(i,j,k,ll)c  35    continuec  40    continuec  50    continuec        if (kyp.lt.kyp2) thenc           do 70 k = 1, kypc           do 60 j = 1, nx+1c           do 55 i = 1, 3c           cu2(i,j,k+kyp,l) = cu(i,j,k,ll+1)c  55       continuec  60       continuec  70       continuec        endifc     endifc this segment is used for mpi computers      if (ll.le.kyb) then         call MPI_IRECV(cu2(1,1,1,l),3*kyp*nxv,mreal,ll-1,moff+1,lgrp,ms     1id,ierr)         if (kyp.lt.kyp2) then            call MPI_IRECV(cu2(1,1,kyp+1,l),3*kyp*nxv,mreal,ll,moff+1,lg     1rp,nsid,ierr)         endif      endif      if (lm.le.(kyb2/2)) then         call MPI_SEND(cu(1,1,1,l),3*kyp*nxv,mreal,lm-1,moff+1,lgrp,ierr     1)      endifc wait for data and unpack it      if (ll.le.kyb) then         call MPI_WAIT(msid,istatus,ierr)         do 50 k = 2, kyp         k1 = kyp - k + 2         k2 = (k1 - 1)/2 + 1         joff = nxv*(k1 - 2*k2 + 1)         do 40 j = 1, nxv         do 35 i = 1, 3         cu2(i,j,k1,l) = cu2(i,j+joff,k2,l)   35    continue   40    continue   50    continue         if (kyp.lt.kyp2) then            call MPI_WAIT(nsid,istatus,ierr)            do 70 k = 2, kyp            k1 = kyp - k + 2            k2 = (k1 - 1)/2 + 1            joff = nxv*(k1 - 2*k2 + 1)            do 60 j = 1, nxv            do 55 i = 1, 3            cu2(i,j,k1+kyp,l) = cu2(i,j+joff,k2+kyp,l)   55       continue   60       continue   70       continue         endif      endif   80 continuec copy to double array in y direction      do 140 l = 1, k2blok      koff = kyp2*(l + ks)      ll = (ny2 - koff - 1)/kyp + 1      koff = kyp*(l + ks)      lm = (ny2 - koff - 1)/kyp2 + 1      koff = koff + kyp2*lm - ny2c this segment is used for shared memory computersc     if (ll.le.kyb) thenc        if ((ll+1).le.kyb) thenc           do 90 j = 1, nx+1c           do 85 i = 1, 3c           cu2(i,j,1,l) = cu(i,j,1,ll+1)c  85       continuec  90       continuec        endifc        if (kyp.lt.kyp2) thenc           do 110 k = 1, kypc           do 100 j = 1, nx+1c           do 95 i = 1, 3c           cu2(i,j,k+kyp,l) = cu(i,j,k,ll)c  95       continuec 100       continuec 110       continuec        endifc        if (kyp.gt.1) thenc           do 130 k = 2, kypc           do 120 j = 1, nx+1c           do 115 i = 1, 3c           cu2(i,j,k,l) = cu(i,j,k,ll-1)c 115       continuec 120       continuec 130       continuec        endifc     endifc ny+1 point is specialc     if (kyp2*(l+ks).eq.ny) thenc        do 136 j = 1, nx+1c        do 135 i = 1, 3c        cu2(i,j,1,l) = cu(i,j,kyp+1,kyb)c 135    continuec 136    continuec     endifc this segment is used for mpi computers      if (ll.le.kyb) then         if ((ll+1).le.kyb) then            call MPI_IRECV(cu2(1,1,1,l),3*nxv,mreal,ll,moff+2,lgrp,lsid,     1ierr)         endif         if (kyp.lt.kyp2) then            call MPI_IRECV(cu2(1,1,kyp+1,l),3*kyp*nxv,mreal,ll-1,moff+2,     1lgrp,msid,ierr)         endif         if (kyp.gt.1) then            call MPI_IRECV(cu2(1,1,2,l),3*(kyp-1)*nxv,mreal,ll-2,moff+2,     1lgrp,nsid,ierr)         endif      endif      if ((lm.gt.(kyb2/2)).and.(lm.le.kyb2)) then         if (koff.eq.0) then            if ((lm+1).le.kyb2) then               call MPI_SEND(cu(1,1,1,l),3*nxv,mreal,lm,moff+2,lgrp,ierr     1)            endif            if (kyp.gt.1) then               call MPI_SEND(cu(1,1,2,l),3*(kyp-1)*nxv,mreal,lm-1,moff+2     1,lgrp,ierr)            endif         else            call MPI_SEND(cu(1,1,1,l),3*kyp*nxv,mreal,lm-1,moff+2,lgrp,i     1err)         endif      endifc wait for data and unpack it      if (ll.le.kyb) then         if ((ll+1).le.kyb) then            call MPI_WAIT(lsid,istatus,ierr)         endif         if (kyp.lt.kyp2) then            call MPI_WAIT(msid,istatus,ierr)            do 100 k = 2, kyp            k1 = kyp - k + 2            k2 = (k1 - 1)/2 + 1            joff = nxv*(k1 - 2*k2 + 1)            do 90 j = 1, nxv            do 85 i = 1, 3            cu2(i,j,k1+kyp,l) = cu2(i,j+joff,k2+kyp,l)   85       continue   90       continue  100       continue         endif         if (kyp.gt.1) then            call MPI_WAIT(nsid,istatus,ierr)            do 120 k = 3, kyp            k1 = kyp - k + 3            k2 = k1/2 + 1            joff = nxv*(k1 - 2*k2 + 2)            do 110 j = 1, nxv            do 105 i = 1, 3            cu2(i,j,k1,l) = cu2(i,j+joff,k2,l)  105       continue  110       continue  120       continue         endif      endifc ny+1 point is special      if (kyp2*(l+ks).eq.ny) then         call MPI_IRECV(cu2(1,1,1,l),3*nxv,mreal,kyb-1,moff+3,lgrp,msid,     1ierr)      endif      if (kyp*(l+ks+1).eq.ny) then         kk = ny/kyp2         call MPI_SEND(cu(1,1,kyp+1,l),3*nxv,mreal,kk,moff+3,lgrp,ierr)      endif      if (kyp2*(l+ks).eq.ny) then         call MPI_WAIT(msid,istatus,ierr)      endif  140 continuec create odd array      do 200 l = 1, k2blok      koff = kyp2*(l + ks)      do 190 k = 1, kyp2      kk = k + koff      if ((kk.eq.1).or.(kk.eq.(ny+1))) then         do 150 j = 1, nxs         cu2(1,j+1,k,l) = 0.         cu2(2,j+1,k,l) = cu2(2,j+1,k,l)         cu2(3,j+1,k,l) = 0.         cu2(1,j+nx+1,k,l) = 0.         cu2(2,j+nx+1,k,l) = -cu2(2,nx-j+1,k,l)         cu2(3,j+nx+1,k,l) = 0.  150    continue         cu2(1,1,k,l) = 0.         cu2(2,1,k,l) = 0.         cu2(3,1,k,l) = 0.         cu2(1,nx+1,k,l) = 0.         cu2(2,nx+1,k,l) = 0.         cu2(3,nx+1,k,l) = 0.      else if (kk.le.ny) then         do 160 j = 1, nxs         cu2(1,nx+j+1,k,l) = cu2(1,nx-j+1,k,l)         cu2(2,nx+j+1,k,l) = -cu2(2,nx-j+1,k,l)         cu2(3,nx+j+1,k,l) = -cu2(3,nx-j+1,k,l)  160    continue         cu2(1,1,k,l) = cu2(1,1,k,l)         cu2(2,1,k,l) = 0.         cu2(3,1,k,l) = 0.         cu2(1,nx+1,k,l) = cu2(1,nx+1,k,l)         cu2(2,nx+1,k,l) = 0.         cu2(3,nx+1,k,l) = 0.      else if (kk.gt.(ny+1)) then         if (k.eq.1) then            do 170 j = 1, nxs            cu2(1,nx+j+1,k,l) = -cu2(1,nx-j+1,k,l)            cu2(2,nx+j+1,k,l) = -cu2(2,nx-j+1,k,l)            cu2(3,nx+j+1,k,l) = cu2(3,nx-j+1,k,l)  170       continue            cu2(1,1,k,l) = -cu2(1,1,k,l)            cu2(2,1,k,l) = 0.            cu2(3,1,k,l) = 0.            cu2(1,nx+1,k,l) = -cu2(1,nx+1,k,l)            cu2(2,nx+1,k,l) = 0.            cu2(3,nx+1,k,l) = 0.         else            do 180 j = 1, nxs            cu2(1,nx+j+1,kyp2-k+2,l) = -cu2(1,nx-j+1,k,l)            cu2(2,nx+j+1,kyp2-k+2,l) = -cu2(2,nx-j+1,k,l)            cu2(3,nx+j+1,kyp2-k+2,l) = cu2(3,nx-j+1,k,l)  180       continue            if (k.le.(kyp2/2+1)) then               at1 = -cu2(1,1,kyp2-k+2,l)               at2 = -cu2(1,nx+1,kyp2-k+2,l)               cu2(1,1,kyp2-k+2,l) = -cu2(1,1,k,l)               cu2(1,nx+1,kyp2-k+2,l) = -cu2(1,nx+1,k,l)               cu2(1,1,k,l) = at1               cu2(1,nx+1,k,l) = at2            endif            cu2(2,1,kyp2-k+2,l) = 0.            cu2(3,1,kyp2-k+2,l) = 0.            cu2(2,nx+1,kyp2-k+2,l) = 0.            cu2(3,nx+1,kyp2-k+2,l) = 0.         endif      endif  190 continue  200 continuec finish odd array      do 230 l = 1, k2blok      koff = kyp2*(l + ks)      do 220 k = 1, kyp2      kk = k + koff      if (kk.gt.(ny+1)) then         do 210 j = 1, nxs         cu2(1,nx-j+1,k,l) = cu2(1,nx+j+1,k,l)         cu2(2,nx-j+1,k,l) = -cu2(2,nx+j+1,k,l)         cu2(3,nx-j+1,k,l) = -cu2(3,nx+j+1,k,l)  210    continue      endif  220 continue  230 continue      return      end