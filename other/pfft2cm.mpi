cat > pfft2cm.f <<EOF      program pfft2cmc indnvp = exponent which determines number of virtual processorsc mshare = (0,1) = (no,yes) architecture is shared memory      parameter( indx =   7, indy =   8, indnvp =   2, mshare =   0)      parameter(nx=2**indx,ny=2**indy)      parameter(nvp=2**indnvp,kyp=(ny-1)/nvp+1,kxp=(nx-1)/nvp+1)      parameter(kblok=1+mshare*(ny/kyp-1),jblok=1+mshare*(nx/kxp-1))      parameter(nmx=nx*(ny/nx)+ny*(nx/ny),nxy=nmx/(2-nx/nmx-ny/nmx))      parameter(kxyp=(nxy-1)/nvp+1,jkblok=1+mshare*(nxy/kxyp-1))      parameter(kxb=nx/kxp,kyb=ny/kyp,kxyb=nxy/kxyp)      parameter(nxv=nx+2,nyv=ny+2,nxyh=nxy/2)      double precision ranorm      complex f, g, h, sct, ssct, s, t, u, v, buff, bbuff, sbuff      dimension f(nxv,kyp,kblok), s(nxv,kyp,kblok), t(nyv,kxp,jblok)      dimension u(kxp,ny,jblok), v(kyp,nx,kblok)c     dimension buff(kxp,jblok), bbuff(kxp,kyp,jkblok)c     dimension sbuff(kxp,kyp,kblok), msgn(kxyb)      dimension buff(kxp,jblok), bbuff(kxp,kyp,kyb,jkblok)      dimension sbuff(kxp,kyp,kxb,kblok), msgn(kxyb)      dimension g(nxv,ny), h(nyv,nx)      dimension mixup(nxy), sct(nxyh)      dimension mmixup(nxy), ssct(nxyh)c ntpose = (0,1) = (no,yes) input, output data are transposed in pfft2c      data ntpose /0/c initialize for parallel processing      call ppinit(idproc,nvp)      kstrt = idproc + 1      ks = kstrt - 2c prepare fft tables      isign = 0c     call pfft2c(f,t,sbuff,bbuff,isign,ntpose,mixup,sct,indx,indy,kstrtc    1,nxv,nyv,kxp,kyp,jblok,kblok,nxy,nxyh)      call pfft2cz(f,v,t,u,sbuff,bbuff,msgn,isign,ntpose,mixup,sct,indx,     1indy,kstrt,nx,ny,nxv,nyv,kxp,kyp,jblok,kblok,kxyb,nxy,nxyh)c     call pfft2cx(f,s,isign,mixup,sct,indx,indy,kstrt,nxv,kyp,kblok,nxyc    1,nxyh)      call fft2c(g,isign,mmixup,ssct,indx,indy,nxv,nyv,nxy,nxyh)c create test function      do 30 k = 1, ny      kk = (k - 1)/kyp      k1 = k - kyp*kk      do 20 j = 1, nx      at1 = ranorm(d)      at2 = ranorm(d)      g(j,k) = cmplx(at1,at2)      h(k,j) = g(j,k)      do 10 l = 1, kblok      if (kk.eq.(l+ks)) f(j,k1,l) = g(j,k)   10 continue   20 continue   30 continue      call timera(-1,'total   ',time)c start special test casec     isign = -1c     call pfft2c(f,t,sbuff,bbuff,isign,ntpose,mixup,sct,indx,indy,kstrtc    1,nxv,nyv,kxp,kyp,jblok,kblok,nxy,nxyh)c     call pfft2cz(f,v,t,u,sbuff,bbuff,msgn,isign,ntpose,mixup,sct,indx,c    1indy,kstrt,nx,ny,nxv,nyv,kxp,kyp,jblok,kblok,kxyb,nxy,nxyh)c     call ptposs(t,f,buff,ny,nx,kstrt,nyv,nxv,kyp,kxp,kblok,jblok)c     call pfft2cx(f,s,isign,mixup,sct,indx,indy,kstrt,nxv,kyp,kblok,nxyc    1,nxyh)      isign = 1c     call ptposs(f,t,buff,nx,ny,kstrt,nxv,nyv,kxp,kyp,jblok,kblok)c     call pfft2c(f,t,sbuff,bbuff,isign,ntpose,mixup,sct,indx,indy,kstrtc    1,nxv,nyv,kxp,kyp,jblok,kblok,nxy,nxyh)!     call pfft2cz(f,v,t,u,sbuff,bbuff,msgn,isign,ntpose,mixup,sct,indx,!    1indy,kstrt,nx,ny,nxv,nyv,kxp,kyp,jblok,kblok,kxyb,nxy,nxyh)c     call pfft2cx(f,s,isign,mixup,sct,indx,indy,kstrt,nxv,kyp,kblok,nxyc    1,nxyh)!     call fft2c(g,isign,mmixup,ssct,indx,indy,nxv,nyv,nxy,nxyh)c     call ptposs(f,t,buff,nx,ny,kstrt,nxv,nyv,kxp,kyp,jblok,kblok)c     call ptpose(f,t,sbuff,bbuff,nx,ny,kstrt,nxv,nyv,kxp,kyp,jblok,kbloc    1k)c     call ptposz(f,t,u,sbuff,msgn,nx,ny,kstrt,nxv,nyv,kxp,kyp,jblok,kblc    1ok,kyb)c     call ptposz(t,f,v,bbuff,msgn,ny,nx,kstrt,nyv,nxv,kyp,kxp,kblok,jblc    1ok,kxb)c      call matpose(f,t,sbuff,bbuff,nxv,nyv,kxp,kyp,kxb,kyb,jblok,kblok)      call matpose(t,f,bbuff,sbuff,nyv,nxv,kyp,kxp,kyb,kxb,kblok,jblok)cc     call mtpose(f,t,sbuff,bbuff,nxv,nyv,kxp,kyp,kblok)c     call mtpose(t,f,bbuff,sbuff,nyv,nxv,kyp,kxp,kblok)c end special test casec     do 40 i = 1, 100c transform to fourier spacec     isign = -1c     call pfft2c(f,t,sbuff,bbuff,isign,ntpose,mixup,sct,indx,indy,kstrtc    1,nxv,nyv,kxp,kyp,jblok,kblok,nxy,nxyh)c     call pfft2cz(f,v,t,u,sbuff,bbuff,msgn,isign,ntpose,mixup,sct,indx,c    1indy,kstrt,nx,ny,nxv,nyv,kxp,kyp,jblok,kblok,kxyb,nxy,nxyh)c     call pfft2cx(f,s,isign,mixup,sct,indx,indy,kstrt,nxv,kyp,kblok,nxyc    1,nxyh)c     call fft2c(g,isign,mixup,sct,indx,indy,nxv,nyv,nxy,nxyh)c     call ptposs(f,t,buff,nx,ny,kstrt,nxv,nyv,kxp,kyp,jblok,kblok)c transform to real spacec     isign = 1c     call pfft2c(f,t,sbuff,bbuff,isign,ntpose,mixup,sct,indx,indy,kstrtc    1,nxv,nyv,kxp,kyp,jblok,kblok,nxy,nxyh)c     call pfft2cz(f,v,t,u,sbuff,bbuff,msgn,isign,ntpose,mixup,sct,indx,c    1indy,kstrt,nx,ny,nxv,nyv,kxp,kyp,jblok,kblok,kxyb,nxy,nxyh)c     call pfft2cx(f,s,isign,mixup,sct,indx,indy,kstrt,nxv,kyp,kblok,nxyc    1,nxyh)c     call fft2c(g,isign,mixup,sct,indx,indy,nxv,nyv,nxy,nxyh)c     call ptposs(t,f,buff,ny,nx,kstrt,nyv,nxv,kyp,kxp,kblok,jblok)c  40 continue      call timera(1,'total   ',time)      sum1 = 0.      epsmax = 0.      if (kstrt.gt.ny) go to 80c     if (kstrt.gt.nx) go to 80      do 70 l = 1, kblokc     do 70 l = 1, jblok      koff = kyp*(l + ks)c     joff = kxp*(l + ks)      do 60 k = 1, kyp      k1 = k + koffc     do 60 k = 1, ny      do 50 j = 1, nxc     do 50 j = 1, kxpc     j1 = j + joff      eps = cabs(f(j,k,l) - g(j,k1))c     eps = cabs(t(k,j,l) - h(k,j1))      if (eps.gt.epsmax) then         write (6,*) j,k1,f(j,k,l)         write (6,*) j,k1,g(j,k1)c        write (6,*) j1,k,t(k,j,l)c        write (6,*) j1,k,h(k,j1)         epsmax = eps      endif      sum1 = sum1 + eps   50 continue   60 continue   70 continue   80 continuec     call psum (sum1,at1,1,1)      write (6,*) 'error=',sum1      call ppexit      stop      endc-----------------------------------------------------------------------      subroutine ppinit(idproc,nvp)c this subroutine initializes parallel processingc input: nvp, output: idprocc idproc = processor idc nvp = number of real or virtual processors requested      implicit none      integer idproc, nvpc get definition of MPI constants      include 'mpif.h'c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplxc lstat = length of status array      parameter(lstat=8)c nproc = number of real or virtual processors obtainedc lgrp = current communicatorc mreal = default datatype for realsc mint = default datatype for integersc mcplx = default datatype for complex type      common /pparms/ nproc, lgrp, mreal, mint, mcplxc local data      integer ierror, ndprec      save /pparms/c ndprec = (0,1) = (no,yes) use (normal,autodouble) precision      data ndprec /0/c this segment is used for shared memory computersc     nproc = nvpc     idproc = 0c this segment is used for mpi computers      if (MPI_STATUS_SIZE.gt.lstat) then         write (2,*) ' status size too small, actual/required = ', lstat     1, MPI_STATUS_SIZE         stop      endifc initialize the MPI execution environment      call MPI_INIT(ierror)      if (ierror.ne.0) stop      lgrp = MPI_COMM_WORLDc determine the rank of the calling process in the communicator      call MPI_COMM_RANK(lgrp,idproc,ierror)c determine the size of the group associated with a communicator      call MPI_COMM_SIZE(lgrp,nproc,ierror)c set default datatypes         mint = MPI_INTEGERc single precision      if (ndprec.eq.0) then         mreal = MPI_REAL         mcplx = MPI_COMPLEXc double precision      else         mreal = MPI_DOUBLE_PRECISION         mcplx = MPI_DOUBLE_COMPLEX      endifc requested number of processors not obtained      if (nproc.ne.nvp) then         write (2,*) ' processor number error: nvp, nproc=', nvp, nproc         call ppexit         stop      endif      return      endc-----------------------------------------------------------------------      subroutine ppexitc this subroutine terminates parallel processing      implicit nonec common block for parallel processing      integer nproc, lgrp, mreal, mint, mcplxc lgrp = current communicator      common /pparms/ nproc, lgrp, mreal, mint, mcplx      integer ierrorc synchronize processes      call MPI_BARRIER(lgrp,ierror)c terminate MPI execution environment      call MPI_FINALIZE(ierror)      return      endc-----------------------------------------------------------------------      subroutine pfft2c(f,g,bs,br,isign,ntpose,mixup,sct,indx,indy,kstrt     1,nxv,nyv,kxp,kyp,jblok,kblok,nxyd,nxyhd)c this subroutine performs a two dimensional complex to complex fastc fourier transform and its inverse, using complex arithmetic,c for data which is distributed in blocksc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc ntpose = (0,1) = (no,yes) input, output data are transposedc if isign = 0, the fft tables are preparedc if isign = -1, an inverse fourier transform is performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(n,m,l) = (1/nx*ny)*sum(f(j,k,i)*c       exp(-sqrt(-1)*2pi*n*j/nx)*exp(-sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, f is the input and g is the outputc g(m,n,l) = (1/nx*ny)*sum(f(j,k,i)*c       exp(-sqrt(-1)*2pi*nn*j/nx)*exp(-sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c if isign = 1, a forward fourier transform is performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(j,k,i) = sum(f(n,m,l)*exp(sqrt(-1)*2pi*n*j/nx)*c       exp(sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, g is the input and f is the outputc f(j,k,i) = sum(g(m,n,l)*exp(sqrt(-1)*2pi*nn*j/nx)*c       exp(sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c bs, br = scratch arraysc kstrt = starting data block numberc nxv/nyv = first dimension of f/gc kxp/kyp = number of data values per block in x/yc jblok/kblok = number of data blocks in x/yc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxy = maximum of (nx,ny)c nxyh = one half of maximum of (nx,ny)c written by viktor k. decyk, uclac parallel version      implicit none      integer isign, ntpose, indx, indy, kstrt, nxv, nyv, kxp, kyp      integer jblok, kblok, nxyd, nxyhd, mixup      complex f, g, bs, br, sct      dimension f(nxv,kyp,kblok), g(nyv,kxp,jblok)      dimension bs(kxp,kyp,kblok), br(kxp,kyp,jblok)      dimension mixup(nxyd), sct(nxyhd)c local data      integer indxy, nx, nxh, ny, nyh, nxy, j, k, lb, ll, jb, it, nxyh      integer nrx, nry, l, i, m, ns, ns2, km, kmr, k1, k2, j1, j2      real dnxy, arg, ani      complex s, t      indxy = max0(indx,indy)      nx = 2**indx      nxh = nx/2      ny = 2**indy      nyh = ny/2      nxy = 2**indxy      if (isign) 50, 10, 270c prepare fft tablesc bit-reverse index table: mixup(j) = 1 + reversed bits of (j - 1)   10 do 30 j = 1, nxy      lb = j - 1      ll = 0      do 20 k = 1, indxy      jb = lb/2      it = lb - 2*jb      lb = jb      ll = 2*ll + it   20 continue      mixup(j) = ll + 1   30 continuec sine/cosine table for the angles 2*n*pi/nxy      nxyh = nxy/2      dnxy = 6.28318530717959/float(nxy)      do 40 j = 1, nxyh      arg = dnxy*float(j - 1)      sct(j) = cmplx(cos(arg),-sin(arg))   40 continue      returnc inverse fourier transform   50 if (kstrt.gt.ny) go to 140      nrx = nxy/nx      do 80 l = 1, kblokc bit-reverse array elements in x      do 70 j = 1, nx      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 70      do 60 k = 1, kypc     if (j.lt.j1) then      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = tc     endif   60 continue   70 continue   80 continuec first transform in x      do 130 m = 1, indx      ns = 2**(m - 1)      ns2 = ns + ns      km = nxh/ns      kmr = km*nrx      do 120 l = 1, kblok      do 110 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 100 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 90 i = 1, kyp      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t   90 continue  100 continue  110 continue  120 continue  130 continuec transpose f array to g  140 call ptpose(f,g,bs,br,nx,ny,kstrt,nxv,nyv,kxp,kyp,jblok,kblok)      if (kstrt.gt.nx) go to 260      nry = nxy/ny      do 170 l = 1, jblokc bit-reverse array elements in y      do 160 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 160      do 150 j = 1, kxpc     if (k.lt.k1) then      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = tc     endif  150 continue  160 continue  170 continuec then transform in y      do 220 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 210 l = 1, jblok      do 200 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 190 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 180 i = 1, kxp      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t  180 continue  190 continue  200 continue  210 continue  220 continuec normalize result      ani = 1./float(nx*ny)      do 250 l = 1, jblok      do 240 j = 1, kxp      do 230 k = 1, ny      g(k,j,l) = g(k,j,l)*ani  230 continue  240 continue  250 continuec transpose g array to f  260 if (ntpose.eq.0) call ptpose(g,f,br,bs,ny,nx,kstrt,nyv,nxv,kyp,kxp     1,kblok,jblok)      returnc forward fourier transformc transpose f array to g  270 if (ntpose.eq.0) call ptpose(f,g,bs,br,nx,ny,kstrt,nxv,nyv,kxp,kyp     1,jblok,kblok)      if (kstrt.gt.nx) go to 360      nry = nxy/ny      do 300 l = 1, jblokc bit-reverse array elements in y      do 290 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 290      do 280 j = 1, kxpc     if (k.lt.k1) then      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = tc     endif  280 continue  290 continue  300 continuec first transform in y      do 350 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 340 l = 1, jblok      do 330 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 320 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 310 i = 1, kxp      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t  310 continue  320 continue  330 continue  340 continue  350 continuec transpose g array to f  360 call ptpose(g,f,br,bs,ny,nx,kstrt,nyv,nxv,kyp,kxp,kblok,jblok)      if (kstrt.gt.ny) return      nrx = nxy/nx      do 390 l = 1, kblokc bit-reverse array elements in x      do 380 j = 1, nx      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 380      do 370 k = 1, kypc     if (j.lt.j1) then      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = tc     endif  370 continue  380 continue  390 continuec then transform in x      do 440 m = 1, indx      ns = 2**(m - 1)      ns2 = ns + ns      km = nxh/ns      kmr = km*nrx      do 430 l = 1, kblok      do 420 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 410 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 400 i = 1, kyp      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t  400 continue  410 continue  420 continue  430 continue  440 continue      return      endc-----------------------------------------------------------------------      subroutine pfft2cz(f,ft,g,gt,bs,br,msgn,isign,ntpose,mixup,sct,ind     1x,indy,kstrt,nxd,nyd,nxv,nyv,kxp,kyp,jblok,kblok,kxybd,nxyd,nxyhd)c this subroutine performs a two dimensional complex to complex fastc fourier transform and its inverse, using complex arithmetic,c for data which is distributed in blocksc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc ntpose = (0,1) = (no,yes) input, output data are transposedc if isign = 0, the fft tables are preparedc if isign = -1, an inverse fourier transform is performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(n,m,l) = (1/nx*ny)*sum(f(j,k,i)*c       exp(-sqrt(-1)*2pi*n*j/nx)*exp(-sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, f is the input and g is the outputc g(m,n,l) = (1/nx*ny)*sum(f(j,k,i)*c       exp(-sqrt(-1)*2pi*nn*j/nx)*exp(-sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c if isign = 1, a forward fourier transform is performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(j,k,i) = sum(f(n,m,l)*exp(sqrt(-1)*2pi*n*j/nx)*c       exp(sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, g is the input and f is the outputc f(j,k,i) = sum(g(m,n,l)*exp(sqrt(-1)*2pi*nn*j/nx)*c       exp(sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c ft, gt, bs, br, msgn = scratch arraysc kstrt = starting data block numberc nxv/nyv = first dimension of f/gc kxp/kyp = number of data values per block in x/yc jblok/kblok = number of data blocks in x/yc mixup = array of bit reversed addressesc sct = sine/cosine tablec kxyb = maximum(nx/kxp,ny/kyp)c nxy = maximum of (nx,ny)c nxyh = one half of maximum of (nx,ny)c written by viktor k. decyk, uclac parallel version      implicit none      integer isign, ntpose, indx, indy, kstrt, nxd, nyd, nxv, nyv      integer kxp, kyp, jblok, kblok, kxybd, nxyd, nxyhd, msgn, mixup      complex f, ft, g, gt, bs, br, sct, s, t      dimension f(nxv,kyp,kblok), g(nyv,kxp,jblok)      dimension ft(kyp,nxd,kblok), gt(kxp,nyd,jblok)      dimension bs(kxp,kyp,kblok), br(kyp,kxp,jblok), msgn(kxybd)      dimension mixup(nxyd), sct(nxyhd)c local data      integer indxy, nx, nxh, ny, nyh, nxy, kxb, kyb, j, k, l, i, m      integer lb, ll, jb, it, nxyh, nrx, nry, ns, ns2, km, kmr, k1, k2      integer j1, j2      real dnxy, arg, ani      indxy = max0(indx,indy)      nx = 2**indx      nxh = nx/2      ny = 2**indy      nyh = ny/2      nxy = 2**indxy      kxb = nx/kxp      kyb = ny/kyp      if (isign) 50, 10, 270c prepare fft tablesc bit-reverse index table: mixup(j) = 1 + reversed bits of (j - 1)   10 do 30 j = 1, nxy      lb = j - 1      ll = 0      do 20 k = 1, indxy      jb = lb/2      it = lb - 2*jb      lb = jb      ll = 2*ll + it   20 continue      mixup(j) = ll + 1   30 continuec sine/cosine table for the angles 2*n*pi/nxy      nxyh = nxy/2      dnxy = 6.28318530717959/float(nxy)      do 40 j = 1, nxyh      arg = dnxy*float(j - 1)      sct(j) = cmplx(cos(arg),-sin(arg))   40 continue      returnc inverse fourier transform   50 if (kstrt.gt.ny) go to 140      nrx = nxy/nx      do 80 l = 1, kblokc bit-reverse array elements in x      do 70 j = 1, nx      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 70      do 60 k = 1, kypc     if (j.lt.j1) then      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = tc     endif   60 continue   70 continue   80 continuec first transform in x      do 130 m = 1, indx      ns = 2**(m - 1)      ns2 = ns + ns      km = nxh/ns      kmr = km*nrx      do 120 l = 1, kblok      do 110 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 100 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 90 i = 1, kyp      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t   90 continue  100 continue  110 continue  120 continue  130 continuec transpose f array to g  140 call ptposz(f,g,gt,bs,msgn,nx,ny,kstrt,nxv,nyv,kxp,kyp,jblok,kblok     1,kyb)      if (kstrt.gt.nx) go to 260      nry = nxy/ny      do 170 l = 1, jblokc bit-reverse array elements in y      do 160 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 160      do 150 j = 1, kxpc     if (k.lt.k1) then      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = tc     endif  150 continue  160 continue  170 continuec then transform in y      do 220 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 210 l = 1, jblok      do 200 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 190 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 180 i = 1, kxp      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t  180 continue  190 continue  200 continue  210 continue  220 continuec normalize result      ani = 1./float(nx*ny)      do 250 l = 1, jblok      do 240 j = 1, kxp      do 230 k = 1, ny      g(k,j,l) = g(k,j,l)*ani  230 continue  240 continue  250 continuec transpose g array to f  260 if (ntpose.eq.0) call ptposz(g,f,ft,br,msgn,ny,nx,kstrt,nyv,nxv,ky     1p,kxp,kblok,jblok,kxb)      returnc forward fourier transformc transpose f array to g  270 if (ntpose.eq.0) call ptposz(f,g,gt,bs,msgn,nx,ny,kstrt,nxv,nyv,kx     1p,kyp,jblok,kblok,kyb)      if (kstrt.gt.nx) go to 360      nry = nxy/ny      do 300 l = 1, jblokc bit-reverse array elements in y      do 290 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 290      do 280 j = 1, kxpc     if (k.lt.k1) then      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = tc     endif  280 continue  290 continue  300 continuec first transform in y      do 350 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 340 l = 1, jblok      do 330 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 320 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 310 i = 1, kxp      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t  310 continue  320 continue  330 continue  340 continue  350 continuec transpose g array to f  360 call ptposz(g,f,ft,br,msgn,ny,nx,kstrt,nyv,nxv,kyp,kxp,kblok,jblok     1,kxb)      if (kstrt.gt.ny) return      nrx = nxy/nx      do 390 l = 1, kblokc bit-reverse array elements in x      do 380 j = 1, nx      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 380      do 370 k = 1, kypc     if (j.lt.j1) then      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = tc     endif  370 continue  380 continue  390 continuec then transform in x      do 440 m = 1, indx      ns = 2**(m - 1)      ns2 = ns + ns      km = nxh/ns      kmr = km*nrx      do 430 l = 1, kblok      do 420 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 410 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 400 i = 1, kyp      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t  400 continue  410 continue  420 continue  430 continue  440 continue      return      endc-----------------------------------------------------------------------      subroutine pfft2cx(f,g,isign,mixup,sct,indx,indy,kstrt,nxv,kyp,kbl     1ok,nxyd,nxyhd)c this subroutine performs a two dimensional complex to complex fastc fourier transform and its inverse, using complex arithmetic,c for data which is distributed in blocksc f = input and output datac g = scratch arrayc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = 0, the fft tables are preparedc if isign = -1, an inverse fourier transform is performedc f(n,m,l) = (1/nx*ny)*sum(f(j,k,i)*c       exp(-sqrt(-1)*2pi*n*j/nx)*exp(-sqrt(-1)*2pi*mm*kk/ny))c if isign = 1, a forward fourier transform is performedc f(j,k,i) = sum(f(n,m,l)*exp(sqrt(-1)*2pi*n*j/nx)*c       exp(sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c kstrt = starting data block numberc nxv = first dimension of f and gc kyp = number of data values per blockc kblok = number of data blocksc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxy = maximum of (nx,ny)c nxyh = one half of maximum of (nx,ny)c written by viktor k. decyk, uclac parallel version      implicit none      integer isign, indx, indy, kstrt, nxv, kyp, kblok, nxyd, nxyhd      integer mixup      complex f, g, sct, s, t      dimension f(nxv,kyp,kblok), g(nxv,kyp,kblok)      dimension mixup(nxyd), sct(nxyhd)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplxc lstat = length of status array      parameter(lstat=8)c lgrp = current communicatorc mcplx = default datatype for complex      common /pparms/ nproc, lgrp, mreal, mint, mcplxc local data      integer indxy, nx, nxh, ny, nyh, nxy, ks, nxyh, nrx, nry, l, k, j      integer i, m, ns, ns2, km, kmr, k1, k2, j1, j2, kys, kb, lb      integer ierr, msid, istatus      real dnxy, arg, ani      dimension istatus(lstat)      indxy = max0(indx,indy)      nx = 2**indx      nxh = nx/2      ny = 2**indy      nyh = ny/2      nxy = 2**indxy      if (kstrt.gt.ny) return      ks = kstrt - 2      if (isign.ne.0) go to 40c prepare fft tablesc bit-reverse index table: mixup(j) = 1 + reversed bits of (j - 1)      call bitrv2(f,g,mixup,isign,indx,indy,kstrt,nxv,kyp,kblok,nxyd)c sine/cosine table for the angles 2*n*pi/nxy      nxyh = nxy/2      dnxy = 6.28318530717959/float(nxy)      do 30 j = 1, nxyh      arg = dnxy*float(j - 1)      sct(j) = cmplx(cos(arg),-sin(arg))   30 continue      returnc bit-reversal   40 nrx = nxy/nx      do 70 l = 1, kblokc bit-reverse array elements in x      do 60 k = 1, kyp      do 50 j = 1, nx      j1 = (mixup(j) - 1)/nrx + 1      g(j,k,l) = f(j1,k,l)   50 continue   60 continue   70 continuec bit-reverse array elements in y      nry = nxy/ny      call bitrv2(g,f,mixup,isign,indx,indy,kstrt,nxv,kyp,kblok,nxyd)      if (isign.gt.0) go to 320c inverse fourier transformc first transform in x      do 150 m = 1, indx      ns = 2**(m - 1)      ns2 = ns + ns      km = nxh/ns      kmr = km*nrx      do 140 l = 1, kblok      do 130 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 120 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 110 i = 1, kyp      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t  110 continue  120 continue  130 continue  140 continue  150 continuec then transform in y      do 280 m = 1, indy      ns = 2**(m - 1)      kys = ns/kyp      km = nyh/ns      kmr = km*nryc local calculation      if (kys.eq.0) then         ns2 = ns + ns         km = kyp/ns2         do 190 l = 1, kblok         do 180 k = 1, km         k1 = ns2*(k - 1)         k2 = k1 + ns         do 170 j = 1, ns         j1 = j + k1         j2 = j + k2         s = sct(1+kmr*(j-1))         do 160 i = 1, nx         t = s*f(i,j2,l)         f(i,j2,l) = f(i,j1,l) - t         f(i,j1,l) = f(i,j1,l) + t  160    continue  170    continue  180    continue  190    continuec distributed calculation      elsec copy distributed data         do 230 l = 1, kblok         kb = l + ks         lb = kb/kys         kb = kb + 1         lb = lb - 2*(lb/2)c this loop is used for shared memory computersc        do 220 k = 1, kypc        if (lb.eq.0) thenc           do 200 j = 1, nxc           g(j,k,l) = f(j,k,kb+kys)c 200       continuec        elsec           do 210 j = 1, nxc           g(j,k,l) = f(j,k,kb-kys)c 210       continuec        endifc 220    continuec this segment is used for mpi computers         if (lb.eq.0) then            call MPI_IRECV(g,nxv*kyp,mcplx,kb+kys-1,m+kyp,lgrp,msid,ierr     1)            call MPI_SEND(f,nxv*kyp,mcplx,kb+kys-1,m+kyp,lgrp,ierr)         else            call MPI_IRECV(g,nxv*kyp,mcplx,kb-kys-1,m+kyp,lgrp,msid,ierr     1)            call MPI_SEND(f,nxv*kyp,mcplx,kb-kys-1,m+kyp,lgrp,ierr)         endif         call MPI_WAIT(msid,istatus,ierr)  230    continuec perform reduction         do 270 l = 1, kblok         do 260 k = 1, kyp         kb = k + kyp*(l + ks) - 1         lb = kb/ns         s = sct(1+kmr*(kb-ns*lb))         lb = lb - 2*(lb/2)         if (lb.eq.0) then            do 240 j = 1, nx            f(j,k,l) = f(j,k,l) + s*g(j,k,l)  240       continue         else            do 250 j = 1, nx            f(j,k,l) = g(j,k,l) - s*f(j,k,l)  250       continue         endif  260    continue  270    continue      endif  280 continuec normalize result      ani = 1./float(nx*ny)      do 310 l = 1, kblok      do 300 k = 1, kyp      do 290 j = 1, nx      f(j,k,l) = f(j,k,l)*ani  290 continue  300 continue  310 continue      returnc forward fourier transformc first transform in x  320 do 370 m = 1, indx      ns = 2**(m - 1)      ns2 = ns + ns      km = nxh/ns      kmr = km*nrx      do 360 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 350 l = 1, kblok      do 340 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 330 i = 1, kyp      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t  330 continue  340 continue  350 continue  360 continue  370 continuec then transform in y      do 500 m = 1, indy      ns = 2**(m - 1)      kys = ns/kyp      km = nyh/ns      kmr = km*nryc local calculation      if (kys.eq.0) then         ns2 = ns + ns         km = kyp/ns2         do 410 l = 1, kblok         do 400 k = 1, km         k1 = ns2*(k - 1)         k2 = k1 + ns         do 390 j = 1, ns         j1 = j + k1         j2 = j + k2         s = conjg(sct(1+kmr*(j-1)))         do 380 i = 1, nx         t = s*f(i,j2,l)         f(i,j2,l) = f(i,j1,l) - t         f(i,j1,l) = f(i,j1,l) + t  380    continue  390    continue  400    continue  410    continuec distributed calculation      elsec copy distributed data         do 450 l = 1, kblok         kb = l + ks         lb = kb/kys         kb = kb + 1         lb = lb - 2*(lb/2)c this loop is used for shared memory computersc        do 440 k = 1, kypc        if (lb.eq.0) thenc           do 420 j = 1, nxc           g(j,k,l) = f(j,k,kb+kys)c 420       continuec        elsec           do 430 j = 1, nxc           g(j,k,l) = f(j,k,kb-kys)c 430       continuec        endifc 440    continuec this segment is used for mpi computers         if (lb.eq.0) then            call MPI_IRECV(g,nxv*kyp,mcplx,kb+kys-1,m+kyp,lgrp,msid,ierr     1)            call MPI_SEND(f,nxv*kyp,mcplx,kb+kys-1,m+kyp,lgrp,ierr)         else            call MPI_IRECV(g,nxv*kyp,mcplx,kb-kys-1,m+kyp,lgrp,msid,ierr     1)            call MPI_SEND(f,nxv*kyp,mcplx,kb-kys-1,m+kyp,lgrp,ierr)         endif         call MPI_WAIT(msid,istatus,ierr)  450    continuec perform reduction         do 490 l = 1, kblok         do 480 k = 1, kyp         kb = k + kyp*(l + ks) - 1         lb = kb/ns         s = conjg(sct(1+kmr*(kb-ns*lb)))         lb = lb - 2*(lb/2)         if (lb.eq.0) then            do 460 j = 1, nx            f(j,k,l) = f(j,k,l) + s*g(j,k,l)  460       continue         else            do 470 j = 1, nx            f(j,k,l) = g(j,k,l) - s*f(j,k,l)  470       continue         endif  480    continue  490    continue      endif  500 continue      return      endc-----------------------------------------------------------------------      subroutine bitrv2(f,g,mixup,isign,indx,indy,kstrt,nxv,kyp,kblok,nx     1yd)c this subroutine performs bit-reversal of distributed complex data in yc that is, it calculates g(j,k,l) = f(j,kk,ll), wherec ll = (k1-1)/kyp+1, and kk = k1- kyp*(ll-1), andc k1 = mixup(k+kyp*(l+kstrt-2))-1)/(max(nx,ny)/ny)+1c mixup(j) = 1 + reversed bits of (j - 1)c f = complex input arrayc g = complex output arrayc mixup = array of bit reversed addressesc if isign = 0, bit-reverse array is preparedc if isign = 1, bit-reversal is performedc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc kstrt = starting data block numberc nxv = first dimension of f and gc kyp = number of data values per blockc kblok = number of data blocksc nxy = maximum of (nx,ny)c written by viktor k. decyk, ucla      implicit none      integer isign, indx, indy, kstrt, nxv, kyp, kblok, nxyd, mixup      complex f, g      dimension f(nxv,kyp,kblok), g(nxv,kyp,kblok), mixup(nxyd)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplxc lstat = length of status array      parameter(lstat=8)c lgrp = current communicatorc mcplx = default datatype for complex      common /pparms/ nproc, lgrp, mreal, mint, mcplxc local datac     integer k1      integer indxy, nx, ny, nxy, ks, nry, j, k, lb, ll, jb, it      integer nvp, kypp, kyb, nvpp, kk, koff, ir, is, l, i, ierr, msid      integer istatus      dimension istatus(lstat)      indxy = max0(indx,indy)      nx = 2**indx      ny = 2**indy      nxy = 2**indxy      if (kstrt.gt.ny) return      ks = kstrt - 2      nry = nxy/ny      if (isign.ne.0) go to 30c prepare bit-reverse index table      do 20 j = 1, nxy      lb = j - 1      ll = 0      do 10 k = 1, indxy      jb = lb/2      it = lb - 2*jb      lb = jb      ll = 2*ll + it   10 continue      mixup(j) = ll + 1   20 continue      returnc bit-reverse array elements in yc this segment is used for shared memory computersc  30 do 60 l = 1, kblokc     koff = kyp*(l + ks)c     do 50 k = 1, kypc     k1 = (mixup(k+koff) - 1)/nry + 1c     ll = (k1 - 1)/kyp + 1c     kk = k1 - kyp*(ll - 1)c     do 40 j = 1, nxc     g(j,k,l) = f(j,kk,ll)c  40 continuec  50 continuec  60 continuec this segment is used for mpi computersc nvp = number of processors involved   30 nvp = ny/kypc kypp = length of data per message      kypp = (kyp - 1)/nvp + 1c kyb = number of messages sent      kyb = kyp/kypp      nvpp = (nvp - 1)/kyp + 1c pack buffers      do 60 l = 1, kblok      do 50 k = 1, kyp      kk = ((mixup(k+kyp*(l+ks))-1)/nry)/nvp+1      do 40 j = 1, nx      g(j,k,l) = f(j,kk,l)   40 continue   50 continue   60 continuec send and receive buffers      do 80 l = 1, kblok      do 70 i = 1, kyb      koff = kyp*(l + ks)      ir = ieor(((mixup(i+koff) - 1)/nry)/kyp,((l+ks)/nvpp)*nvpp) + 1      is = ir      ll = ((mixup((ir-1)/nvpp+1+koff) - 1)/nry)/kyp      call MPI_IRECV(f(1,1+(kyp*ll)/nvp,l),nxv*kypp,mcplx,ir-1,kyp-kyb+i     1,lgrp,msid,ierr)      call MPI_SEND(g(1,1+(kyp*(is-1))/nvp,l),nxv*kypp,mcplx,is-1,kyp-ky     1b+i,lgrp,ierr)      call MPI_WAIT(msid,istatus,ierr)   70 continue   80 continuec unpack buffers      do 120 l = 1, kblok      do 110 i = 1, kyb      do 100 k = 1, kypp      do 90 j = 1, nx      g(j,i+kyb*(k-1),l) = f(j,k+kypp*(i-1),l)   90 continue  100 continue  110 continue  120 continue      return      endc-----------------------------------------------------------------------      subroutine ptpose(f,g,s,t,nx,ny,kstrt,nxv,nyv,kxp,kyp,jblok,kblok)c this subroutine performs a transpose of a matrix f, distributed in y,c to a matrix g, distributed in x, that is,c g(k+kyp*(m-1),j,l) = f(j+kxp*(l-1),k,m), wherec 1 <= j <= kxp, 1 <= k <= kyp, 1 <= l <= nx/kxp, 1 <= m <= ny/kypc and where indices l and m can be distributed across processors.c this subroutine sends and receives one message at a time, eitherc synchronously or asynchronously. it uses a minimum of system resourcesc f = complex input arrayc g = complex output arrayc s, t = complex scratch arraysc nx/ny = number of points in x/yc kstrt = starting data block numberc nxv/nyv = first dimension of f/gc kxp/kyp = number of data values per block in x/yc jblok/kblok = number of data blocks in x/yc optimized version      implicit none      integer nx, ny, kstrt, nxv, nyv, kxp, kyp, jblok, kblok      complex f, g, s, t      dimension f(nxv,kyp,kblok), g(nyv,kxp,jblok)      dimension s(kxp,kyp,kblok), t(kxp,kyp,jblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplxc lstat = length of status array      parameter(lstat=8)c lgrp = current communicatorc mcplx = default datatype for complex      common /pparms/ nproc, lgrp, mreal, mint, mcplxc local data      integer ks, kxb, kyb, jkblok, kxym, mtr, ntr, mntr      integer l, i, joff, koff, k, j      integer ir0, is0, ii, ir, is, ierr, msid, istatus      dimension istatus(lstat)      ks = kstrt - 2      kxb = nx/kxp      kyb = ny/kypc this segment is used for shared memory computersc     if (kstrt.gt.nx) returnc     do 40 l = 1, jblokc     joff = kxp*(l + ks)c     do 30 i = 1, kybc     koff = kyp*(i - 1)c     do 20 k = 1, kypc     do 10 j = 1, kxpc     g(k+koff,j,l) = f(j+joff,k,i)c  10 continuec  20 continuec  30 continuec  40 continuec this segment is used for mpi computers      jkblok = max0(jblok,kblok)      kxym = min0(kxb,kyb)      mtr = kyb/kxym      ntr = kxb/kxym      mntr = max0(mtr,ntr)      do 70 l = 1, jkblok      do 60 i = 1, kxymc     ir0 = l + ks - i + 2c     if (ir0.lt.1) ir0 = ir0 + kybc     ir0 = ir0 - ((ir0 - 1)/kxym)*kxym      ir0 = iand(kxym-1,ieor(l+ks,i-1)) + 1c     is0 = l + ks + ic     is0 = is0 - ((is0 - 1)/kxym)*kxym      is0 = ir0      do 50 ii = 1, mntrc post receive      if ((kstrt.le.nx).and.(ii.le.mtr)) then         ir = ir0 + kxym*(ii - 1)         call MPI_IRECV(t(1,1,l),kxp*kyp,mcplx,ir-1,ir,lgrp,msid,ierr)      endifc send data      if ((kstrt.le.ny).and.(ii.le.ntr)) then         is = is0 + kxym*(ii - 1)         joff = kxp*(is - 1)         do 20 k = 1, kyp         do 10 j = 1, kxp         s(j,k,l) = f(j+joff,k,l)   10    continue   20    continue         call MPI_SEND(s(1,1,l),kxp*kyp,mcplx,is-1,l+ks+1,lgrp,ierr)      endifc receive data      if ((kstrt.le.nx).and.(ii.le.mtr)) then         koff = kyp*(ir - 1)         call MPI_WAIT(msid,istatus,ierr)         do 40 k = 1, kyp         do 30 j = 1, kxp         g(k+koff,j,l) = t(j,k,l)   30    continue   40    continue      endif   50 continue   60 continue   70 continue      return      endc-----------------------------------------------------------------------      subroutine mtpose(f,g,s,t,nxv,nyv,kxp,kyp,kblok)c this subroutine performs a transpose of a matrix f, distributed in y,c to a matrix g, distributed in x, that is,c g(k+kyp*(m-1),j,l) = f(j+kxp*(l-1),k,m), wherec 1 <= j <= kxp, 1 <= k <= kyp, 1 <= l <= nx/kxp, 1 <= m <= ny/kypc where nx/ny = total number of points in x/yc and where indices l and m can be distributed across processors.c this subroutine sends and receives one message at a time, c and uses a minimum of system resources.c f = complex input arrayc g = complex output arrayc s, t = complex scratch arraysc nxv/nyv = first dimension of f/gc kxp/kyp = number of data values per block in x/yc kblok = number of data blocks in x/yc optimized version      implicit none      integer kstrt, nxv, nyv, kxp, kyp, kblok      complex f, g, s, t      dimension f(nxv,kyp,kblok), g(nyv,kxp,kblok)      dimension s(kxp,kyp,kblok), t(kxp,kyp,kblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplxc lstat = length of status array      parameter(lstat=8)c nproc = number of real or virtual processors obtainedc lgrp = current communicatorc mcplx = default datatype for complex      common /pparms/ nproc, lgrp, mreal, mint, mcplxc local data      integer istatus      integer idproc, ks, ir, joff, koff, i, j, k, l, msid, ierr      dimension istatus(lstat)c this segment is used for shared memory computersc     do 40 l = 1, kblokc     joff = kxp*(l - 1)c     do 30 i = 1, kblokc     koff = kyp*(i - 1)c     do 20 k = 1, kypc     do 10 j = 1, kxpc     g(k+koff,j,l) = f(j+joff,k,i)c  10 continuec  20 continuec  30 continuec  40 continuec this segment is used for mpi computers      call MPI_COMM_RANK(lgrp,idproc,ierr)      ks = idproc - 1      do 80 l = 1, kblok      do 70 i = 1, nproc      ir = i - (l + ks)      if (ir.lt.1) ir = ir + nprocc post receive      call MPI_IRECV(t,kxp*kyp,mcplx,ir-1,i,lgrp,msid,ierr)c send data      joff = kxp*(ir - 1)      do 20 k = 1, kyp      do 10 j = 1, kxp      s(j,k,l) = f(j+joff,k,l)   10 continue   20 continuec copy data to oneself directly      if (ir.eq.kstrt) then         do 40 k = 1, kyp         do 30 j = 1, kxp         t(j,k,l) = s(j,k,l)   30    continue   40    continue      else         call MPI_SEND(s,kxp*kyp,mcplx,ir-1,i,lgrp,ierr)      endifc receive data      if (ir.ne.kstrt) call MPI_WAIT(msid,istatus,ierr)      koff = kyp*(ir - 1)      do 60 k = 1, kyp      do 50 j = 1, kxp      g(k+koff,j,l) = t(j,k,l)   50 continue   60 continue   70 continue   80 continue      return      endc-----------------------------------------------------------------------      subroutine matpose(f,g,s,t,nxv,nyv,kxp,kyp,kxb,kyb,jblok,kblok)c this subroutine performs a transpose of a matrix f, distributed in y,c to a matrix g, distributed in x, that is,c g(k+kyp*(m-1),j,l) = f(j+kxp*(l-1),k,m), wherec 1 <= j <= kxp, 1 <= k <= kyp, 1 <= l <= kxb, 1 <= m <= kybc and where indices l and m can be distributed across processors.c this subroutine calls MPI_ALLTOALL to send data.c f = complex input arrayc g = complex output arrayc s, t = complex scratch arraysc nxv/nyv = first dimension of f/gc kxp/kyp = number of data values per block in x/yc kxb = nx/kxp = number of processors distributed in xc kyb = ny/kyp = number of processors distributed in yc jblok/kblok = number of data blocks in x/y      implicit none      integer nxv, nyv, kxp, kyp, kxb, kyb, jblok, kblok      complex f, g, s, t      dimension f(nxv,kyp,kblok), g(nyv,kxp,jblok)      dimension s(kxp,kyp,kxb,kblok), t(kxp,kyp,kyb,jblok)      integer ic(4),is(4)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx      parameter(lstat=8)c lgrp = current communicatorc mcplx = default datatype for complex      common /pparms/ nproc, lgrp, mreal, mint, mcplxc local data      integer joff, koff, i, j, k, l, ierrc this segment is used for shared memory computersc     if (kstrt.gt.nx) returnc     do 40 l = 1, jblokc     joff = kxp*(l + ks)c     do 30 i = 1, kybc     koff = kyp*(i - 1)c     do 20 k = 1, kypc     do 10 j = 1, kxpc     g(k+koff,j,l) = f(j+joff,k,i)c  10 continuec  20 continuec  30 continuec  40 continuec this segment is used for mpi computersc pack send data      do 40 l = 1, kblok      do 30 i = 1, kxb      joff = kxp*(i - 1)      do 20 k = 1, kyp      do 10 j = 1, kxp      s(j,k,i,l) = f(j+joff,k,l)   10 continue   20 continue   30 continue   40 continuec     call MPI_ALLTOALL(s,kxp*kyp,mcplx,t,kxp*kyp,mcplx,lgrp,ierr)c special test case      do 45 l = 1, 4      ic(l) = kxp*kyp      is(l) = kxp*kyp*(l-1)  45  continue      call MPI_ALLTOALLV(s,ic,is,mcplx,t,ic,is,mcplx,lgrp,ierr)c unpack receive data      do 80 l = 1, kblok      do 70 i = 1, kyb      koff = kyp*(i - 1)      do 60 k = 1, kyp      do 50 j = 1, kxp      g(k+koff,j,l) = t(j,k,i,l)   50 continue   60 continue   70 continue   80 continue      return      endc-----------------------------------------------------------------------      subroutine ptposz(f,g,h,t,msgn,nx,ny,kstrt,nxv,nyv,kxp,kyp,jblok,k     1blok,kyb)c this subroutine performs a transpose of a matrix f, distributed in y,c to a matrix g, distributed in x, that is,c g(k+kyp*(m-1),j,l) = f(j+kxp*(l-1),k,m), wherec 1 <= j <= kxp, 1 <= k <= kyp, 1 <= l <= nx/kxp, 1 <= m <= ny/kypc and where indices l and m can be distributed across processors.c this subroutine sends many messages at once, then receives themc asyncronously.  it uses significant buffer space.c f = complex input arrayc g = complex output arrayc h, t, msgn = complex scratch arraysc nx/ny = number of points in x/yc kstrt = starting data block numberc nxv/nyv = first dimension of f/gc kxp/kyp = number of data values per block in x/yc jblok/kblok = number of data blocks in x/yc kyb = ny/kypc optimized version      implicit none      integer nx, ny, kstrt, nxv, nyv, kxp, kyp, jblok, kblok, kyb, msgn      complex f, g, h, t      dimension f(nxv,kyp,kblok), g(nyv,kxp,jblok), h(kxp,ny,jblok)      dimension t(kxp,kyp,kblok), msgn(kyb)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplxc lstat = length of status array      parameter(lstat=8)c lgrp = current communicatorc mcplx = default datatype for complex      common /pparms/ nproc, lgrp, mreal, mint, mcplxc local data      integer ks, kxb, l, i, joff, koff, k, j      integer ir, is, ierr, istatus      dimension istatus(lstat)      ks = kstrt - 2      kxb = nx/kxpc this segment is used for shared memory computersc     if (kstrt.gt.nx) returnc     do 40 l = 1, jblokc     joff = kxp*(l + ks)c     do 30 i = 1, kybc     koff = kyp*(i - 1)c     do 20 k = 1, kypc     do 10 j = 1, kxpc     g(k+koff,j,l) = f(j+joff,k,i)c  10 continuec  20 continuec  30 continuec  40 continuec this segment is used for mpi computers      if (kstrt.gt.nx) go to 30c post receive      do 20 l = 1, jblok      do 10 i = 1, kybc     ir = ic     ir = l + ks - i + 2c     if (ir.lt.1) ir = ir + kybc     ir = ir - ((ir - 1)/kyb)*kyb      ir = iand(kyb-1,ieor(l+ks,i-1)) + 1      call MPI_IRECV(h(1,1+kyp*(ir-1),l),kxp*kyp,mcplx,ir-1,ir,lgrp,msgn     1(ir),ierr)   10 continue   20 continue   30 if (kstrt.gt.ny) go to 80c send data      do 70 l = 1, kblok      do 60 i = 1, kxbc     is = ic     is = l + ks + ic     is = is - ((is - 1)/kxb)*kxb      is = iand(kxb-1,ieor(l+ks,i-1)) + 1      joff = kxp*(is - 1)      do 50 k = 1, kyp      do 40 j = 1, kxp      t(j,k,l) = f(j+joff,k,l)   40 continue   50 continue      call MPI_SEND(t(1,1,l),kxp*kyp,mcplx,is-1,l+ks+1,lgrp,ierr)   60 continue   70 continue   80 if (kstrt.gt.nx) returnc receive data      do 120 l = 1, jblok      do 110 i = 1, kybc     ir = ic     ir = l + ks - i + 2c     if (ir.lt.1) ir = ir + kybc     ir = ir - ((ir - 1)/kyb)*kyb      ir = iand(kyb-1,ieor(l+ks,i-1)) + 1      koff = kyp*(ir - 1)      call MPI_WAIT(msgn(ir),istatus,ierr)      do 100 k = 1, kyp      do 90 j = 1, kxp      g(k+koff,j,l) = h(j,k+koff,l)   90 continue  100 continue  110 continue  120 continue      return      endc-----------------------------------------------------------------------      subroutine ptposs(f,g,t,nx,ny,kstrt,nxv,nyv,kxp,kyp,jblok,kblok)c this subroutine performs a transpose of a matrix f, distributed in y,c to a matrix g, distributed in x, that is,c g(k+kyp*(m-1),j,l) = f(j+kxp*(l-1),k,m), wherec 1 <= j <= kxp, 1 <= k <= kyp, 1 <= l <= nx/kxp, 1 <= m <= ny/kypc and where indices l and m can be distributed across processors.c this subroutine uses a small buffer, but is relatively slow.c f = complex input arrayc g = complex output arrayc t = complex scratch arrayc nx/ny = number of points in x/yc kstrt = starting data block numberc nxv/nyv = first dimension of f/gc kxp/kyp = number of data values per block in x/yc jblok/kblok = number of data blocks in x/y      implicit none      integer nx, ny, kstrt, nxv, nyv, kxp, kyp, jblok, kblok      complex f, g, t      dimension f(nxv,kyp,kblok), g(nyv,kxp,jblok), t(kxp,jblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplxc lstat = length of status array      parameter(lstat=8)c lgrp = current communicatorc mcplx = default datatype for complex      common /pparms/ nproc, lgrp, mreal, mint, mcplxc local datac     integer kyb, jj, koff      integer ks, l, j, k, joff      integer kxb, ierr, msid, istatus      dimension istatus(lstat)      ks = kstrt - 2c this segment is used for shared memory computersc     if (kstrt.gt.nx) returnc     kyb = ny/kypc     do 40 l = 1, jblokc     joff = kxp*(l + ks)c     do 30 j = 1, kxpc     jj = j + joffc     do 20 i = 1, kybc     koff = kyp*(i - 1)c     do 10 k = 1, kypc     g(k+koff,j,l) = f(jj,k,i)c  10 continuec  20 continuec  30 continuec  40 continuec this segment is used for mpi computers      if (kstrt.gt.ny) go to 40      kxb = nx/kxpc send data      do 30 l = 1, kblok      do 20 k = 1, kyp      do 10 j = 1, kxb      joff = kxp*(j - 1) + 1      call MPI_ISEND(f(joff,k,l),kxp,mcplx,j-1,k+kyp*(l+ks),lgrp,msid,ie     1rr)   10 continue   20 continue   30 continue   40 if (kstrt.gt.nx) returnc receive data      do 70 l = 1, jblok      do 60 k = 1, ny      call MPI_RECV(t(1,l),kxp,mcplx,(k-1)/kyp,k,lgrp,istatus,ierr)      call MPI_WAIT(msid,istatus,ierr)      do 50 j = 1, kxp      g(k,j,l) = t(j,l)   50 continue   60 continue   70 continue      return      endc-----------------------------------------------------------------------      subroutine fft2c(f,isign,mixup,sct,indx,indy,nxd,nyd,nxyd,nxyhd)c this subroutine performs a two dimensional complex to complex fastc fourier transform and its inverse, using complex arithmeticc f = input and output datac indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = 0, the fft tables are preparedc if isign = -1, an inverse fourier transform is performedc f(n,m) = (1/nx*ny)*sum(f(j,k)*c       exp(-sqrt(-1)*2pi*n*j/nx)*exp(-sqrt(-1)*2pi*m*k/ny))c if isign = 1, a forward fourier transform is performedc f(j,k) = sum(f(n,m)*exp(sqrt(-1)*2pi*n*j/nx)*exp(sqrt(-1)*2pi*m*k/ny))c mixup = array of bit reversed addressesc sct = sine/cosine tablec nxy = maximum of (nx,ny)c nxyh = one half of maximum of (nx,ny)c written by viktor k. decyk, ucla      implicit none      integer isign, indx, indy, nxd, nyd, nxyd, nxyhd, mixup      complex f, sct      dimension f(nxd,nyd), mixup(nxyd), sct(nxyhd)c local data      integer indxy, nx, nxh, ny, nyh, nxy, j, k, lb, ll, jb, it, nxyh      integer nrx, nry, i, l, ns, ns2, km, kmr, k1, k2, j1, j2      real dnxy, arg, ani      complex s, t      indxy = max0(indx,indy)      nx = 2**indx      nxh = nx/2      ny = 2**indy      nyh = ny/2      nxy = 2**indxy      if (isign.ne.0) go to 40c prepare fft tablesc bit-reverse index table: mixup(j) = 1 + reversed bits of (j - 1)      do 20 j = 1, nxy      lb = j - 1      ll = 0      do 10 k = 1, indxy      jb = lb/2      it = lb - 2*jb      lb = jb      ll = 2*ll + it   10 continue      mixup(j) = ll + 1   20 continuec sine/cosine table for the angles 2*n*pi/nxy      nxyh = nxy/2      dnxy = 6.28318530717959/float(nxy)      do 30 j = 1, nxyh      arg = dnxy*float(j - 1)      sct(j) = cmplx(cos(arg),-sin(arg))   30 continue      returnc bit-reverse array elements in x   40 nrx = nxy/nx      do 60 j = 1, nx      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 60      do 50 i = 1, ny      t = f(j1,i)      f(j1,i) = f(j,i)      f(j,i) = t   50 continue   60 continuec bit-reverse array elements in y      nry = nxy/ny      do 80 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 80      do 70 i = 1, nx      t = f(i,k1)      f(i,k1) = f(i,k)      f(i,k) = t   70 continue   80 continue      if (isign.gt.0) go to 190c inverse fourier transformc first transform in x      do 120 l = 1, indx      ns = 2**(l - 1)      ns2 = ns + ns      km = nxh/ns      kmr = km*nrx      do 110 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 100 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 90 i = 1, ny      t = s*f(j2,i)      f(j2,i) = f(j1,i) - t      f(j1,i) = f(j1,i) + t   90 continue  100 continue  110 continue  120 continuec then transform in y      do 160 l = 1, indy      ns = 2**(l - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 150 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 140 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 130 i = 1, nx      t = s*f(i,j2)      f(i,j2) = f(i,j1) - t      f(i,j1) = f(i,j1) + t  130 continue  140 continue  150 continue  160 continuec normalize result      ani = 1./float(nx*ny)      do 180 k = 1, ny      do 170 j = 1, nx      f(j,k) = f(j,k)*ani  170 continue  180 continue      returnc forward fourier transformc first transform in x  190 do 230 l = 1, indx      ns = 2**(l - 1)      ns2 = ns + ns      km = nxh/ns      kmr = km*nrx      do 220 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 210 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 200 i = 1, ny      t = s*f(j2,i)      f(j2,i) = f(j1,i) - t      f(j1,i) = f(j1,i) + t  200 continue  210 continue  220 continue  230 continuec then transform in y      do 270 l = 1, indy      ns = 2**(l - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 260 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 250 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 240 i = 1, nx      t = s*f(i,j2)      f(i,j2) = f(i,j1) - t      f(i,j1) = f(i,j1) + t  240 continue  250 continue  260 continue  270 continue      return      endc-----------------------------------------------------------------------      function ranorm(d)c this program calculates a random number y from a gaussian distributionc with zero mean and unit variance, according to the method ofc mueller and box:c    y(k) = (-2*ln(x(k)))**1/2*sin(2*pi*x(k+1))c    y(k+1) = (-2*ln(x(k)))**1/2*cos(2*pi*x(k+1)),c where x is a random number uniformly distributed on (0,1).c written for the ibm by viktor k. decyk, ucla      integer r1,r2,r4,r5      double precision ranorm,h1l,h1u,h2l,r0,r3,asc,bsc,temp      save iflg,r1,r2,r4,r5,h1l,h1u,h2l,r0      data r1,r2,r4,r5 /885098780,1824280461,1396483093,55318673/      data h1l,h1u,h2l /65531.0d0,32767.0d0,65525.0d0/      data iflg,r0 /0,0.0d0/      if (iflg.eq.0) go to 10      ranorm = r0      r0 = 0.0d0      iflg = 0      return   10 isc = 65536      asc = dfloat(isc)      bsc = asc*asc      i1 = r1 - (r1/isc)*isc      r3 = h1l*dfloat(r1) + asc*h1u*dfloat(i1)      i1 = r3/bsc      r3 = r3 - dfloat(i1)*bsc      bsc = 0.5d0*bsc      i1 = r2/isc      isc = r2 - i1*isc      r0 = h1l*dfloat(r2) + asc*h1u*dfloat(isc)      asc = 1.0d0/bsc      isc = r0*asc      r2 = r0 - dfloat(isc)*bsc      r3 = r3 + (dfloat(isc) + 2.0d0*h1u*dfloat(i1))      isc = r3*asc      r1 = r3 - dfloat(isc)*bsc      temp = dsqrt(-2.0d0*dlog((dfloat(r1) + dfloat(r2)*asc)*asc))      isc = 65536      asc = dfloat(isc)      bsc = asc*asc      i1 = r4 - (r4/isc)*isc      r3 = h2l*dfloat(r4) + asc*h1u*dfloat(i1)      i1 = r3/bsc      r3 = r3 - dfloat(i1)*bsc      bsc = 0.5d0*bsc      i1 = r5/isc      isc = r5 - i1*isc      r0 = h2l*dfloat(r5) + asc*h1u*dfloat(isc)      asc = 1.0d0/bsc      isc = r0*asc      r5 = r0 - dfloat(isc)*bsc      r3 = r3 + (dfloat(isc) + 2.0d0*h1u*dfloat(i1))      isc = r3*asc      r4 = r3 - dfloat(isc)*bsc      r0 = 6.28318530717959d0*((dfloat(r4) + dfloat(r5)*asc)*asc)      ranorm = temp*dsin(r0)      r0 = temp*dcos(r0)      iflg = 1      return      endc-----------------------------------------------------------------------      subroutine timera(icntrl,chr,time)c this subroutine performs timingc input: icntrl, chrc icntrl = (-1,0,1) = (initialize,ignore,read) clockc clock should be initialized before it is read!c chr = character variable for labeling timingsc time = elapsed time in secondsc written for mpi      implicit none      integer icntrl      character*8 chr      real timec get definition of MPI constants      include 'mpif.h'c common block for parallel processing      integer nproc, lgrp, mreal, mint, mcplxc lgrp = current communicatorc mreal = default datatype for reals      common /pparms/ nproc, lgrp, mreal, mint, mcplxc local data      integer idproc, ierr      real nclock, mclock      double precision jclock      save jclock   91 format (1x,a8,1x,'max/min real time = ',e14.7,1x,e14.7,1x,'sec')      data jclock /0.0d0/      if (icntrl.eq.0) return      if (icntrl.eq.1) go to 10c initialize clock      call MPI_BARRIER(lgrp,ierr)      jclock = MPI_WTIME()      returnc read clock and write time difference from last clock initialization   10 nclock = real(MPI_WTIME() - jclock)      call MPI_ALLREDUCE(nclock,time,1,mreal,MPI_MIN,lgrp,ierr)      mclock = time      call MPI_ALLREDUCE(nclock,time,1,mreal,MPI_MAX,lgrp,ierr)      call MPI_COMM_RANK(lgrp,idproc,ierr)      if (idproc.eq.0) write (6,91) chr, time, mclock      return      endc-----------------------------------------------------------------------      subroutine psum (f,g,nxp,nblok)c this subroutine performs a parallel sum of a vector, that is:c f(j,k) = sum over k of f(j,k)c assumes the number of processors nproc is a power of two.c the algorithm performs partial sums in binary pairs, as follows:c first, adjacent processors exchange vectors and sum them.  next,c processors separated by 2 exchange the new vectors and sum them, thenc those separated by 4, up to processors separated by nproc/2.  at thec end, all processors contain the same summation.c f = input and output datac g = scratch arrayc nxp = number of data values in vectorc nblok = number of data blocksc written by viktor k. decyk, ucla      implicit none      real f, g      integer nxp, nblok      dimension f(nxp,nblok), g(nxp,nblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplxc lstat = length of status array      parameter(lstat=8)c nproc = number of real or virtual processors obtainedc lgrp = current communicatorc mreal = default datatype for reals      common /pparms/ nproc, lgrp, mreal, mint, mcplxc local data      integer istatus      integer idproc, ierr, kstrt, ks, l, kxs, k, kb, lb, msid, j      dimension istatus(lstat)c find processor idc this line is used for shared memory computersc     idproc = 0c this line is used for mpi computers      call MPI_COMM_RANK(lgrp,idproc,ierr)      kstrt = idproc + 1      if (kstrt.gt.nproc) return      ks = kstrt - 2      l = 1      kxs = 1c main iteration loop   10 if (kxs.ge.nproc) go to 60c shift data      do 30 k = 1, nblok      kb = k + ks      lb = kb/kxs      kb = kb + 1      lb = lb - 2*(lb/2)c this loop is used for shared memory computersc     do 20 j = 1, nxpc     if (lb.eq.0) thenc        g(j,k) = f(j,kb+kxs)c     elsec        g(j,k) = f(j,kb-kxs)c     endifc  20 continuec this segment is used for mpi computers      if (lb.eq.0) then         call MPI_IRECV(g,nxp,mreal,kb+kxs-1,l+nxp,lgrp,msid,ierr)         call MPI_SEND(f,nxp,mreal,kb+kxs-1,l+nxp,lgrp,ierr)      else         call MPI_IRECV(g,nxp,mreal,kb-kxs-1,l+nxp,lgrp,msid,ierr)         call MPI_SEND(f,nxp,mreal,kb-kxs-1,l+nxp,lgrp,ierr)      endif      call MPI_WAIT(msid,istatus,ierr)   30 continuec perform sum      do 50 k = 1, nblok      do 40 j = 1, nxp      f(j,k) = f(j,k) + g(j,k)   40 continue   50 continue      l = l + 1      kxs = kxs + kxs      go to 10   60 return      endEOF#if77 -O -nx pfft2cm.f -L/usr/local/lib -lmpi -lOtools -lOsystem -o pfft2cm.out#f90 -O3 pfft2cm.f -o pfft2cm.out#mpprun -n 4 ./pfft2cm.outmpxlf -O3 -qfixed pfft2cm.f -o pfft2cm.out poe pfft2cm.out -procs 4 -rmpool 0rm pfft2cm.fexit