cat > pfft2tst.f <<EOF      program pfft2tstc indnvp = exponent which determines number of virtual processorsc mshare = (0,1) = (no,yes) architecture is shared memory      parameter( indx =   7, indy =   8, indnvp =   2, mshare =   0)      parameter(nx=2**indx,ny=2**indy)      parameter(nxh=nx/2)      parameter(nvp=2**indnvp,kyp=(ny-1)/nvp+1,kxp=(nxh-1)/nvp+1)      parameter(kblok=1+mshare*(ny/kyp-1),jblok=1+mshare*(nxh/kxp-1))      parameter(nmx=nx*(ny/nx)+ny*(nx/ny),nxy=nmx/(2-nx/nmx-ny/nmx))      parameter(nmxh=nxh*(ny/nxh)+ny*(nxh/ny))      parameter(nxhy=nmxh/(2-nxh/nmxh-ny/nmxh))      parameter(nxv=nx+2,nyv=ny+2,nxvh=nxv/2,nxyh=nxy/2)      double precision ranorm      complex sct, ssct, sbuff, bbuff      dimension f(nxv,kyp,kblok), t(2*nyv,kxp,jblok)      dimension sbuff(kxp,kyp,kblok), bbuff(kxp,kyp,jblok)      dimension g(nxv,ny), h(nyv,nx)      dimension mixup(nxhy), sct(nxyh)      dimension mmixup(nxy), ssct(nxyh)c ntpose = (0,1) = (no,yes) input, output data are transposed in pfft2r      data ntpose /0/c initialize for parallel processing      call ppinit(idproc,nvp)      kstrt = idproc + 1      ks = kstrt - 2c prepare fft tables      isign = 0      indx1 = indx - 1      call pfft2r(f,t,sbuff,bbuff,isign,ntpose,mixup,sct,indx,indy,kstrt     1,nxvh,nyv,kxp,kyp,jblok,kblok,nxhy,nxyh)      call fft2rx(g,isign,mmixup,ssct,indx,indy,nxvh,nyv,nxhy,nxyh)c create test function      do 30 k = 1, ny      kk = (k - 1)/kyp      k1 = k - kyp*kk      do 20 j = 1, nx      g(j,k) = ranorm(d)      h(k,j) = g(j,k)      do 10 l = 1, kblok      if (kk.eq.(l+ks)) f(j,k1,l) = g(j,k)   10 continue   20 continue   30 continue      call timera(-1,'total   ',time)c start special test case      isign = 1c     call ptpose(f,t,sbuff,bbuff,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,jblok,kbc    1lok)      call pfft2r(f,t,sbuff,bbuff,isign,ntpose,mixup,sct,indx,indy,kstrt     1,nxvh,nyv,kxp,kyp,jblok,kblok,nxhy,nxyh)c     call ptpose(t,f,bbuff,sbuff,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kblok,jbc    1lok)      call fft2rx(g,isign,mmixup,ssct,indx,indy,nxvh,nyv,nxhy,nxyh)c     do 35 k = 1, nyc     do 33 j = 1, nxc     h(k,j) = g(j,k)c  33 continuec  35 continuec end special test casec     do 40 i = 1, 100c transform to fourier spacec     isign = -1c     call pfft2r(f,t,sbuff,bbuff,isign,ntpose,mixup,sct,indx,indy,kstrtc    1,nxvh,nyv,kxp,kyp,jblok,kblok,nxhy,nxyh)c     call fft2rx(g,isign,mmixup,ssct,indx,indy,nxvh,nyv,nxhy,nxyh)c transform to real spacec     isign = 1c     call pfft2r(f,t,sbuff,bbuff,isign,ntpose,mixup,sct,indx,indy,kstrtc    1,nxvh,nyv,kxp,kyp,jblok,kblok,nxhy,nxyh)c     call fft2rx(g,isign,mmixup,ssct,indx,indy,nxvh,nyv,nxhy,nxyh)c  40 continue      call timera(1,'total   ',time)      kxp2 = kxp + kxp      sum1 = 0.      epsmax = 0.      if (kstrt.gt.ny) go to 80c     if (kstrt.gt.nxh) go to 80      do 70 l = 1, kblokc     do 70 l = 1, jblok      koff = kyp*(l + ks)c     joff = kxp2*(l + ks)      do 60 k = 1, kyp      k1 = k + koffc     do 60 k = 1, ny      do 50 j = 1, nxc     do 50 j = 1, kxp2c     j1 = j + joffc     jj = (j - 1)/2 + 1c     if ((j-1).eq.(2*(jj-1))) thenc        kk = 2*k-1c     elsec        kk = 2*kc     endif      eps = abs(f(j,k,l) - g(j,k1))c     eps = abs(t(kk,jj,l) - h(k,j1))      if (eps.gt.epsmax) then         write (6,*) j,k1,f(j,k,l)         write (6,*) j,k1,g(j,k1)c        write (6,*) j1,k,t(kk,jj,l)c        write (6,*) j1,k,h(k,j1)         epsmax = eps      endif      sum1 = sum1 + eps   50 continue   60 continue   70 continue   80 continuec     call psum (sum1,at1,1,1)      write (6,*) 'error=',sum1      call ppexit      stop      endc-----------------------------------------------------------------------      subroutine ppinit(idproc,nvp)c this subroutine initializes parallel processingc input: nvp, output: idprocc idproc = processor idc nvp = number of real or virtual processors requested      implicit none      integer idproc, nvpc get definition of MPI constants      include 'mpif.h'c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplxc lstat = length of status array      parameter(lstat=8)c nproc = number of real or virtual processors obtainedc lgrp = current communicatorc mreal = default datatype for realsc mint = default datatype for integersc mcplx = default datatype for complex type      common /pparms/ nproc, lgrp, mreal, mint, mcplxc local data      integer ierror, ndprec      save /pparms/c ndprec = (0,1) = (no,yes) use (normal,autodouble) precision      data ndprec /0/c this segment is used for shared memory computersc     nproc = nvpc     idproc = 0c this segment is used for mpi computers      if (MPI_STATUS_SIZE.gt.lstat) then         write (2,*) ' status size too small, actual/required = ', lstat     1, MPI_STATUS_SIZE         stop      endifc initialize the MPI execution environment      call MPI_INIT(ierror)      if (ierror.ne.0) stop      lgrp = MPI_COMM_WORLDc determine the rank of the calling process in the communicator      call MPI_COMM_RANK(lgrp,idproc,ierror)c determine the size of the group associated with a communicator      call MPI_COMM_SIZE(lgrp,nproc,ierror)c set default datatypes         mint = MPI_INTEGERc single precision      if (ndprec.eq.0) then         mreal = MPI_REAL         mcplx = MPI_COMPLEXc double precision      else         mreal = MPI_DOUBLE_PRECISION         mcplx = MPI_DOUBLE_COMPLEX      endifc requested number of processors not obtained      if (nproc.ne.nvp) then         write (2,*) ' processor number error: nvp, nproc=', nvp, nproc         call ppexit         stop      endif      return      endc-----------------------------------------------------------------------      subroutine ppexitc this subroutine terminates parallel processing      implicit nonec common block for parallel processing      integer nproc, lgrp, mreal, mint, mcplxc lgrp = current communicator      common /pparms/ nproc, lgrp, mreal, mint, mcplx      integer ierrorc synchronize processes      call MPI_BARRIER(lgrp,ierror)c terminate MPI execution environment      call MPI_FINALIZE(ierror)      return      endc-----------------------------------------------------------------------      subroutine pfft2r(f,g,bs,br,isign,ntpose,mixup,sct,indx,indy,kstrt     1,nxvh,nyv,kxp,kyp,jblok,kblok,nxhyd,nxyhd)c this subroutine performs a two dimensional real to complex fastc fourier transform and its inverse, using complex arithmetic,c for data which is distributed in blocksc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc ntpose = (0,1) = (no,yes) input, output data are transposedc if isign = 0, the fft tables are preparedc if isign = -1, an inverse fourier transform is performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(n,m,l) = (1/nx*ny)*sum(f(j,k,i)*c       exp(-sqrt(-1)*2pi*n*j/nx)*exp(-sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, f is the input and g is the outputc g(m,n,l) = (1/nx*ny)*sum(f(j,k,i)*c       exp(-sqrt(-1)*2pi*nn*j/nx)*exp(-sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c if isign = 1, a forward fourier transform is performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(j,k,i) = sum(f(n,m,l)*exp(sqrt(-1)*2pi*n*j/nx)*c       exp(sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, g is the input and f is the outputc f(j,k,i) = sum(g(m,n,l)*exp(sqrt(-1)*2pi*nn*j/nx)*c       exp(sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c bs, br = scratch arraysc kstrt = starting data block numberc nxvh/nyv = first dimension of f/gc kxp/kyp = number of data values per block in x/yc jblok/kblok = number of data blocks in x/yc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxhyd = maximum of (nx/2,ny)c nxyhd = one half of maximum of (nx,ny)c the real data is stored in a complex array of length nx/2, nyc with the odd/even x points stored in the real/imaginary parts.c in complex notation, fourier coefficients are stored as follows:c if ntpose = 0,c f(j,k,i) = mode j-1,kk-1, where kk = k + kyp*(i - 1)c 1 <= j <= nx/2 and 1 <= kk <= ny, except forc f(1,k,i) = mode nx/2,kk-1, where ny/2+2 <= kk <= ny, andc imaginary part of f(1,1,1) = real part of mode nx/2,0 andc imaginary part of f(1,1,(ny/2)/kyp+1) = real part of mode nx/2,ny/2c if ntpose = 1,c g(k,j,i) = mode jj-1,k-1, where jj = j + kxp*(i - 1)c 1 <= jj <= nx/2 and 1 <= k <= ny, except forc g(k,1,1) = mode nx/2,k-1, where ny/2+2 <= k <= ny, andc imaginary part of g(1,1,1) = real part of mode nx/2,0 andc imaginary part of g(ny/2+1,1,1) = real part of mode nx/2,ny/2c written by viktor k. decyk, uclac parallel version      implicit none      integer isign, ntpose, indx, indy, kstrt, nxvh, nyv, kxp, kyp      integer jblok, kblok, nxhyd, nxyhd, mixup      complex f, g, bs, br, sct      dimension f(nxvh,kyp,kblok), g(nyv,kxp,jblok)      dimension bs(kxp,kyp,kblok), br(kxp,kyp,jblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, nxh, nxhh, nxh2, ny, nyh, ny2, nxy      integer nxhy, ks, j, k, lb, ll, jb, it, nxyh, nrx, nry, l, i, m      integer ns, ns2, km, kmr, k1, k2, j1, j2      real dnxy, arg, ani      complex s, t, t1      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nxh2 = nxh + 2      ny = 2**indy      nyh = ny/2      ny2 = ny + 2      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      if (isign) 50, 10, 300c prepare fft tablesc bit-reverse index table: mixup(j) = 1 + reversed bits of (j - 1)   10 do 30 j = 1, nxhy      lb = j - 1      ll = 0      do 20 k = 1, indx1y      jb = lb/2      it = lb - 2*jb      lb = jb      ll = 2*ll + it   20 continue      mixup(j) = ll + 1   30 continuec sine/cosine table for the angles 2*n*pi/nxy      nxyh = nxy/2      dnxy = 6.28318530717959/float(nxy)      do 40 j = 1, nxyh      arg = dnxy*float(j - 1)      sct(j) = cmplx(cos(arg),-sin(arg))   40 continue      returnc inverse fourier transform   50 if (kstrt.gt.ny) go to 180      nrx = nxhy/nxh      do 80 l = 1, kblokc bit-reverse array elements in x      do 70 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 70      do 60 k = 1, kypc     if (j.lt.j1) then      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = tc     endif   60 continue   70 continue   80 continuec first transform in x      nrx = nxy/nxh      do 130 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 120 l = 1, kblok      do 110 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 100 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 90 i = 1, kyp      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t   90 continue  100 continue  110 continue  120 continue  130 continuec unscramble coefficients and normalize      kmr = nxy/nx      ani = 1./float(2*nx*ny)      do 170 l = 1, kblok      do 150 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),-real(sct(1+kmr*(j-1))))      do 140 k = 1, kyp      t = conjg(f(nxh2-j,k,l))      s = f(j,k,l) + t      t = (f(j,k,l) - t)*t1      f(j,k,l) = ani*(s + t)      f(nxh2-j,k,l) = ani*conjg(s - t)  140 continue  150 continue      do 160 k = 1, kyp      f(nxhh+1,k,l) = 2.*ani*conjg(f(nxhh+1,k,l))      f(1,k,l) = 2.*ani*cmplx(real(f(1,k,l)) + aimag(f(1,k,l)),real(f(1,     1k,l)) - aimag(f(1,k,l)))  160 continue  170 continuec transpose f array to g  180 call ptpose(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,jblok,kblok)      if (kstrt.gt.nxh) go to 290      nry = nxhy/ny      do 210 l = 1, jblokc bit-reverse array elements in y      do 200 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 200      do 190 j = 1, kxpc     if (k.lt.k1) then      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = tc     endif  190 continue  200 continue  210 continuec then transform in y      nry = nxy/ny      do 260 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 250 l = 1, jblok      do 240 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 230 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 220 i = 1, kxp      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t  220 continue  230 continue  240 continue  250 continue  260 continuec unscramble modes kx = 0, nx/2      do 280 l = 1, jblok      if ((l+ks).gt.0) go to 280      do 270 k = 2, nyhc     if ((l+ks).eq.0) then      s = g(ny2-k,1,l)      g(ny2-k,1,l) = .5*cmplx(aimag(g(k,1,l) + s),real(g(k,1,l) - s))      g(k,1,l) = .5*cmplx(real(g(k,1,l) + s),aimag(g(k,1,l) - s))c     endif  270 continue  280 continuec transpose g array to f  290 if (ntpose.eq.0) call ptpose(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,kyp,k     1xp,kblok,jblok)      returnc forward fourier transformc transpose f array to g  300 if (ntpose.eq.0) call ptpose(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,kxp,k     1yp,jblok,kblok)      if (kstrt.gt.nxh) go to 410      nry = nxhy/ny      do 350 l = 1, jblokc scramble modes kx = 0, nx/2      if ((l+ks).gt.0) go to 320      do 310 k = 2, nyhc     if ((l+ks).eq.0) then      s = cmplx(aimag(g(ny2-k,1,l)),real(g(ny2-k,1,l)))      g(ny2-k,1,l) = conjg(g(k,1,l) - s)      g(k,1,l) = g(k,1,l) + sc     endif  310 continuec bit-reverse array elements in y  320 do 340 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 340      do 330 j = 1, kxpc     if (k.lt.k1) then      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = tc     endif  330 continue  340 continue  350 continuec first transform in y      nry = nxy/ny      do 400 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 390 l = 1, jblok      do 380 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 370 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 360 i = 1, kxp      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t  360 continue  370 continue  380 continue  390 continue  400 continuec transpose g array to f  410 call ptpose(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kblok,jblok)      if (kstrt.gt.ny) return      nrx = nxhy/nxh      kmr = nxy/nx      do 470 l = 1, kblokc scramble coefficients      do 430 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),real(sct(1+kmr*(j-1))))      do 420 k = 1, kyp      t = conjg(f(nxh2-j,k,l))      s = f(j,k,l) + t      t = (f(j,k,l) - t)*t1      f(j,k,l) = s + t      f(nxh2-j,k,l) = conjg(s - t)  420 continue  430 continue      do 440 k = 1, kyp      f(nxhh+1,k,l) = 2.*conjg(f(nxhh+1,k,l))      f(1,k,l) = cmplx(real(f(1,k,l)) + aimag(f(1,k,l)),real(f(1,k,l)) -     1 aimag(f(1,k,l)))  440 continuec bit-reverse array elements in x      do 460 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 460      do 450 k = 1, kypc     if (j.lt.j1) then      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = tc     endif  450 continue  460 continue  470 continuec then transform in x      nrx = nxy/nxh      do 520 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 510 l = 1, kblok      do 500 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 490 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 480 i = 1, kyp      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t  480 continue  490 continue  500 continue  510 continue  520 continue      return      endc-----------------------------------------------------------------------      subroutine ptpose(f,g,s,t,nx,ny,kstrt,nxv,nyv,kxp,kyp,jblok,kblok)c this subroutine performs a transpose of a matrix f, distributed in y,c to a matrix g, distributed in x, that is,c g(k+kyp*(m-1),j,l) = f(j+kxp*(l-1),k,m), wherec 1 <= j <= kxp, 1 <= k <= kyp, 1 <= l <= nx/kxp, 1 <= m <= ny/kypc and where indices l and m can be distributed across processors.c this subroutine sends and receives one message at a time, eitherc synchronously or asynchronously. it uses a minimum of system resourcesc f = complex input arrayc g = complex output arrayc s, t = complex scratch arraysc nx/ny = number of points in x/yc kstrt = starting data block numberc nxv/nyv = first dimension of f/gc kxp/kyp = number of data values per block in x/yc jblok/kblok = number of data blocks in x/yc optimized version      implicit none      integer nx, ny, kstrt, nxv, nyv, kxp, kyp, jblok, kblok      complex f, g, s, t      dimension f(nxv,kyp,kblok), g(nyv,kxp,jblok)      dimension s(kxp,kyp,kblok), t(kxp,kyp,jblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplxc lstat = length of status array      parameter(lstat=8)c lgrp = current communicatorc mcplx = default datatype for complex      common /pparms/ nproc, lgrp, mreal, mint, mcplxc local data      integer ks, kxb, kyb, jkblok, kxym, mtr, ntr, mntr      integer l, i, joff, koff, k, j      integer ir0, is0, ii, ir, is, ierr, msid, istatus      dimension istatus(lstat)      ks = kstrt - 2      kxb = nx/kxp      kyb = ny/kypc this segment is used for shared memory computersc     if (kstrt.gt.nx) returnc     do 40 l = 1, jblokc     joff = kxp*(l + ks)c     do 30 i = 1, kybc     koff = kyp*(i - 1)c     do 20 k = 1, kypc     do 10 j = 1, kxpc     g(k+koff,j,l) = f(j+joff,k,i)c  10 continuec  20 continuec  30 continuec  40 continuec this segment is used for mpi computers      jkblok = max0(jblok,kblok)      kxym = min0(kxb,kyb)      mtr = kyb/kxym      ntr = kxb/kxym      mntr = max0(mtr,ntr)      do 70 l = 1, jkblok      do 60 i = 1, kxym      ir0 = iand(kxym-1,ieor(l+ks,i-1)) + 1      is0 = ir0      do 50 ii = 1, mntrc post receive      if ((kstrt.le.nx).and.(ii.le.mtr)) then         ir = ir0 + kxym*(ii - 1)         call MPI_IRECV(t(1,1,l),kxp*kyp,mcplx,ir-1,ir+kxym+1,lgrp,msid,     1ierr)      endifc send data      if ((kstrt.le.ny).and.(ii.le.ntr)) then         is = is0 + kxym*(ii - 1)         joff = kxp*(is - 1)         do 20 k = 1, kyp         do 10 j = 1, kxp         s(j,k,l) = f(j+joff,k,l)   10    continue   20    continue         call MPI_SEND(s(1,1,l),kxp*kyp,mcplx,is-1,l+ks+kxym+2,lgrp,ierr     1)      endifc receive data      if ((kstrt.le.nx).and.(ii.le.mtr)) then         koff = kyp*(ir - 1)         call MPI_WAIT(msid,istatus,ierr)         do 40 k = 1, kyp         do 30 j = 1, kxp         g(k+koff,j,l) = t(j,k,l)   30    continue   40    continue      endif   50 continue   60 continue   70 continue      return      endc-----------------------------------------------------------------------      subroutine fft2rx(f,isign,mixup,sct,indx,indy,nxhd,nyd,nxhyd,nxyhd     1)c this subroutine performs a two dimensional real to complex fastc fourier transform and its inverse, using complex arithmeticc f = input and output datac indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = 0, the fft tables are preparedc if isign = -1, an inverse fourier transform is performedc f(n,m) = (1/nx*ny)*sum(f(j,k)*c       exp(-sqrt(-1)*2pi*n*j/nx)*exp(-sqrt(-1)*2pi*m*k/ny))c if isign = 1, a forward fourier transform is performedc f(j,k) = sum(f(n,m)*exp(sqrt(-1)*2pi*n*j/nx)*exp(sqrt(-1)*2pi*m*k/ny))c mixup = array of bit reversed addressesc sct = sine/cosine tablec nxhd = first dimension of fc nyd = second dimension of fc nxhyd = maximum of (nx/2,ny)c nxyhd = maximum of (nx,ny)/2c fourier coefficients are stored as follows:c f(2*j-1,k),f(2*j,k) = real, imaginary part of mode j-1,k-1, wherec 1 <= j <= nx/2 and 1 <= k <= ny, except forc f(1,k),f(2,k) = real, imaginary part of mode nx/2,k-1, wherec ny/2+2 <= k <= ny, andc f(2,1) = real part of mode nx/2,0 andc f(2,ny/2+1) = real part of mode nx/2,ny/2c written by viktor k. decyk, ucla      implicit none      integer isign, indx, indy, nxhd, nyd, nxhyd, nxyhd, mixup      complex f, sct      dimension f(nxhd,nyd), mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, nxh, nxhh, nxh2, ny, nyh, ny2, nxy      integer nxhy, j, k, lb, ll, jb, it, nxyh, nrx, nry, l, i      integer ns, ns2, km, kmr, k1, k2, j1, j2      real dnxy, arg, ani      complex t1, t2, t3      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nxh2 = nxh + 2      ny = 2**indy      nyh = ny/2      ny2 = ny + 2      nxy = max0(nx,ny)      nxhy = 2**indx1y      if (isign) 50, 10, 220c prepare fft tablesc bit-reverse index table: mixup(j) = 1 + reversed bits of (j - 1)   10 do 30 j = 1, nxhy      lb = j - 1      ll = 0      do 20 k = 1, indx1y      jb = lb/2      it = lb - 2*jb      lb = jb      ll = 2*ll + it   20 continue      mixup(j) = ll + 1   30 continuec sine/cosine table for the angles 2*n*pi/nxy      nxyh = nxy/2      dnxy = 6.28318530717959/float(nxy)      do 40 j = 1, nxyh      arg = dnxy*float(j - 1)      sct(j) = cmplx(cos(arg),-sin(arg))   40 continue      returnc inverse fourier transformc bit-reverse array elements in x   50 nrx = nxhy/nxh      nry = nxhy/ny      do 70 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 70      do 60 k = 1, ny      t1 = f(j1,k)      f(j1,k) = f(j,k)      f(j,k) = t1   60 continue   70 continuec first transform in x      nrx = nxy/nxh      do 110 l = 1, indx1      ns = 2**(l - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 100 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 90 j = 1, ns      j1 = j + k1      j2 = j + k2      t1 = sct(1+kmr*(j-1))      do 80 i = 1, ny      t2 = t1*f(j2,i)      f(j2,i) = f(j1,i) - t2      f(j1,i) = f(j1,i) + t2   80 continue   90 continue  100 continue  110 continuec unscramble coefficients and normalize      kmr = nxy/nx      ani = 1./float(2*nx*ny)      do 130 j = 2, nxhh      t3 = cmplx(aimag(sct(1+kmr*(j-1))),-real(sct(1+kmr*(j-1))))      do 120 k = 1, ny      t2 = conjg(f(nxh2-j,k))      t1 = f(j,k) + t2      t2 = (f(j,k) - t2)*t3      f(j,k) = ani*(t1 + t2)      f(nxh2-j,k) = ani*conjg(t1 - t2)  120 continue  130 continue      ani = 2.*ani      do 140 k = 1, ny      f(nxhh+1,k) = ani*conjg(f(nxhh+1,k))      f(1,k) = ani*cmplx(real(f(1,k)) + aimag(f(1,k)),real(f(1,k)) - aim     1ag(f(1,k)))  140 continuec bit-reverse array elements in y      do 160 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 160      do 150 j = 1, nxh      t1 = f(j,k1)      f(j,k1) = f(j,k)      f(j,k) = t1  150 continue  160 continuec then transform in y      nry = nxy/ny      do 200 l = 1, indy      ns = 2**(l - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 190 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 180 j = 1, ns      j1 = j + k1      j2 = j + k2      t1 = sct(1+kmr*(j-1))      do 170 i = 1, nxh      t2 = t1*f(i,j2)      f(i,j2) = f(i,j1) - t2      f(i,j1) = f(i,j1) + t2  170 continue  180 continue  190 continue  200 continuec unscramble modes kx = 0, nx/2      do 210 k = 2, nyh      t1 = f(1,ny2-k)      f(1,ny2-k) = .5*cmplx(aimag(f(1,k) + t1),real(f(1,k) - t1))      f(1,k) = .5*cmplx(real(f(1,k) + t1),aimag(f(1,k) - t1))  210 continue      returnc forward fourier transformc scramble modes kx = 0, nx/2  220 do 230 k = 2, nyh      t1 = cmplx(aimag(f(1,ny2-k)),real(f(1,ny2-k)))      f(1,ny2-k) = conjg(f(1,k) - t1)      f(1,k) = f(1,k) + t1  230 continuec bit-reverse array elements in y      nry = nxhy/ny      do 250 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 250      do 240 j = 1, nxh      t1 = f(j,k1)      f(j,k1) = f(j,k)      f(j,k) = t1  240 continue  250 continuec first transform in y      nry = nxy/ny      do 290 l = 1, indy      ns = 2**(l - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 280 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 270 j = 1, ns      j1 = j + k1      j2 = j + k2      t1 = conjg(sct(1+kmr*(j-1)))      do 260 i = 1, nxh      t2 = t1*f(i,j2)      f(i,j2) = f(i,j1) - t2      f(i,j1) = f(i,j1) + t2  260 continue  270 continue  280 continue  290 continuec scramble coefficients      kmr = nxy/nx      do 310 j = 2, nxhh      t3 = cmplx(aimag(sct(1+kmr*(j-1))),real(sct(1+kmr*(j-1))))      do 300 k = 1, ny      t2 = conjg(f(nxh2-j,k))      t1 = f(j,k) + t2      t2 = (f(j,k) - t2)*t3      f(j,k) = t1 + t2      f(nxh2-j,k) = conjg(t1 - t2)  300 continue  310 continue      do 320 k = 1, ny      f(nxhh+1,k) = 2.*conjg(f(nxhh+1,k))      f(1,k) = cmplx(real(f(1,k)) + aimag(f(1,k)),real(f(1,k)) - aimag(f     1(1,k)))  320 continuec bit-reverse array elements in x      nrx = nxhy/nxh      do 340 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 340      do 330 k = 1, ny      t1 = f(j1,k)      f(j1,k) = f(j,k)      f(j,k) = t1  330 continue  340 continuec then transform in x      nrx = nxy/nxh      do 380 l = 1, indx1      ns = 2**(l - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 370 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 360 j = 1, ns      j1 = j + k1      j2 = j + k2      t1 = conjg(sct(1+kmr*(j-1)))      do 350 i = 1, ny      t2 = t1*f(j2,i)      f(j2,i) = f(j1,i) - t2      f(j1,i) = f(j1,i) + t2  350 continue  360 continue  370 continue  380 continue      return      endc-----------------------------------------------------------------------      function ranorm(d)c this program calculates a random number y from a gaussian distributionc with zero mean and unit variance, according to the method ofc mueller and box:c    y(k) = (-2*ln(x(k)))**1/2*sin(2*pi*x(k+1))c    y(k+1) = (-2*ln(x(k)))**1/2*cos(2*pi*x(k+1)),c where x is a random number uniformly distributed on (0,1).c written for the ibm by viktor k. decyk, ucla      integer r1,r2,r4,r5      double precision ranorm,h1l,h1u,h2l,r0,r3,asc,bsc,temp      save iflg,r1,r2,r4,r5,h1l,h1u,h2l,r0      data r1,r2,r4,r5 /885098780,1824280461,1396483093,55318673/      data h1l,h1u,h2l /65531.0d0,32767.0d0,65525.0d0/      data iflg,r0 /0,0.0d0/      if (iflg.eq.0) go to 10      ranorm = r0      r0 = 0.0d0      iflg = 0      return   10 isc = 65536      asc = dfloat(isc)      bsc = asc*asc      i1 = r1 - (r1/isc)*isc      r3 = h1l*dfloat(r1) + asc*h1u*dfloat(i1)      i1 = r3/bsc      r3 = r3 - dfloat(i1)*bsc      bsc = 0.5d0*bsc      i1 = r2/isc      isc = r2 - i1*isc      r0 = h1l*dfloat(r2) + asc*h1u*dfloat(isc)      asc = 1.0d0/bsc      isc = r0*asc      r2 = r0 - dfloat(isc)*bsc      r3 = r3 + (dfloat(isc) + 2.0d0*h1u*dfloat(i1))      isc = r3*asc      r1 = r3 - dfloat(isc)*bsc      temp = dsqrt(-2.0d0*dlog((dfloat(r1) + dfloat(r2)*asc)*asc))      isc = 65536      asc = dfloat(isc)      bsc = asc*asc      i1 = r4 - (r4/isc)*isc      r3 = h2l*dfloat(r4) + asc*h1u*dfloat(i1)      i1 = r3/bsc      r3 = r3 - dfloat(i1)*bsc      bsc = 0.5d0*bsc      i1 = r5/isc      isc = r5 - i1*isc      r0 = h2l*dfloat(r5) + asc*h1u*dfloat(isc)      asc = 1.0d0/bsc      isc = r0*asc      r5 = r0 - dfloat(isc)*bsc      r3 = r3 + (dfloat(isc) + 2.0d0*h1u*dfloat(i1))      isc = r3*asc      r4 = r3 - dfloat(isc)*bsc      r0 = 6.28318530717959d0*((dfloat(r4) + dfloat(r5)*asc)*asc)      ranorm = temp*dsin(r0)      r0 = temp*dcos(r0)      iflg = 1      return      endc-----------------------------------------------------------------------      subroutine timera(icntrl,chr,time)c this subroutine performs timingc input: icntrl, chrc icntrl = (-1,0,1) = (initialize,ignore,read) clockc clock should be initialized before it is read!c chr = character variable for labeling timingsc time = elapsed time in secondsc written for mpi      implicit none      integer icntrl      character*8 chr      real timec get definition of MPI constants      include 'mpif.h'c common block for parallel processing      integer nproc, lgrp, mreal, mint, mcplxc lgrp = current communicatorc mreal = default datatype for reals      common /pparms/ nproc, lgrp, mreal, mint, mcplxc local data      integer idproc, ierr      real nclock, mclock      double precision jclock      save jclock   91 format (1x,a8,1x,'max/min real time = ',e14.7,1x,e14.7,1x,'sec')      data jclock /0.0d0/      if (icntrl.eq.0) return      if (icntrl.eq.1) go to 10c initialize clock      call MPI_BARRIER(lgrp,ierr)      jclock = MPI_WTIME()      returnc read clock and write time difference from last clock initialization   10 nclock = real(MPI_WTIME() - jclock)      call MPI_ALLREDUCE(nclock,time,1,mreal,MPI_MIN,lgrp,ierr)      mclock = time      call MPI_ALLREDUCE(nclock,time,1,mreal,MPI_MAX,lgrp,ierr)      call MPI_COMM_RANK(lgrp,idproc,ierr)      if (idproc.eq.0) write (6,91) chr, time, mclock      return      endc-----------------------------------------------------------------------      subroutine psum (f,g,nxp,nblok)c this subroutine performs a parallel sum of a vector, that is:c f(j,k) = sum over k of f(j,k)c assumes the number of processors nproc is a power of two.c the algorithm performs partial sums in binary pairs, as follows:c first, adjacent processors exchange vectors and sum them.  next,c processors separated by 2 exchange the new vectors and sum them, thenc those separated by 4, up to processors separated by nproc/2.  at thec end, all processors contain the same summation.c f = input and output datac g = scratch arrayc nxp = number of data values in vectorc nblok = number of data blocksc written by viktor k. decyk, ucla      implicit none      real f, g      integer nxp, nblok      dimension f(nxp,nblok), g(nxp,nblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplxc lstat = length of status array      parameter(lstat=8)c nproc = number of real or virtual processors obtainedc lgrp = current communicatorc mreal = default datatype for reals      common /pparms/ nproc, lgrp, mreal, mint, mcplxc local data      integer istatus      integer idproc, ierr, kstrt, ks, l, kxs, k, kb, lb, msid, j      dimension istatus(lstat)c find processor idc this line is used for shared memory computersc     idproc = 0c this line is used for mpi computers      call MPI_COMM_RANK(lgrp,idproc,ierr)      kstrt = idproc + 1      if (kstrt.gt.nproc) return      ks = kstrt - 2      l = 1      kxs = 1c main iteration loop   10 if (kxs.ge.nproc) go to 60c shift data      do 30 k = 1, nblok      kb = k + ks      lb = kb/kxs      kb = kb + 1      lb = lb - 2*(lb/2)c this loop is used for shared memory computersc     do 20 j = 1, nxpc     if (lb.eq.0) thenc        g(j,k) = f(j,kb+kxs)c     elsec        g(j,k) = f(j,kb-kxs)c     endifc  20 continuec this segment is used for mpi computers      if (lb.eq.0) then         call MPI_IRECV(g,nxp,mreal,kb+kxs-1,l+nxp,lgrp,msid,ierr)         call MPI_SEND(f,nxp,mreal,kb+kxs-1,l+nxp,lgrp,ierr)      else         call MPI_IRECV(g,nxp,mreal,kb-kxs-1,l+nxp,lgrp,msid,ierr)         call MPI_SEND(f,nxp,mreal,kb-kxs-1,l+nxp,lgrp,ierr)      endif      call MPI_WAIT(msid,istatus,ierr)   30 continuec perform sum      do 50 k = 1, nblok      do 40 j = 1, nxp      f(j,k) = f(j,k) + g(j,k)   40 continue   50 continue      l = l + 1      kxs = kxs + kxs      go to 10   60 return      endEOF#if77 -O -nx pfft2tst.f -L/usr/local/lib -lmpi -lOtools -lOsystem -o pfft2tst.out#f90 -O3 pfft2tst.f -o pfft2tst.out#mpprun -n 4 ./pfft2tst.outmpxlf -O3 -qfixed pfft2tst.f -o pfft2tst.out poe pfft2tst.out -procs 4 -rmpool 0rm pfft2tst.fexit