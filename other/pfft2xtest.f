c-----------------------------------------------------------------------      program pfft2xtest      implicit none      integer indx, indy, indnvp, mshare      integer nx, ny, nxh, nyh, nvp, kyp, kxp, kblok, jblok      integer kxp2, j2blok      integer nmx, nxy, nmxh, nxhy, nxv, nyv, nxvh, nxyhc indnvp = exponent which determines number of virtual processorsc mshare = (0,1) = (no,yes) architecture is shared memory      parameter( indx =   7, indy =   8, indnvp =   2, mshare =   0)      parameter(nx=2**indx,ny=2**indy)      parameter(nxh=nx/2,nyh=ny/2)      parameter(nvp=2**indnvp,kyp=(ny-1)/nvp+1,kxp=(nxh-1)/nvp+1)      parameter(kblok=1+mshare*(ny/kyp-1),jblok=1+mshare*(nxh/kxp-1))      parameter(kxp2=(nx-1)/nvp+1,j2blok=1+mshare*(nx/kxp2-1))      parameter(nmx=nx*(ny/nx)+ny*(nx/ny),nxy=nmx/(2-nx/nmx-ny/nmx))      parameter(nmxh=nxh*(ny/nxh)+ny*(nxh/ny))      parameter(nxhy=nmxh/(2-nxh/nmxh-ny/nmxh))      parameter(nxv=nx+2,nyv=ny+2,nxvh=nxv/2,nxyh=nxy/2)      integer ntpose, idproc, kstrt, ks, isign      integer j, k, l, j1, joff, kk, k1, koff      real time, ttp, epsmax, eps      double precision dtime, ranorm      dimension time(2)c      real h, f      integer mixup      complex g, sct, bs, br, zt1      dimension h(nxv,ny), f(nxv,kyp,kblok), g(nyv,kxp,jblok)      dimension mixup(nxhy), sct(nxyh)      integer mixupc      complex hc, fc, gc, sctc, bs2, br2      dimension hc(nxv,ny), fc(nxv,kyp,kblok), gc(nyv,kxp2,j2blok)      dimension bs(kxp,kyp,kblok), br(kxp,kyp,jblok)      dimension mixupc(nxy), sctc(nxyh)      dimension bs2(kxp2,kyp,kblok), br2(kxp2,kyp,j2blok)c ntpose = (0,1) = (no,yes) input, output data are transposed in pfft2r      data ntpose /0/c initialize for parallel processing      call PPINIT0(idproc,nvp)      kstrt = idproc + 1      ks = kstrt - 2c prepare fft tables      isign = 0c     call WFFT2RINIT(mixup,sct,indx,indy,nxhy,nxyh)c     call FFT2C(fc,isign,mixupc,sctc,indx,indy,nxv,nyv,nxy,nxyh)      call WPFFT2RINIT(mixup,sct,indx,indy,nxhy,nxyh)      call PFFT2C(fc,gc,bs2,br2,isign,ntpose,mixupc,sctc,indx,indy,kstrt     1,nxv,nyv,kxp2,kyp,kyp,j2blok,kblok,nxy,nxyh)c create test functions      do 30 k = 1, ny      kk = (k - 1)/kyp      k1 = k - kyp*kk      do 20 j = 1, nx      h(j,k) = ranorm()      hc(j,k) = cmplx(h(j,k),ranorm())      do 10 l = 1, kblok      if (kk.eq.(l+ks)) then         f(j,k1,l) = h(j,k)         fc(j,k1,l) = hc(j,k)      endif   10 continue   20 continue   30 continuec set time      call PTIMERA(-1,time,dtime)c complex to complex fourier space transform      isign = -1      call FFT2C(hc,isign,mixupc,sctc,indx,indy,nxv,nyv,nxy,nxyh)      call PFFT2C(fc,gc,bs2,br2,isign,ntpose,mixupc,sctc,indx,indy,kstrt     1,nxv,nyv,kxp2,kyp,kyp,j2blok,kblok,nxy,nxyh)c measure time      call PTIMERA(1,time,dtime)c verify complex fourier data      epsmax = 0.0      if (kstrt.gt.nx) go to 70      do 60 l = 1, j2blok      joff = kxp2*(l + ks)      do 50 j = 1, kxp2      j1 = j + joff      do 40 k = 1, ny      eps = abs(gc(k,j,l) - hc(j1,k))      if (eps.gt.epsmax) then         write (71,*) k,j,l,gc(k,j,l),hc(j1,k),eps         epsmax = eps      endif   40 continue   50 continue   60 continue   70 continue      write (71,*) 'local complex fourier epsmax=',epsmax      call PMAX(epsmax,eps,1,1)      write (71,*) 'global complex fourier epsmax=',epsmaxc fourier space to complex transform      isign = 1      call FFT2C(hc,isign,mixupc,sctc,indx,indy,nxv,nyv,nxy,nxyh)      call PFFT2C(fc,gc,bs2,br2,isign,ntpose,mixupc,sctc,indx,indy,kstrt     1,nxv,nyv,kxp2,kyp,kyp,j2blok,kblok,nxy,nxyh)c verify complex data      epsmax = 0.      if (kstrt.gt.ny) go to 110      do 100 l = 1, kblok      koff = kyp*(l + ks)      do 90 k = 1, kyp      k1 = k + koff      do 80 j = 1, nx      eps = abs(fc(j,k,l) - hc(j,k1))      if (eps.gt.epsmax) then         write (71,*) j,k,l,fc(j,k,l),hc(j,k1),eps         epsmax = eps      endif   80 continue   90 continue  100 continue  110 continue      write (71,*) 'local complex epsmax=',epsmax      call PMAX(epsmax,eps,1,1)      write (71,*) 'global complex epsmax=',epsmaxcc real to complex fourier space transform      isign = -1      call WFFT2RX(h,isign,mixup,sct,indx,indy,nxvh,nyv,nxhy,nxyh)      call WPFFT2R(f,g,bs,br,isign,ntpose,mixup,sct,ttp,indx,indy,kstrt,     1nxvh,nyv,kxp,kyp,kyp,jblok,kblok,nxhy,nxyh)c verify real fourier data      epsmax = 0.0      if (kstrt.gt.nxh) go to 150      do 140 l = 1, jblok      joff = kxp*(l + ks)      do 130 j = 1, kxp      j1 = j + joff      do 120 k = 1, ny      zt1 = cmplx(h(2*j1-1,k),h(2*j1,k))      eps = abs(g(k,j,l) - zt1)      if (eps.gt.epsmax) then         write (71,*) k,j,l,g(k,j,l),zt1,eps         epsmax = eps      endif  120 continue  130 continue  140 continue  150 continue      write (71,*) 'local real fourier epsmax=',epsmax      call PMAX(epsmax,eps,1,1)      write (71,*) 'global real fourier epsmax=',epsmaxc fourier space to real transform      isign = 1      call WFFT2RX(h,isign,mixup,sct,indx,indy,nxvh,nyv,nxhy,nxyh)      call WPFFT2R(f,g,bs,br,isign,ntpose,mixup,sct,ttp,indx,indy,kstrt,     1nxvh,nyv,kxp,kyp,kyp,jblok,kblok,nxhy,nxyh)c verify real data      epsmax = 0.      if (kstrt.gt.ny) go to 190      do 180 l = 1, kblok      koff = kyp*(l + ks)      do 170 k = 1, kyp      k1 = k + koff      do 160 j = 1, nx      eps = abs(f(j,k,l) - h(j,k1))      write (70,*) j,k,l,f(j,k,l),h(j,k1),eps      if (eps.gt.epsmax) then         write (71,*) j,k,l,f(j,k,l),h(j,k1),eps         epsmax = eps      endif  160 continue  170 continue  180 continue  190 continue      write (71,*) 'local real epsmax=',epsmax      call PMAX(epsmax,eps,1,1)      write (71,*) 'global real epsmax=',epsmaxc      call PPEXIT      stop      endc-----------------------------------------------------------------------      function vresult(prec)      implicit none      real prec, vresult      vresult = prec      return      endc-----------------------------------------------------------------------      subroutine PPINIT0(idproc,nvp)c this subroutine initializes parallel processingc input: nvp, output: idprocc idproc = processor id in lgrp communicatorc nvp = number of real or virtual processors requested      implicit none      integer idproc, nvpc get definition of MPI constants      include 'mpif.h'c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=10)c nproc = number of real or virtual processors obtainedc lgrp = current communicatorc mreal = default datatype for realsc mint = default datatype for integersc mcplx = default datatype for complex typec mdouble = default double precision typec lworld = MPI_COMM_WORLD communicator      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer ierror, ndprec      logical flag      real small, prec, vresult      save /PPARMS/      data small /1.0e-12/      prec = 1.0 + smallc ndprec = (0,1) = (no,yes) use (normal,autodouble) precision      if (vresult(prec).gt.1.0) then         ndprec = 1      else         ndprec = 0      endifc this segment is used for shared memory computersc     nproc = nvpc     idproc = 0c this segment is used for mpi computers      if (MPI_STATUS_SIZE.gt.lstat) then         write (2,*) ' status size too small, actual/required = ', lstat     1, MPI_STATUS_SIZE         stop      endifc indicate whether MPI_INIT has been called      call MPI_INITIALIZED(flag,ierror)      if (.not.flag) thenc initialize the MPI execution environment         call MPI_INIT(ierror)         if (ierror.ne.0) stop      endif      lworld = MPI_COMM_WORLD      lgrp = lworldc determine the rank of the calling process in the communicator      call MPI_COMM_RANK(lgrp,idproc,ierror)c determine the size of the group associated with a communicator      call MPI_COMM_SIZE(lgrp,nproc,ierror)c set default datatypes      mint = MPI_INTEGER      mdouble = MPI_DOUBLE_PRECISIONc single precision      if (ndprec.eq.0) then         mreal = MPI_REAL         mcplx = MPI_COMPLEXc double precision      elsec        mint = MPI_INTEGER8         mreal = MPI_DOUBLE_PRECISION         mcplx = MPI_DOUBLE_COMPLEX      endifc requested number of processors not obtained      if (nproc.ne.nvp) then         write (2,*) ' processor number error: nvp, nproc=', nvp, nproc         call ppexit         stop      endif      return      endc-----------------------------------------------------------------------      subroutine PPEXITc this subroutine terminates parallel processing      implicit nonec common block for parallel processing      integer nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc lworld = MPI_COMM_WORLD communicator      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworld      integer ierror      logical flagc indicate whether MPI_INIT has been called      call MPI_INITIALIZED(flag,ierror)      if (flag) thenc synchronize processes         call MPI_BARRIER(lworld,ierror)c terminate MPI execution environment         call MPI_FINALIZE(ierror)      endif      return      endc-----------------------------------------------------------------------      subroutine WPFFT2RINIT(mixup,sct,indx,indy,nxhyd,nxyhd)c this subroutine calculates tables needed by a two dimensionalc real to complex fast fourier transform and its inverse.c input: indx, indy, nxhyd, nxyhdc output: mixup, sctc mixup = array of bit reversed addressesc sct = sine/cosine tablec indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc nxhyd = maximum of (nx/2,ny)c nxyhd = one half of maximum of (nx,ny)c written by viktor k. decyk, ucla      implicit none      integer indx, indy, nxhyd, nxyhd      integer mixup      complex sct      dimension mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, ny, nxy, nxhy, nxyh      integer j, k, lb, ll, jb, it      real dnxy, arg      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      ny = 2**indy      nxy = max0(nx,ny)      nxhy = 2**indx1yc bit-reverse index table: mixup(j) = 1 + reversed bits of (j - 1)      do 20 j = 1, nxhy      lb = j - 1      ll = 0      do 10 k = 1, indx1y      jb = lb/2      it = lb - 2*jb      lb = jb      ll = 2*ll + it   10 continue      mixup(j) = ll + 1   20 continuec sine/cosine table for the angles 2*n*pi/nxy      nxyh = nxy/2      dnxy = 6.28318530717959/float(nxy)      do 30 j = 1, nxyh      arg = dnxy*float(j - 1)      sct(j) = cmplx(cos(arg),-sin(arg))   30 continue      return      endc-----------------------------------------------------------------------      subroutine WPFFT2R(f,g,bs,br,isign,ntpose,mixup,sct,ttp,indx,indy,     1kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)c wrapper function for parallel real to complex fft      implicit none      integer isign, ntpose, indx, indy, kstrt, nxvh, nyv, kxp, kyp      integer kypd, jblok, kblok, nxhyd, nxyhd, mixup      real ttp      complex f, g, bs, br, sct      dimension f(nxvh,kypd,kblok), g(nyv,kxp,jblok)      dimension bs(kxp,kyp,kblok), br(kxp,kyp,jblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer nxh, ny, kxpi, kypi      real tf      double precision dtime      data kxpi, kypi /1,1/c calculate range of indices      nxh = 2**(indx - 1)      ny = 2**indyc inverse fourier transform      if (isign.lt.0) thenc perform x fft         call PFFT2RXX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kyp,nxvh,k     1ypd,kblok,nxhyd,nxyhd)c transpose f array to g         call PWTIMERA(-1,ttp,dtime)         call PTPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kypd,jb     1lok,kblok)         call PWTIMERA(1,ttp,dtime)c perform y fft         call PFFT2RXY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxp,nyv,kx     1p,jblok,nxhyd,nxyhd)c transpose g array to f         if (ntpose.eq.0) then            call PWTIMERA(-1,tf,dtime)            call PTPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kxp     1,kblok,jblok)            call PWTIMERA(1,tf,dtime)         endifc forward fourier transform      else if (isign.gt.0) thenc transpose f array to g         if (ntpose.eq.0) then            call PWTIMERA(-1,tf,dtime)            call PTPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kypd     1,jblok,kblok)            call PWTIMERA(1,tf,dtime)         endifc perform y fft         call PFFT2RXY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxp,nyv,kx     1p,jblok,nxhyd,nxyhd)c transpose g array to f         call PWTIMERA(-1,ttp,dtime)         call PTPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kxp,kb     1lok,jblok)         call PWTIMERA(1,ttp,dtime)c perform x fft         call PFFT2RXX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kyp,nxvh,k     1ypd,kblok,nxhyd,nxyhd)      endif      if (ntpose.eq.0) ttp = ttp + tf      return      endc-----------------------------------------------------------------------      subroutine PFFT2RXX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kypp,nx     1vh,kypd,kblok,nxhyd,nxyhd)c this subroutine performs the x part of a two dimensional real toc complex fast fourier transform and its inverse, for a subset of y,c using complex arithmetic, for data which is distributed in blocksc for isign = (-1,1), input: all, output: fc for isign = -1, approximate flop count: N*(5*log2(N) + 10)/nvpc for isign = 1,  approximate flop count: N*(5*log2(N) + 8)/nvpc where N = (nx/2)*ny, and nvp = number of procsc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, an inverse fourier transform is performedc f(n,m,i) = (1/nx*ny)*sum(f(j,k,i)*exp(-sqrt(-1)*2pi*n*j/nx)c if isign = 1, a forward fourier transform is performedc f(j,k,i) = sum(f(n,m,i)*exp(sqrt(-1)*2pi*n*j/nx)c kstrt = starting data block numberc kypi = initial y index usedc kypp = number of y indices usedc nxvh = first dimension of fc kypd = second dimension of fc kblok = number of data blocks in yc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxhyd = maximum of (nx/2,ny)c nxyhd = one half of maximum of (nx,ny)c the real data is stored in a complex array of length nx/2, nyc with the odd/even x points stored in the real/imaginary parts.c in complex notation, fourier coefficients are stored as follows:c f(j,k,i) = mode j-1,kk-1, where kk = k + kyp*(i - 1)c 1 <= j <= nx/2 and 1 <= kk <= ny, except forc f(1,k,i) = mode nx/2,kk-1, where ny/2+2 <= kk <= ny, andc imaginary part of f(1,1,1) = real part of mode nx/2,0 andc imaginary part of f(1,1,(ny/2)/kyp+1) = real part of mode nx/2,ny/2c written by viktor k. decyk, uclac parallel, RISC optimized version      implicit none      integer isign, mixup, indx, indy, kstrt, nxvh, kypi, kypp      integer kypd, kblok, nxhyd, nxyhd      complex f, sct      dimension f(nxvh,kypd,kblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, nxh, nxhh, nxh2, ny      integer nxy, nxhy, ks, kypt, j, k, nrx      integer l, i, m, ns, ns2, km, kmr, k1, k2, j1, j2      real ani      complex s, t, t1      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nxh2 = nxh + 2      ny = 2**indy      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      kypt = kypi + kypp - 1      if (kstrt.gt.ny) return      if (isign.gt.0) go to 130c inverse fourier transform      ani = 1./float(2*nx*ny)      nrx = nxhy/nxh      do 30 l = 1, kblokc bit-reverse array elements in x      do 20 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 20      do 10 k = kypi, kypt      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = t   10 continue   20 continue   30 continuec first transform in x      nrx = nxy/nxh      do 80 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 70 l = 1, kblok      do 60 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 50 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 40 i = kypi, kypt      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t   40 continue   50 continue   60 continue   70 continue   80 continuec unscramble coefficients and normalize      kmr = nxy/nx      do 120 l = 1, kblok      do 100 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),-real(sct(1+kmr*(j-1))))      do 90 k = kypi, kypt      t = conjg(f(nxh2-j,k,l))      s = f(j,k,l) + t      t = (f(j,k,l) - t)*t1      f(j,k,l) = ani*(s + t)      f(nxh2-j,k,l) = ani*conjg(s - t)   90 continue  100 continue      do 110 k = kypi, kypt      f(nxhh+1,k,l) = 2.*ani*conjg(f(nxhh+1,k,l))      f(1,k,l) = 2.*ani*cmplx(real(f(1,k,l)) + aimag(f(1,k,l)),real(f(1,     1k,l)) - aimag(f(1,k,l)))  110 continue  120 continue      returnc forward fourier transform  130 kmr = nxy/nx      do 190 l = 1, kblokc scramble coefficients      do 150 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),real(sct(1+kmr*(j-1))))      do 140 k = kypi, kypt      t = conjg(f(nxh2-j,k,l))      s = f(j,k,l) + t      t = (f(j,k,l) - t)*t1      f(j,k,l) = s + t      f(nxh2-j,k,l) = conjg(s - t)  140 continue  150 continue      do 160 k = kypi, kypt      f(nxhh+1,k,l) = 2.*conjg(f(nxhh+1,k,l))      f(1,k,l) = cmplx(real(f(1,k,l)) + aimag(f(1,k,l)),real(f(1,k,l)) -     1 aimag(f(1,k,l)))  160 continue      nrx = nxhy/nxhc bit-reverse array elements in x      do 180 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 180      do 170 k = kypi, kypt      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = t  170 continue  180 continue  190 continuec then transform in x      nrx = nxy/nxh      do 240 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 230 l = 1, kblok      do 220 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 210 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 200 i = kypi, kypt      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t  200 continue  210 continue  220 continue  230 continue  240 continue      return      endc-----------------------------------------------------------------------      subroutine PFFT2RXY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxpp,ny     1v,kxp,jblok,nxhyd,nxyhd)c this subroutine performs the y part of a two dimensional real toc complex fast fourier transform and its inverse, for a subset of x,c using complex arithmetic, for data which is distributed in blocksc for isign = (-1,1), input: all, output: f, gc for isign = -1, approximate flop count: N*(5*log2(N) + 10)/nvpc for isign = 1,  approximate flop count: N*(5*log2(N) + 8)/nvpc where N = (nx/2)*ny, and nvp = number of procsc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, an inverse fourier transform is performedc g(m,n,i) = sum(g(k,j,i)*exp(-sqrt(-1)*2pi*m*k/ny))c if isign = 1, a forward fourier transform is performedc g(k,j,i) = sum(g(m,n,i)*exp(sqrt(-1)*2pi*m*k/ny))c kstrt = starting data block numberc kxpi = initial x index usedc kxpp = number of   indices usedc nyv = first dimension of gc kxp = number of data values per block in xc jblok = number of data blocks in xc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxhyd = maximum of (nx/2,ny)c nxyhd = one half of maximum of (nx,ny)c the real data is stored in a complex array of length nx/2, nyc with the odd/even x points stored in the real/imaginary parts.c in complex notation, fourier coefficients are stored as follows:c g(k,j,i) = mode jj-1,k-1, where jj = j + kxp*(i - 1)c 1 <= jj <= nx/2 and 1 <= k <= ny, except forc g(k,1,1) = mode nx/2,k-1, where ny/2+2 <= k <= ny, andc imaginary part of g(1,1,1) = real part of mode nx/2,0 andc imaginary part of g(ny/2+1,1,1) = real part of mode nx/2,ny/2c written by viktor k. decyk, uclac parallel, RISC optimized version      implicit none      integer isign, mixup, indx, indy, kstrt, kxpi, kxpp, nyv      integer kxp, jblok, nxhyd, nxyhd      complex g, sct      dimension g(nyv,kxp,jblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, nxh, ny, nyh, ny2      integer nxy, nxhy, ks, kxpt, j, k, nry      integer l, i, m, ns, ns2, km, kmr, k1, k2, j1, j2      complex s, t      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      ny = 2**indy      nyh = ny/2      ny2 = ny + 2      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      kxpt = kxpi + kxpp - 1      if (kstrt.gt.nxh) return      if (isign.gt.0) go to 110c inverse fourier transform      nry = nxhy/ny      do 30 l = 1, jblokc bit-reverse array elements in y      do 20 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 20      do 10 j = kxpi, kxpt      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = t   10 continue   20 continue   30 continuec then transform in y      nry = nxy/ny      do 80 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 70 l = 1, jblok      do 60 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 50 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 40 i = kxpi, kxpt      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t   40 continue   50 continue   60 continue   70 continue   80 continuec unscramble modes kx = 0, nx/2      do 100 l = 1, jblok      if ((l+ks).gt.0) go to 100      do 90 k = 2, nyh      if (kxpi.eq.1) then         s = g(ny2-k,1,l)         g(ny2-k,1,l) = .5*cmplx(aimag(g(k,1,l) + s),real(g(k,1,l) - s))         g(k,1,l) = .5*cmplx(real(g(k,1,l) + s),aimag(g(k,1,l) - s))      endif   90 continue  100 continue      returnc forward fourier transformc scramble modes kx = 0, nx/2  110 nry = nxhy/ny      do 160 l = 1, jblok      if ((l+ks).gt.0) go to 130      do 120 k = 2, nyh      if (kxpi.eq.1) then         s = cmplx(aimag(g(ny2-k,1,l)),real(g(ny2-k,1,l)))         g(ny2-k,1,l) = conjg(g(k,1,l) - s)         g(k,1,l) = g(k,1,l) + s      endif  120 continuec bit-reverse array elements in y  130 do 150 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 150      do 140 j = kxpi, kxpt      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = t  140 continue  150 continue  160 continuec first transform in y      nry = nxy/ny      do 210 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 200 l = 1, jblok      do 190 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 180 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 170 i = kxpi, kxpt      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t  170 continue  180 continue  190 continue  200 continue  210 continue      return      endc-----------------------------------------------------------------------      subroutine PFFT2C(f,g,bs,br,isign,ntpose,mixup,sct,indx,indy,kstrt     1,nxv,nyv,kxp,kyp,kypd,jblok,kblok,nxyd,nxyhd)c this subroutine performs a two dimensional complex to complex fastc fourier transform and its inverse, using complex arithmetic,c for data which is distributed in blocksc for isign = 0, input: isign, indx, indy, kstrt, nxyd, nxyhdc output: mixup, sctc for isign = (-1,1), input: all, output: f, g, bs, brc approximate flop count: 5*N*log2(N)/nvpc where N = nx*ny, and nvp = number of procsc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc ntpose = (0,1) = (no,yes) input, output data are transposedc if isign = 0, the fft tables are preparedc if isign = -1, an inverse fourier transform is performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(n,m,l) = (1/nx*ny)*sum(f(j,k,i)*c       exp(-sqrt(-1)*2pi*n*j/nx)*exp(-sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, f is the input and g is the outputc g(m,n,l) = (1/nx*ny)*sum(f(j,k,i)*c       exp(-sqrt(-1)*2pi*nn*j/nx)*exp(-sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c if isign = 1, a forward fourier transform is performedc if ntpose = 0, f is the input and output array, g is a scratch arrayc f(j,k,i) = sum(f(n,m,l)*exp(sqrt(-1)*2pi*n*j/nx)*c       exp(sqrt(-1)*2pi*mm*kk/ny))c where mm = m + kyp*(l - 1) and kk = k + kyp*(i - 1)c if ntpose = 1, g is the input and f is the outputc f(j,k,i) = sum(g(m,n,l)*exp(sqrt(-1)*2pi*nn*j/nx)*c       exp(sqrt(-1)*2pi*m*kk/ny))c where nn = n + kxp*(l - 1) and kk = k + kyp*(i - 1)c bs, br = scratch arraysc kstrt = starting data block numberc nxv/nyv = first dimension of f/gc kypd = second dimension of f c kxp/kyp = number of data values per block in x/yc jblok/kblok = number of data blocks in x/yc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxy = maximum of (nx,ny)c nxyh = one half of maximum of (nx,ny)c written by viktor k. decyk, uclac parallel version      implicit none      integer isign, ntpose, indx, indy, kstrt, nxv, nyv, kxp, kyp      integer kypd, jblok, kblok, nxyd, nxyhd, mixup      complex f, g, bs, br, sct      dimension f(nxv,kypd,kblok), g(nyv,kxp,jblok)      dimension bs(kxp,kyp,kblok), br(kxp,kyp,jblok)      dimension mixup(nxyd), sct(nxyhd)c local data      integer indxy, nx, nxh, ny, nyh, nxy, j, k, lb, ll, jb, it, nxyh      integer nrx, nry, l, i, m, ns, ns2, km, kmr, k1, k2, j1, j2      real dnxy, arg, ani      complex s, t      indxy = max0(indx,indy)      nx = 2**indx      nxh = nx/2      ny = 2**indy      nyh = ny/2      nxy = 2**indxy      if (isign) 50, 10, 270c prepare fft tablesc bit-reverse index table: mixup(j) = 1 + reversed bits of (j - 1)   10 do 30 j = 1, nxy      lb = j - 1      ll = 0      do 20 k = 1, indxy      jb = lb/2      it = lb - 2*jb      lb = jb      ll = 2*ll + it   20 continue      mixup(j) = ll + 1   30 continuec sine/cosine table for the angles 2*n*pi/nxy      nxyh = nxy/2      dnxy = 6.28318530717959/float(nxy)      do 40 j = 1, nxyh      arg = dnxy*float(j - 1)      sct(j) = cmplx(cos(arg),-sin(arg))   40 continue      returnc inverse fourier transform   50 if (kstrt.gt.ny) go to 140      nrx = nxy/nx      do 80 l = 1, kblokc bit-reverse array elements in x      do 70 j = 1, nx      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 70      do 60 k = 1, kyp      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = t   60 continue   70 continue   80 continuec first transform in x      do 130 m = 1, indx      ns = 2**(m - 1)      ns2 = ns + ns      km = nxh/ns      kmr = km*nrx      do 120 l = 1, kblok      do 110 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 100 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 90 i = 1, kyp      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t   90 continue  100 continue  110 continue  120 continue  130 continuec transpose f array to g  140 call PTPOSE(f,g,bs,br,nx,ny,kstrt,nxv,nyv,kxp,kyp,kxp,kypd,jblok,k     1blok)      if (kstrt.gt.nx) go to 260      nry = nxy/ny      do 170 l = 1, jblokc bit-reverse array elements in y      do 160 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 160      do 150 j = 1, kxp      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = t  150 continue  160 continue  170 continuec then transform in y      do 220 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 210 l = 1, jblok      do 200 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 190 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 180 i = 1, kxp      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t  180 continue  190 continue  200 continue  210 continue  220 continuec normalize result      ani = 1./float(nx*ny)      do 250 l = 1, jblok      do 240 j = 1, kxp      do 230 k = 1, ny      g(k,j,l) = g(k,j,l)*ani  230 continue  240 continue  250 continuec transpose g array to f  260 if (ntpose.eq.0) call PTPOSE(g,f,br,bs,ny,nx,kstrt,nyv,nxv,kyp,kxp     1,kypd,kxp,kblok,jblok)      returnc forward fourier transformc transpose f array to g  270 if (ntpose.eq.0) call PTPOSE(f,g,bs,br,nx,ny,kstrt,nxv,nyv,kxp,kyp     1,kxp,kypd,jblok,kblok)      if (kstrt.gt.nx) go to 360      nry = nxy/ny      do 300 l = 1, jblokc bit-reverse array elements in y      do 290 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 290      do 280 j = 1, kxp      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = t  280 continue  290 continue  300 continuec first transform in y      do 350 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 340 l = 1, jblok      do 330 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 320 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 310 i = 1, kxp      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t  310 continue  320 continue  330 continue  340 continue  350 continuec transpose g array to f  360 call PTPOSE(g,f,br,bs,ny,nx,kstrt,nyv,nxv,kyp,kxp,kypd,kxp,kblok,j     1blok)      if (kstrt.gt.ny) return      nrx = nxy/nx      do 390 l = 1, kblokc bit-reverse array elements in x      do 380 j = 1, nx      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 380      do 370 k = 1, kyp      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = t  370 continue  380 continue  390 continuec then transform in x      do 440 m = 1, indx      ns = 2**(m - 1)      ns2 = ns + ns      km = nxh/ns      kmr = km*nrx      do 430 l = 1, kblok      do 420 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 410 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 400 i = 1, kyp      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t  400 continue  410 continue  420 continue  430 continue  440 continue      return      endc-----------------------------------------------------------------------      subroutine PTPOSE(f,g,s,t,nx,ny,kstrt,nxv,nyv,kxp,kyp,kxpd,kypd,jb     1lok,kblok)c this subroutine performs a transpose of a matrix f, distributed in y,c to a matrix g, distributed in x, that is,c g(k+kyp*(m-1),j,l) = f(j+kxp*(l-1),k,m), wherec 1 <= j <= kxp, 1 <= k <= kyp, 1 <= l <= nx/kxp, 1 <= m <= ny/kypc and where indices l and m can be distributed across processors.c this subroutine sends and receives one message at a time, eitherc synchronously or asynchronously. it uses a minimum of system resourcesc f = complex input arrayc g = complex output arrayc s, t = complex scratch arraysc nx/ny = number of points in x/yc kstrt = starting data block numberc nxv/nyv = first dimension of f/gc kypd/kxpd = second dimension of f/gc kxp/kyp = number of data values per block in x/yc jblok/kblok = number of data blocks in x/y      implicit none      integer nx, ny, kstrt, nxv, nyv, kxp, kyp, kxpd, kypd      integer jblok, kblok      complex f, g, s, t      dimension f(nxv,kypd,kblok), g(nyv,kxpd,jblok)      dimension s(kxp,kyp,kblok), t(kxp,kyp,jblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=10)c lgrp = current communicatorc mcplx = default datatype for complex      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer ks, kxb, kyb      integer jkblok, kxym, mtr, ntr, mntr      integer l, i, joff, koff, k, j      integer ir0, is0, ii, ir, is, ierr, msid, istatus      dimension istatus(lstat)      ks = kstrt - 2      kxb = nx/kxp      kyb = ny/kypc this segment is used for shared memory computersc     if (kstrt.gt.nx) returnc     do 40 l = 1, jblokc     joff = kxp*(l + ks)c     do 30 i = 1, kybc     koff = kyp*(i - 1)c     do 20 k = 1, kypc     do 10 j = 1, kxpc     g(k+koff,j,l) = f(j+joff,k,i)c  10 continuec  20 continuec  30 continuec  40 continuec this segment is used for mpi computers      jkblok = max0(jblok,kblok)      kxym = min0(kxb,kyb)      mtr = kyb/kxym      ntr = kxb/kxym      mntr = max0(mtr,ntr)      do 70 l = 1, jkblok      do 60 i = 1, kxym      ir0 = iand(kxym-1,ieor(l+ks,i-1)) + 1      is0 = ir0      do 50 ii = 1, mntrc post receive      if ((kstrt.le.nx).and.(ii.le.mtr)) then         ir = ir0 + kxym*(ii - 1)         call MPI_IRECV(t(1,1,l),kxp*kyp,mcplx,ir-1,ir+kxym+1,lgrp,msid,     1ierr)      endifc send data      if ((kstrt.le.ny).and.(ii.le.ntr)) then         is = is0 + kxym*(ii - 1)         joff = kxp*(is - 1)         do 20 k = 1, kyp         do 10 j = 1, kxp         s(j,k,l) = f(j+joff,k,l)   10    continue   20    continue         call MPI_SEND(s(1,1,l),kxp*kyp,mcplx,is-1,l+ks+kxym+2,lgrp,ierr     1)      endifc receive data      if ((kstrt.le.nx).and.(ii.le.mtr)) then         koff = kyp*(ir - 1)         call MPI_WAIT(msid,istatus,ierr)         do 40 k = 1, kyp         do 30 j = 1, kxp         g(k+koff,j,l) = t(j,k,l)   30    continue   40    continue      endif   50 continue   60 continue   70 continue      return      endc-----------------------------------------------------------------------      subroutine PMAX(f,g,nxp,nblok)c this subroutine finds parallel maximum for each element of a vectorc that is, f(j,k) = maximum as a function of k of f(j,k)c assumes the number of processors nproc is a power of two.c the algorithm performs partial sums in binary pairs, as follows:c first, adjacent processors exchange vectors and sum them.  next,c processors separated by 2 exchange the new vectors and sum them, thenc those separated by 4, up to processors separated by nproc/2.  at thec end, all processors contain the same summation.c f = input and output datac g = scratch arrayc nxp = number of data values in vectorc nblok = number of data blocksc written by viktor k. decyk, ucla      implicit none      real f, g      integer nxp, nblok      dimension f(nxp,nblok), g(nxp,nblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=10)c nproc = number of real or virtual processors obtainedc lgrp = current communicatorc mreal = default datatype for reals      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer istatus, ierr, msid      integer idproc, kstrt, ks, l, kxs, k, kb, lb, j      dimension istatus(lstat)c find processor idc this line is used for shared memory computersc     idproc = 0c this line is used for mpi computers      call MPI_COMM_RANK(lgrp,idproc,ierr)      kstrt = idproc + 1      if (kstrt.gt.nproc) return      ks = kstrt - 2      l = 1      kxs = 1c main iteration loop   10 if (kxs.ge.nproc) go to 60c shift data      do 30 k = 1, nblok      kb = k + ks      lb = kb/kxs      kb = kb + 1      lb = lb - 2*(lb/2)c this loop is used for shared memory computersc     do 20 j = 1, nxpc     if (lb.eq.0) thenc        g(j,k) = f(j,kb+kxs)c     elsec        g(j,k) = f(j,kb-kxs)c     endifc  20 continuec this segment is used for mpi computers      if (lb.eq.0) then         call MPI_IRECV(g,nxp,mreal,kb+kxs-1,l+nxp,lgrp,msid,ierr)         call MPI_SEND(f,nxp,mreal,kb+kxs-1,l+nxp,lgrp,ierr)      else         call MPI_IRECV(g,nxp,mreal,kb-kxs-1,l+nxp,lgrp,msid,ierr)         call MPI_SEND(f,nxp,mreal,kb-kxs-1,l+nxp,lgrp,ierr)      endif      call MPI_WAIT(msid,istatus,ierr)   30 continuec find maximum      do 50 k = 1, nblok      do 40 j = 1, nxp      f(j,k) = amax1(f(j,k),g(j,k))   40 continue   50 continue      l = l + 1      kxs = kxs + kxs      go to 10   60 return      endc-----------------------------------------------------------------------      subroutine PTIMERA(icntrl,time,dtime)c this subroutine performs parallel wall clock timingc input: icntrl, dtimec icntrl = (-1,0,1) = (initialize,ignore,read) clockc clock should be initialized before it is read!c time = maximum/minimum elapsed time in secondsc dtime = current timec written for mpi      implicit none      integer icntrl      real time      double precision dtime      dimension time(2)c get definition of MPI constants      include 'mpif.h'c common block for parallel processing      integer nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc lgrp = current communicatorc mreal = default datatype for reals      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer ierr      real nclock, ttime      double precision jclock      dimension ttime(2)c initialize clock      if (icntrl.eq.(-1)) then         call MPI_BARRIER(lgrp,ierr)         dtime = MPI_WTIME()c read clock and write time difference from last clock initialization      else if (icntrl.eq.1) then         jclock = dtime         dtime = MPI_WTIME()         nclock = real(dtime - jclock)         ttime(1) = nclock         ttime(2) = -nclock         call MPI_ALLREDUCE(ttime,time,2,mreal,MPI_MAX,lgrp,ierr)         time(2) = -time(2)      endif      return      endc-----------------------------------------------------------------------      subroutine PWTIMERA(icntrl,time,dtime)c this subroutine performs local wall clock timingc input: icntrl, dtimec icntrl = (-1,0,1) = (initialize,ignore,read) clockc clock should be initialized before it is read!c time = elapsed time in secondsc dtime = current timec written for mpi      implicit none      integer icntrl      real time      double precision dtimec local data      double precision jclock      double precision MPI_WTIME      external MPI_WTIMEc initialize clock      if (icntrl.eq.(-1)) then         dtime = MPI_WTIME()c read clock and write time difference from last clock initialization      else if (icntrl.eq.1) then         jclock = dtime         dtime = MPI_WTIME()         time = real(dtime - jclock)      endif      return      endc-----------------------------------------------------------------------      subroutine WFFT2RINIT(mixup,sct,indx,indy,nxhyd,nxyhd)c this subroutine calculates tables needed by a two dimensionalc real to complex fast fourier transform and its inverse.c input: indx, indy, nxhyd, nxyhdc output: mixup, sctc mixup = array of bit reversed addressesc sct = sine/cosine tablec indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc nxhyd = maximum of (nx/2,ny)c nxyhd = one half of maximum of (nx,ny)c written by viktor k. decyk, ucla      implicit none      integer indx, indy, nxhyd, nxyhd      integer mixup      complex sct      dimension mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, ny, nxy, nxhy, nxyh      integer j, k, lb, ll, jb, it      real dnxy, arg      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      ny = 2**indy      nxy = max0(nx,ny)      nxhy = 2**indx1yc bit-reverse index table: mixup(j) = 1 + reversed bits of (j - 1)      do 20 j = 1, nxhy      lb = j - 1      ll = 0      do 10 k = 1, indx1y      jb = lb/2      it = lb - 2*jb      lb = jb      ll = 2*ll + it   10 continue      mixup(j) = ll + 1   20 continuec sine/cosine table for the angles 2*n*pi/nxy      nxyh = nxy/2      dnxy = 6.28318530717959/float(nxy)      do 30 j = 1, nxyh      arg = dnxy*float(j - 1)      sct(j) = cmplx(cos(arg),-sin(arg))   30 continue      return      endc-----------------------------------------------------------------------      subroutine WFFT2RX(f,isign,mixup,sct,indx,indy,nxhd,nyd,nxhyd,nxyh     1d)c wrapper function for real to complex fft      implicit none      complex f, sct      integer mixup      integer isign, indx, indy, nxhd, nyd, nxhyd, nxyhd      dimension f(nxhd,nyd), mixup(nxhyd), sct(nxyhd)c local data      integer nxh, ny, nxi, nyi      data nxi, nyi /1,1/c calculate range of indices      nxh = 2**(indx - 1)      ny = 2**indyc inverse fourier transform      if (isign.lt.0) thenc perform x fft         call FFT2RXX(f,isign,mixup,sct,indx,indy,nyi,ny,nxhd,nyd,nxhyd,     1nxyhd)c perform y fft         call FFT2RXY(f,isign,mixup,sct,indx,indy,nxi,nxh,nxhd,nyd,nxhyd     1,nxyhd)c forward fourier transform      else if (isign.gt.0) thenc perform y fft         call FFT2RXY(f,isign,mixup,sct,indx,indy,nxi,nxh,nxhd,nyd,nxhyd     1,nxyhd)c perform x fft         call FFT2RXX(f,isign,mixup,sct,indx,indy,nyi,ny,nxhd,nyd,nxhyd,     1nxyhd)      endif      return      endc-----------------------------------------------------------------------      subroutine FFT2RXX(f,isign,mixup,sct,indx,indy,nyi,nyp,nxhd,nyd,nx     1hyd,nxyhd)c this subroutine performs the x part of a two dimensional real toc complex fast fourier transform and its inverse, for a subset of y,c using complex arithmeticc for isign = (-1,1), input: all, output: fc for isign = -1, approximate flop count: N*(5*log2(N) + 19/2)c for isign = 1,  approximate flop count: N*(5*log2(N) + 15/2)c where N = (nx/2)*nyc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, an inverse fourier transform is performedc f(n,m) = (1/nx*ny)*sum(f(j,k)*c       exp(-sqrt(-1)*2pi*n*j/nx)*exp(-sqrt(-1)*2pi*m*k/ny))c if isign = 1, a forward fourier transform is performedc f(j,k) = sum(f(n,m)*exp(sqrt(-1)*2pi*n*j/nx)*exp(sqrt(-1)*2pi*m*k/ny))c mixup = array of bit reversed addressesc sct = sine/cosine tablec nyi = initial y index usedc nyp = number of y indices usedc nxhd = first dimension of fc nyd = second dimension of fc nxhyd = maximum of (nx/2,ny)c nxyhd = maximum of (nx,ny)/2c fourier coefficients are stored as follows:c f(2*j-1,k),f(2*j,k) = real, imaginary part of mode j-1,k-1, wherec 1 <= j <= nx/2 and 1 <= k <= ny, except forc f(1,k),f(2,k) = real, imaginary part of mode nx/2,k-1, wherec ny/2+2 <= k <= ny, andc f(2,1) = real part of mode nx/2,0 andc f(2,ny/2+1) = real part of mode nx/2,ny/2c written by viktor k. decyk, ucla      complex f, sct, t1, t2, t3      dimension f(nxhd,nyd), mixup(nxhyd), sct(nxyhd)      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nxh2 = nxh + 2      ny = 2**indy      nxy = max0(nx,ny)      nxhy = 2**indx1y      nyt = nyi + nyp - 1      if (isign.gt.0) go to 100c inverse fourier transformc bit-reverse array elements in x      nrx = nxhy/nxh      do 20 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 20      do 10 k = nyi, nyt      t1 = f(j1,k)      f(j1,k) = f(j,k)      f(j,k) = t1   10 continue   20 continuec first transform in x      nrx = nxy/nxh      do 60 l = 1, indx1      ns = 2**(l - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 50 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 40 j = 1, ns      j1 = j + k1      j2 = j + k2      t1 = sct(1+kmr*(j-1))      do 30 i = nyi, nyt      t2 = t1*f(j2,i)      f(j2,i) = f(j1,i) - t2      f(j1,i) = f(j1,i) + t2   30 continue   40 continue   50 continue   60 continuec unscramble coefficients and normalize      kmr = nxy/nx      ani = 1./float(2*nx*ny)      do 80 j = 2, nxhh      t3 = cmplx(aimag(sct(1+kmr*(j-1))),-real(sct(1+kmr*(j-1))))      do 70 k = nyi, nyt      t2 = conjg(f(nxh2-j,k))      t1 = f(j,k) + t2      t2 = (f(j,k) - t2)*t3      f(j,k) = ani*(t1 + t2)      f(nxh2-j,k) = ani*conjg(t1 - t2)   70 continue   80 continue      ani = 2.*ani      do 90 k = nyi, nyt      f(nxhh+1,k) = ani*conjg(f(nxhh+1,k))      f(1,k) = ani*cmplx(real(f(1,k)) + aimag(f(1,k)),real(f(1,k)) - aim     1ag(f(1,k)))   90 continue      returnc forward fourier transformc scramble coefficients  100 kmr = nxy/nx      do 120 j = 2, nxhh      t3 = cmplx(aimag(sct(1+kmr*(j-1))),real(sct(1+kmr*(j-1))))      do 110 k = nyi, nyt      t2 = conjg(f(nxh2-j,k))      t1 = f(j,k) + t2      t2 = (f(j,k) - t2)*t3      f(j,k) = t1 + t2      f(nxh2-j,k) = conjg(t1 - t2)  110 continue  120 continue      do 130 k = nyi, nyt      f(nxhh+1,k) = 2.*conjg(f(nxhh+1,k))      f(1,k) = cmplx(real(f(1,k)) + aimag(f(1,k)),real(f(1,k)) - aimag(f     1(1,k)))  130 continuec bit-reverse array elements in x      nrx = nxhy/nxh      do 150 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 150      do 140 k = nyi, nyt      t1 = f(j1,k)      f(j1,k) = f(j,k)      f(j,k) = t1  140 continue  150 continuec then transform in x      nrx = nxy/nxh      do 190 l = 1, indx1      ns = 2**(l - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 180 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 170 j = 1, ns      j1 = j + k1      j2 = j + k2      t1 = conjg(sct(1+kmr*(j-1)))      do 160 i = nyi, nyt      t2 = t1*f(j2,i)      f(j2,i) = f(j1,i) - t2      f(j1,i) = f(j1,i) + t2  160 continue  170 continue  180 continue  190 continue      return      endc-----------------------------------------------------------------------      subroutine FFT2RXY(f,isign,mixup,sct,indx,indy,nxi,nxp,nxhd,nyd,nx     1hyd,nxyhd)c this subroutine performs the y part of a two dimensional real toc complex fast fourier transform and its inverse, for a subset of x,c using complex arithmeticc for isign = (-1,1), input: all, output: fc for isign = -1, approximate flop count: N*(5*log2(N) + 19/2)c for isign = 1,  approximate flop count: N*(5*log2(N) + 15/2)c where N = (nx/2)*nyc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, an inverse fourier transform is performedc f(n,m) = (1/nx*ny)*sum(f(j,k)*c       exp(-sqrt(-1)*2pi*n*j/nx)*exp(-sqrt(-1)*2pi*m*k/ny))c if isign = 1, a forward fourier transform is performedc f(j,k) = sum(f(n,m)*exp(sqrt(-1)*2pi*n*j/nx)*exp(sqrt(-1)*2pi*m*k/ny))c mixup = array of bit reversed addressesc sct = sine/cosine tablec nxi = initial x index usedc nxp = number of x indices usedc nxhd = first dimension of fc nyd = second dimension of fc nxhyd = maximum of (nx/2,ny)c nxyhd = maximum of (nx,ny)/2c fourier coefficients are stored as follows:c f(2*j-1,k),f(2*j,k) = real, imaginary part of mode j-1,k-1, wherec 1 <= j <= nx/2 and 1 <= k <= ny, except forc f(1,k),f(2,k) = real, imaginary part of mode nx/2,k-1, wherec ny/2+2 <= k <= ny, andc f(2,1) = real part of mode nx/2,0 andc f(2,ny/2+1) = real part of mode nx/2,ny/2c written by viktor k. decyk, ucla      complex f, sct, t1, t2      dimension f(nxhd,nyd), mixup(nxhyd), sct(nxyhd)      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      ny = 2**indy      nyh = ny/2      ny2 = ny + 2      nxy = max0(nx,ny)      nxhy = 2**indx1y      nxt = nxi + nxp - 1      if (isign.gt.0) go to 80c inverse fourier transform      nry = nxhy/nyc bit-reverse array elements in y      do 20 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 20      do 10 j = nxi, nxt      t1 = f(j,k1)      f(j,k1) = f(j,k)      f(j,k) = t1   10 continue   20 continuec then transform in y      nry = nxy/ny      do 60 l = 1, indy      ns = 2**(l - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 50 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 40 j = 1, ns      j1 = j + k1      j2 = j + k2      t1 = sct(1+kmr*(j-1))      do 30 i = nxi, nxt      t2 = t1*f(i,j2)      f(i,j2) = f(i,j1) - t2      f(i,j1) = f(i,j1) + t2   30 continue   40 continue   50 continue   60 continuec unscramble modes kx = 0, nx/2      do 70 k = 2, nyh      if (nxi.eq.1) then         t1 = f(1,ny2-k)         f(1,ny2-k) = .5*cmplx(aimag(f(1,k) + t1),real(f(1,k) - t1))         f(1,k) = .5*cmplx(real(f(1,k) + t1),aimag(f(1,k) - t1))      endif   70 continue      returnc forward fourier transformc scramble modes kx = 0, nx/2   80 do 90 k = 2, nyh      if (nxi.eq.1) then         t1 = cmplx(aimag(f(1,ny2-k)),real(f(1,ny2-k)))         f(1,ny2-k) = conjg(f(1,k) - t1)         f(1,k) = f(1,k) + t1      endif   90 continuec bit-reverse array elements in y      nry = nxhy/ny      do 110 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 110      do 100 j = nxi, nxt      t1 = f(j,k1)      f(j,k1) = f(j,k)      f(j,k) = t1  100 continue  110 continuec first transform in y      nry = nxy/ny      do 150 l = 1, indy      ns = 2**(l - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 140 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 130 j = 1, ns      j1 = j + k1      j2 = j + k2      t1 = conjg(sct(1+kmr*(j-1)))      do 120 i = nxi, nxt      t2 = t1*f(i,j2)      f(i,j2) = f(i,j1) - t2      f(i,j1) = f(i,j1) + t2  120 continue  130 continue  140 continue  150 continue      return      endc-----------------------------------------------------------------------      subroutine FFT2C(f,isign,mixup,sct,indx,indy,nxd,nyd,nxyd,nxyhd)c this subroutine performs a two dimensional complex to complex fastc fourier transform and its inverse, using complex arithmeticc for isign = 0, input: all except f, output: mixup, sctc for isign = (-1,1), input: all, output: fc for isign = (-1,1), approximate flop count: 5*N*log2(N)c where N = nx*nyc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = 0, the fft tables are preparedc if isign = -1, an inverse fourier transform is performedc f(n,m) = (1/nx*ny)*sum(f(j,k)*c       exp(-sqrt(-1)*2pi*n*j/nx)*exp(-sqrt(-1)*2pi*m*k/ny))c if isign = 1, a forward fourier transform is performedc f(j,k) = sum(f(n,m)*exp(sqrt(-1)*2pi*n*j/nx)*exp(sqrt(-1)*2pi*m*k/ny))c mixup = array of bit reversed addressesc sct = sine/cosine tablec nxd, nyd = first and second dimensions of fc nxyd = maximum of (nx,ny)c nxyhd = one half of maximum of (nx,ny)c written by viktor k. decyk, ucla      complex f, sct, s, t      dimension f(nxd,nyd), mixup(nxyd), sct(nxyhd)      indxy = max0(indx,indy)      nx = 2**indx      nxh = nx/2      ny = 2**indy      nyh = ny/2      nxy = 2**indxy      if (isign.ne.0) go to 40c prepare fft tablesc bit-reverse index table: mixup(j) = 1 + reversed bits of (j - 1)      do 20 j = 1, nxy      lb = j - 1      ll = 0      do 10 k = 1, indxy      jb = lb/2      it = lb - 2*jb      lb = jb      ll = 2*ll + it   10 continue      mixup(j) = ll + 1   20 continuec sine/cosine table for the angles 2*n*pi/nxy      nxyh = nxy/2      dnxy = 6.28318530717959/float(nxy)      do 30 j = 1, nxyh      arg = dnxy*float(j - 1)      sct(j) = cmplx(cos(arg),-sin(arg))   30 continue      returnc bit-reverse array elements in x   40 nrx = nxy/nx      do 60 j = 1, nx      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 60      do 50 i = 1, ny      t = f(j1,i)      f(j1,i) = f(j,i)      f(j,i) = t   50 continue   60 continuec bit-reverse array elements in y      nry = nxy/ny      do 80 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 80      do 70 i = 1, nx      t = f(i,k1)      f(i,k1) = f(i,k)      f(i,k) = t   70 continue   80 continue      if (isign.gt.0) go to 190c inverse fourier transformc first transform in x      do 120 l = 1, indx      ns = 2**(l - 1)      ns2 = ns + ns      km = nxh/ns      kmr = km*nrx      do 110 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 100 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 90 i = 1, ny      t = s*f(j2,i)      f(j2,i) = f(j1,i) - t      f(j1,i) = f(j1,i) + t   90 continue  100 continue  110 continue  120 continuec then transform in y      do 160 l = 1, indy      ns = 2**(l - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 150 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 140 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 130 i = 1, nx      t = s*f(i,j2)      f(i,j2) = f(i,j1) - t      f(i,j1) = f(i,j1) + t  130 continue  140 continue  150 continue  160 continuec normalize result      ani = 1./float(nx*ny)      do 180 k = 1, ny      do 170 j = 1, nx      f(j,k) = f(j,k)*ani  170 continue  180 continue      returnc forward fourier transformc first transform in x  190 do 230 l = 1, indx      ns = 2**(l - 1)      ns2 = ns + ns      km = nxh/ns      kmr = km*nrx      do 220 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 210 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 200 i = 1, ny      t = s*f(j2,i)      f(j2,i) = f(j1,i) - t      f(j1,i) = f(j1,i) + t  200 continue  210 continue  220 continue  230 continuec then transform in y      do 270 l = 1, indy      ns = 2**(l - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 260 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 250 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 240 i = 1, nx      t = s*f(i,j2)      f(i,j2) = f(i,j1) - t      f(i,j1) = f(i,j1) + t  240 continue  250 continue  260 continue  270 continue      return      endc-----------------------------------------------------------------------      function ranorm()c this program calculates a random number y from a gaussian distributionc with zero mean and unit variance, according to the method ofc mueller and box:c    y(k) = (-2*ln(x(k)))**1/2*sin(2*pi*x(k+1))c    y(k+1) = (-2*ln(x(k)))**1/2*cos(2*pi*x(k+1)),c where x is a random number uniformly distributed on (0,1).c written for the ibm by viktor k. decyk, ucla      integer r1,r2,r4,r5      double precision ranorm,h1l,h1u,h2l,r0,r3,asc,bsc,temp      save iflg,r1,r2,r4,r5,h1l,h1u,h2l,r0      data r1,r2,r4,r5 /885098780,1824280461,1396483093,55318673/      data h1l,h1u,h2l /65531.0d0,32767.0d0,65525.0d0/      data iflg,r0 /0,0.0d0/      if (iflg.eq.0) go to 10      ranorm = r0      r0 = 0.0d0      iflg = 0      return   10 isc = 65536      asc = dble(isc)      bsc = asc*asc      i1 = r1 - (r1/isc)*isc      r3 = h1l*dble(r1) + asc*h1u*dble(i1)      i1 = r3/bsc      r3 = r3 - dble(i1)*bsc      bsc = 0.5d0*bsc      i1 = r2/isc      isc = r2 - i1*isc      r0 = h1l*dble(r2) + asc*h1u*dble(isc)      asc = 1.0d0/bsc      isc = r0*asc      r2 = r0 - dble(isc)*bsc      r3 = r3 + (dble(isc) + 2.0d0*h1u*dble(i1))      isc = r3*asc      r1 = r3 - dble(isc)*bsc      temp = dsqrt(-2.0d0*dlog((dble(r1) + dble(r2)*asc)*asc))      isc = 65536      asc = dble(isc)      bsc = asc*asc      i1 = r4 - (r4/isc)*isc      r3 = h2l*dble(r4) + asc*h1u*dble(i1)      i1 = r3/bsc      r3 = r3 - dble(i1)*bsc      bsc = 0.5d0*bsc      i1 = r5/isc      isc = r5 - i1*isc      r0 = h2l*dble(r5) + asc*h1u*dble(isc)      asc = 1.0d0/bsc      isc = r0*asc      r5 = r0 - dble(isc)*bsc      r3 = r3 + (dble(isc) + 2.0d0*h1u*dble(i1))      isc = r3*asc      r4 = r3 - dble(isc)*bsc      r0 = 6.28318530717959d0*((dble(r4) + dble(r5)*asc)*asc)      ranorm = temp*dsin(r0)      r0 = temp*dcos(r0)      iflg = 1      return      end