!-----------------------------------------------------------------------! 2D Electrostatic PIC code with Vacuum Poisson solver! written by viktor k. decyk, ucla! copyright 2005, regents of the university of california! update: march 18, 2006!      module globals!      implicit none      integer, parameter :: LINEAR = 1, QUADRATIC = 2      integer, parameter :: STANDARD = 1, LOOKAHEAD = 2, VECTOR = 3!      end module globals!!-----------------------------------------------------------------------!      module p0d!! basic parallel PIC library for MPI communications!      implicit none      private      public :: wtimer, plsum!! define interface to original Fortran77 procedures!      interface         subroutine PSUM(f,g,nxp,nblok)         implicit none         integer :: nxp, nblok         real, dimension(nxp,nblok) :: f, g         end subroutine      end interface      interface         subroutine PWTIMERA(icntrl,time,dtime)         implicit none         integer :: icntrl         real :: time         double precision :: dtime         end subroutine      end interface!! define generic interface to Fortran90 library!      interface plsum         module procedure ipsum      end interface!      contains  !         subroutine wtimer(time,dtime,icntrl)! local wall clock timer         implicit none         real, intent(out) :: time         double precision, intent(inout) :: dtime         integer, intent(in), optional :: icntrl         integer :: ltime         ltime = 1         if (present(icntrl)) ltime = icntrl         if (ltime==0) return         call PWTIMERA(ltime,time,dtime)         end subroutine wtimer!         subroutine ipsum(f)! perform global sum of 1d real array         implicit none         real, dimension(:) :: f         integer :: nxp, nblok         real, dimension(size(f)) :: g         nxp = size(f); nblok = 1         call PSUM(f,g,nxp,nblok)         end subroutine ipsum!      end module p0d!!-----------------------------------------------------------------------!      module p2d!! 2d parallel PIC library for MPI communications!      use globals, only: LINEAR, QUADRATIC      use p0d, only: wtimer, plsum      implicit none      private      public :: wtimer, plsum, dcomp, pmove, repart      public :: zdbl, hafdbl, pnlcguard, pnlaguard, pfmove!! define interface to original Fortran77 procedures!      interface         subroutine DCOMP2(edges,nyp,noff,ny,kstrt,nvp,idps,nblok)         implicit none         integer :: ny, kstrt, nvp, idps, nblok         real, dimension(idps,nblok) :: edges         integer, dimension(nblok) :: nyp, noff         end subroutine      end interface      interface         subroutine DCOMP2L(edges,nyp,noff,ny,kstrt,nvp,idps,nblok)         implicit none         integer :: ny, kstrt, nvp, idps, nblok         real, dimension(idps,nblok) :: edges         integer, dimension(nblok) :: nyp, noff         end subroutine      end interface      interface         subroutine PMOVE2(part,edges,npp,sbufr,sbufl,rbufr,rbufl,ihole,&     &jsr,jsl,jss,ny,kstrt,nvp,idimp,npmax,nblok,idps,nbmax,ntmax,info)         implicit none         integer :: ny, kstrt, nvp, idimp, npmax, nblok, idps         integer :: nbmax, ntmax         real, dimension(idimp,npmax,nblok) :: part         real, dimension(idps,nblok) :: edges         integer, dimension(nblok) :: npp         real, dimension(idimp,nbmax,nblok) :: sbufl, sbufr         real, dimension(idimp,nbmax,nblok) :: rbufl, rbufr         integer, dimension(idps,nblok) :: jsl, jsr, jss         integer, dimension(ntmax,nblok) :: ihole         integer, dimension(7) :: info         end subroutine      end interface      interface         subroutine REPARTD2(edges,edg,eds,eg,es,et2,npic,noff,nyp,anpav&     &,nypmin,nypmax,kstrt,nvp,nblok,idps,nypm)         implicit none         integer :: nypmin, nypmax, kstrt, nvp, nblok, idps, nypm         real :: anpav         real, dimension(idps,nblok) :: edges         real, dimension(nypm,nblok) :: edg, eds         real, dimension(idps,nblok) :: eg, es         real, dimension(2*idps,nblok) :: et2         integer, dimension(nypm,nblok) :: npic         integer, dimension(nblok) :: noff, nyp         end subroutine      end interface      interface         subroutine PZDBL2D(q,q2,nx,ny,kstrt,nxv,kyp,kypd,kyp2,kblok,k2b&     &lok)         implicit none         integer :: nx, ny, kstrt, nxv, kyp, kypd, kyp2, kblok, k2blok         real :: q         real, dimension(2*nxv,kyp2,k2blok) :: q2         end subroutine      end interface      interface         subroutine PHAFDBL2C(fxy,fxy2,nx,ny,kstrt,nxv,kyp,kypd,kyp2,kbl&     &ok,k2blok)         implicit none         integer :: nx, ny, kstrt, nxv, kyp, kypd, kyp2, kblok, k2blok         real :: fxy         real, dimension(2,2*nxv,kyp2,k2blok) :: fxy2         end subroutine      end interface      interface         subroutine PHAFDBL2D(q,q2,nx,ny,kstrt,nxv,kyp,kypd,kyp2,kblok,k&     &2blok)         implicit none         integer :: nx, ny, kstrt, nxv, kyp, kypd, kyp2, kblok, k2blok         real :: q         real, dimension(2*nxv,kyp2,k2blok) :: q2         end subroutine      end interface      interface         subroutine PNLCGUARD2(f,scs,nyp,kstrt,nvp,nx,nxv,nypmx,nblok,mt&     &er)         implicit none         integer :: kstrt, nvp, nx, nxv, nypmx, nblok, mter         real, dimension(2,nxv,nypmx,nblok) :: f         real, dimension(2,nxv,nblok) :: scs         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PNLDGUARD2(f,scs,nyp,kstrt,nvp,nx,nxv,nypmx,nblok,mt&     &er)         implicit none         integer :: kstrt, nvp, nx, nxv, nypmx, nblok, mter         real, dimension(nxv,nypmx,nblok) :: f         real, dimension(nxv,nblok) :: scs         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PNLCGUARD2L(f,nyp,kstrt,nvp,nxv,nypmx,nblok)         implicit none         integer :: kstrt, nvp, nxv, nypmx, nblok         real, dimension(nxv,nypmx,nblok) :: f         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PNLAGUARD2(f,scr,scs,nyp,kstrt,nvp,nx,nxv,nypmx,nblo&     &k,ngds,mter)         implicit none         integer :: kstrt, nvp, nx, nxv, nypmx, nblok, ngds, mter         real, dimension(3,nxv,nypmx,nblok) :: f         real, dimension(3,nxv,ngds,nblok) :: scr         real, dimension(3,nxv,nblok) :: scs         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PNLAGUARDS2(f,nyp,kstrt,nvp,nx,nxv,nypmx,nblok,mter)         implicit none         integer :: kstrt, nvp, nx, nxv, nypmx, nblok, mter         real, dimension(nxv,nypmx,nblok) :: f         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PNLAGUARD2L(f,scr,nyp,kstrt,nvp,nx,nxv,nypmx,nblok)         implicit none         integer :: kstrt, nvp, nx, nxv, nypmx, nblok         real, dimension(nxv,nypmx,nblok) :: f         real, dimension(nxv,nblok) :: scr         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PFMOVE2(f,g,noff,nyp,noffs,nyps,noffd,nypd,jsr,jsl,i&     &sign,kyp,kstrt,nvp,nxv,nypmx,nblok,idps,mter,ierr)         implicit none         integer :: isign, kyp, kstrt, nvp, nxv, nypmx, nblok, idps         integer :: mter, ierr!        real, dimension(*) :: f         real :: f         real, dimension(nxv,nypmx,nblok) :: g         integer, dimension(nblok) :: noff, nyp         integer, dimension(nblok) :: noffs, nyps, noffd, nypd         integer, dimension(idps,nblok) :: jsl, jsr         end subroutine      end interface!! define generic interface to Fortran90 library!      interface dcomp         module procedure idcomp2      end interface!      interface pmove         module procedure ipdmove2      end interface!      interface repart         module procedure irepartd2      end interface!      interface zdbl         module procedure izpdbl2d      end interface!      interface hafdbl         module procedure iphafdbl2c         module procedure iphafdbl2d      end interface!      interface pnlcguard         module procedure ipnlcguard2         module procedure ipnldguard2      end interface!      interface pnlaguard         module procedure ipnlaguard2      end interface!      interface pfmove         module procedure ipfmove2         module procedure ipfcmove2         module procedure ipnfmove2      end interface!      contains!         subroutine idcomp2(edges,nyp,noff,ny,kstrt,nvp,inorder)! find uniform 1d partition boundaries in 2d code         implicit none         integer :: ny, kstrt, nvp         integer, optional :: inorder         real, dimension(:), pointer :: edges         integer, dimension(:), pointer :: nyp, noff! local data         integer :: idps, nblok, order         idps = size(edges,1); nblok = 1         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call DCOMP2L(edges,nyp,noff,ny,kstrt,nvp,idps,nblok)         else            call DCOMP2(edges,nyp,noff,ny,kstrt,nvp,idps,nblok)         endif         end subroutine idcomp2!         subroutine ipdmove2(part,edges,npp,anpav,pibal,tmove,ny,kstrt,n&     &vp,nbmax,ierr)! particle manager: moves particles to appropriate processor! non-uniform 1d partition boundaries in 2d code! returns load imbalance         implicit none         integer :: ny, kstrt, nvp, nbmax, ierr         real :: anpav, pibal, tmove         real, dimension(:,:), pointer :: part         real, dimension(:), pointer :: edges         integer, dimension(:), pointer :: npp! local data         real, dimension(size(part,1),nbmax) :: sbufl         real, dimension(size(part,1),nbmax) :: sbufr         real, dimension(size(part,1),nbmax) :: rbufl         real, dimension(size(part,1),nbmax) :: rbufr         integer, dimension(size(edges,1)) :: jsl, jsr         integer, dimension(size(edges,1)) :: jss         integer, dimension(2*nbmax) :: ihole         integer, dimension(7) :: info         integer :: idimp, npmax, nblok, idps, ntmax         double precision :: dtime         idimp = size(part,1); npmax = size(part,2)         nblok = 1         idps = size(edges,1)         ntmax = 2*nbmax! initialize timer         call wtimer(tmove,dtime,-1)         call PMOVE2(part,edges,npp,sbufr,sbufl,rbufr,rbufl,ihole,jsr,js&     &l,jss,ny,kstrt,nvp,idimp,npmax,nblok,idps,nbmax,ntmax,info)! record time         call wtimer(tmove,dtime)! calculate percent imbalance         anpav = real(info(7))/real(nvp)         if (anpav > 0.0) then            pibal = max(real(info(2))-anpav,anpav-real(info(3)))/anpav         endif         ierr = info(1)         end subroutine ipdmove2!         subroutine irepartd2(edges,npic,noff,nyp,anpav,kstrt,nvp,nypmx,&     &nterg,ierr,inorder)! finds new 1d partitions from old partition and particle information         implicit none         integer :: kstrt, nvp, nypmx, nterg, ierr         real :: anpav         integer, optional :: inorder         real, dimension(:), pointer :: edges         integer, dimension(:), pointer :: npic         integer, dimension(:), pointer :: noff, nyp! local data         real, dimension(size(npic,1)) :: edg, eds         real, dimension(size(edges,1)) :: eg, es         real, dimension(2*size(edges,1)) :: et2         integer :: nypmin, nypmax, nblok, idps, nypm, order         idps = size(edges,1); nblok = 1         nypm = size(npic,1)         ierr = 0         order = QUADRATIC         if (present(inorder)) order = inorder         call REPARTD2(edges,edg,eds,eg,es,et2,npic,noff,nyp,anpav,nypmi&     &n,nypmax,kstrt,nvp,nblok,idps,nypm)         if (order==LINEAR) then            nypmax = nypmax + 1         else            nypmax = nypmax + 3         endif         if ((nypmin.lt.1).or.(nypmax.gt.nypmx)) then            write (2,*) 'Field size error: nypmin,nypmax=',nypmin,nypmax            ierr = 1         endif         nterg = nypmin - 1         end subroutine irepartd2!         subroutine izpdbl2d(q,q2,nx,ny,kstrt,kyp,kyp2,inorder)! double array in each dimension for 2d scalar data, zeroing copies! for open boundary conditions         implicit none         integer :: nx, ny, kstrt, kyp, kyp2         integer, optional :: inorder         real, dimension(:,:), pointer :: q         real, dimension(:,:), pointer :: q2! local data         integer :: nxv, kypd, kblok, k2blok, order         nxv = size(q,1);  kypd = size(q,2); kblok = 1         k2blok = 1         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PZDBL2D(q(1,1),q2,nx,ny,kstrt,nxv,kyp,kypd,kyp2,kblok,k&     &2blok)         else            call PZDBL2D(q(2,2),q2,nx,ny,kstrt,nxv,kyp,kypd,kyp2,kblok,k&     &2blok)         endif         end subroutine izpdbl2d!         subroutine iphafdbl2c(fxy,fxy2,nx,ny,kstrt,kyp,kyp2,inorder)! copy from double to normal array in each dimension for 2d vector data         implicit none         integer :: nx, ny, kstrt, kyp, kyp2         integer, optional :: inorder         real, dimension(:,:,:), pointer :: fxy         real, dimension(:,:,:), pointer :: fxy2! local data         integer :: nxv, kypd, kblok, k2blok, order         nxv = size(fxy,2);  kypd = size(fxy,3); kblok = 1         k2blok = 1         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PHAFDBL2C(fxy(1,1,1),fxy2,nx,ny,kstrt,nxv,kyp,kypd,kyp2&     &,kblok,k2blok)         else            call PHAFDBL2C(fxy(1,2,2),fxy2,nx,ny,kstrt,nxv,kyp,kypd,kyp2&     &,kblok,k2blok)         endif         end subroutine iphafdbl2c!         subroutine iphafdbl2d(q,q2,nx,ny,kstrt,kyp,kyp2,inorder)! copy from double to normal array in each dimension for 2d scalar data         implicit none         integer :: nx, ny, kstrt, kyp, kyp2         integer, optional :: inorder         real, dimension(:,:), pointer :: q         real, dimension(:,:), pointer :: q2! local data         integer :: nxv, kypd, kblok, k2blok, order         nxv = size(q,1);  kypd = size(q,2); kblok = 1         k2blok = 1         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PHAFDBL2D(q(1,1),q2,nx,ny,kstrt,nxv,kyp,kypd,kyp2,kblok&     &,k2blok)         else            call PHAFDBL2D(q(2,2),q2,nx,ny,kstrt,nxv,kyp,kypd,kyp2,kblok&     &,k2blok)         endif         end subroutine iphafdbl2d!         subroutine ipnlcguard2(f,nyp,kstrt,nvp,nx,mter,inorder)! copy guard cells in y for non-uniform 2d vector data, for ipbc=2         implicit none         integer :: kstrt, nvp, nx, mter         integer, optional :: inorder         real, dimension(:,:,:), pointer :: f         integer, dimension(:), pointer :: nyp! local data         integer :: nxv, nypmx, nblok, order         real, dimension(size(f,1)*size(f,2)) :: scs         nxv = size(f,1)*size(f,2); nypmx = size(f,3); nblok = 1         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PNLCGUARD2L(f,nyp,kstrt,nvp,nxv,nypmx,nblok)         else            nxv = size(f,2)            call PNLCGUARD2(f,scs,nyp,kstrt,nvp,nx,nxv,nypmx,nblok,mter)         endif         end subroutine ipnlcguard2!         subroutine ipnldguard2(f,nyp,kstrt,nvp,nx,mter,inorder)! copy guard cells in y for non-uniform 2d scalar data, for ipbc=2         implicit none         integer :: kstrt, nvp, nx, mter         integer, optional :: inorder         real, dimension(:,:), pointer :: f         integer, dimension(:), pointer :: nyp! local data         integer :: nxv, nypmx, nblok, order         real, dimension(size(f,1)) :: scs         nxv = size(f,1); nypmx = size(f,2); nblok = 1         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PNLCGUARD2L(f,nyp,kstrt,nvp,nxv,nypmx,nblok)         else            call PNLDGUARD2(f,scs,nyp,kstrt,nvp,nx,nxv,nypmx,nblok,mter)         endif         end subroutine ipnldguard2!         subroutine ipnlaguard2(f,nyp,kstrt,nvp,nx,mter,ngds)! add guard cells in y for non-uniform 2d scalar data, for ipbc=2         implicit none         integer :: kstrt, nvp, nx, mter, ngds         real, dimension(:,:), pointer :: f         integer, dimension(:), pointer :: nyp! local data         integer :: nxv, nypmx, nblok         real, dimension(size(f,1),ngds) :: scr         real, dimension(size(f,1)) :: scs         nxv = size(f,1); nypmx = size(f,2); nblok = 1         if (ngds.eq.1) then            call PNLAGUARD2L(f,scr,nyp,kstrt,nvp,nx,nxv,nypmx,nblok)         else            call PNLAGUARD2(f,scr,scs,nyp,kstrt,nvp,nx,nxv,nypmx,nblok,n&     &gds,mter)            call PNLAGUARDS2(f,nyp,kstrt,nvp,nx,nxv,nypmx,nblok,mter)         endif         end subroutine ipnlaguard2!         subroutine ipfcmove2(f,noff,nyp,isign,tfmove,kyp,kstrt,nvp,idps&     &,mter,ierr,inorder)! field manager: moves 2d vector data between uniform and non-uniform! 1d partitions         implicit none         integer :: isign, kyp, kstrt, nvp, idps, mter, ierr         real :: tfmove         integer, optional :: inorder         real, dimension(:,:,:), pointer :: f         integer, dimension(:), pointer :: noff, nyp! local data         real, dimension(size(f,1),size(f,2),size(f,3)) :: g         integer, dimension(size(noff,1)) :: noffs, nyps, noffd, nypd         integer, dimension(idps) :: jsl, jsr         integer :: nxv, nypmx, nblok, order         real :: tfm         double precision :: dtime         nxv = size(f,1)*size(f,2); nypmx = size(f,3); nblok = 1         order = QUADRATIC         if (present(inorder)) order = inorder! initialize timer         call wtimer(tfm,dtime,-1)         if (order==LINEAR) then            call PFMOVE2(f(1,1,1),g,noff,nyp,noffs,nyps,noffd,nypd,jsr,j&     &sl,isign,kyp,kstrt,nvp,nxv,nypmx,nblok,idps,mter,ierr)         else            call PFMOVE2(f(1,1,2),g,noff,nyp,noffs,nyps,noffd,nypd,jsr,j&     &sl,isign,kyp,kstrt,nvp,nxv,nypmx,nblok,idps,mter,ierr)         endif! record time         call wtimer(tfm,dtime)         tfmove = tfmove + tfm         end subroutine ipfcmove2!         subroutine ipfmove2(f,noff,nyp,isign,tfmove,kyp,kstrt,nvp,idps,&     &mter,ierr,inorder)! field manager: moves 2d scalar data between uniform and non-uniform! 1d partitions         implicit none         integer :: isign, kyp, kstrt, nvp, idps, mter, ierr         real :: tfmove         integer, optional :: inorder         real, dimension(:,:), pointer :: f         integer, dimension(:), pointer :: noff, nyp! local data         real, dimension(size(f,1),size(f,2)) :: g         integer, dimension(size(noff,1)) :: noffs, nyps, noffd, nypd         integer, dimension(idps) :: jsl, jsr         integer :: nxv, nypmx, nblok, order         real :: tfm         double precision :: dtime         nxv = size(f,1); nypmx = size(f,2); nblok = 1         order = QUADRATIC         if (present(inorder)) order = inorder! initialize timer         call wtimer(tfm,dtime,-1)         if (order==LINEAR) then            call PFMOVE2(f(1,1),g,noff,nyp,noffs,nyps,noffd,nypd,jsr,jsl&     &,isign,kyp,kstrt,nvp,nxv,nypmx,nblok,idps,mter,ierr)         else            call PFMOVE2(f(1,2),g,noff,nyp,noffs,nyps,noffd,nypd,jsr,jsl&     &,isign,kyp,kstrt,nvp,nxv,nypmx,nblok,idps,mter,ierr)         endif! record time         call wtimer(tfm,dtime)         tfmove = tfmove + tfm         end subroutine ipfmove2!         subroutine ipnfmove2(f,noff,nyp,noffs,nyps,tfmove,kstrt,nvp,idp&     &s,ierr,inorder)! field manager: moves 2d scalar data between two different non-uniform! 1d partitions! noffs and nyps are modified by this call         implicit none         integer :: kstrt, nvp, idps, ierr         real :: tfmove         integer, optional :: inorder         real, dimension(:,:), pointer :: f         integer, dimension(:), pointer :: noff, nyp, noffs, nyps! local data         real, dimension(size(f,1),size(f,2)) :: g         integer, dimension(size(noff,1)) :: noffd, nypd         integer, dimension(idps) :: jsl, jsr         integer :: isign = 0, mter = 0, kyp = 1, nxv, nypmx, nblok         integer :: order         real :: tfm         double precision :: dtime         nxv = size(f,1); nypmx = size(f,2); nblok = 1         noffd = noff; nypd = nyp         order = QUADRATIC         if (present(inorder)) order = inorder! initialize timer         call wtimer(tfm,dtime,-1)         if (order==LINEAR) then            call PFMOVE2(f(1,1),g,noff,nyp,noffs,nyps,noffd,nypd,jsr,jsl&     &,isign,kyp,kstrt,nvp,nxv,nypmx,nblok,idps,mter,ierr)         else            call PFMOVE2(f(1,2),g,noff,nyp,noffs,nyps,noffd,nypd,jsr,jsl&     &,isign,kyp,kstrt,nvp,nxv,nypmx,nblok,idps,mter,ierr)         endif! record time         call wtimer(tfm,dtime)         tfmove = tfmove + tfm         end subroutine ipnfmove2!      end module p2d!!-----------------------------------------------------------------------!      module pinit2d!! 2d parallel PIC library for initialization!      use globals, only: LINEAR, QUADRATIC      implicit none      private      public :: fdistr, vdistr, fedges!! define interface to original Fortran77 procedures!      interface         subroutine PFDISTR2(part,nps,fnx,argx1,argx2,argx3,fny,argy1,ar&     &gy2,argy3,npx,npy,nx,ny,idimp,npmax,nblok,kstrt,nvp,ipbc,ierr)         implicit none         integer :: npx, npy, nx, ny, idimp, npmax, nblok, kstrt, nvp         integer :: ipbc, ierr         real :: argx1, argx2, argx3, argy1, argy2, argy3         real, dimension(idimp,npmax,nblok) :: part         integer, dimension(nblok) :: nps         real, external :: fnx, fny         end subroutine      end interface      interface         subroutine PRDISTR2(part,nps,fnx,argx1,argx2,argx3,fny,argy1,ar&     &gy2,argy3,npx,npy,nx,ny,idimp,npmax,nblok,kstrt,nvp,ipbc)         implicit none         integer :: npx, npy, nx, ny, idimp, npmax, nblok, kstrt, nvp         integer :: ipbc         real :: argx1, argx2, argx3, argy1, argy2, argy3         real, dimension(idimp,npmax,nblok) :: part         integer, dimension(nblok) :: nps         real, external :: fnx, fny         end subroutine      end interface      interface         subroutine PVRDISTR2(part,nps,fnx,argx1,argx2,argx3,fny,argy1,a&     &rgy2,argy3,npx,npy,nx,ny,idimp,npmax,nblok,vranx,vrany,kstrt,nvp,n&     &dv,nvrp,ipbc,ierr)         implicit none         integer :: npx, npy, nx, ny, idimp, npmax, nblok, kstrt, nvp         integer :: ndv, nvrp, ipbc, ierr         real :: argx1, argx2, argx3, argy1, argy2, argy3         real, dimension(idimp,npmax,nblok) :: part         integer, dimension(nblok) :: nps         double precision, dimension(nvrp,nblok) :: vranx, vrany         real, external :: fnx, fny         end subroutine      end interface      interface         subroutine PVDISTR2(part,npp,nps,vtx,vty,vdx,vdy,npx,npy,idimp,&     &npmax,nblok,kstrt,nvp,ierr)         implicit none         integer :: npx, npy, idimp, npmax, nblok, kstrt, nvp, ierr         real :: vtx, vty, vdx, vdy         real, dimension(idimp,npmax,nblok) :: part         integer, dimension(nblok) :: npp, nps         end subroutine      end interface      interface         subroutine FEDGES2(edges,noff,nyp,fny,arg1,arg2,arg3,ny,nypmin,&     &nypmax,kstrt,nvp,nblok,idps,ipbc)         implicit none         integer :: ny, nypmin, nypmax, kstrt, nvp, nblok, idps, ipbc         real :: arg1, arg2, arg3         real, dimension(idps,nblok) :: edges         integer, dimension(nblok) :: noff, nyp         real, external :: fny         end subroutine      end interface!! define generic interfaces to Fortran90 library!!      interface fdistr         module procedure ipfdistr2      end interface!      interface vdistr         module procedure ipvdistr2      end interface!      interface fedges         module procedure ifedges2      end interface!! define Fortran90 interface functions to Fortran77 library!      contains!         subroutine ipfdistr2(part,nps,ampx,scalex,shiftx,ampy,scaley,sh&     &ifty,npx,npy,nx,ny,kstrt,nvp,ipbc,ndpro,nsran)! calculates initial particle co-ordinates in 2d! with various density profiles         implicit none         integer :: npx, npy, nx, ny, kstrt, nvp, ipbc, ndpro, nsran         real :: ampx, scalex, shiftx, ampy, scaley, shifty         real, dimension(:,:), pointer :: part         integer, dimension(:), pointer :: nps! local data         integer :: idimp, npmax, nblok, ierr         real :: sxi, syi, zero         real, external :: FLDISTR1, FSDISTR1, FGDISTR1, FHDISTR1         idimp = size(part,1); npmax = size(part,2)         nblok = 1         sxi = 0.         if (scalex /= 0.) sxi = 1.0/scalex         syi = 0.         if (scaley /= 0.) syi = 1.0/scaley         zero = 0.0! uniform density         if (ndpro==0) then            call PFDISTR2(part,nps,FLDISTR1,zero,zero,zero,FLDISTR1,zero&     &,zero,zero,npx,npy,nx,ny,idimp,npmax,nblok,kstrt,nvp,ipbc,ierr)            if (nsran /= 0) then               call PRDISTR2(part,nps,FLDISTR1,zero,zero,zero,FLDISTR1,z&     &ero,zero,zero,npx,npy,nx,ny,idimp,npmax,nblok,kstrt,nvp,ipbc)            endif! linear density         else if (ndpro==1) then            call PFDISTR2(part,nps,FLDISTR1,ampx,sxi,shiftx,FLDISTR1,amp&     &y,syi,shifty,npx,npy,nx,ny,idimp,npmax,nblok,kstrt,nvp,ipbc,ierr)            if (nsran /= 0) then               call PRDISTR2(part,nps,FLDISTR1,ampx,sxi,shiftx,FLDISTR1,&     &ampy,syi,shifty,npx,npy,nx,ny,idimp,npmax,nblok,kstrt,nvp,ipbc)            endif! sinusoidal density         else if (ndpro==2) then            call PFDISTR2(part,nps,FSDISTR1,ampx,sxi,shiftx,FSDISTR1,amp&     &y,syi,shifty,npx,npy,nx,ny,idimp,npmax,nblok,kstrt,nvp,ipbc,ierr)            if (nsran /= 0) then               call PRDISTR2(part,nps,FSDISTR1,ampx,sxi,shiftx,FSDISTR1,&     &ampy,syi,shifty,npx,npy,nx,ny,idimp,npmax,nblok,kstrt,nvp,ipbc)            endif! gaussian density         else if (ndpro==3) then            call PFDISTR2(part,nps,FGDISTR1,ampx,sxi,shiftx,FGDISTR1,amp&     &y,syi,shifty,npx,npy,nx,ny,idimp,npmax,nblok,kstrt,nvp,ipbc,ierr)            if (nsran /= 0) then               call PRDISTR2(part,nps,FGDISTR1,ampx,sxi,shiftx,FGDISTR1,&     &ampy,syi,shifty,npx,npy,nx,ny,idimp,npmax,nblok,kstrt,nvp,ipbc)            endif! hyperbolic secant squared density         else if (ndpro==4) then            call PFDISTR2(part,nps,FHDISTR1,ampx,sxi,shiftx,FHDISTR1,amp&     &y,syi,shifty,npx,npy,nx,ny,idimp,npmax,nblok,kstrt,nvp,ipbc,ierr)            if (nsran /= 0) then               call PRDISTR2(part,nps,FHDISTR1,ampx,sxi,shiftx,FHDISTR1,&     &ampy,syi,shifty,npx,npy,nx,ny,idimp,npmax,nblok,kstrt,nvp,ipbc)            endif         endif         end subroutine ipfdistr2!         subroutine ipvdistr2(part,npp,nps,vtx,vty,vdx,vdy,npx,npy,kstrt&     &,nvp)! calculates initial particle velocities in 2d! with maxwellian velocity with drift         implicit none         integer :: npx, npy, kstrt, nvp         real :: vtx, vty, vdx, vdy         real, dimension(:,:), pointer :: part         integer, dimension(:), pointer :: npp, nps! local data         integer :: idimp, npmax, nblok, ierr         idimp = size(part,1); npmax = size(part,2)         nblok = 1         call PVDISTR2(part,npp,nps,vtx,vty,vdx,vdy,npx,npy,idimp,npmax,&     &nblok,kstrt,nvp,ierr)         end subroutine ipvdistr2!         subroutine ifedges2(edges,noff,nyp,ampy,scaley,shifty,ny,kstrt,&     &nvp,nypmx,ipbc,ndpro,nterg,ierr,inorder)! finds new 1d partitions from initial analytic distribution function         implicit none         integer :: ny, kstrt, nvp, nypmx, ipbc, ndpro, nterg, ierr         real :: ampy, scaley, shifty         integer, optional :: inorder         real, dimension(:), pointer :: edges         integer, dimension(:), pointer :: noff, nyp! local data         integer :: idps, nblok, nypmin, nypmax, order         real :: syi, zero         real, external :: FLDISTR1, FSDISTR1, FGDISTR1, FHDISTR1         idps = size(edges,1); nblok = 1         syi = 0.         if (scaley /= 0.) syi = 1.0/scaley         zero = 0.0         ierr = 0         order = QUADRATIC         if (present(inorder)) order = inorder! uniform density         if (ndpro==0) then            call FEDGES2(edges,noff,nyp,FLDISTR1,zero,zero,zero,ny,nypmi&     &n,nypmax,kstrt,nvp,nblok,idps,ipbc)! linear density         else if (ndpro==1) then            call FEDGES2(edges,noff,nyp,FLDISTR1,ampy,syi,shifty,ny,nypm&     &in,nypmax,kstrt,nvp,nblok,idps,ipbc)! sinusoidal density         else if (ndpro==2) then            call FEDGES2(edges,noff,nyp,FSDISTR1,ampy,syi,shifty,ny,nypm&     &in,nypmax,kstrt,nvp,nblok,idps,ipbc)! gaussian density         else if (ndpro==3) then            call FEDGES2(edges,noff,nyp,FGDISTR1,ampy,syi,shifty,ny,nypm&     &in,nypmax,kstrt,nvp,nblok,idps,ipbc)! hyperbolic secant squared density         else if (ndpro==4) then            call FEDGES2(edges,noff,nyp,FHDISTR1,ampy,syi,shifty,ny,nypm&     &in,nypmax,kstrt,nvp,nblok,idps,ipbc)         endif         if (order==LINEAR) then            nypmax = nypmax + 1         else            nypmax = nypmax + 3         endif         if ((nypmin.lt.1).or.(nypmax.gt.nypmx)) then            write (2,*) 'Field size error: nypmin,nypmax=',nypmin,nypmax            ierr = 1         endif         nterg = nypmin - 1         end subroutine ifedges2!      end module pinit2d!!-----------------------------------------------------------------------!      module ppush2d!! 2d parallel PIC library for pushing particles and depositing charge!      use globals, only: LINEAR, QUADRATIC, STANDARD, LOOKAHEAD, VECTOR      use p0d, only: wtimer      implicit none      private      public :: dpost, push, sortp, countp!! define interface to Fortran77 procedures!      interface         subroutine PGPOST2(part,q,npp,noff,qm,idimp,npmax,nblok,nxv,nyp&     &mx)         implicit none         integer :: idimp, npmax, nblok, nxv, nypmx         real :: qm         real, dimension(idimp,npmax,nblok) :: part         real, dimension(nxv,nypmx,nblok) :: q         integer, dimension(nblok) :: npp, noff         end subroutine      end interface      interface         subroutine PGSPOST2(part,q,npp,noff,qm,idimp,npmax,nblok,nxv,nx&     &yp)         implicit none         integer :: idimp, npmax, nblok, nxv, nxyp         real :: qm         real, dimension(idimp,npmax,nblok) :: part         real, dimension(nxyp,nblok) :: q         integer, dimension(nblok) :: npp, noff         end subroutine      end interface      interface         subroutine PGSOST2X(part,q,npp,noff,nn,amxy,qm,idimp,npmax,nblo&     &k,nxv,nxvyp,npd,nine)         implicit none         integer :: idimp, npmax, nblok, nxv, nxvyp, npd, nine         real :: qm         real, dimension(idimp,npmax,nblok) :: part         real, dimension(nxvyp,nblok) :: q         integer, dimension(nblok) :: npp, noff         integer, dimension(nine,npd,nblok) :: nn         real, dimension(nine,npd,nblok) :: amxy         end subroutine      end interface      interface         subroutine PGPOST2L(part,q,npp,noff,qm,idimp,npmax,nblok,nxv,ny&     &pmx)         implicit none         integer :: idimp, npmax, nblok, nxv, nypmx         real :: qm         real, dimension(idimp,npmax,nblok) :: part         real, dimension(nxv,nypmx,nblok) :: q         integer, dimension(nblok) :: npp, noff         end subroutine      end interface      interface         subroutine PGSPOST2L(part,q,npp,noff,qm,idimp,npmax,nblok,nxv,n&     &xyp)         implicit none         integer :: idimp, npmax, nblok, nxv, nxyp         real :: qm         real, dimension(idimp,npmax,nblok) :: part         real, dimension(nxyp,nblok) :: q         integer, dimension(nblok) :: npp, noff         end subroutine      end interface      interface         subroutine PGSOST2XL(part,q,npp,noff,nn,amxy,qm,idimp,npmax,nbl&     &ok,nxv,nxvyp,npd,ifour)         implicit none         integer :: idimp, npmax, nblok, nxv, nxvyp, npd, ifour         real :: qm         real, dimension(idimp,npmax,nblok) :: part         real, dimension(nxvyp,nblok) :: q         integer, dimension(nblok) :: npp, noff         integer, dimension(ifour,npd,nblok) :: nn         real, dimension(ifour,npd,nblok) :: amxy         end subroutine      end interface      interface         subroutine PGPUSH2(part,fxy,npp,noff,qbm,dt,ek,nx,ny,idimp,npma&     &x,nblok,nxv,nypmx,ipbc)         implicit none         integer :: nx, ny, idimp, npmax, nblok, nxv, nypmx, ipbc         real :: qbm, dt, ek         real, dimension(idimp,npmax,nblok) :: part         real, dimension(2,nxv,nypmx,nblok) :: fxy         integer, dimension(nblok) :: npp, noff         end subroutine      end interface      interface         subroutine PGSPUSH2(part,fxy,npp,noff,qbm,dt,ek,nx,ny,idimp,npm&     &ax,nblok,nxv,nxyp,ipbc)         implicit none         integer :: nx, ny, idimp, npmax, nblok, nxv, nxyp, ipbc         real :: qbm, dt, ek         real, dimension(idimp,npmax,nblok) :: part         real, dimension(2,nxyp,nblok) :: fxy         integer, dimension(nblok) :: npp, noff         end subroutine      end interface      interface         subroutine PGPUSH2L(part,fxy,npp,noff,qbm,dt,ek,nx,ny,idimp,npm&     &ax,nblok,nxv,nypmx,ipbc)         implicit none         integer :: nx, ny, idimp, npmax, nblok, nxv, nypmx, ipbc         real :: qbm, dt, ek         real, dimension(idimp,npmax,nblok) :: part         real, dimension(2,nxv,nypmx,nblok) :: fxy         integer, dimension(nblok) :: npp, noff         end subroutine      end interface      interface         subroutine PGSPUSH2L(part,fxy,npp,noff,qbm,dt,ek,nx,ny,idimp,np&     &max,nblok,nxv,nxyp,ipbc)         implicit none         integer :: nx, ny, idimp, npmax, nblok, nxv, nxyp, ipbc         real :: qbm, dt, ek         real, dimension(idimp,npmax,nblok) :: part         real, dimension(2,nxyp,nblok) :: fxy         integer, dimension(nblok) :: npp, noff         end subroutine      end interface      interface         subroutine PSORTP2Y(part,pt,ip,npic,npp,noff,nyp,idimp,npmax,nb&     &lok,nypm1)         implicit none         integer :: idimp, npmax, nblok, nypm1         real, dimension(idimp,npmax,nblok) :: part         real, dimension(npmax,nblok) :: pt         integer, dimension(npmax,nblok) :: ip         integer, dimension(nypm1,nblok) :: npic         integer, dimension(nblok) :: npp, noff, nyp         end subroutine      end interface      interface         subroutine PSORTP2YL(part,pt,ip,npic,npp,noff,nyp,idimp,npmax,n&     &blok,nypm1)         implicit none         integer :: idimp, npmax, nblok, nypm1         real, dimension(idimp,npmax,nblok) :: part         real, dimension(npmax,nblok) :: pt         integer, dimension(npmax,nblok) :: ip         integer, dimension(nypm1,nblok) :: npic         integer, dimension(nblok) :: npp, noff, nyp         end subroutine      end interface      interface         subroutine PDSORTP2Y(parta,partb,npic,npp,noff,nyp,idimp,npmax,&     &nblok,nypm1)         implicit none         integer :: idimp, npmax, nblok, nypm1         real, dimension(idimp,npmax,nblok) :: parta, partb         integer, dimension(nypm1,nblok) :: npic         integer, dimension(nblok) :: npp, noff, nyp         end subroutine      end interface      interface         subroutine PDSORTP2YL(parta,partb,npic,npp,noff,nyp,idimp,npmax&     &,nblok,nypm1)         implicit none         integer :: idimp, npmax, nblok, nypm1         real, dimension(idimp,npmax,nblok) :: parta, partb         integer, dimension(nypm1,nblok) :: npic         integer, dimension(nblok) :: npp, noff, nyp         end subroutine      end interface      interface         subroutine PCOUNT2YL(part,isign,npic,npp,noff,nyp,idimp,npmax,n&     &blok,nypm1)         implicit none         integer :: isign, idimp, npmax, nblok, nypm1         real, dimension(idimp,npmax,nblok) :: part         integer, dimension(nypm1,nblok) :: npic         integer, dimension(nblok) :: npp, noff, nyp         end subroutine      end interface!! define generic interface to Fortran90 library!      interface dpost         module procedure ipgpost2      end interface!      interface push         module procedure ipgpush2      end interface!      interface sortp         module procedure ipsortp2y         module procedure ipdsortp2y      end interface!      interface countp         module procedure ipcount2y      end interface!! define Fortran90 interface functions to Fortran77 library!      contains  !         subroutine ipgpost2(part,q,qm,npp,noff,tdpost,inorder,dopt)! deposit charge, 1d partition         implicit none         integer, optional :: inorder, dopt         real :: qm, tdpost         real, dimension(:,:), pointer :: part         real, dimension(:,:), pointer :: q         integer, dimension(:), pointer :: npp, noff! local data         integer :: idimp, npmax, nblok, nxv, nypmx, nxyp, order, opt! npd = size of scratch buffers for vectorized charge deposition         integer, parameter :: npd = 128, ifour = 4, nine = 9         integer, dimension(nine,npd) :: nn         real, dimension(nine,npd) :: amxy         double precision :: dtime         idimp = size(part,1); npmax = size(part,2)         nblok = 1         nxv = size(q,1); nypmx = size(q,2); nxyp = nxv*nypmx         order = QUADRATIC         if (present(inorder)) order = inorder         opt = STANDARD         if (present(dopt)) opt = dopt! initialize timer         call wtimer(tdpost,dtime,-1)         if (order==LINEAR) then            if (opt==LOOKAHEAD) then               call PGSPOST2L(part,q,npp,noff,qm,idimp,npmax,nblok,nxv,n&     &xyp)            else if (opt==VECTOR) then               call PGSOST2XL(part,q,npp,noff,nn,amxy,qm,idimp,npmax,nbl&     &ok,nxv,nxyp,npd,ifour)            else               call PGPOST2L(part,q,npp,noff,qm,idimp,npmax,nblok,nxv,ny&     &pmx)            endif         else            if (opt==LOOKAHEAD) then               call PGSPOST2(part,q,npp,noff,qm,idimp,npmax,nblok,nxv,nx&     &yp)            else if (opt==VECTOR) then               call PGSOST2X(part,q,npp,noff,nn,amxy,qm,idimp,npmax,nblo&     &k,nxv,nxyp,npd,nine)            else               call PGPOST2(part,q,npp,noff,qm,idimp,npmax,nblok,nxv,nyp&     &mx)            endif         endif! record time         call wtimer(tdpost,dtime)         end subroutine ipgpost2!         subroutine ipgpush2(part,fxy,npp,noff,qbm,dt,ek,tpush,nx,ny,ipb&     &c,inorder,popt)! push particles with 2d electrostatic fields, 1d partition         implicit none         integer :: nx, ny, ipbc         integer, optional :: inorder, popt         real :: qbm, dt, ek, tpush         real, dimension(:,:), pointer :: part         real, dimension(:,:,:), pointer :: fxy         integer, dimension(:), pointer :: npp, noff! local data         integer :: idimp, npmax, nblok, nxv, nypmx, nxyp, order, opt         double precision :: dtime         idimp = size(part,1); npmax = size(part,2)         nblok = 1         nxv = size(fxy,2); nypmx = size(fxy,3); nxyp = nxv*nypmx         order = QUADRATIC         if (present(inorder)) order = inorder         opt = STANDARD         if (present(popt)) opt = popt! initialize timer         call wtimer(tpush,dtime,-1)         if (order==LINEAR) then            if (opt==LOOKAHEAD) then               call PGSPUSH2L(part,fxy,npp,noff,qbm,dt,ek,nx,ny,idimp,np&     &max,nblok,nxv,nxyp,ipbc)            else               call PGPUSH2L(part,fxy,npp,noff,qbm,dt,ek,nx,ny,idimp,npm&     &ax,nblok,nxv,nypmx,ipbc)            endif         else            if (opt==LOOKAHEAD) then               call PGSPUSH2(part,fxy,npp,noff,qbm,dt,ek,nx,ny,idimp,npm&     &ax,nblok,nxv,nxyp,ipbc)            else               call PGPUSH2(part,fxy,npp,noff,qbm,dt,ek,nx,ny,idimp,npma&     &x,nblok,nxv,nypmx,ipbc)            endif         endif! record time         call wtimer(tpush,dtime)         end subroutine ipgpush2!         subroutine ipsortp2y(part,pt,ip,npp,noff,nyp,npic,tsort,inorder&     &)! sort particles by y grid using memory-conserving bin sort         implicit none         integer, optional :: inorder         real :: tsort         real, dimension(:,:), pointer :: part         real, dimension(:), pointer :: pt         integer, dimension(:), pointer :: ip, npic         integer, dimension(:), pointer :: npp, noff, nyp! local data         integer :: idimp, npmax, nblok, nypm1, order         double precision :: dtime         idimp = size(part,1); npmax = size(part,2)         nblok = 1; nypm1 = size(npic,1)         order = QUADRATIC         if (present(inorder)) order = inorder! initialize timer         call wtimer(tsort,dtime,-1)         if (order==LINEAR) then            call PSORTP2YL(part,pt,ip,npic,npp,noff,nyp,idimp,npmax,nblo&     &k,nypm1)         else            call PSORTP2Y(part,pt,ip,npic,npp,noff,nyp,idimp,npmax,nblok&     &,nypm1)         endif! record time         call wtimer(tsort,dtime)         end subroutine ipsortp2y!         subroutine ipdsortp2y(parta,partb,npp,noff,nyp,npic,tsort,inord&     &er)! sort particles by y grid using optimized bin sort         implicit none         integer, optional :: inorder         real :: tsort         real, dimension(:,:), pointer :: parta, partb         integer, dimension(:), pointer :: npp, noff, nyp         integer, dimension(:), pointer :: npic         real, dimension(:,:), pointer :: part! local data         integer :: idimp, npmax, nblok, nypm1, order         double precision :: dtime         idimp = size(parta,1); npmax = size(parta,2)         nblok = 1; nypm1 = size(npic,1)         order = QUADRATIC         if (present(inorder)) order = inorder! initialize timer         call wtimer(tsort,dtime,-1)         if (order==LINEAR) then            call PDSORTP2YL(parta,partb,npic,npp,noff,nyp,idimp,npmax,nb&     &lok,nypm1)         else            call PDSORTP2Y(parta,partb,npic,npp,noff,nyp,idimp,npmax,nbl&     &ok,nypm1)         endif         part => parta         parta => partb         partb => part! record time         call wtimer(tsort,dtime)         end subroutine ipdsortp2y!         subroutine ipcount2y(part,npic,npp,noff,nyp)! counts number of particles per cell in y grid         implicit none         real, dimension(:,:), pointer :: part         integer, dimension(:), pointer :: npic         integer, dimension(:), pointer :: npp, noff, nyp! local data         integer :: isign = 1         integer :: idimp, npmax, nblok, nypm1         idimp = size(part,1); npmax = size(part,2)         nblok = 1; nypm1 = size(npic,1)         call PCOUNT2YL(part,isign,npic,npp,noff,nyp,idimp,npmax,nblok,n&     &ypm1)         end subroutine ipcount2y!      end module ppush2d!!-----------------------------------------------------------------------!      module prbpush2d!! 2d parallel PIC library for pushing relativistic particles!      use globals, only: LINEAR, QUADRATIC, STANDARD, LOOKAHEAD, VECTOR      use p0d, only: wtimer      implicit none      private      public :: rpush!! define interface to original Fortran77 procedures!      interface         subroutine PGRPUSH2(part,fxy,npp,noff,qbm,dt,ci,ek,nx,ny,idimp,&     &npmax,nblok,nxv,nypmx,ipbc)         implicit none         integer :: nx, ny, idimp, npmax, nblok, nxv, nypmx, ipbc         real :: qbm, dt, ci, ek         real, dimension(idimp,npmax,nblok) :: part         real, dimension(2,nxv,nypmx,nblok) :: fxy         integer, dimension(nblok) :: npp, noff         end subroutine      end interface      interface         subroutine PGSRPUSH2(part,fxy,npp,noff,qbm,dt,ci,ek,nx,ny,idimp&     &,npmax,nblok,nxv,nxyp,ipbc)         implicit none         integer :: nx, ny, idimp, npmax, nblok, nxv, nxyp, ipbc         real :: qbm, dt, ci, ek         real, dimension(idimp,npmax,nblok) :: part         real, dimension(2,nxyp,nblok) :: fxy         integer, dimension(nblok) :: npp, noff         end subroutine      end interface      interface         subroutine PGRPUSH2L(part,fxy,npp,noff,qbm,dt,ci,ek,nx,ny,idimp&     &,npmax,nblok,nxv,nypmx,ipbc)         implicit none         integer :: nx, ny, idimp, npmax, nblok, nxv, nypmx, ipbc         real :: qbm, dt, ci, ek         real, dimension(idimp,npmax,nblok) :: part         real, dimension(2,nxv,nypmx,nblok) :: fxy         integer, dimension(nblok) :: npp, noff         end subroutine      end interface      interface         subroutine PGSRPUSH2L(part,fxy,npp,noff,qbm,dt,ci,ek,nx,ny,idim&     &p,npmax,nblok,nxv,nxyp,ipbc)         implicit none         integer :: nx, ny, idimp, npmax, nblok, nxv, nxyp, ipbc         real :: qbm, dt, ci, ek         real, dimension(idimp,npmax,nblok) :: part         real, dimension(2,nxyp,nblok) :: fxy         integer, dimension(nblok) :: npp, noff         end subroutine      end interface!! define generic interface to Fortran90 library!      interface rpush         module procedure ipgrpush2      end interface!! define Fortran90 interface functions to Fortran77 library!      contains!         subroutine ipgrpush2(part,fxy,npp,noff,qbm,dt,ci,ek,tpush,nx,ny&     &,ipbc,inorder,popt)! push relativistic particles with 2d electrostatic fields, 1d partition         implicit none         integer :: nx, ny, ipbc         integer, optional :: inorder, popt         real :: qbm, dt, ci, ek, tpush         real, dimension(:,:), pointer :: part         real, dimension(:,:,:), pointer :: fxy         integer, dimension(:), pointer :: npp, noff! local data         integer :: idimp, npmax, nblok, nxv, nypmx, nxyp, order, opt         double precision :: dtime         idimp = size(part,1); npmax = size(part,2)         nblok = 1         nxv = size(fxy,2); nypmx = size(fxy,3); nxyp = nxv*nypmx         order = QUADRATIC         if (present(inorder)) order = inorder         opt = STANDARD         if (present(popt)) opt = popt! initialize timer         call wtimer(tpush,dtime,-1)         if (order==LINEAR) then            if (opt==LOOKAHEAD) then               call PGSRPUSH2L(part,fxy,npp,noff,qbm,dt,ci,ek,nx,ny,idim&     &p,npmax,nblok,nxv,nxyp,ipbc)            else               call PGRPUSH2L(part,fxy,npp,noff,qbm,dt,ci,ek,nx,ny,idimp&     &,npmax,nblok,nxv,nypmx,ipbc)            endif         else            if (opt==LOOKAHEAD) then               call PGSRPUSH2(part,fxy,npp,noff,qbm,dt,ci,ek,nx,ny,idimp&     &,npmax,nblok,nxv,nxyp,ipbc)            else               call PGRPUSH2(part,fxy,npp,noff,qbm,dt,ci,ek,nx,ny,idimp,&     &npmax,nblok,nxv,nypmx,ipbc)            endif         endif! record time         call wtimer(tpush,dtime)         end subroutine ipgrpush2!      end module prbpush2d!!-----------------------------------------------------------------------!      module pfft2d!! 2d parallel PIC library for fast fourier transforms!      use globals, only: LINEAR, QUADRATIC      use p0d, only: wtimer      implicit none      private      public :: fft_init, fft!! define interface to original Fortran77 procedures!      interface         subroutine WPFFT2RINIT(mixup,sct,indx,indy,nxhyd,nxyhd)         implicit none         integer :: indx, indy         integer :: nxhyd, nxyhd         integer, dimension(nxhyd) :: mixup         complex, dimension(nxyhd) :: sct         end subroutine      end interface      interface         subroutine WPFFT2R(f,g,bs,br,isign,ntpose,mixup,sct,ttp,indx,in&     &dy,kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         implicit none         integer :: isign, ntpose, indx, indy, kstrt, nxvh, nyv         integer :: kxp, kyp, kypd, jblok, kblok, nxhyd, nxyhd         real :: ttp         real :: f         complex, dimension(nyv,kxp,jblok) :: g         complex, dimension(kxp,kyp,kblok) :: bs         complex, dimension(kxp,kyp,jblok) :: br         integer, dimension(nxhyd) :: mixup         complex, dimension(nxyhd) :: sct         end subroutine      end interface      interface         subroutine WPFFT2R2(f,g,bs,br,isign,ntpose,mixup,sct,ttp,indx,i&     &ndy,kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         implicit none         integer :: isign, ntpose, indx, indy, kstrt, nxvh, nyv         integer :: kxp, kyp, kypd, jblok, kblok, nxhyd, nxyhd         real :: ttp         real :: f         complex, dimension(2,nyv,kxp,jblok) :: g         complex, dimension(2,kxp,kyp,kblok) :: bs         complex, dimension(2,kxp,kyp,jblok) :: br         integer, dimension(nxhyd) :: mixup         complex, dimension(nxyhd) :: sct         end subroutine      end interface!! define generic interfaces to Fortran90 library!      interface fft_init         module procedure iwpfft2rinit      end interface!      interface fft         module procedure iwpfft2r         module procedure iwpfft2r2      end interface!      contains!         subroutine iwpfft2rinit(mixup,sct,indx,indy)! initialize 2d real to complex fft         implicit none         integer :: indx, indy         integer, dimension(:), pointer :: mixup         complex, dimension(:), pointer :: sct! local data         integer :: nxhyd, nxyhd         nxhyd = size(mixup); nxyhd = size(sct)         call WPFFT2RINIT(mixup,sct,indx,indy,nxhyd,nxyhd)         end subroutine iwpfft2rinit!         subroutine iwpfft2r(f,g,isign,mixup,sct,tfft,indx,indy,kstrt,ky&     &p,inorder)! perform 2d scalar real to complex fft         implicit none         integer :: isign, indx, indy, kstrt, kyp         integer, optional :: inorder         real, dimension(2) :: tfft         real, dimension(:,:), pointer :: f         complex, dimension(:,:), pointer :: g         integer, dimension(:), pointer :: mixup         complex, dimension(:), pointer :: sct! local data         integer :: ntpose = 1, nxvh, nyv         integer :: kxp, kypd, jblok, kblok, nxhyd, nxyhd, order         complex, dimension(size(g,2),kyp) :: bs         complex, dimension(size(g,2),kyp) :: br         real :: tf, ttp         double precision :: dtime         nxvh = size(f,1)/2; kypd = size(f,2); kblok = 1         nyv = size(g,1); kxp = size(g,2); jblok = 1         nxhyd = size(mixup); nxyhd = size(sct)         order = QUADRATIC         if (present(inorder)) order = inorder! initialize timer         call wtimer(tf,dtime,-1)         if (order==LINEAR) then            call WPFFT2R(f(1,1),g,bs,br,isign,ntpose,mixup,sct,ttp,indx,&     &indy,kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         else            call WPFFT2R(f(2,2),g,bs,br,isign,ntpose,mixup,sct,ttp,indx,&     &indy,kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         endif! record time         call wtimer(tf,dtime)         tfft(1) = tfft(1) + tf         tfft(2) = tfft(2) + ttp         end subroutine iwpfft2r!         subroutine iwpfft2r2(f,g,mixup,sct,tfft,indx,indy,kstrt,kyp,ino&     &rder)! perform 2d vector real to complex fft for 2 component vectors         implicit none         integer :: indx, indy, kstrt, kyp         integer, optional :: inorder         real, dimension(2) :: tfft         real, dimension(:,:,:), pointer :: f         complex, dimension(:,:,:), pointer :: g         integer, dimension(:), pointer :: mixup         complex, dimension(:), pointer :: sct! local data         integer :: isign = 1, ntpose = 1, nxvh, nyv         integer :: kxp, kypd, jblok, kblok, nxhyd, nxyhd, order         complex, dimension(2,size(g,3),kyp) :: bs         complex, dimension(2,size(g,3),kyp) :: br         real :: tf, ttp         double precision :: dtime         nxvh = size(f,2)/2; kypd = size(f,3); kblok = 1         nyv = size(g,2); kxp = size(g,3); jblok = 1         nxhyd = size(mixup); nxyhd = size(sct)         order = QUADRATIC         if (present(inorder)) order = inorder! initialize timer         call wtimer(tf,dtime,-1)         if (order==LINEAR) then            call WPFFT2R2(f(1,1,1),g,bs,br,isign,ntpose,mixup,sct,ttp,in&     &dx,indy,kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         else            call WPFFT2R2(f(1,2,2),g,bs,br,isign,ntpose,mixup,sct,ttp,in&     &dx,indy,kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)         endif! record time         call wtimer(tf,dtime)         tfft(1) = tfft(1) + tf         tfft(2) = tfft(2) + ttp         end subroutine iwpfft2r2!      end module pfft2d!!-----------------------------------------------------------------------!      module pdfield2d!! 2d parallel PIC library for solving field equations with dirichlet! boundary conditions!      use globals, only: LINEAR, QUADRATIC      implicit none      private      public :: laguard, lcguard!! define interface to original Fortran77 procedures!      interface         subroutine PLCGUARD2X(fxy,nyp,nx,nxe,nypmx,nblok)         implicit none         integer :: nx, nxe, nypmx, nblok         real, dimension(2,nxe,nypmx,nblok) :: fxy         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PLDGUARD2X(q,nyp,nx,nxe,nypmx,nblok)         implicit none         integer :: nx, nxe, nypmx, nblok         real, dimension(nxe,nypmx,nblok) :: q         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PLAGUARD2X(q,nyp,nx,nxe,nypmx,nblok)         implicit none         integer :: nx, nxe, nypmx, nblok         real :: q         integer, dimension(nblok) :: nyp         end subroutine      end interface!! define generic interfaces to Fortran90 library!            interface laguard         module procedure iplaguard2x      end interface!      interface lcguard         module procedure iplcguard2x         module procedure ipldguard2x      end interface!! define Fortran90 interface functions to Fortran77 library!      contains!         subroutine iplaguard2x(q,nyp,nx,inorder)! add guard cells in x for non-uniform 2d scalar data! disable quadratic interpolation at edge         implicit none         integer :: nx         integer, optional :: inorder         real, dimension(:,:), pointer :: q         integer, dimension(:), pointer :: nyp! local data         integer :: nxe, nypmx, nblok, order         nxe = size(q,1); nypmx = size(q,2); nblok = 1         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==QUADRATIC) then            call PLAGUARD2X(q(2,1),nyp,nx-2,nxe,nypmx,nblok)         endif         end subroutine iplaguard2x!         subroutine iplcguard2x(fxy,nyp,nx,inorder)! copy guard cells in x for non-uniform 2d vector data! disable quadratic interpolation at edge         implicit none         integer :: nx         integer, optional :: inorder         real, dimension(:,:,:), pointer :: fxy         integer, dimension(:), pointer :: nyp! local data         integer :: nxe, nypmx, nblok, order         nxe = size(fxy,2); nypmx = size(fxy,3); nblok = 1         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==QUADRATIC) then            call PLCGUARD2X(fxy,nyp,nx,nxe,nypmx,nblok)         endif         end subroutine iplcguard2x!         subroutine ipldguard2x(q,nyp,nx,inorder)! copy guard cells in x for non-uniform 2d scalar data! disable quadratic interpolation at edge         implicit none         integer :: nx         integer, optional :: inorder         real, dimension(:,:), pointer :: q         integer, dimension(:), pointer :: nyp! local data         integer :: nxe, nypmx, nblok, order         nxe = size(q,1); nypmx = size(q,2); nblok = 1         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==QUADRATIC) then            call PLDGUARD2X(q,nyp,nx,nxe,nypmx,nblok)         endif         end subroutine ipldguard2x!      end module pdfield2d!!-----------------------------------------------------------------------!      module pcfield2d!! 2d parallel PIC library for solving field equations with open (vacuum)! boundary conditions!      use globals, only: LINEAR, QUADRATIC      implicit none      private      public :: poisc2_init, poisc3_init, poisc!! define interface to original Fortran77 procedures!      interface         subroutine PFORMC2(ffg,f,ft,bs,br,fpotc,mixup2,sct2,affp,ar,ind&     &x1,indy1,kstrt,nxv,ny2d,kxp2,kyp2,j2blok,k2blok,kxp2d,ny1d,nxhy2,n&     &xyh2)         implicit none         integer :: indx1, indy1, kstrt, nxv, ny2d, kxp2, kyp2         integer :: j2blok, k2blok, kxp2d, ny1d, nxhy2, nxyh2         real :: ar, affp         real, dimension(4,ny1d,kxp2d,j2blok) :: ffg         real, dimension(2*nxv,kyp2,k2blok) :: f         complex, dimension(ny2d,kxp2,j2blok) :: ft         complex, dimension(kxp2,kyp2,k2blok) :: bs         complex, dimension(kxp2,kyp2,j2blok) :: br         integer, dimension(nxhy2) :: mixup2         complex, dimension(nxyh2) :: sct2         real, external :: fpotc         end subroutine      end interface      interface         subroutine PPOISC2(q,fx,fy,isign,ffg,we,nx,ny,kstrt,ny2d,kxp2,j&     &2blok,ny1d,kxp2d)         implicit none         real :: we         integer :: isign, nx, ny, kstrt, ny2d, kxp2, j2blok         integer :: ny1d, kxp2d          complex, dimension(ny2d,kxp2,j2blok) :: q, fx, fy         real, dimension(4,ny1d,kxp2d,j2blok) :: ffg         end subroutine      end interface      interface         subroutine PPOISC22(q,fxy,ffg,we,nx,ny,kstrt,ny2d,kxp2,j2blok,n&     &y1d,kxp2d)         implicit none         real :: we         integer :: nx, ny, kstrt, ny2d, kxp2, j2blok, ny1d, kxp2d          complex, dimension(ny2d,kxp2,j2blok) :: q         complex, dimension(2,ny2d,kxp2,j2blok) :: fxy         real, dimension(4,ny1d,kxp2d,j2blok) :: ffg         end subroutine      end interface!! define generic interfaces to Fortran90 library!      interface poisc2_init         module procedure ippoisc2init      end interface!      interface poisc3_init         module procedure ippoisc3init      end interface!      interface poisc         module procedure ippoisc2         module procedure ippoisc22      end interface!! define Fortran90 interface functions to Fortran77 library!      contains!         subroutine ippoisc2init(ffg,f,ft,mixup2,sct2,ar,affp,indx,indy,&     &kstrt)! initialize 2d poisson solver, open boundary conditions         implicit none         integer :: indx, indy, kstrt         real :: ar, affp         real, dimension(:,:,:), pointer :: ffg         real, dimension(:,:), pointer :: f         complex, dimension(:,:), pointer :: ft         integer, dimension(:), pointer :: mixup2         complex, dimension(:), pointer :: sct2! local data         integer :: indx1, indy1, nxv, ny2d, kxp2, kyp2, j2blok, k2blok         integer :: kxp2d, ny1d, nxhy2, nxyh2         complex, dimension(size(ft,2),size(f,2)) :: bs         complex, dimension(size(ft,2),size(f,2)) :: br         real, external :: POTC2         indx1 = indx + 1; indy1 = indy + 1         ny1d = size(ffg,2); kxp2d = size(ffg,3)         nxv = size(f,1)/2; kyp2 = size(f,2); k2blok = 1         ny2d = size(ft,1); kxp2 = size(ft,2); j2blok = 1         nxhy2 = size(mixup2); nxyh2 = size(sct2)         call PFORMC2(ffg,f,ft,bs,br,POTC2,mixup2,sct2,affp,ar,indx1,ind&     &y1,kstrt,nxv,ny2d,kxp2,kyp2,j2blok,k2blok,kxp2d,ny1d,nxhy2,nxyh2)         end subroutine ippoisc2init!         subroutine ippoisc3init(ffg,f,ft,mixup2,sct2,ar,affp,indx,indy,&     &kstrt)! initialize 2d poisson solver with 3d fields, open boundary conditions         implicit none         integer :: indx, indy, kstrt         real :: ar, affp         real, dimension(:,:,:), pointer :: ffg         real, dimension(:,:), pointer :: f         complex, dimension(:,:), pointer :: ft         integer, dimension(:), pointer :: mixup2         complex, dimension(:), pointer :: sct2! local data         integer :: indx1, indy1, nxv, ny2d, kxp2, kyp2, j2blok, k2blok         integer :: kxp2d, ny1d, nxhy2, nxyh2         complex, dimension(size(ft,2),size(f,2)) :: bs         complex, dimension(size(ft,2),size(f,2)) :: br         real, external :: POTC3         indx1 = indx + 1; indy1 = indy + 1         ny1d = size(ffg,2); kxp2d = size(ffg,3)         nxv = size(f,1)/2; kyp2 = size(f,2); k2blok = 1         ny2d = size(ft,1); kxp2 = size(ft,2); j2blok = 1         nxhy2 = size(mixup2); nxyh2 = size(sct2)         call PFORMC2(ffg,f,ft,bs,br,POTC3,mixup2,sct2,affp,ar,indx1,ind&     &y1,kstrt,nxv,ny2d,kxp2,kyp2,j2blok,k2blok,kxp2d,ny1d,nxhy2,nxyh2)         end subroutine ippoisc3init!         subroutine ippoisc2(q,fx,ffg,we,nx,ny,kstrt)! poisson solver for 2d potential, open boundaries         implicit none         integer :: nx, ny, kstrt         real :: we         complex, dimension(:,:), pointer :: q, fx         real, dimension(:,:,:), pointer :: ffg! local data         integer :: isign = 1, ny2d, kxp2, j2blok, ny1d, kxp2d         complex, dimension(1,1,1) :: fy         ny2d = size(q,1); kxp2 = size(q,2); j2blok = 1         ny1d = size(ffg,2); kxp2d = size(ffg,3)         call PPOISC2(q,fx,fy,isign,ffg,we,nx,ny,kstrt,ny2d,kxp2,j2blok,&     &ny1d,kxp2d)         end subroutine ippoisc2!         subroutine ippoisc22(q,fxy,ffg,we,nx,ny,kstrt)! poisson solver for 2d electric field, open boundaries         implicit none         integer :: nx, ny, kstrt         real :: we         complex, dimension(:,:), pointer :: q         complex, dimension(:,:,:), pointer :: fxy         real, dimension(:,:,:), pointer :: ffg! local data         integer :: ny2d, kxp2, j2blok, ny1d, kxp2d         ny2d = size(q,1); kxp2 = size(q,2); j2blok = 1         ny1d = size(ffg,2); kxp2d = size(ffg,3)         call PPOISC22(q,fxy,ffg,we,nx,ny,kstrt,ny2d,kxp2,j2blok,ny1d,kx&     &p2d)         end subroutine ippoisc22!      end module pcfield2d!!-----------------------------------------------------------------------!      module pfield2d!! 2d parallel PIC library for solving field equations!      use globals, only: LINEAR, QUADRATIC      implicit none      private      public :: zguard!! define interface to original Fortran77 procedures!      interface         subroutine PZGUARD2(q,nyp,nx,nxe,nypmx,nblok)         implicit none         integer nx, nxe, nypmx, nblok         real, dimension(nxe,nypmx,nblok) :: q         integer, dimension(nblok) :: nyp         end subroutine      end interface      interface         subroutine PZGUARD2L(q,nyp,nx,nxe,nypmx,nblok)         implicit none         integer nx, nxe, nypmx, nblok         real, dimension(nxe,nypmx,nblok) :: q         integer, dimension(nblok) :: nyp         end subroutine      end interface!! define generic interfaces to Fortran90 library!      interface zguard         module procedure ipzguard2      end interface!! define Fortran90 interface functions to Fortran77 library!      contains!         subroutine ipzguard2(q,nyp,nx,inorder)! zero out guard cells in periodic 2d scalar field         implicit none         integer :: nx         integer, optional :: inorder         real, dimension(:,:), pointer :: q         integer, dimension(:), pointer :: nyp! local data         integer :: nxe, nypmx, nblok, order         nxe = size(q,1); nypmx = size(q,2); nblok = 1         order = QUADRATIC         if (present(inorder)) order = inorder         if (order==LINEAR) then            call PZGUARD2L(q,nyp,nx,nxe,nypmx,nblok)         else            call PZGUARD2(q,nyp,nx,nxe,nypmx,nblok)         endif         end subroutine ipzguard2!      end module pfield2d