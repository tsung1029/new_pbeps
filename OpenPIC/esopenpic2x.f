!-----------------------------------------------------------------------! 2D Electrostatic PIC code with Vacuum Poisson solver! version compatible with both shared and distributed memory programming! written by viktor k. decyk, ucla! update: april 25, 2008      program esopenpic2x      use globals, only: LINEAR, QUADRATIC, STANDARD, LOOKAHEAD, VECTOR      use pinit2d!     use mppush2d      use ppush2d!     use mprbpush2d      use prbpush2d!     use mpfft2d      use pfft2d      use pdfield2d      use pcfield2d      use pfield2d      use p2d!     use mp0d, only: mpinit      implicit none! indx/indy = exponent which determines length in x/y direction,! where nx=2**indx, ny=2**indy! npx/npy = initial number of particles distributed in x/y direction      integer :: indx =   6, indy =   7, npx =     384, npy =     768! inorder = interpolation order (LINEAR = 1, QUADRATIC = 2)      integer :: inorder = QUADRATIC! popt = particle optimization scheme! dopt = charge deposit optimization scheme! djopt = current deposit optimization scheme      integer :: popt = STANDARD, dopt = LOOKAHEAD! dt = time interval between successive calculations      real :: dt = 0.2000000e+00! qme = charge on electron, in units of e! vtx/vty = thermal velocity of electrons in x/y direction! vx0/vy0 = drift velocity of electrons in x/y direction      real :: qme = -1.0, vtx = 1.0, vty = 1.0, vx0 = 0.0, vy0 = 0.0! relativity = (no,yes) = (0,1) = relativity is used      integer :: relativity = 0! ci = reciprical of velocity of light      real :: ci = 1.0! sortime = number of time steps between electron sorting      integer :: sortime = 50! nsrand = (0,1) = (no,yes) randomize spatially positions locally! ndprof = profile type (uniform=0,linear=1,sinusoidal=2,gaussian=3,!                        hyperbolic secant squared=4)      integer :: nsrand = 0, ndprof = 0! ampdx/ampdx = amplitude of density compared to uniform in x/y! scaledx/scaledx = scale length for spatial coordinate in x/y! shiftdx/shiftdx = shift of spatial coordinate in x/y      real :: ampdx = 0.0, scaledx = 0.0, shiftdx = 0.0      real :: ampdy = 0.0, scaledy = 0.0, shiftdy = 0.0! imbalance = load imbalance fraction repartition trigger! (< 0.  to suppress repartion)      real :: imbalance = .08! ipbc = particle boundary condition = (0,1,2,3) =! (none,2d periodic,2d reflecting,mixed reflecting in x/periodic in y)      integer :: ipbc = 2! idps = number of partition boundaries! idimp = dimension of phase space = 4! mshare = (0,1) = (no,yes) architecture is shared memory      integer :: idps =    2, idimp =   4, mshare =   0!     integer :: ntasks      integer :: idproc, id0, nvp, kstrt, nx, ny, nxh, np      integer :: kyp, nblok, kblok, nypm1, kxp, kyb, kxb, kxyb      integer :: kbmin, nxe, nypmx, isign, ierr      integer :: itime, npmax, nbmax, nterg, nterf, nxyh, nxhy, ngds      real :: we = 0.0, wke = 0.0, anpav = 0.0, pibal = 0.0      real :: tpush = 0.0, tdpost = 0.0, tmove = 0.0, tfmove = 0.0      real :: tsort = 0.0, time = 0.0      real :: qbme, opibal, affp, ar      double precision :: dtime      real, dimension(:,:,:), pointer :: part!     real, dimension(:,:,:), pointer :: part2      real, dimension(:,:,:), pointer :: qe, qi      real, dimension(:,:,:,:), pointer :: fxye      real, dimension(:,:), pointer  :: edges      integer, dimension(:), pointer :: nyp, noff, nypu, noffu      integer, dimension(:), pointer :: npp, nps      real, dimension(:,:), pointer :: pt      integer, dimension(:,:), pointer :: ip, npic      integer, dimension(:), pointer :: nyps, noffs! vacuum boundary conditions      integer :: indx1, indy1, nx2, ny2, nx2e      integer :: kxp2, j2blok, kxb2, kyp2, kyb2, kxyb2      integer :: kbmin2, k2blok      real, dimension(:,:,:), pointer :: q2      real, dimension(:,:,:,:), pointer :: fxy2      complex, dimension(:,:,:,:), pointer :: fxyt2      complex, dimension(:,:,:), pointer :: qt2      real, dimension(:,:,:,:), pointer :: ffg      integer, dimension(:), pointer :: mixup2      complex, dimension(:), pointer :: sct2!      real, dimension(3) :: wtot      real, dimension(2) :: tfft = 0.0!! nvp = number of real or virtual processors! initialize for parallel processing      call PPINIT1(idproc,id0,nvp)      kstrt = idproc + 1      nx = 2**indx; ny = 2**indy; nxh = nx/2! np = total number of electrons in simulation      np = npx*npy! set size of fft tables      nxyh = max(nx,ny)/2; nxhy = max(nxh,ny)! initialize for multiprocessing!     ntasks = mpinit()!     if (id0==0) write (18,*) ntasks+1, ' processors found and used'! kyp = number of complex grids in each field partition in y direction      kyp = (ny - 1)/nvp + 1! nblok = number of particle partitions      nblok = 1 + mshare*(nvp - 1)! kblok = number of field partitions in y direction      kblok = 1 + mshare*(ny/kyp - 1)! size of spatial regions including extra cells for repartitioning      if (imbalance >= 0.0) then         nypm1 = 2*kyp + 1      else         nypm1 = kyp + 1      endif! kxp = number of complex grids in each field partition in x direction      kxp = (nxh - 1)/nvp + 1! kyb = number of processors in y! kxb = number of processors in x      kyb = ny/kyp; kxb = nxh/kxp! kxyb = maximum(kxb,kyb)      kxyb = max(kxb,kyb)      kbmin = 1 + (1 - mshare)*(kxyb/kxb - 1)! edges(1,l) = lower boundary of particle partition l! edges(2,l) = upper boundary of particle partition l      allocate(edges(idps,nblok))! nyp(l) = number of primary gridpoints in particle partition l.! noff(l) = lowermost global gridpoint in particle partition l.! nypu(l) = number of primary gridpoints in uniform partition l.! noffu(l) = lowermost global gridpoint in uniform partition l.      allocate(nyp(nblok),noff(nblok),nypu(nblok),noffu(nblok))! calculate uniform partition variables      call dcomp(edges,nypu,noffu,ny,kstrt,nvp,inorder)! ngds = number of guard cells this array has! nxe = size of x coordinate, including guard cells (must be even)! nypmx = maximum size of particle partition, including guard cells.! ar = half-width of particle in r direction      if (inorder==LINEAR) then         ngds = (idps - 1)/2 + 1         nxe = nx + 2; nypmx = nypm1         ar = .912871      else         ngds = 3*((idps - 1)/2 + 1)         nxe = nx + 4; nypmx = nypm1 + 2         ar = .866667      endif! initialize constants for guard cells      nterf = 0      nterg = kyp - 1! npmax = maximum number of electrons in each partition      npmax = (np/nvp)*1.2! nbmax = size of buffer for passing particles between processors      nbmax = 1 + (2*np*vty + 1.4*np*abs(vy0))*dt/ny!! part(1,n,l) = position x of particle n in partition l! part(2,n,l) = position y of particle n in partition l! part(3,n,l) = velocity vx of particle n in partition l! part(4,n,l) = velocity vy of particle n in partition l      allocate(part(idimp,npmax,nblok))! qe = real space charge density      allocate(qe(nxe,nypmx*kbmin,kblok))! qi = real space ion background charge density      allocate(qi(nxe,nypmx*kbmin,kblok))! fxye = real space force/charge, or convolution of the electric field! over the particle shape      allocate(fxye(2,nxe,nypmx*kbmin,kblok))! npp(l) = number of particles in partition l! nps(l) = starting address of particles in partition l      allocate(npp(nblok),nps(nblok))! sorting arrays      allocate(pt(npmax,nblok))      allocate(ip(npmax,nblok),npic(nypm1,nblok))!     allocate(part2(idimp,npmax,nblok))! data for moving field partitions      allocate(nyps(nblok),noffs(nblok))! vacuum boundary conditions      indx1 = indx+1; indy1 = indy+1      nx2 = 2*nx; ny2 = 2*ny; nx2e = 2*nxe      kxp2 = (nx - 1)/nvp + 1; kxb2 = nx/kxp2      j2blok = 1 + mshare*(nx/kxp2 - 1)      kyp2 = (ny2-1)/nvp + 1; kyb2 = ny2/kyp2      kxyb2 = max(kxb2,kyb2)      kbmin2 = 1 + (1 - mshare)*(kxyb2/kxb2 - 1)      k2blok = 1 + mshare*(ny2/kyp2 - 1)      allocate(q2(nx2e,kyp2*kbmin2,k2blok))      allocate(fxy2(2,nx2e,kyp2*kbmin2,k2blok))      allocate(qt2(ny2,kxp2,j2blok),fxyt2(2,ny2,kxp2,j2blok))      allocate(ffg(4,ny+1,kxp2+1,j2blok))      allocate(mixup2(2*nxhy), sct2(2*nxyh))!! initialize timer      call wtimer(time,dtime,-1)! initialize constants      qbme = qme      affp = float((nx-2)*(ny-2))/float(np)!! vacuum boundary conditions      call fft_init(mixup2,sct2,indx1,indy1)!     call poisc2_init(ffg,q2,qt2,mixup2,sct2,ar,affp,indx,indy,kstrt)      call poisc3_init(ffg,q2,qt2,mixup2,sct2,ar,affp,indx,indy,kstrt)!! new start! initialize particles      nps = 1      npp = 0! background electrons      if (np > 0) then         call fdistr(part,nps,ampdx,scaledx,shiftdx,ampdy,scaledy,shiftd&     &y,npx,npy,nx,ny,kstrt,nvp,ipbc,ndprof,nsrand)         call vdistr(part,npp,nps,vtx,vty,vx0,vy0,npx,npy,kstrt,nvp)      endif! find new partition analytically      if (imbalance >= 0.0) then         call fedges(edges,noff,nyp,ampdy,scaledy,shiftdy,ny,kstrt,nvp,n&     &ypmx,ipbc,ndprof,nterg,ierr,inorder)         if (ierr /= 0) then!           call MP_END            call PPEXIT            stop         endif! use uniform partition      else         noff = noffu; nyp = nypu      endif! move particles into appropriate spatial regions      call pmove(part,edges,npp,anpav,pibal,tmove,ny,kstrt,nvp,nbmax,ier&     &r)      if (ierr /= 0) then!        call MP_END         call PPEXIT         stop      endif! initialize background charge density      qi = 0.0      call dpost(part,qi,-qme,npp,noff,tdpost,inorder,dopt)! add guard cells for ion density in x      call laguard(qi,nyp,nx,inorder)! add guard cells for ion density in y      call pnlaguard(qi,nyp,kstrt,nvp,nx,nterg,ngds)! record time      call wtimer(time,dtime)      if (kstrt==1) write (*,*) 'initialization time=', time      call wtimer(time,dtime,-1)!! * * * start main iteration loop * * *!      do itime = 0, 324!! initialize charge density      qe = 0.0! deposit charge      call dpost(part,qe,qme,npp,noff,tdpost,inorder,dopt)! add ion charge density      qe = qe + qi! add guard cells for density in x      call laguard(qe,nyp,nx,inorder)! add guard cells for density in y      call pnlaguard(qe,nyp,kstrt,nvp,nx,nterg,ngds)!! vacuum boundary conditions!! move charge density to uniform field partition      isign = -1      call pfmove(qe,noff,nyp,isign,tfmove,kyp,kstrt,nvp,idps,nterf,ierr&     &,inorder)      if (ierr /= 0) then!        call MP_END         call PPEXIT         stop      endif! copy charge density array qe to double size array q2      call zdbl(qe,q2,nx,ny,kstrt,kyp,kyp2,inorder)! transform charge to fourier space      isign = -1      call fft(q2,qt2,isign,mixup2,sct2,tfft,indx1,indy1,kstrt,kyp2,LINE&     &AR)! calculate force/charge in fourier space      call poisc(qt2,fxyt2,ffg,we,nx,ny,kstrt)      call fft(fxy2,fxyt2,mixup2,sct2,tfft,indx1,indy1,kstrt,kyp2,LINEAR&     &)      call hafdbl(fxye,fxy2,nx,ny,kstrt,kyp,kyp2,inorder)! move force/charge to non-uniform field partition      isign = 1      call pfmove(fxye,noff,nyp,isign,tfmove,kyp,kstrt,nvp,idps,nterf,ie&     &rr,inorder)      if (ierr /= 0) then!        call MP_END         call PPEXIT         stop      endif! copy to guard cells      call pnlcguard(fxye,nyp,kstrt,nvp,nx,nterg,inorder)      call lcguard(fxye,nyp,nx,inorder)!! push particles      wke = 0.      if (relativity==1) then         call rpush(part,fxye,npp,noff,qbme,dt,ci,wke,tpush,nx,ny,ipbc,i&     &norder,popt)      else         call push(part,fxye,npp,noff,qbme,dt,wke,tpush,nx,ny,ipbc,inord&     &er,popt)      endif! move particles into appropriate spatial regions      call pmove(part,edges,npp,anpav,pibal,tmove,ny,kstrt,nvp,nbmax,ier&     &r)      if (ierr /= 0) then!        call MP_END         call PPEXIT         stop      endif!! begin repartitioning      if (imbalance >= 0.0) then      if (pibal > imbalance) then         opibal = pibal! count the number of particles per cell         call countp(part,npic,npp,noff,nyp)! save old repartitioning boundaries         noffs = noff         nyps = nyp! determine new repartitioning boundaries         call repart(edges,npic,noff,nyp,anpav,kstrt,nvp,nypmx,nterg,ier&     &r,inorder)         if (ierr /= 0) then!           call MP_END            call PPEXIT            stop         endif         nterf = 0! move background ion density to new field partition         call pfmove(qi,noff,nyp,noffs,nyps,tfmove,kstrt,nvp,idps,ierr,i&     &norder)         if (ierr /= 0) then!           call MP_END            call PPEXIT            stop         endif! zero out guard cells         call zguard(qi,nyp,nx,inorder)! move particles into new spatial regions         call pmove(part,edges,npp,anpav,pibal,tmove,ny,kstrt,nvp,nbmax,&     &ierr)         if (ierr /= 0) then!           call MP_END            call PPEXIT            stop         endif         if (kstrt==1) then            write (*,*) 'repartitioning complete, imbalance = ', opibal         endif      endif      endif! end repartitioning!! sort particles      if (sortime > 0) then         if (mod(itime,sortime)==0) then            call sortp(part,pt,ip,npp,noff,nyp,npic,tsort,inorder)!           call sortp(part,part2,npp,noff,nyp,npic,tsort,inorder)            if (kstrt==1) write (*,*) 'particles sorted'         endif      endif! energy diagnostic      wtot(1) = we      wtot(2) = wke      wtot(3) = we + wke      call plsum(wtot)      if (kstrt==1) write (*,*) 'time, energies=', itime, wtot!      enddo!! * * * end main iteration loop * * *!! record timings      call wtimer(time,dtime)      if (kstrt==1) then         write (*,*) 'partition used: nvp = ', nvp         write (*,*) 'total main time=', time, 'sec'         time = tpush + tdpost         write (*,*) 'push and deposit time = ', time, 'sec'         write (*,*) 'sort time = ', tsort         write (*,*) 'particle manager time = ', tmove, 'sec'         time = time + tsort + tmove         write (*,*) 'total particle time = ', time, 'sec'         write (*,*) 'fft, transpose time = ', tfft, 'sec'         write (*,*) 'moving partition time = ', tfmove, 'sec'      endif!     call MP_END      call PPEXIT      stop!      end program esopenpic2x