c-----------------------------------------------------------------------c 2D Electrostatic PIC code with Vacuum Poisson solverc Linear Interpolation, Fortran77 Versionc written by viktor k. decyk, uclac update: march 18, 2006      program lesopenpic2f77      implicit none      integer indx, indy, npx, npy, indnvp, idps, idimp, mshare, np      integer nx, ny, nxh, nyh, nxe, nxeh, nvp, nblok, npav, npmax      integer kyp, kxp, nypm1, nypmx, kyb, kxb, jkmx, kxyb, kbmin, kblok      integer nmx, nxy, nxyh, nmxh, nxhy, nbmax, ntmax, ipbc, nxeyp      integer indx1, indy1, nx2, ny2, nx2e, nxhy2, nxyh2, kxp2, j2blok      integer kxb2, kyp2, k2blok, kyb2, jkmx2, kxyb2, kbmin2, kxp21, ny1      real dt, vty, avy0      integer nyp, noff, nypu, noffu, npp, nps, ihole, jsl, jsr, jss      integer ip, npic, nyps, noffs, nypd, noffd, mixup2, info      real part, qe, qi, fxye, pot, edges, sbufl, sbufr, rbufl, rbufr      real scr, wtot, work, pt, g, h, edg, eds, eg, es, et2      real q2, fxy2, pot2, ffg      complex qt2, fxyt2, fxt2, fyt2, sct2, bs2, br2      integer ntpose, sortime, nsrand, ndprof      real vtx, qme, vx0, vy0, ar, relativity, ci, imbalance      real ampdx, scaledx, shiftdx, ampdy, scaledy, shiftdy      integer j, k, l, itime      integer idproc, id0,  kstrt, nypmin, nypmax, nterf, isign, ierr      real anpav, qbme, zero, affp, sxi, syi, ttp, we, wf, wke, pibalc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indy      parameter( indx =   6, indy =   7)c npx/npy = initial number of particles distributed in x/y direction      parameter( npx =     384, npy =     768)c dt = time interval between successive calculations      parameter( dt = 0.2000000e+00)c vty = thermal velocity of electrons in y direction      parameter( vty =   1.000)c avy0 = absolute value of drift velocity of beam electrons y direction      parameter( avy0 =   0.000)c indnvp = exponent determining number of real or virtual processorsc indnvp must be <= indyc idps = number of partition boundariesc idimp = dimension of phase space = 4c mshare = (0,1) = (no,yes) architecture is shared memory      parameter( indnvp =   2, idps =    2, idimp =   4, mshare =   0)c np = total number of electrons in simulation      parameter(np=npx*npy)      parameter(nx=2**indx,ny=2**indy,nxh=nx/2,nyh=ny/2)      parameter(nxe=nx+2,nxeh=nxe/2)c nvp = number of real or virtual processors, nvp = 2**indnvpc nblok = number of particle partitions      parameter(nvp=2**indnvp,nblok=1+mshare*(nvp-1))c npav = average number of particles per processorc npmax = maximum number of particles in each partitionc nypmx = maximum size of particle partition, including guard cells.      parameter(npav=np/nvp,npmax=(np/nvp)*1.2)c kyp = number of complex grids in each field partition in y directionc kxp = number of complex grids in each field partition in x direction      parameter(kyp=(ny-1)/nvp+1,kxp=(nxh-1)/nvp+1)c kyb = number of processors in yc kxb = number of processors in x      parameter(kyb=ny/kyp,kxb=nxh/kxp,jkmx=kxb*(kyb/kxb)+kyb*(kxb/kyb))c nypmx = maximum size of particle partition, including guard cells.      parameter(nypm1=2*kyp+1,nypmx=nypm1)      parameter(nxeyp=nxe*nypmx)c kxyb = maximum(kxb,kyb)      parameter(kxyb=jkmx/(2-kxb/jkmx-kyb/jkmx))c kblok = number of field partitions in y direction      parameter(kbmin=1+(1-mshare)*(kxyb/kxb-1))      parameter(kblok=1+mshare*(ny/kyp-1))c nxyh = maximum(nx,ny)/2c nxhy = maximum(nx/2,ny)      parameter(nmx=nx*(ny/nx)+ny*(nx/ny),nxy=nmx/(2-nx/nmx-ny/nmx))      parameter(nxyh=nxy/2,nmxh=nxh*(ny/nxh)+ny*(nxh/ny))      parameter(nxhy=nmxh/(2-nxh/nmxh-ny/nmxh))c nbmax = size of buffer for passing particles between processors      parameter(nbmax=1+(2*np*vty+1.4*np*avy0)*dt/ny)c ntmax = size of hole array for particles leaving processors      parameter(ntmax=2*nbmax)c (none,2d periodic,2d reflecting,mixed reflecting/periodic)      parameter(ipbc=2)      common /large/ partc part(1,n,l) = position x of particle n in partition lc part(2,n,l) = position y of particle n in partition lc part(3,n,l) = velocity vx of particle n in partition lc part(4,n,l) = velocity vy of particle n in partition l      dimension part(idimp,npmax,nblok)c in real space, qe(j1,k,l) = charge density at grid point (j,kk)c where kk = k + noff(l) - 1      dimension qe(nxe,nypmx*kbmin,kblok)c in real space, qi(j1,k,l) = ion background charge densityc at grid point (j,kk) where kk = k + noff(l) - 1      dimension qi(nxe,nypmx*kbmin,kblok)c in real space, fxye(i,j,k,l) = i component of force/charge at c grid point (j,kk)c in other words, fxye are the convolutions of the electric fieldc over the particle shape, where kk = k + noff(l) - 1      dimension fxye(2,nxe,nypmx*kbmin,kblok)c potential      dimension pot(nxe,nypmx,kblok)c edges(1,l) = lower boundary of particle partition lc edges(2,l) = upper boundary of particle partition l      dimension edges(idps,nblok)c nyp(l) = number of primary gridpoints in particle partition l.c noff(l) = lowermost global gridpoint in particle partition l.      dimension nyp(nblok), noff(nblok)c nypu(l) = number of primary gridpoints in uniform partition l.c noffu(l) = lowermost global gridpoint in uniform partition l.      dimension nypu(nblok), noffu(nblok)c npp(l) = number of particles in partition lc nps(l) = starting address of particles in partition l      dimension npp(nblok), nps(nblok)c sbufl = buffer for particles being sent to lower processorc sbufr = buffer for particles being sent to upper processor      dimension sbufl(idimp,nbmax,nblok), sbufr(idimp,nbmax,nblok)c rbufl = buffer for particles being received from lower processorc rbufr = buffer for particles being received from upper processor      dimension rbufl(idimp,nbmax,nblok), rbufr(idimp,nbmax,nblok)c ihole = location of holes left in particle arrays      dimension ihole(ntmax,nblok)c jsl(idps,l) = number of particles going down in particle partition lc jsr(idps,l) = number of particles going up in particle partition l      dimension jsl(idps,nblok), jsr(idps,nblok)c jss(idps,l) = scratch array for particle partition lc scr(j,l) = complex scratch array for particle partition l      dimension jss(idps,nblok), scr(nxe,nblok), info(7)c wtot = total energy      dimension wtot(3), work(3)c sorting arrays      dimension pt(npmax,nblok), ip(npmax,nblok), npic(nypm1,nblok)c scratch data for moving field partitions      dimension g(nxe,nypmx,kblok), h(2,nxe,nypmx,kblok)      dimension nyps(nblok), noffs(nblok), nypd(nblok), noffd(nblok)c scratch data for repartitioning      dimension edg(nypm1,nblok), eds(nypm1,nblok)      dimension eg(idps,nblok), es(idps,nblok), et2(2*idps,nblok)      real FLDISTR1, FSDISTR1, FGDISTR1, FHDISTR1      external FLDISTR1, FSDISTR1, FGDISTR1, FHDISTR1      character*12 labelc      parameter(indx1=indx+1,indy1=indy+1,nx2=2*nx,ny2=2*ny,nx2e=2*nxe)      parameter(nxhy2=2*nxhy,nxyh2=2*nxyh)      parameter(kxp2=(nx-1)/nvp+1,j2blok=1+mshare*(nx/kxp2-1))      parameter(kxb2=nx/kxp2)      parameter(kyp2=(ny2-1)/nvp+1,k2blok=1+mshare*(ny2/kyp2-1))      parameter(kyb2=ny2/kyp2)      parameter(jkmx2=kxb2*(kyb2/kxb2)+kyb2*(kxb2/kyb2))      parameter(kxyb2=jkmx2/(2-kxb2/jkmx2-kyb2/jkmx2))      parameter(kbmin2=1+(1-mshare)*(kxyb2/kxb2-1))      parameter(kxp21=kxp2+1,ny1=ny+1)c      dimension q2(nx2e,kyp2*kbmin2,k2blok)      dimension fxy2(2,nx2e,kyp2*kbmin2,k2blok)      dimension pot2(nx2e,kyp2*kbmin2,k2blok)      dimension qt2(ny2,kxp2,j2blok), fxyt2(2,ny2,kxp2,j2blok)      dimension fxt2(ny2,kxp2,j2blok), fyt2(ny2,kxp2,j2blok)      dimension ffg(4,ny1,kxp21,j2blok)      dimension mixup2(nxhy2), sct2(nxyh2)      dimension bs2(2,kxp2,kyp2,k2blok), br2(2,kxp2,kyp2,j2blok)      real POTC3, POTC2      external POTC3, POTC2   c  991 format (5h T = ,i7)  992 format (19h * * * q.e.d. * * *)  993 format (34h field, kinetic, total energies = ,3e14.7)c vtx = thermal velocity of electrons in x directionc qme = charge on electron, in units of e      data vtx,qme,vx0,vy0 /1.0,-1.0,0.0,0.0/c ar = half-width of particle in r direction      data ar /.912871/c relativity = (no,yes) = (0,1) = relativity is used      data relativity /0/c ci = reciprical of velocity of light      data ci /0.1/c sortime = number of time steps between electron sorting      data sortime /50/c nsrand = (0,1) = (no,yes) randomize spatially positions locallyc ndprof = profile type (uniform=0,linear=1,sinusoidal=2,gaussian=3,c                        hyperbolic secant squared=4)      data nsrand, ndprof /0,0/c ampdx/ampdx = amplitude of density compared to uniform in x/yc scaledx/scaledx = scale length for spatial coordinate in x/yc shiftdx/shiftdx = shift of spatial coordinate in x/y      data ampdx, scaledx, shiftdx /0.0,0.0,0.0/      data ampdy, scaledy, shiftdy /0.0,0.0,0.0/c imbalance = load imbalance fraction repartition triggerc (< 0.  to suppress repartion)      data imbalance /.08/c ntpose = (0,1) = (no,yes) input, output data are transposed in pfft2r      data ntpose /1/c initialize for parallel processing      call PPINIT1(idproc,id0,nvp)      kstrt = idproc + 1      if (kstrt.eq.1) then         open(unit=18,file='output2',form='formatted',status='unknown')      endifc initialize constants      nypmin = kyp      nypmax = kyp      nterf = 0      qbme = qmec     qtme = qme*dt      zero = 0.      affp = float((nx-2)*(ny-2))/float(np)c calculate partition variables      call DCOMP2L(edges,nypu,noffu,ny,kstrt,nvp,idps,nblok)c prepare fft tables      isign = 0      call WPFFT2RINIT(mixup2,sct2,indx1,indy1,nxhy2,nxyh2)c calculate form factors      call PFORMC2(ffg,q2,qt2,bs2,br2,POTC3,mixup2,sct2,affp,ar,indx1,in     1dy1,kstrt,nxe,ny2,kxp2,kyp2,j2blok,k2blok,kxp21,ny1,nxhy2,nxyh2)c     call PFORMC2(ffg,q2,qt2,bs2,br2,POTC2,mixup2,sct2,affp,ar,indx1,inc    1dy1,kstrt,nxe,ny2,kxp2,kyp2,j2blok,k2blok,kxp21,ny1,nxhy2,nxyh2)cc initialize background electrons      sxi = 0.      if (scaledx.ne.0.) sxi = 1.0/scaledx      syi = 0.      if (scaledy.ne.0.) syi = 1.0/scaledy      do 130 l = 1, nblok      nps(l) = 1      npp(l) = 0  130 continue      if (np.gt.0) thenc uniform density         if (ndprof.eq.0) then            call PFDISTR2(part,nps,FLDISTR1,zero,zero,zero,FLDISTR1,zero     1,zero,zero,npx,npy,nx,ny,idimp,npmax,nblok,kstrt,nvp,ipbc,ierr)            if (ierr.ne.0) then               call PPEXIT               stop            endif            if (nsrand.ne.0) then               call PRDISTR2(part,nps,FLDISTR1,zero,zero,zero,FLDISTR1,z     1ero,zero,zero,npx,npy,nx,ny,idimp,npmax,nblok,kstrt,nvp,ipbc)            endifc linear density         else if (ndprof.eq.1) then            call PFDISTR2(part,nps,FLDISTR1,ampdx,sxi,shiftdx,FLDISTR1,a     1mpdy,syi,shiftdy,npx,npy,nx,ny,idimp,npmax,nblok,kstrt,nvp,ipbc,ie     2rr)            if (ierr.ne.0) then               call PPEXIT               stop            endif            if (nsrand.ne.0) then               call PRDISTR2(part,nps,FLDISTR1,ampdx,sxi,shiftdx,FLDISTR     11,ampdy,syi,shiftdy,npx,npy,nx,ny,idimp,npmax,nblok,kstrt,nvp,ipbc     2)            endif         endif         call PVDISTR2(part,npp,nps,vtx,vty,vx0,vy0,npx,npy,idimp,npmax,     1nblok,kstrt,nvp,ierr)         if (ierr.ne.0) then            call PPEXIT            stop         endif      endifc find new partition analytically      if (imbalance.ge.0.0) thenc uniform density         if (ndprof.eq.0) then            call FEDGES2(edges,noff,nyp,FLDISTR1,zero,zero,zero,ny,nypmi     1n,nypmax,kstrt,nvp,nblok,idps,ipbc)c linear density         else if (ndprof.eq.1) then            call FEDGES2(edges,noff,nyp,FLDISTR1,ampdy,syi,shiftdy,ny,ny     1pmin,nypmax,kstrt,nvp,nblok,idps,ipbc)         endif         if ((nypmin.ge.1).and.((nypmax+1).le.nypmx)) then            continue         else            write (18,*) 'Field size error:nypmin,nypmax=',nypmin,nypmax            call PPEXIT            stop         endif      else         do 150 l = 1, nblok         noff(l) = noffu(l)         nyp(l) = nypu(l)  150    continue      endifc move particles into appropriate spatial regions      call PMOVE2(part,edges,npp,sbufr,sbufl,rbufr,rbufl,ihole,jsr,jsl,j     1ss,ny,kstrt,nvp,idimp,npmax,nblok,idps,nbmax,ntmax,info)      if (ierr.ne.0) then         call PPEXIT         stop      endifc set ion background      do 330 l = 1, kblok      do 320 k = 1, nypmx      do 310 j = 1, nxe      qi(j,k,l) = 0.0  310 continue  320 continue  330 continue      call PGPOST2L(part,qi,npp,noff,abs(qme),idimp,npmax,nblok,nxe,nypm     1x)c add guard cells      call PNLAGUARD2L(qi,scr,nyp,kstrt,nvp,nx,nxe,nypmx,nblok)cc * * * start main iteration loop * * *c  500 do 2000 itime = 0, 324      if (kstrt.eq.1) write (18,991) itime      write (label,991) itimec initialize charge density to background      do 530 l = 1, kblok      do 520 k = 1, nypmx      do 510 j = 1, nxe      qe(j,k,l) = 0.0  510 continue  520 continue  530 continuec deposit chargec     call PGPOST2L(part,qe,npp,noff,qme,idimp,npmax,nblok,nxe,nypmx)      call PGSPOST2L(part,qe,npp,noff,qme,idimp,npmax,nblok,nxe,nxeyp)c add guard cells      do 560 l = 1, kblok      do 550 k = 1, nypmx      do 540 j = 1, nxe      qe(j,k,l) = qe(j,k,l) + qi(j,k,l)  540 continue  550 continue  560 continuec add guard cells      call PNLAGUARD2L(qe,scr,nyp,kstrt,nvp,nx,nxe,nypmx,nblok)cc vacuum boundary conditionscc move charge density to uniform field partition      isign = -1      call PFMOVE2(qe,g,noff,nyp,noffs,nyps,noffd,nypd,jsr,jsl,isign,kyp     1,kstrt,nvp,nxe,nypmx,nblok,idps,nterf,ierr)      if (ierr.ne.0) then         call PPEXIT         stop      endifc copy charge density array qe to double size array q2      call PZDBL2D(qe,q2,nx,ny,kstrt,nxe,kyp,nypmx,kyp2,kblok,k2blok)c transform charge to fourier space      isign = -1      call WPFFT2R(q2,qt2,bs2,br2,isign,ntpose,mixup2,sct2,ttp,indx1,ind     1y1,kstrt,nxe,ny2,kxp2,kyp2,kyp2,j2blok,k2blok,nxhy2,nxyh2)c solve for electric fields      call PPOISC22(qt2,fxyt2,ffg,we,nx,ny,kstrt,ny2,kxp2,j2blok,ny1,kxp     121)      isign = 1      call WPFFT2R2(fxy2,fxyt2,bs2,br2,isign,ntpose,mixup2,sct2,ttp,indx     11,indy1,kstrt,nxe,ny2,kxp2,kyp2,kyp2,j2blok,k2blok,nxhy2,nxyh2)      call PHAFDBL2C(fxye,fxy2,nx,ny,kstrt,nxe,kyp,nypmx,kyp2,kblok,k2bl     1ok)c solve for potential      isign = 1      call PPOISC2(qt2,fxt2,fyt2,isign,ffg,wf,nx,ny,kstrt,ny2,kxp2,j2blo     1k,ny1,kxp21)      call WPFFT2R(pot2,fxt2,bs2,br2,isign,ntpose,mixup2,sct2,ttp,indx1,     1indy1,kstrt,nxe,ny2,kxp2,kyp2,kyp2,j2blok,k2blok,nxhy2,nxyh2)      call PHAFDBL2D(pot,pot2,nx,ny,kstrt,nxe,kyp,nypmx,kyp2,kblok,k2blo     1k)c move force/charge to non-uniform field partition.      isign = 1      call PFMOVE2(fxye,h,noff,nyp,noffs,nyps,noffd,nypd,jsr,jsl,isign,k     1yp,kstrt,nvp,2*nxe,nypmx,nblok,idps,nterf,ierr)      if (ierr.ne.0) then         call PPEXIT         stop      endifc copy data from field to particle partition, and copy to guard cells      call PNLCGUARD2L(fxye,nyp,kstrt,nvp,2*nxe,nypmx,nblok)c push particles      wke = 0.      if (relativity.eq.1) then         call PGRPUSH2L(part,fxye,npp,noff,qbme,dt,ci,wke,nx,ny,idimp,np     1max,nblok,nxe,nypmx,ipbc)c        call PGSRPUSH2L(part,fxye,npp,noff,qbme,dt,ci,wke,nx,ny,idimp,nc    1pmax,nblok,nxe,nxeyp,ipbc)      else         call PGPUSH2L(part,fxye,npp,noff,qbme,dt,wke,nx,ny,idimp,npmax,     1nblok,nxe,nypmx,ipbc)c        call PGSPUSH2L(part,fxye,npp,noff,qbme,dt,wke,nx,ny,idimp,npmaxc    1,nblok,nxe,nxeyp,ipbc)      endifc move particles into appropriate spatial regions      call PMOVE2(part,edges,npp,sbufr,sbufl,rbufr,rbufl,ihole,jsr,jsl,j     1ss,ny,kstrt,nvp,idimp,npmax,nblok,idps,nbmax,ntmax,info)      if (ierr.ne.0) then         call PPEXIT         stop      endifcc begin repartitioning      if (imbalance >= 0.0) thenc calculate percent imbalance      anpav = real(info(7))/real(nvp)      if (anpav > 0.0) then         pibal = max(real(info(2))-anpav,anpav-real(info(3)))/anpav      endif      if (pibal > imbalance) thenc count the number of particles per cell         isign = 1         call PCOUNT2YL(part,isign,npic,npp,noff,nyp,idimp,npmax,nblok,n     1ypm1)c save old repartitioning boundaries         do 720 l = 1, nblok         noffs(l) = noff(l)         nyps(l) = nyp(l)  720    continuec determine new repartitioning boundaries         call REPARTD2(edges,edg,eds,eg,es,et2,npic,noff,nyp,anpav,nypmi     1n,nypmax,kstrt,nvp,nblok,idps,nypm1)         if ((nypmin.ge.1).and.((nypmax+1).le.nypmx)) then            continue         else            write (18,*) 'Field size error:nypmin,nypmax=',nypmin,nypmax            call PPEXIT            stop         endif         nterf = 0c move background ion density to new field partition         do 730 l = 1, nblok         noffd(l) = noff(l)         nypd(l) = nyp(l)  730    continue         isign = 0         call PFMOVE2(qi,g,noff,nyp,noffs,nyps,noffd,nypd,jsr,jsl,isign,     1kyp,kstrt,nvp,nxe,nypmx,nblok,idps,nterf,ierr)         if (ierr.ne.0) then            call PPEXIT            stop         endif         nterf = 0c zero out guard cells         call PZGUARD2L(qi,nyp,nx,nxe,nypmx,kblok)c move particles into appropriate spatial regions         call PMOVE2(part,edges,npp,sbufr,sbufl,rbufr,rbufl,ihole,jsr,js     1l,jss,ny,kstrt,nvp,idimp,npmax,nblok,idps,nbmax,ntmax,info)         if (ierr.ne.0) then            call PPEXIT            stop         endif         if (kstrt.eq.1) then            write (18,*) 'repartitioning complete, imbalance = ',pibal         endif      endif      endifc end repartitioningcc sort particles      if (sortime.gt.0) then         if (mod(itime,sortime).eq.0) then            call PSORTP2YL(part,pt,ip,npic,npp,noff,nyp,idimp,npmax,nblo     1k,nypm1)         endif       endifc energy diagnostic      wtot(1) = we      wtot(2) = wke      wtot(3) = we + wke      call PSUM(wtot,work,3,1)      if (kstrt.eq.1) write (18,993) wtot(1), wtot(2), wtot(3) 2000 continuecc * * * end main iteration loop * * *c      if (kstrt.eq.1) write (18,992) 3000 continue      call PPEXIT      stop      end