c basic parallel PIC library for MPI communicationsc written by viktor k. decyk, uclac copyright 1995, regents of the university of californiac update: august 20, 2005c-----------------------------------------------------------------------      subroutine PPINIT1(idproc,id0,nvp)c this subroutine initializes parallel processingc output: idproc, id0, nvpc idproc = processor id in lgrp communicatorc id0 = processor id in MPI_COMM_WORLDc nvp = number of real or virtual processors obtained      implicit none      integer idproc, id0, nvpc get definition of MPI constants      include 'mpif.h'c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=10)c nproc = number of real or virtual processors obtainedc lgrp = current communicatorc mreal = default datatype for realsc mint = default datatype for integersc mcplx = default datatype for complex typec mdouble = default double precision typec lworld = MPI_COMM_WORLD communicator      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer ierror, ndprec      logical flag      real small, prec, vresult      save /PPARMS/      data small /1.0e-12/      prec = 1.0 + smallc ndprec = (0,1) = (no,yes) use (normal,autodouble) precision      if (vresult(prec).gt.1.0) then         ndprec = 1      else         ndprec = 0      endifc this segment is used for shared memory computersc     nproc = nvpc     id0 = 0c     idproc = 0c this segment is used for mpi computers      if (MPI_STATUS_SIZE.gt.lstat) then         write (2,*) ' status size too small, actual/required = ', lstat     1, MPI_STATUS_SIZE         stop      endifc indicate whether MPI_INIT has been called      call MPI_INITIALIZED(flag,ierror)      if (.not.flag) thenc initialize the MPI execution environment         call MPI_INIT(ierror)         if (ierror.ne.0) stop      endif      lworld = MPI_COMM_WORLD      lgrp = lworldc determine the rank of the calling process in the communicator      call MPI_COMM_RANK(lgrp,idproc,ierror)c determine the size of the group associated with a communicator      call MPI_COMM_SIZE(lgrp,nproc,ierror)c set default datatypes      mint = MPI_INTEGER      mdouble = MPI_DOUBLE_PRECISIONc single precision      if (ndprec.eq.0) then         mreal = MPI_REAL         mcplx = MPI_COMPLEXc double precision      elsec        mint = MPI_INTEGER8         mreal = MPI_DOUBLE_PRECISION         mcplx = MPI_DOUBLE_COMPLEX      endif      nvp = nproc      id0 = idproc      return      endc-----------------------------------------------------------------------      function vresult(prec)      implicit none      real prec, vresult      vresult = prec      return      endc-----------------------------------------------------------------------      subroutine PPEXITc this subroutine terminates parallel processing      implicit nonec common block for parallel processing      integer nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc lgrp = current communicator      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworld      integer ierror      logical flagc indicate whether MPI_INIT has been called      call MPI_INITIALIZED(flag,ierror)      if (flag) thenc synchronize processes         call MPI_BARRIER(lworld,ierror)c terminate MPI execution environment         call MPI_FINALIZE(ierror)      endif      return      endc-----------------------------------------------------------------------      subroutine PWTIMERA(icntrl,time,dtime)c this subroutine performs local wall clock timingc input: icntrl, dtimec icntrl = (-1,0,1) = (initialize,ignore,read) clockc clock should be initialized before it is read!c time = elapsed time in secondsc dtime = current timec written for mpi      implicit none      integer icntrl      real time      double precision dtimec local data      double precision jclock      double precision MPI_WTIME      external MPI_WTIMEc initialize clock      if (icntrl.eq.(-1)) then         dtime = MPI_WTIME()c read clock and write time difference from last clock initialization      else if (icntrl.eq.1) then         jclock = dtime         dtime = MPI_WTIME()         time = real(dtime - jclock)      endif      return      endc-----------------------------------------------------------------------      subroutine PSUM(f,g,nxp,nblok)c this subroutine performs a parallel sum of a vector, that is:c f(j,k) = sum over k of f(j,k)c assumes the number of processors nproc is a power of two.c the algorithm performs partial sums in binary pairs, as follows:c first, adjacent processors exchange vectors and sum them.  next,c processors separated by 2 exchange the new vectors and sum them, thenc those separated by 4, up to processors separated by nproc/2.  at thec end, all processors contain the same summation.c f = input and output datac g = scratch arrayc nxp = number of data values in vectorc nblok = number of data blocksc written by viktor k. decyk, ucla      implicit none      real f, g      integer nxp, nblok      dimension f(nxp,nblok), g(nxp,nblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=10)c nproc = number of real or virtual processors obtainedc lgrp = current communicatorc mreal = default datatype for reals      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer istatus, ierr, msid      integer idproc, kstrt, ks, l, kxs, k, kb, lb, j      dimension istatus(lstat)c find processor idc this line is used for shared memory computersc     idproc = 0c this line is used for mpi computers      call MPI_COMM_RANK(lgrp,idproc,ierr)      kstrt = idproc + 1      if (kstrt.gt.nproc) return      ks = kstrt - 2      l = 1      kxs = 1c main iteration loop   10 if (kxs.ge.nproc) go to 60c shift data      do 30 k = 1, nblok      kb = k + ks      lb = kb/kxs      kb = kb + 1      lb = lb - 2*(lb/2)c this loop is used for shared memory computersc     do 20 j = 1, nxpc     if (lb.eq.0) thenc        g(j,k) = f(j,kb+kxs)c     elsec        g(j,k) = f(j,kb-kxs)c     endifc  20 continuec this segment is used for mpi computers      if (lb.eq.0) then         call MPI_IRECV(g,nxp,mreal,kb+kxs-1,l+nxp,lgrp,msid,ierr)         call MPI_SEND(f,nxp,mreal,kb+kxs-1,l+nxp,lgrp,ierr)      else         call MPI_IRECV(g,nxp,mreal,kb-kxs-1,l+nxp,lgrp,msid,ierr)         call MPI_SEND(f,nxp,mreal,kb-kxs-1,l+nxp,lgrp,ierr)      endif      call MPI_WAIT(msid,istatus,ierr)   30 continuec perform sum      do 50 k = 1, nblok      do 40 j = 1, nxp      f(j,k) = f(j,k) + g(j,k)   40 continue   50 continue      l = l + 1      kxs = kxs + kxs      go to 10   60 return      endc-----------------------------------------------------------------------      subroutine PISUM(if,ig,nxp,nblok)c this subroutine performs a parallel sum of a vector, that is:c if(j,k) = sum over k of if(j,k)c assumes the number of processors nproc is a power of two.c the algorithm performs partial sums in binary pairs, as follows:c first, adjacent processors exchange vectors and sum them.  next,c processors separated by 2 exchange the new vectors and sum them, thenc those separated by 4, up to processors separated by nproc/2.  at thec end, all processors contain the same summation.c if = input and output integer datac ig = scratch integer arrayc nxp = number of data values in vectorc nblok = number of data blocksc written by viktor k. decyk, ucla      implicit none      integer if, ig, nxp, nblok      dimension if(nxp,nblok), ig(nxp,nblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=10)c nproc = number of real or virtual processors obtainedc lgrp = current communicatorc mint = default datatype for integers      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer istatus, ierr, nsid      integer idproc, kstrt, ks, l, kxs, k, kb, lb, j      dimension istatus(lstat)c find processor idc this line is used for shared memory computersc     idproc = 0c this line is used for mpi computers      call MPI_COMM_RANK(lgrp,idproc,ierr)      kstrt = idproc + 1      if (kstrt.gt.nproc) return      ks = kstrt - 2      l = 1      kxs = 1c main iteration loop   10 if (kxs.ge.nproc) go to 60c shift data      do 30 k = 1, nblok      kb = k + ks      lb = kb/kxs      kb = kb + 1      lb = lb - 2*(lb/2)c this loop is used for shared memory computersc     do 20 j = 1, nxpc     if (lb.eq.0) thenc        ig(j,k) = if(j,kb+kxs)c     elsec        ig(j,k) = if(j,kb-kxs)c     endifc  20 continuec this segment is used for mpi computers      if (lb.eq.0) then         call MPI_ISEND(if,nxp,mint,kb+kxs-1,l+nxp,lgrp,nsid,ierr)         call MPI_RECV(ig,nxp,mint,kb+kxs-1,l+nxp,lgrp,istatus,ierr)      else         call MPI_ISEND(if,nxp,mint,kb-kxs-1,l+nxp,lgrp,nsid,ierr)         call MPI_RECV(ig,nxp,mint,kb-kxs-1,l+nxp,lgrp,istatus,ierr)      endif      call MPI_WAIT(nsid,istatus,ierr)   30 continuec perform sum      do 50 k = 1, nblok      do 40 j = 1, nxp      if(j,k) = if(j,k) + ig(j,k)   40 continue   50 continue      l = l + 1      kxs = kxs + kxs      go to 10   60 return      endc-----------------------------------------------------------------------      subroutine PDSUM(f,g,nxp,nblok)c this subroutine performs a parallel sum of a vector, that is:c f(j,k) = sum over k of f(j,k)c assumes the number of processors nproc is a power of two.c the algorithm performs partial sums in binary pairs, as follows:c first, adjacent processors exchange vectors and sum them.  next,c processors separated by 2 exchange the new vectors and sum them, thenc those separated by 4, up to processors separated by nproc/2.  at thec end, all processors contain the same summation.c f = input and output double precision datac g = scratch double precision arrayc nxp = number of data values in vectorc nblok = number of data blocksc written by viktor k. decyk, ucla      implicit none      double precision f, g      integer nxp, nblok      dimension f(nxp,nblok), g(nxp,nblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=10)c nproc = number of real or virtual processors obtainedc lgrp = current communicatorc mreal = default datatype for reals      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer istatus, ierr, msid      integer idproc, kstrt, ks, l, kxs, k, kb, lb, j      dimension istatus(lstat)c find processor idc this line is used for shared memory computersc     idproc = 0c this line is used for mpi computers      call MPI_COMM_RANK(lgrp,idproc,ierr)      kstrt = idproc + 1      if (kstrt.gt.nproc) return      ks = kstrt - 2      l = 1      kxs = 1c main iteration loop   10 if (kxs.ge.nproc) go to 60c shift data      do 30 k = 1, nblok      kb = k + ks      lb = kb/kxs      kb = kb + 1      lb = lb - 2*(lb/2)c this loop is used for shared memory computersc     do 20 j = 1, nxpc     if (lb.eq.0) thenc        g(j,k) = f(j,kb+kxs)c     elsec        g(j,k) = f(j,kb-kxs)c     endifc  20 continuec this segment is used for mpi computers      if (lb.eq.0) then         call MPI_IRECV(g,nxp,mdouble,kb+kxs-1,l+nxp,lgrp,msid,ierr)         call MPI_SEND(f,nxp,mdouble,kb+kxs-1,l+nxp,lgrp,ierr)      else         call MPI_IRECV(g,nxp,mdouble,kb-kxs-1,l+nxp,lgrp,msid,ierr)         call MPI_SEND(f,nxp,mdouble,kb-kxs-1,l+nxp,lgrp,ierr)      endif      call MPI_WAIT(msid,istatus,ierr)   30 continuec perform sum      do 50 k = 1, nblok      do 40 j = 1, nxp      f(j,k) = f(j,k) + g(j,k)   40 continue   50 continue      l = l + 1      kxs = kxs + kxs      go to 10   60 return      endc-----------------------------------------------------------------------      subroutine PIMAX(if,ig,nxp,nblok)c this subroutine finds parallel maximum for each element of a vectorc that is, if(j,k) = maximum as a function of k of if(j,k)c assumes the number of processors nproc is a power of two.c the algorithm performs partial sums in binary pairs, as follows:c first, adjacent processors exchange vectors and sum them.  next,c processors separated by 2 exchange the new vectors and sum them, thenc those separated by 4, up to processors separated by nproc/2.  at thec end, all processors contain the same summation.c if = input and output integer datac ig = scratch integer arrayc nxp = number of data values in vectorc nblok = number of data blocksc written by viktor k. decyk, ucla      implicit none      integer if, ig      integer nxp, nblok      dimension if(nxp,nblok), ig(nxp,nblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=10)c nproc = number of real or virtual processors obtainedc lgrp = current communicatorc mreal = default datatype for reals      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer istatus, ierr, msid      integer idproc, kstrt, ks, l, kxs, k, kb, lb, j      dimension istatus(lstat)c find processor idc this line is used for shared memory computersc     idproc = 0c this line is used for mpi computers      call MPI_COMM_RANK(lgrp,idproc,ierr)      kstrt = idproc + 1      if (kstrt.gt.nproc) return      ks = kstrt - 2      l = 1      kxs = 1c main iteration loop   10 if (kxs.ge.nproc) go to 60c shift data      do 30 k = 1, nblok      kb = k + ks      lb = kb/kxs      kb = kb + 1      lb = lb - 2*(lb/2)c this loop is used for shared memory computersc     do 20 j = 1, nxpc     if (lb.eq.0) thenc        ig(j,k) = if(j,kb+kxs)c     elsec        ig(j,k) = if(j,kb-kxs)c     endifc  20 continuec this segment is used for mpi computers      if (lb.eq.0) then         call MPI_IRECV(ig,nxp,mint,kb+kxs-1,l+nxp,lgrp,msid,ierr)         call MPI_SEND(if,nxp,mint,kb+kxs-1,l+nxp,lgrp,ierr)      else         call MPI_IRECV(ig,nxp,mint,kb-kxs-1,l+nxp,lgrp,msid,ierr)         call MPI_SEND(if,nxp,mint,kb-kxs-1,l+nxp,lgrp,ierr)      endif      call MPI_WAIT(msid,istatus,ierr)   30 continuec find maximum      do 50 k = 1, nblok      do 40 j = 1, nxp      if(j,k) = max0(if(j,k),ig(j,k))   40 continue   50 continue      l = l + 1      kxs = kxs + kxs      go to 10   60 return      endc-----------------------------------------------------------------------      subroutine PSCAN(f,g,s,nxp,nblok)c this subroutine performs a parallel prefix reduction of a vector,c that is: f(j,k) = sum over k of f(j,k), where the sum is over k valuesc less than idproc.c assumes the number of processors nproc is a power of two.c the algorithm performs partial sums in binary pairs, as follows:c first, adjacent processors exchange vectors and sum them.  next,c processors separated by 2 exchange the new vectors and sum them, thenc those separated by 4, up to processors separated by nproc/2.  at thec end, all processors contain the same summation.c f = input and output datac g, s = scratch arrayc nxp = number of data values in vectorc nblok = number of data blocksc written by viktor k. decyk, ucla      implicit none      real f, g, s      integer nxp, nblok      dimension f(nxp,nblok), g(nxp,nblok), s(nxp,nblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=10)c nproc = number of real or virtual processors obtainedc lgrp = current communicatorc mreal = default datatype for reals      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer istatus, ierr, msid      integer idproc, kstrt, ks, l, kxs, k, kb, lb, j      dimension istatus(lstat)c find processor idc this line is used for shared memory computersc     idproc = 0c this line is used for mpi computers      call MPI_COMM_RANK(lgrp,idproc,ierr)      kstrt = idproc + 1      if (kstrt.gt.nproc) return      ks = kstrt - 2      l = 1      kxs = 1c initialize global sum      do 20 k = 1, nblok      do 10 j = 1, nxp      s(j,k) = f(j,k)   10 continue   20 continuec main iteration loop   30 if (kxs.ge.nproc) go to 90c shift data      do 60 k = 1, nblok      kb = k + ks      lb = kb/kxs      kb = kb + 1      lb = lb - 2*(lb/2)c this loop is used for shared memory computersc     do 40 j = 1, nxpc     if (lb.eq.0) thenc        g(j,k) = s(j,kb+kxs)c     elsec        g(j,k) = s(j,kb-kxs)c     endifc  40 continuec this segment is used for mpi computers      if (lb.eq.0) then         call MPI_IRECV(g,nxp,mreal,kb+kxs-1,l+nxp,lgrp,msid,ierr)         call MPI_SEND(s,nxp,mreal,kb+kxs-1,l+nxp,lgrp,ierr)      else         call MPI_IRECV(g,nxp,mreal,kb-kxs-1,l+nxp,lgrp,msid,ierr)         call MPI_SEND(s,nxp,mreal,kb-kxs-1,l+nxp,lgrp,ierr)      endif      call MPI_WAIT(msid,istatus,ierr)c perform prefix scan      if (lb.ne.0) then         do 50 j = 1, nxp         f(j,k) = f(j,k) + g(j,k)   50    continue      endif   60 continuec perform sum      do 80 k = 1, nblok      do 70 j = 1, nxp      s(j,k) = s(j,k) + g(j,k)   70 continue   80 continue      l = l + 1      kxs = kxs + kxs      go to 30   90 return      endc-----------------------------------------------------------------------      subroutine P0COPY(f,g,nxp)c this subroutine copies real data f on node 0 to g on other nodesc f/g = data to be sent/receivedc nxp = size of data fc input: f, nxpc output: g      implicit none      integer nxp      real f, g      dimension f(nxp), g(nxp)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=10)c nproc = number of real or virtual processors obtainedc lgrp = current communicatorc mdouble = default double precision type      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer istatus, idproc, i, id, ierr      dimension istatus(lstat)c this segment is used for mpi computersc determine the rank of the calling process in the communicator      call MPI_COMM_RANK(lgrp,idproc,ierr)c node 0 sends messages to other nodes      if (idproc.eq.0) then         do 10 i = 2, nproc            id = i - 1            call MPI_SEND(f,nxp,mreal,id,95,lgrp,ierr)   10    continuec other nodes receive data from node 0      else         call MPI_RECV(g,nxp,mreal,0,95,lgrp,istatus,ierr)      endif      return      endc-----------------------------------------------------------------------c 2d parallel PIC library for MPI communicationsc written by viktor k. decyk, uclac copyright 1995, regents of the university of californiac update: march 24, 2006c-----------------------------------------------------------------------      subroutine DCOMP2L(edges,nyp,noff,ny,kstrt,nvp,idps,nblok)c this subroutine determines spatial boundaries for particlec decomposition, calculates number of grid points in each spatialc region, and the offset of these grid points from the global addressc edges(1,l) = lower boundary of particle partition lc edges(2,l) = upper boundary of particle partition lc nyp(l) = number of primary gridpoints in particle partition l.c noff(l) = lowermost global gridpoint in particle partition l.c ny = system length in y directionc kstrt = starting data block numberc nvp = number of real or virtual processorsc idps = number of partition boundariesc nblok = number of particle partitions.      dimension edges(idps,nblok)      dimension nyp(nblok), noff(nblok)      ks = kstrt - 2      at1 = float(ny)/float(nvp)      do 10 l = 1, nblok      kb = l + ks      edges(1,l) = at1*float(kb)      noff(l) = edges(1,l)      edges(2,l) = at1*float(kb + 1)      kr = edges(2,l)      nyp(l) = kr - noff(l)   10 continue      return      endc-----------------------------------------------------------------------      subroutine PMOVE2(part,edges,npp,sbufr,sbufl,rbufr,rbufl,ihole,jsr     1,jsl,jss,ny,kstrt,nvp,idimp,npmax,nblok,idps,nbmax,ntmax,info)c this subroutine moves particles into appropriate spatial regionsc periodic boundary conditionsc part(1,n,l) = position x of particle n in partition lc part(2,n,l) = position y of particle n in partition lc part(3,n,l) = velocity vx of particle n in partition lc part(4,n,l) = velocity vy of particle n in partition lc edges(1,l) = lower boundary of particle partition lc edges(2,l) = upper boundary of particle partition lc npp(l) = number of particles in partition lc sbufl = buffer for particles being sent to lower processorc sbufr = buffer for particles being sent to upper processorc rbufl = buffer for particles being received from lower processorc rbufr = buffer for particles being received from upper processorc ihole = location of holes left in particle arraysc jsl(idps,l) = number of particles going down in particle partition lc jsr(idps,l) = number of particles going up in particle partition lc jss(idps,l) = scratch array for particle partition lc ny = system length in y directionc kstrt = starting data block numberc nvp = number of real or virtual processorsc idimp = size of phase space = 4c npmax = maximum number of particles in each partitionc nblok = number of particle partitions.c idps = number of partition boundariesc nbmax =  size of buffers for passing particles between processorsc ntmax =  size of hole array for particles leaving processorsc info = status informationc info(1) = ierr = (0,N) = (no,yes) error condition existsc info(2) = maximum number of particles per processorc info(3) = minimum number of particles per processorc info(4) = maximum number of buffer overflowsc info(5) = maximum number of particle passes requiredc info(6) = total number of particles on entryc info(7) = total number of particles on exit      implicit none      real part, edges, sbufr, sbufl, rbufr, rbufl      integer npp, ihole, jsr, jsl, jss, info      integer ny, kstrt, nvp, idimp, npmax, nblok, idps, nbmax, ntmax      dimension part(idimp,npmax,nblok)      dimension edges(idps,nblok), npp(nblok)      dimension sbufl(idimp,nbmax,nblok), sbufr(idimp,nbmax,nblok)      dimension rbufl(idimp,nbmax,nblok), rbufr(idimp,nbmax,nblok)      dimension jsl(idps,nblok), jsr(idps,nblok), jss(idps,nblok)      dimension ihole(ntmax,nblok)      dimension info(7)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=10)c lgrp = current communicatorc mint = default datatype for integersc mreal = default datatype for reals      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer iy      parameter(iy=2)      integer ierr, l, ks, iter, npr, nps, npt, kb, kl, kr, j, j1, j2      integer i, nbsize, nter, mter, itermax      integer msid, istatus      integer ibflg, iwork      real any, yt      dimension msid(4), istatus(lstat)      dimension ibflg(4), iwork(4)      any = float(ny)      ks = kstrt - 2      nbsize = idimp*nbmax      iter = 2      nter = 0      do 5 j = 1, 7      info(j) = 0    5 continue      itermax = 2000c debugging section: count total number of particles before move      npr = 0      do 10 l = 1, nblok      npr = npr + npp(l)   10 continuec buffer outgoing particles   20 mter = 0      do 50 l = 1, nblok      kb = l + ks      jsl(1,l) = 0      jsr(1,l) = 0      jss(2,l) = 0      do 30 j = 1, npp(l)      yt = part(iy,j,l)c particles going down      if (yt.lt.edges(1,l)) then         if (jsl(1,l).lt.nbmax) then            jsl(1,l) = jsl(1,l) + 1            if (kb.eq.0) yt = yt + any            do 23 i = 1, idimp            sbufl(i,jsl(1,l),l) = part(i,j,l)   23       continue            sbufl(iy,jsl(1,l),l) = yt            ihole(jsl(1,l)+jsr(1,l),l) = j         else            jss(2,l) = 1            go to 40         endifc particles going up      else if (yt.ge.edges(2,l)) then         if (jsr(1,l).lt.nbmax) then            jsr(1,l) = jsr(1,l) + 1            if ((kb+1).eq.nvp) yt = yt - any            do 27 i = 1, idimp            sbufr(i,jsr(1,l),l) = part(i,j,l)   27       continue            sbufr(iy,jsr(1,l),l) = yt            ihole(jsl(1,l)+jsr(1,l),l) = j         else            jss(2,l) = 1            go to 40         endif      endif   30 continue   40 jss(1,l) = jsl(1,l) + jsr(1,l)   50 continuec check for full buffer condition      nps = 0      do 90 l = 1, nblok      nps = max0(nps,jss(2,l))   90 continue      ibflg(3) = npsc copy particle buffers  100 iter = iter + 2      mter = mter + 1      do 130 l = 1, nblokc get particles from below and above      kr = l + ks + 2      if (kr.gt.nvp) kr = kr - nvp      kl = l + ks      if (kl.lt.1) kl = kl + nvpc this segment is used for shared memory computersc     jsl(2,l) = jsr(1,kl)c     do 110 j = 1, jsl(2,l)c     do 105 i = 1, idimpc     rbufl(i,j,l) = sbufr(i,j,kl)c 105 continuec 110 continuec     jsr(2,l) = jsl(1,kr)c     do 120 j = 1, jsr(2,l)c     do 115 i = 1, idimpc     rbufr(i,j,l) = sbufl(i,j,kr)c 115 continuec 120 continuec this segment is used for mpi computersc post receive      call MPI_IRECV(rbufl,nbsize,mreal,kl-1,iter-1,lgrp,msid(1),ierr)      call MPI_IRECV(rbufr,nbsize,mreal,kr-1,iter,lgrp,msid(2),ierr)c send particles      call MPI_ISEND(sbufr,idimp*jsr(1,l),mreal,kr-1,iter-1,lgrp,msid(3)     1,ierr)      call MPI_ISEND(sbufl,idimp*jsl(1,l),mreal,kl-1,iter,lgrp,msid(4),i     1err)c wait for particles to arrive      call MPI_WAIT(msid(1),istatus,ierr)      call MPI_GET_COUNT(istatus,mreal,nps,ierr)      jsl(2,l) = nps/idimp      call MPI_WAIT(msid(2),istatus,ierr)      call MPI_GET_COUNT(istatus,mreal,nps,ierr)      jsr(2,l) = nps/idimp  130 continuec check if particles must be passed further      nps = 0      do 160 l = 1, nblokc check if any particles coming from above belong here      jsl(1,l) = 0      jsr(1,l) = 0      jss(2,l) = 0      do 140 j = 1, jsr(2,l)      if (rbufr(iy,j,l).lt.edges(1,l)) jsl(1,l) = jsl(1,l) + 1      if (rbufr(iy,j,l).ge.edges(2,l)) jsr(1,l) = jsr(1,l) + 1  140 continue      if (jsr(1,l).ne.0) write (2,*) 'Info: particles returning up'c check if any particles coming from below belong here      do 150 j = 1, jsl(2,l)      if (rbufl(iy,j,l).ge.edges(2,l)) jsr(1,l) = jsr(1,l) + 1      if (rbufl(iy,j,l).lt.edges(1,l)) jss(2,l) = jss(2,l) + 1  150 continue      if (jss(2,l).ne.0) write (2,*) 'Info: particles returning down'      jsl(1,l) = jsl(1,l) + jss(2,l)      nps = max0(nps,jsl(1,l)+jsr(1,l))  160 continue      ibflg(2) = npsc make sure sbufr and sbufl have been sent      call MPI_WAIT(msid(3),istatus,ierr)      call MPI_WAIT(msid(4),istatus,ierr)      if (nps.eq.0) go to 210c remove particles which do not belong here      do 200 l = 1, nblok      kb = l + ksc first check particles coming from above      jsl(1,l) = 0      jsr(1,l) = 0      jss(2,l) = 0      do 170 j = 1, jsr(2,l)      yt = rbufr(iy,j,l)c particles going down      if (yt.lt.edges(1,l)) then         jsl(1,l) = jsl(1,l) + 1         if (kb.eq.0) yt = yt + any         rbufr(iy,j,l) = yt         do 163 i = 1, idimp         sbufl(i,jsl(1,l),l) = rbufr(i,j,l)  163    continuec particles going up, should not happen      elseif (yt.ge.edges(2,l)) then         jsr(1,l) = jsr(1,l) + 1         if ((kb+1).eq.nvp) yt = yt - any         rbufr(iy,j,l) = yt         do 165 i = 1, idimp         sbufr(i,jsr(1,l),l) = rbufr(i,j,l)  165    continuec particles staying here      else         jss(2,l) = jss(2,l) + 1         do 167 i = 1, idimp         rbufr(i,jss(2,l),l) = rbufr(i,j,l)  167    continue      endif  170 continue      jsr(2,l) = jss(2,l)c next check particles coming from below      jss(2,l) = 0      do 180 j = 1, jsl(2,l)      yt = rbufl(iy,j,l)c particles going up      if (yt.ge.edges(2,l)) then         if (jsr(1,l).lt.nbmax) then            jsr(1,l) = jsr(1,l) + 1            if ((kb+1).eq.nvp) yt = yt - any            rbufl(iy,j,l) = yt            do 173 i = 1, idimp            sbufr(i,jsr(1,l),l) = rbufl(i,j,l)  173       continue             else            jss(2,l) = 2*npmax            go to 190         endifc particles going down, should not happen      elseif (yt.lt.edges(1,l)) then         if (jsl(1,l).lt.nbmax) then            jsl(1,l) = jsl(1,l) + 1            if (kb.eq.0) yt = yt + any            rbufl(iy,j,l) = yt            do 175 i = 1, idimp            sbufl(i,jsl(1,l),l) = rbufl(i,j,l)  175       continue         else            jss(2,l) = 2*npmax            go to 190         endifc particles staying here      else         jss(2,l) = jss(2,l) + 1         do 177 i = 1, idimp         rbufl(i,jss(2,l),l) = rbufl(i,j,l)  177    continue      endif  180 continue  190 jsl(2,l) = jss(2,l)  200 continuec check if move would overflow particle array  210 nps = 0      npt = npmax      do 220 l = 1, nblok      jss(2,l) = npp(l) + jsl(2,l) + jsr(2,l) - jss(1,l)        nps = max0(nps,jss(2,l))      npt = min0(npt,jss(2,l))  220 continue      ibflg(1) = nps      ibflg(4) = -npt      call PIMAX(ibflg,iwork,4,1)      info(2) = ibflg(1)      info(3) = -ibflg(4)      ierr = ibflg(1) - npmax      if (ierr.gt.0) then         write (2,*) 'particle overflow error, ierr = ', ierr         info(1) = ierr         return      endif      do 260 l = 1, nblokc distribute incoming particles from buffersc distribute particles coming from below into holes      jss(2,l) = min0(jss(1,l),jsl(2,l))      do 230 j = 1, jss(2,l)      do 225 i = 1, idimp      part(i,ihole(j,l),l) = rbufl(i,j,l)  225 continue  230 continue      if (jss(1,l).gt.jsl(2,l)) then         jss(2,l) = min0(jss(1,l)-jsl(2,l),jsr(2,l))      else         jss(2,l) = jsl(2,l) - jss(1,l)      endif      do 240 j = 1, jss(2,l)c no more particles coming from belowc distribute particles coming from above into holes      if (jss(1,l).gt.jsl(2,l)) then         do 233 i = 1, idimp         part(i,ihole(j+jsl(2,l),l),l) = rbufr(i,j,l)  233    continue      elsec no more holesc distribute remaining particles from below into bottom         do 237 i = 1, idimp         part(i,j+npp(l),l) = rbufl(i,j+jss(1,l),l)  237    continue      endif  240 continue      if (jss(1,l).le.jsl(2,l)) then         npp(l) = npp(l) + (jsl(2,l) - jss(1,l))         jss(1,l) = jsl(2,l)      endif      jss(2,l) = jss(1,l) - (jsl(2,l) + jsr(2,l))      if (jss(2,l).gt.0) then         jss(1,l) = (jsl(2,l) + jsr(2,l))         jsr(2,l) = jss(2,l)      else         jss(1,l) = jss(1,l) - jsl(2,l)         jsr(2,l) = -jss(2,l)      endif      do 250 j = 1, jsr(2,l)c holes left overc fill up remaining holes in particle array with particles from bottom      if (jss(2,l).gt.0) then         j1 = npp(l) - j + 1         j2 = jss(1,l) + jss(2,l) - j + 1         if (j1.gt.ihole(j2,l)) thenc move particle only if it is below current hole            do 243 i = 1, idimp            part(i,ihole(j2,l),l) = part(i,j1,l)  243       continue         endif      elsec no more holesc distribute remaining particles from above into bottom         do 247 i = 1, idimp         part(i,j+npp(l),l) = rbufr(i,j+jss(1,l),l)  247    continue      endif  250 continue      if (jss(2,l).gt.0) then         npp(l) = npp(l) - jsr(2,l)      else         npp(l) = npp(l) + jsr(2,l)      endif      jss(1,l) = 0  260 continuec check if any particles have to be passed further      info(5) = max0(info(5),mter)      if (ibflg(2).gt.0) then         write (2,*) 'Info: particles being passed further = ', ibflg(2)         if (ibflg(3).gt.0) ibflg(3) = 1         if (iter.lt.itermax) go to 100         ierr = -((iter-2)/2)         write (2,*) 'Iteration overflow, iter = ', ierr         info(1) = ierr         go to 280      endifc check if buffer overflowed and more particles remain to be checked      if (ibflg(3).gt.0) then         nter = nter + 1         info(4) = nter         go to 20      endifc debugging section: count total number of particles after move      nps = 0      do 270 l = 1, nblok      nps = nps + npp(l)  270 continue      ibflg(2) = nps      ibflg(1) = npr      call PISUM(ibflg,iwork,2,1)      info(6) = ibflg(1)      info(7) = ibflg(2)      if (ibflg(1).ne.ibflg(2)) then         write (2,*) 'particle number error, old/new=',ibflg(1),ibflg(2)         info(1) = 1      endifc information  280 if (nter.gt.0) then         write (2,*) 'Info: ', nter, ' buffer overflows, nbmax=', nbmax      endif      return      endc-----------------------------------------------------------------------      subroutine REPARTD2(edges,edg,eds,eg,es,et2,npic,noff,nyp,anpav,ny     1pmin,nypmax,kstrt,nvp,nblok,idps,nypm)c this subroutines finds new partitions boundaries (edges,noff,nyp)c from old partition information (npic,nyp).c edges(1,l) = lower boundary of particle partition lc edges(2,l) = upper boundary of particle partition lc edg/eds/eg/es/et2 = scratch arraysc npic(l) = number of particles per grid in partition lc noff(l) = lowermost global gridpoint in particle partition lc nyp(l) = number of primary gridpoints in particle partition lc anpav = average number of particles per partition desiredc nypmin/nypmax = minimum/maximum value of nyp in new partitionc kstrt = starting data block numberc nvp = number of real or virtual processorsc nblok = number of field partitions.c idps = number of partition boundariesc nypm = maximum size of particle partition      implicit none      real edges, edg, eds, eg, es, et2      integer npic, noff, nyp      real anpav      integer nypmin, nypmax, kstrt, nvp, nblok, idps, nypm      dimension edges(idps,nblok)      dimension edg(nypm,nblok), eds(nypm,nblok)      dimension eg(idps,nblok), es(idps,nblok), et2(2*idps,nblok)      dimension npic(nypm,nblok), noff(nblok), nyp(nblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=10)c lgrp = current communicatorc mint = default datatype for integersc mreal = default datatype for reals      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer ks, iter, nter, nyp1, npav, k1, kl, kr, k, l, ierr      real sum1, at1, at2, apav, anpl, anpr      integer msid, istatus      integer ibflg, iwork      dimension istatus(lstat)      dimension ibflg(2), iwork(2)c exit if flag is set      ks = kstrt - 2      iter = 2c copy number of particles and grid in current partition      do 20 l = 1, nblok      sum1 = 0.      do 10 k = 1, nyp(l)      at1 = npic(k,l)      sum1 = sum1 + at1      eds(k,l) = at1   10 continue      edges(1,l) = sum1      edges(2,l) = nyp(l)      et2(1,l) = edges(1,l)      et2(2,l) = edges(2,l)   20 continuec perform running sum      call PSCAN(edges,eg,es,idps,nblok)      do 30 l = 1, nblok      es(1,l) = et2(1,l)      es(2,l) = et2(2,l)      et2(1,l) = edges(1,l)      et2(2,l) = edges(2,l)      et2(3,l) = et2(1,l)      et2(4,l) = et2(2,l)      eg(1,l) = 0.      eg(2,l) = 0.      edges(2,l) = 1.0   30 continuec move partitions   40 iter = iter + 2c get partition from left      do 60 l = 1, nblok      kr = l + ks + 2      kl = l + ksc apav = desired number of particles on processor to left      npav = real(kl)*anpav + .5      apav = real(npav)c anpl = deficit of particles on processor to left      anpl = apav - et2(1,l) + es(1,l)c anpr = excess of particles on current processor      npav = real(kl+1)*anpav + .5      anpr = et2(1,l) - real(npav)c this segment is used for shared memory computersc     if (anpl.lt.0.) thenc        nyp1 = es(2,kl)c        do 50 k = 1, nyp1c        edg(k,l) = eds(k,kl)c  50    continuec        eg(1,l) = es(1,kl)c        eg(2,l) = es(2,kl)c     endifc this segment is used for mpi computersc post receive from left      if (anpl.lt.0.) then         call MPI_IRECV(edg,nypm,mreal,kl-1,iter-1,lgrp,msid,ierr)      endifc send partition to right      if (anpr.gt.0.) then         nyp1 = es(2,l)         call MPI_SEND(eds,nyp1,mreal,kr-1,iter-1,lgrp,ierr)      endifc wait for partition to arrive      if (anpl.lt.0.) then         call MPI_WAIT(msid,istatus,ierr)         call MPI_GET_COUNT(istatus,mreal,nyp1,ierr)         eg(2,l) = nyp1         sum1 = 0.         do 50 k = 1, nyp1         sum1 = sum1 + edg(k,l)   50    continue         eg(1,l) = sum1      endif   60 continuec find new partitions      nter = 0      do 100 l = 1, nblok      kl = l + ks      npav = real(kl)*anpav + .5      apav = real(npav)      anpl = apav - et2(1,l) + es(1,l)      npav = real(kl+1)*anpav + .5      anpr = et2(1,l) - real(npav)c left boundary is on the left      if (anpl.lt.0.) then         if ((anpl+eg(1,l)).ge.0.) then            nyp1 = eg(2,l)            k1 = nyp1            sum1 = 0.   70       at1 = sum1            sum1 = sum1 - edg(k1,l)            k1 = k1 - 1            if ((sum1.gt.anpl).and.(k1.gt.0)) go to 70            at1 = real(nyp1 - k1 - 1) + (anpl - at1)/(sum1 - at1)            edges(1,l) = (et2(2,l) - es(2,l)) - at1c left boundary is even further to left         else            nter = nter + 1         endifc left boundary is inside      else if (et2(1,l).ge.apav) then         nyp1 = es(2,l)         k1 = 1         sum1 = 0.   80    at1 = sum1         sum1 = sum1 + eds(k1,l)         k1 = k1 + 1         if ((sum1.lt.anpl).and.(k1.le.nyp1)) go to 80         at2 = real(k1 - 2)         if (sum1.gt.at1) at2 = at2 + (anpl - at1)/(sum1 - at1)         edges(1,l) = (et2(2,l) - es(2,l)) + at2      endifc right going data will need to be sent      if (anpr.gt.es(1,l)) nter = nter + 1      if (kl.gt.0) then         nyp1 = eg(2,l)         do 90 k = 1, nyp1         eds(k,l) = edg(k,l)   90    continue         et2(1,l) = et2(1,l) - es(1,l)         et2(2,l) = et2(2,l) - es(2,l)         es(1,l) = eg(1,l)         es(2,l) = eg(2,l)      endif  100 continuec get more data from left      if (nter.gt.0) go to 40      iter = nvp + 2c restore partition data      do 120 l = 1, nblok      sum1 = 0.      do 110 k = 1, nyp(l)      at1 = npic(k,l)      sum1 = sum1 + at1      eds(k,l) = at1  110 continue      et2(1,l) = et2(3,l)      et2(2,l) = et2(4,l)      es(1,l) = sum1      es(2,l) = nyp(l)      eg(1,l) = 0.      eg(2,l) = 0.  120 continuec continue moving partitions  130 iter = iter + 2c get partition from right      do 150 l = 1, nblok      kr = l + ks + 2      kl = l + ks      npav = real(kl)*anpav + .5      apav = real(npav)      npav = real(kl-1)*anpav + .5      anpl = real(npav) - et2(1,l) + es(1,l)c this segment is used for shared memory computersc     if (et2(1,l).lt.apav) thenc        nyp1 = es(2,kr)c        do 140 k = 1, nyp1c        edg(k,l) = eds(k,kr)c 140    continuec        eg(1,l) = es(1,kr)c        eg(2,l) = es(2,kr)c     endifc this segment is used for mpi computersc post receive from right      if (et2(1,l).lt.apav) then         call MPI_IRECV(edg,nypm,mreal,kr-1,iter,lgrp,msid,ierr)      endifc send partition to left      if (anpl.gt.0.) then         nyp1 = es(2,l)         call MPI_SEND(eds,nyp1,mreal,kl-1,iter,lgrp,ierr)      endifc wait for partition to arrive      if (et2(1,l).lt.apav) then         call MPI_WAIT(msid,istatus,ierr)         call MPI_GET_COUNT(istatus,mreal,nyp1,ierr)         eg(2,l) = nyp1         sum1 = 0.         do 140 k = 1, nyp1         sum1 = sum1 + edg(k,l)  140    continue         eg(1,l) = sum1      endif  150 continuec find new partitions      nter = 0      do 180 l = 1, nblok      kr = l + ks + 2      kl = l + ks      npav = real(kl)*anpav + .5      apav = real(npav)      npav = real(kl-1)*anpav + .5      anpl = real(npav) - et2(1,l) + es(1,l)      anpr = et2(1,l) - apavc left boundary is on the right      if (et2(1,l).lt.apav) then         if ((et2(1,l)+eg(1,l)).ge.apav) then            nyp1 = eg(2,l)            k1 = 1            sum1 = 0.            at2 = -anpr  160       at1 = sum1            sum1 = sum1 + edg(k1,l)            k1 = k1 + 1            if ((sum1.lt.at2).and.(k1.le.nyp1)) go to 160            at1 = real(k1 - 2) + (at2 - at1)/(sum1 - at1)            edges(1,l) = et2(2,l) + at1c left boundary is even further to right         else            nter = nter + 1         endif      endifc left going data will need to be sent      if (anpl.gt.es(1,l)) nter = nter + 1      if (kr.le.nvp) then         nyp1 = eg(2,l)         do 170 k = 1, nyp1         eds(k,l) = edg(k,l)  170    continue         et2(1,l) = et2(1,l) + eg(1,l)         et2(2,l) = et2(2,l) + eg(2,l)         es(1,l) = eg(1,l)         es(2,l) = eg(2,l)      endif  180 continuec get more data from right      if (nter.gt.0) go to 130c send left edge to processor on right      iter = 2      do 190 l = 1, nblok      kr = l + ks + 2      kl = l + ksc this segment is used for shared memory computersc     if (kr.le.nvp) thenc        edges(2,l) = edges(1,kr)c     elsec        edges(2,l) = et2(4,l)c     endifc this segment is used for mpi computersc post receive from right      if (kr.le.nvp) then         call MPI_IRECV(edges(2,l),1,mreal,kr-1,iter,lgrp,msid,ierr)      endifc send left edge to left      if (kl.gt.0) then         call MPI_SEND(edges(1,l),1,mreal,kl-1,iter,lgrp,ierr)      endifc wait for edge to arrive      if (kr.le.nvp) then         call MPI_WAIT(msid,istatus,ierr)      else         edges(2,l) = et2(4,l)      endif  190 continuec calculate number of grids and offsets in new partitions      do 200 l = 1, nblok      kl = edges(1,l) + .5      noff(l) = kl      kr = edges(2,l) + .5      nyp(l) = kr - kl      edges(1,l) = real(kl)      edges(2,l) = real(kr)  200 continuec find minimum and maximum partition size      nypmin = nyp(1)      nypmax = nyp(1)      do 210 l = 1, nblok      nypmin = min0(nypmin,nyp(l))      nypmax = max0(nypmax,nyp(l))  210 continue      ibflg(1) = -nypmin      ibflg(2) = nypmax      call PIMAX(ibflg,iwork,2,1)      nypmin = -ibflg(1)      nypmax = ibflg(2)      return      endc-----------------------------------------------------------------------      subroutine PZDBL2D(q,q2,nx,ny,kstrt,nxv,kyp,kypd,kyp2,kblok,k2blok     1)c this subroutine creates an zeroed array q2 from an array q, so thatc a 2d real to complex transform will perform a correct convolution.c linear interpolation for distributed datac q2 array may be modifiedc nx/ny = system length in x/y directionc kstrt = starting data block numberc nxv = first dimension of input array q, must be >= nxc kyp = number of data values per block in yc kypd = second dimension of input array q, must be >= kypc kyp2 = second dimension of output array q2, must be >= kyp2c kblok = number of data blocks in yc k2blok = number of data blocks in y for doubled data      implicit none      real q, q2      integer nx, ny, kstrt, nxv, kyp, kypd, kyp2, kblok, k2blok      dimension q(nxv,kypd,kblok), q2(2*nxv,kyp2,k2blok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=10)c lgrp = current communicatorc mreal = default datatype for reals      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer istatus, msid, nsid, ierr      integer j, k, l, ny2, kyb, kyb2, ks, koff, moff      integer ll, lm, k1, k2, joff      dimension istatus(lstat)      kyb = ny/kyp      ny2 = ny + ny      kyb2 = ny2/kyp2      ks = kstrt - 2      moff = kypd + kybc copy to double array in x direction      do 70 l = 1, k2blok      koff = kyp2*(l + ks)      ll = koff/kyp + 1      koff = kyp*(l + ks)      lm = koff/kyp2 + 1c special case for one processor      if (kyb2.eq.1) then         do 20 k = 1, ny         do 10 j = 1, nx         q2(j,k,l) = q(j,k,l)         q2(nx+j,k,l) = 0.         q2(j,ny+k,l) =  0.         q2(nx+j,ny+k,l) =  0.   10    continue   20    continue         return      endifc this segment is used for shared memory computersc     if (ll.le.kyb) thenc        do 40 k = 1, kypc        do 30 j = 1, nxc        q2(j,k,l) = q(j,k,ll)c  30    continuec  40    continuec        if (kyp.lt.kyp2) thenc           do 60 k = 1, kypc           do 50 j = 1, nxc           q2(j,k+kyp,l) = q(j,k,ll+1)c  50       continuec  60       continuec        endifc     endifc this segment is used for mpi computers      if (ll.le.kyb) then         call MPI_IRECV(q2(1,1,l),kyp*nxv,mreal,ll-1,moff+1,lgrp,msid,ie     1rr)         if (kyp.lt.kyp2) then            call MPI_IRECV(q2(1,kyp+1,l),kyp*nxv,mreal,ll,moff+1,lgrp,ns     1id,ierr)         endif      endif      if (lm.le.(kyb2/2)) then         call MPI_SEND(q(1,1,l),kyp*nxv,mreal,lm-1,moff+1,lgrp,ierr)      endifc wait for data and unpack it      if (ll.le.kyb) then         call MPI_WAIT(msid,istatus,ierr)         do 40 k = 2, kyp         k1 = kyp - k + 2         k2 = (k1 - 1)/2 + 1         joff = nxv*(k1 - 2*k2 + 1)         do 30 j = 1, nxv         q2(j,k1,l) = q2(j+joff,k2,l)   30    continue   40    continue         if (kyp.lt.kyp2) then            call MPI_WAIT(nsid,istatus,ierr)            do 60 k = 2, kyp            k1 = kyp - k + 2            k2 = (k1 - 1)/2 + 1            joff = nxv*(k1 - 2*k2 + 1)            do 50 j = 1, nxv            q2(j,k1+kyp,l) = q2(j+joff,k2+kyp,l)   50       continue   60       continue         endif      endif   70 continuec zero out remainder of array      do 110 l = 1, k2blok      koff = kyp2*(l + ks)      do 100 k = 1, kyp2      k1 = k + koff      if (k1.le.ny) then         do 80 j = 1, nx         q2(j+nx,k,l) = 0.   80    continue      else         do 90 j = 1, nx         q2(j,k,l) = 0.         q2(j+nx,k,l) = 0.   90    continue      endif  100 continue  110 continue      return      endc-----------------------------------------------------------------------      subroutine PHAFDBL2C(fxy,fxy2,nx,ny,kstrt,nxv,kyp,kypd,kyp2,kblok,     1k2blok)c this subroutine copies data from a double array to regular arrayc with guard cells for vector field and linear interpolationc for distributed datac fxy array may be modifiedc nx/ny = system length in x/y directionc kstrt = starting data block numberc nxv = second dimension of output array fxy, must be >= nxc kyp = number of data values per block in yc kypd = third dimension of output array fxy, must be >= kyp+1c kyp2 = third dimension of output array fxy2, must be >= kyp2c kblok = number of data blocks in yc k2blok = number of data blocks in y for doubled data      implicit none      real fxy, fxy2      integer nx, ny, kstrt, nxv, kyp, kypd, kyp2, kblok, k2blok      dimension fxy(2,nxv,kypd,kblok), fxy2(2,2*nxv,kyp2,k2blok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=10)c lgrp = current communicatorc mreal = default datatype for reals      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer istatus, msid, nsid, ierr      integer j, k, l, nx1, ny1, kyb, kyb2, kyp1, ks, joff, koff, moff      integer kk, ll, lm      dimension istatus(lstat)      nx1 = nx + 1      ny1 = ny + 1      kyb = ny/kyp      kyb2 = (ny + ny)/kyp2      kyp1 = kyp + 1      ks = kstrt - 2      moff = kypd + kyb      do 90 l = 1, k2blok      koff = kyp2*(l + ks)      lm = koff/kyp + 1      koff = kyp*(l + ks)      ll = koff/kyp2 + 1      koff = koff - kyp2*(ll - 1)c special case for one processor      if (kyb2.eq.1) then         do 20 k = 1, ny1         do 10 j = 1, nx1         fxy(1,j,k,l) = fxy2(1,j,k,l)         fxy(2,j,k,l) = fxy2(2,j,k,l)   10    continue   20    continue         go to 90      endifc this segment is used for shared memory computersc     if (ll.le.kyb) thenc        if ((koff.eq.0).and.(kyp.lt.kyp2)) thenc           do 40 k = 1, kyp1c           do 30 j = 1, nx1c           fxy(1,j,k,l) = fxy2(1,j,k,ll)c           fxy(2,j,k,l) = fxy2(2,j,k,ll)c  30       continuec  40       continuec        elsec           do 60 k = 1, kypc           do 50 j = 1, nx1c           fxy(1,j,k,l) = fxy2(1,j,k+koff,ll)c           fxy(2,j,k,l) = fxy2(2,j,k+koff,ll)c  50       continuec  60       continuec           do 70 j = 1, nx1c           fxy(1,j,kyp+1,l) = fxy2(1,j,1,ll+1)c           fxy(2,j,kyp+1,l) = fxy2(2,j,1,ll+1)c  70       continuec        endifc     endifc this segment is used for mpi computers      if (ll.le.kyb) then         if ((koff.eq.0).and.(kyp.lt.kyp2)) then            call MPI_IRECV(fxy(1,1,1,l),2*nxv*kyp1,mreal,ll-1,moff+3,lgr     1p,msid,ierr)         else            call MPI_IRECV(fxy(1,1,1,l),2*nxv*kyp,mreal,ll-1,moff+3,lgrp     1,msid,ierr)            call MPI_IRECV(fxy(1,1,kyp+1,l),2*nxv,mreal,ll,moff+3,lgrp,n     1sid,ierr)         endif      endifc pack data and send it      if (lm.le.kyb) then         if (kyp.lt.kyp2) then            do 40 k = 2, kyp1            kk = (k - 1)/2 + 1            joff = nxv*(k - 2*kk + 1)            do 30 j = 1, nxv            fxy2(1,j+joff,kk,l) = fxy2(1,j,k,l)            fxy2(2,j+joff,kk,l) = fxy2(2,j,k,l)   30       continue   40       continue            call MPI_SEND(fxy2(1,1,1,l),2*nxv*kyp1,mreal,lm-1,moff+3,lgr     1p,ierr)            do 60 k = 2, kyp            kk = (k - 1)/2 + 1            joff = nxv*(k - 2*kk + 1)            do 50 j = 1, nxv            fxy2(1,j+joff,kk+kyp,l) = fxy2(1,j,k+kyp,l)            fxy2(2,j+joff,kk+kyp,l) = fxy2(2,j,k+kyp,l)   50       continue   60       continue            call MPI_SEND(fxy2(1,1,kyp+1,l),2*nxv*kyp,mreal,lm,moff+3,lg     1rp,ierr)         else            do 80 k = 2, kyp            kk = (k - 1)/2 + 1            joff = nxv*(k - 2*kk + 1)            do 70 j = 1, nxv            fxy2(1,j+joff,kk,l) = fxy2(1,j,k,l)            fxy2(2,j+joff,kk,l) = fxy2(2,j,k,l)   70       continue   80       continue            call MPI_SEND(fxy2(1,1,1,l),2*nxv*kyp,mreal,lm-1,moff+3,lgrp     1,ierr)         endif         if (lm.gt.1) then            call MPI_SEND(fxy2(1,1,1,l),2*nxv,mreal,lm-2,moff+3,lgrp,ier     1r)         endif      else if (lm.eq.(kyb+1)) then         call MPI_SEND(fxy2(1,1,1,l),2*nxv,mreal,lm-2,moff+3,lgrp,ierr)      endifc wait for data      if (ll.le.kyb) then         if ((koff.eq.0).and.(kyp.lt.kyp2)) then            call MPI_WAIT(msid,istatus,ierr)         else            call MPI_WAIT(msid,istatus,ierr)            call MPI_WAIT(nsid,istatus,ierr)         endif      endif   90 continue      return      endc-----------------------------------------------------------------------      subroutine PHAFDBL2D(q,q2,nx,ny,kstrt,nxv,kyp,kypd,kyp2,kblok,k2bl     1ok)c this subroutine copies data from a double array to regular arrayc with guard cells for scalar field and linear interpolationc for distributed datac q2 array may be modifiedc nx/ny = system length in x/y directionc kstrt = starting data block numberc nxv = second dimension of output array fxy, must be >= nxc kyp = number of data values per block in yc kypd = third dimension of output array fxy, must be >= kyp+1c kyp2 = third dimension of output array fxy2, must be >= kyp2c kblok = number of data blocks in yc k2blok = number of data blocks in y for doubled data      implicit none      real q, q2      integer nx, ny, kstrt, nxv, kyp, kypd, kyp2, kblok, k2blok      dimension q(nxv,kypd,kblok), q2(2*nxv,kyp2,k2blok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=10)c lgrp = current communicatorc mreal = default datatype for reals      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer istatus, msid, nsid, ierr      integer j, k, l, nx1, ny1, kyb, kyb2, kyp1, ks, joff, koff, moff      integer  kk, ll, lm      dimension istatus(lstat)      nx1 = nx + 1      ny1 = ny + 1      kyb = ny/kyp      kyb2 = (ny + ny)/kyp2      kyp1 = kyp + 1      ks = kstrt - 2      moff = kypd + kyb      do 90 l = 1, k2blok      koff = kyp2*(l + ks)      lm = koff/kyp + 1      koff = kyp*(l + ks)      ll = koff/kyp2 + 1      koff = koff - kyp2*(ll - 1)c special case for one processor      if (kyb2.eq.1) then         do 20 k = 1, ny1         do 10 j = 1, nx1         q(j,k,l) = q2(j,k,l)   10    continue   20    continue         go to 90      endifc this segment is used for shared memory computersc     if (ll.le.kyb) thenc        if ((koff.eq.0).and.(kyp.lt.kyp2)) thenc           do 40 k = 1, kyp1c           do 30 j = 1, nx1c           q(j,k,l) = q2(j,k,ll)c  30       continuec  40       continuec        elsec           do 60 k = 1, kypc           do 50 j = 1, nx1c           q(j,k,l) = q2(j,k+koff,ll)c  50       continuec  60       continuec           do 70 j = 1, nx1c           q(j,kyp+1,l) = q2(j,1,ll+1)c  70       continuec        endifc     endifc this segment is used for mpi computers      if (ll.le.kyb) then         if ((koff.eq.0).and.(kyp.lt.kyp2)) then            call MPI_IRECV(q(1,1,l),nxv*kyp1,mreal,ll-1,moff+4,lgrp,msid     1,ierr)         else            call MPI_IRECV(q(1,1,l),nxv*kyp,mreal,ll-1,moff+4,lgrp,msid,     1ierr)            call MPI_IRECV(q(1,kyp+1,l),nxv,mreal,ll,moff+4,lgrp,nsid,ie     1rr)         endif      endifc pack data and send it      if (lm.le.kyb) then         if (kyp.lt.kyp2) then            do 40 k = 2, kyp1            kk = (k - 1)/2 + 1            joff = nxv*(k - 2*kk + 1)            do 30 j = 1, nxv            q2(j+joff,kk,l) = q2(j,k,l)   30       continue   40       continue            call MPI_SEND(q2(1,1,l),nxv*kyp1,mreal,lm-1,moff+4,lgrp,ierr     1)            do 60 k = 2, kyp            kk = (k - 1)/2 + 1            joff = nxv*(k - 2*kk + 1)            do 50 j = 1, nxv            q2(j+joff,kk+kyp,l) = q2(j,k+kyp,l)   50       continue   60       continue            call MPI_SEND(q2(1,kyp+1,l),nxv*kyp,mreal,lm,moff+4,lgrp,ier     1r)         else            do 80 k = 2, kyp            kk = (k - 1)/2 + 1            joff = nxv*(k - 2*kk + 1)            do 70 j = 1, nxv            q2(j+joff,kk,l) = q2(j,k,l)   70       continue   80       continue            call MPI_SEND(q2(1,1,l),nxv*kyp,mreal,lm-1,moff+4,lgrp,ierr)         endif         if (lm.gt.1) then            call MPI_SEND(q2(1,1,l),nxv,mreal,lm-2,moff+4,lgrp,ierr)         endif      else if (lm.eq.(kyb+1)) then         call MPI_SEND(q2(1,1,l),nxv,mreal,lm-2,moff+4,lgrp,ierr)      endifc wait for data      if (ll.le.kyb) then         if ((koff.eq.0).and.(kyp.lt.kyp2)) then            call MPI_WAIT(msid,istatus,ierr)         else            call MPI_WAIT(msid,istatus,ierr)            call MPI_WAIT(nsid,istatus,ierr)         endif      endif   90 continue      return      endc-----------------------------------------------------------------------      subroutine PNLCGUARD2L(f,nyp,kstrt,nvp,nxv,nypmx,nblok)c this subroutine copies data to guard cells in non-uniform partitionsc guard cell on last processor is presumed already set.c f(j,k,l) = real data for grid j,k in field partition l.c the grid is non-uniform and includes one extra guard cell.c nyp(l) = number of primary gridpoints in field partition lc it is assumed the nyp(l) > 0.c kstrt = starting data block numberc nvp = number of real or virtual processorsc nxv = first dimension of f, must be >= nxc nypmx = maximum size of field partition, including guard cell.c nblok = number of field partitions.c linear interpolation, for distributed data      implicit none      real f      integer nyp      integer kstrt, nvp, nxv, nypmx, nblok      dimension f(nxv,nypmx,nblok)      dimension nyp(nblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=10)c lgrp = current communicatorc mreal = default datatype for reals      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer istatus, msid, ierr      integer ks, moff, kl, kr, lc     integer j      dimension istatus(lstat)      ks = kstrt - 2      moff = nypmx*nvpc copy to guard cells      do 20 l = 1, nblok      kr = l + ks + 2      kl = l + ksc this loop is used for shared memory computersc     if (kr.le.nvp) thenc        do 10 j = 1, nxvc        f(j,nyp(l)+1,l) = f(j,1,kr)c  10    continuec     endifc this segment is used for mpi computers      if (kr.le.nvp) then         call MPI_IRECV(f(1,nyp(l)+1,l),nxv,mreal,kr-1,moff+2,lgrp,msid,     1ierr)      endif      if (kl.ge.1) then         call MPI_SEND(f(1,1,l),nxv,mreal,kl-1,moff+2,lgrp,ierr)      endif      if (kr.le.nvp) then         call MPI_WAIT(msid,istatus,ierr)      endif   20 continue      return      endc-----------------------------------------------------------------------      subroutine PNLAGUARD2(f,scr,scs,nyp,kstrt,nvp,nx,nxv,nypmx,nblok,n     1gds,mter)c this subroutine adds data from guard cells in non-uniform partitionsc for scalar data, the field is added up so as to disable quadraticc interpolation within half a cell of the edges, and reduce it to linearc interpolation in the y direction.c f(j,k,l) = real data for grid j,k in field partition l.c the grid is non-uniform and includes three extra guard cells.c scr(j,ngds,l) = scratch array for particle partition lc scs(j,l) = scratch array for field partition lc nyp(l) = number of primary gridpoints in field partition lc it is assumed the nyp(l) > 0.c kstrt = starting data block numberc nvp = number of real or virtual processorsc nx = system length in x directionc nxv = first dimension of f, must be >= nxc nypmx = maximum size of field partition, including guard cells.c nblok = number of field partitions.c ngds = number of guard cellsc mter = (0,1) = (no,yes) pass data to next processor onlyc quadratic interpolation, for distributed data      implicit none      real f, scr, scs      integer nyp      integer kstrt, nvp, nx, nxv, nypmx, nblok, ngds, mter      dimension f(nxv,nypmx,nblok), scr(nxv,ngds,nblok)      dimension scs(nxv,nblok)      dimension nyp(nblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=10)c lgrp = current communicatorc mreal = default datatype for reals      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer istatus, msid, nsid, ierr      integer nx3, ks, moff, kr, krr, kl, kll, ngc, j, l      dimension istatus(lstat)      nx3 = nx + 3      ks = kstrt - 2      moff = nypmx*nvpc add guard cells      do 120 l = 1, nblok      kr = l + ks + 2      krr = kr + 1      kl = l + ks      kll = kl - 1c this segment is used for shared memory computersc     if (kl.ge.1) thenc        if (nyp(kl).eq.1) thenc           do 10 j = 1, nx3c           scr(j,1,l) = f(j,nyp(kl)+2,kl) + f(j,nyp(kll)+2,kll)c           scr(j,2,l) = f(j,nyp(kl)+3,kl)c  10       continuec        elsec           do 20 j = 1, nx3c           scr(j,1,l) = f(j,nyp(kl)+2,kl)c           scr(j,2,l) = f(j,nyp(kl)+3,kl)c  20       continuec     elsec        do 30 j = 1, nx3c        scr(j,1,l) = 2.*f(j,1,l)c        scr(j,2,l) = -f(j,1,l)c  30    continuec     endifc     if (kr.le.nvp) thenc        do 40 j = 1, nx3c        scr(j,3,l) = f(j,1,kr)c  40    continuec     elsec        do 50 j = 1, nx3c        scr(j,3,l) = -f(j,nyp(l)+3,l)c        f(j,nyp(l)+2,l) = f(j,nyp(l)+2,l) + 2.*f(j,nyp(l)+3,l)c  50    continuec     endifc     if (kl.ge.1) thenc        if ((nyp(kl).eq.1).and.(kl.eq.1)) thenc           do 60 j = 1, nx3c           scr(j,1,l) = scr(j,1,l) - f(j,1,kl)c  60       continuec        endifc     else if (nyp(l).eq.1) thenc        do 80 j = 1, nx3c        scr(j,2,l) = 0.c  80    continuec     endifc this segment is used for mpi computers      if (kl.ge.1) then         call MPI_IRECV(scr,2*nxv,mreal,kl-1,moff+1,lgrp,msid,ierr)      endif      if (kr.le.nvp) then         call MPI_SEND(f(1,nyp(l)+2,l),2*nxv,mreal,kr-1,moff+1,lgrp,ierr     1)      endif      if (kl.ge.1) then         call MPI_WAIT(msid,istatus,ierr)      else         do 30 j = 1, nx3         scr(j,1,l) = 2.*f(j,1,l)         scr(j,2,l) = -f(j,1,l)   30    continue      endif      if (kr.le.nvp) then         call MPI_IRECV(scr(1,3,l),nxv,mreal,kr-1,moff+2,lgrp,msid,ierr)      endif      if (kl.ge.1) then         call MPI_SEND(f(1,1,l),nxv,mreal,kl-1,moff+2,lgrp,ierr)      endif      if (kr.le.nvp) then         call MPI_WAIT(msid,istatus,ierr)      else         do 50 j = 1, nx3         scr(j,3,l) = -f(j,nyp(l)+3,l)         f(j,nyp(l)+2,l) = f(j,nyp(l)+2,l) + 2.*f(j,nyp(l)+3,l)   50    continue      endifc special case of only one grid per processor      if (mter.ge.1) go to 90      if (kl.ge.1) then         call MPI_IRECV(ngc,1,mint,kl-1,moff+3,lgrp,msid,ierr)      endif      if (kll.ge.1) then         call MPI_IRECV(scs,nxv,mreal,kll-1,moff+5,lgrp,nsid,ierr)      else if (kl.eq.1) then         call MPI_IRECV(scs,nxv,mreal,kl-1,moff+5,lgrp,nsid,ierr)      endif      if (kr.le.nvp) then         call MPI_SEND(nyp(l),1,mint,kr-1,moff+3,lgrp,ierr)      endif      if (krr.le.nvp) then         call MPI_SEND(f(1,nyp(l)+3,l),nxv,mreal,krr-1,moff+5,lgrp,ierr)      endif      if ((kl.eq.0).and.(kr.le.nvp)) then         call MPI_SEND(f(1,1,l),nxv,mreal,kr-1,moff+5,lgrp,ierr)      endif      if (kl.ge.1) then         call MPI_WAIT(msid,istatus,ierr)         call MPI_WAIT(nsid,istatus,ierr)         if (ngc.eq.1) then            if (kl.eq.1) then               do 60 j = 1, nx3               scr(j,1,l) = scr(j,1,l) - scs(j,l)   60          continue            else               do 70 j = 1, nx3               scr(j,1,l) = scr(j,1,l) + scs(j,l)   70          continue            endif         endif      else if (nyp(l).eq.1) then         do 80 j = 1, nx3         scr(j,2,l) = 0.   80    continue      endifc add up the guard cells   90 do 100 j = 1, nx3      f(j,2,l) = f(j,2,l) + scr(j,1,l)      f(j,3,l) = f(j,3,l) + scr(j,2,l)      f(j,nyp(l)+1,l) = f(j,nyp(l)+1,l) + scr(j,3,l)      f(j,1,l) = 0.      f(j,nyp(l)+3,l) = 0.  100 continue      if (kr.le.nvp) then         do 110 j = 1, nx3         f(j,nyp(l)+2,l) = 0.  110    continue      endif  120 continuec zero out the left edge      do 140 l = 1, nblok      kl = l + ks      if (kl.eq.0) then         do 130 j = 1, nx3         f(j,1,l) = 0.  130    continue      endif  140 continue      return      endc-----------------------------------------------------------------------      subroutine PNLAGUARDS2(f,nyp,kstrt,nvp,nx,nxv,nypmx,nblok,mter)c this subroutine corrects charge density data for particle boundaryc conditions which keep particles one grid away from the edgesc the field is added up so as to disable quadratic interpolationc within half a cell of the edges, and reduce it to linear interpolationc in the y direction.c f(j,k,l) = real data for grid j,k in field partition l.c the grid is non-uniform and includes three extra guard cells.c nyp(l) = number of primary gridpoints in field partition lc it is assumed the nyp(l) > 0.c kstrt = starting data block numberc nvp = number of real or virtual processorsc nx = system length in x directionc nxv = first dimension of f, must be >= nxc nypmx = maximum size of field partition, including guard cells.c nblok = number of field partitions.c mter = (0,1,2) = (no,yes) pass data to next processor onlyc quadratic interpolation, for distributed data      implicit none      real f      integer nyp      integer kstrt, nvp, nx, nxv, nypmx, nblok, mter      dimension f(nxv,nypmx,nblok)      dimension nyp(nblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=10)c lgrp = current communicatorc mreal = default datatype for reals      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer istatus, msid, nsid, ierr      integer ks, moff, kr, krr, kl, kll, ngc, nps, j, l      dimension istatus(lstat)      ks = kstrt - 2      moff = nypmx*nvpc add guard cells      do 130 l = 1, nblok      kr = l + ks + 2      krr = kr + 1      kl = l + ks      kll = kl - 1c fix edges if all points are on the same processor      if (kl.eq.0) then         if (nyp(l).gt.2) then            do 10 j = 2, nx            f(j+1,3,l) = f(j+1,3,l) + 2.*f(j+1,2,l)            f(j+1,4,l) = f(j+1,4,l) - f(j+1,2,l)            f(j+1,2,l) = 0.   10       continue         else if (nyp(l).eq.2) then            do 20 j = 2, nx            f(j+1,3,l) = f(j+1,3,l) + 2.*f(j+1,2,l)   20       continue         endif      endif      if (kr.eq.(nvp+1)) then         if (nyp(l).gt.1) then            do 30 j = 2, nx            f(j+1,nyp(l),l) = f(j+1,nyp(l),l) - f(j+1,nyp(l)+2,l)            f(j+1,nyp(l)+1,l) = f(j+1,nyp(l)+1,l) + 2.*f(j+1,nyp(l)+2,l)            f(j+1,nyp(l)+2,l) = 0.   30       continue         else if (nyp(l).eq.1) then            do 40 j = 2, nx            f(j+1,nyp(l)+1,l) = f(j+1,nyp(l)+1,l) + 2.*f(j+1,nyp(l)+2,l)   40       continue         endif      endifc this segment is used for shared memory computersc     if (mter.ge.2) go to 130c     if (mter.eq.1) go to 80c     if (kll.eq.1) thenc        if (nyp(kll).eq.1).and.(nyp(kl).eq.1)) thenc           do 50 j = 2, nxc           f(j+1,2,l) = f(j+1,2,l) - f(j+1,2,kll)c  50       continuec        endifc     endifc     if (kr.eq.nvp) thenc        if (nyp(kr).eq.1) thenc           do 70 j = 2, nxc           f(j+1,nyp(l)+1,l) = f(j+1,nyp(l)+1,l) - f(j+1,nyp(kr)+2,kr)c  70       continuec        endifc     endifc  80 if (kl.eq.1) thenc        if (nyp(kl).le.2) thenc           if (nyp(kl).eq.1) thenc              if (nyp(l).gt.1) thenc                 do 100 j = 2, nxc                 f(j+1,3,l) = f(j+1,3,l) - f(j+1,2,kl)c 100             continuec              endifc              do 110 j = 2, nxc              f(j+1,2,l) = f(j+1,2,l) + 2.*f(j+1,2,kl)c 110          continuec           elsec              do 120 j = 2, nxc              f(j+1,2,l) = f(j+1,2,l) - f(j+1,2,kl)c 120          continuec           endifc        endifc     endifc this segment is used for mpi computers      if (mter.ge.2) go to 130      if (mter.eq.1) go to 80      if (kll.eq.1) then         call MPI_IRECV(ngc,1,mint,kl-1,moff+4,lgrp,msid,ierr)         call MPI_IRECV(f(1,1,l),nxv,mreal,kll-1,moff+1,lgrp,nsid,ierr)      endif      if (kl.eq.1) then         call MPI_SEND(nyp(l),1,mint,kr-1,moff+4,lgrp,ierr)      endif      if (kl.eq.0) then         if (nyp(l).eq.1) then            call MPI_SEND(f(1,2,l),nxv,mreal,krr-1,moff+1,lgrp,ierr)         else            nps = 0            call MPI_SEND(f(1,2,l),nps,mreal,krr-1,moff+1,lgrp,ierr)         endif      endif      if (kll.eq.1) then         call MPI_WAIT(msid,istatus,ierr)         call MPI_WAIT(nsid,istatus,ierr)         call MPI_GET_COUNT(istatus,mreal,nps,ierr)         if (nps.gt.0) then            if (ngc.eq.1) then               do 50 j = 2, nx               f(j+1,2,l) = f(j+1,2,l) - f(j+1,1,l)   50          continue            endif            do 60 j = 2, nx            f(j+1,1,l) = 0.   60       continue         endif      endif      if (kr.eq.nvp) then         call MPI_IRECV(f(1,1,l),nxv,mreal,kr-1,moff+2,lgrp,msid,ierr)      endif      if (kr.eq.(nvp+1)) then         if (nyp(l).eq.1) then            call MPI_SEND(f(1,nyp(l)+2,l),nxv,mreal,kl-1,moff+2,lgrp,ier     1r)         else            nps = 0            call MPI_SEND(f(1,nyp(l)+2,l),nps,mreal,kl-1,moff+2,lgrp,ier     1r)         endif      endif      if (kr.eq.nvp) then         call MPI_WAIT(msid,istatus,ierr)         call MPI_GET_COUNT(istatus,mreal,nps,ierr)         if (nps.gt.0) then            do 70 j = 2, nx            f(j+1,nyp(l)+1,l) = f(j+1,nyp(l)+1,l) - f(j+1,1,l)            f(j+1,1,l) = 0.   70       continue         endif      endif   80 if (kl.eq.1) then         call MPI_IRECV(ngc,1,mint,kl-1,moff+5,lgrp,msid,ierr)         call MPI_IRECV(f(1,1,l),nxv,mreal,kl-1,moff+1,lgrp,nsid,ierr)      endif      if ((kl.eq.0).and.(kr.le.nvp)) then         call MPI_SEND(nyp(l),1,mint,kr-1,moff+5,lgrp,ierr)         if (nyp(l).le.2) then            call MPI_SEND(f(1,2,l),nxv,mreal,kr-1,moff+1,lgrp,ierr)            do 90 j = 2, nx            f(j+1,2,l) = 0.   90       continue         else            nps = 0            call MPI_SEND(f(1,2,l),nps,mreal,kr-1,moff+1,lgrp,ierr)         endif      endif      if (kl.eq.1) then         call MPI_WAIT(msid,istatus,ierr)         call MPI_WAIT(nsid,istatus,ierr)         call MPI_GET_COUNT(istatus,mreal,nps,ierr)         if (nps.gt.0) then            if (ngc.eq.1) then               if (nyp(l).gt.1) then                  do 100 j = 2, nx                  f(j+1,3,l) = f(j+1,3,l) - f(j+1,1,l)  100             continue               endif               do 110 j = 2, nx               f(j+1,2,l) = f(j+1,2,l) + 2.*f(j+1,1,l)               f(j+1,1,l) = 0.  110          continue            else               do 120 j = 2, nx               f(j+1,2,l) = f(j+1,2,l) - f(j+1,1,l)               f(j+1,1,l) = 0.  120          continue            endif         endif      endif  130 continue      return      endc-----------------------------------------------------------------------      subroutine PNLAGUARD2L(f,scr,nyp,kstrt,nvp,nx,nxv,nypmx,nblok)c this subroutine adds data from guard cells in non-uniform partitionsc for scalar data.  no copying is done at the boundary edges.c f(j,k,l) = real data for grid j,k in field partition l.c the grid is non-uniform and includes one extra guard cell.c scr(j,l) = scratch array for particle partition lc nyp(l) = number of primary gridpoints in field partition lc it is assumed the nyp(l) > 0.c kstrt = starting data block numberc nvp = number of real or virtual processorsc nx = system length in x directionc nxv = first dimension of f, must be >= nxc nypmx = maximum size of field partition, including guard cells.c nblok = number of field partitions.c linear interpolation, for distributed data      implicit none      real f, scr      integer nyp      integer kstrt, nvp, nx, nxv, nypmx, nblok      dimension f(nxv,nypmx,nblok), scr(nxv,nblok)      dimension nyp(nblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=10)c lgrp = current communicatorc mreal = default datatype for reals      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer istatus, msid, ierr      integer nx1, ks, moff, kl, kr, j, l      dimension istatus(lstat)      nx1 = nx + 1      ks = kstrt - 2      moff = nypmx*nvpc add guard cells      do 50 l = 1, nblok      kr = l + ks + 2      kl = l + ksc this segment is used for shared memory computersc     if (kl.ge.1) thenc        do 10 j = 1, nx1c        scr(j,l) = f(j,nyp(kl)+1,kl)c  10    continuec     elsec        do 20 j = 1, nx1c        scr(j,l) = 0.c  20    continuec     endifc this segment is used for mpi computers      if (kl.ge.1) then         call MPI_IRECV(scr,nxv,mreal,kl-1,moff+1,lgrp,msid,ierr)      endif      if (kr.le.nvp) then         call MPI_SEND(f(1,nyp(l)+1,l),nxv,mreal,kr-1,moff+1,lgrp,ierr)      endif      if (kl.ge.1) then         call MPI_WAIT(msid,istatus,ierr)      else         do 20 j = 1, nx1         scr(j,l) = 0.   20    continue      endifc add up the guard cells      do 30 j = 1, nx1      f(j,1,l) = f(j,1,l) + scr(j,l)   30 continue      if (kr.le.nvp) then         do 40 j = 1, nx1         f(j,nyp(l)+1,l) = 0.   40    continue      endif   50 continue      return      endc-----------------------------------------------------------------------      subroutine PTPOSE(f,g,s,t,nx,ny,kstrt,nxv,nyv,kxp,kyp,kxpd,kypd,jb     1lok,kblok)c this subroutine performs a transpose of a matrix f, distributed in y,c to a matrix g, distributed in x, that is,c g(k+kyp*(m-1),j,l) = f(j+kxp*(l-1),k,m), wherec 1 <= j <= kxp, 1 <= k <= kyp, 1 <= l <= nx/kxp, 1 <= m <= ny/kypc and where indices l and m can be distributed across processors.c this subroutine sends and receives one message at a time, eitherc synchronously or asynchronously. it uses a minimum of system resourcesc f = complex input arrayc g = complex output arrayc s, t = complex scratch arraysc nx/ny = number of points in x/yc kstrt = starting data block numberc nxv/nyv = first dimension of f/gc kypd/kxpd = second dimension of f/gc kxp/kyp = number of data values per block in x/yc jblok/kblok = number of data blocks in x/y      implicit none      integer nx, ny, kstrt, nxv, nyv, kxp, kyp, kxpd, kypd      integer jblok, kblok      complex f, g, s, t      dimension f(nxv,kypd,kblok), g(nyv,kxpd,jblok)      dimension s(kxp,kyp,kblok), t(kxp,kyp,jblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=10)c lgrp = current communicatorc mcplx = default datatype for complex      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer ks, kxb, kyb      integer jkblok, kxym, mtr, ntr, mntr      integer l, i, joff, koff, k, j      integer ir0, is0, ii, ir, is, ierr, msid, istatus      dimension istatus(lstat)      ks = kstrt - 2      kxb = nx/kxp      kyb = ny/kypc this segment is used for shared memory computersc     if (kstrt.gt.nx) returnc     do 40 l = 1, jblokc     joff = kxp*(l + ks)c     do 30 i = 1, kybc     koff = kyp*(i - 1)c     do 20 k = 1, kypc     do 10 j = 1, kxpc     g(k+koff,j,l) = f(j+joff,k,i)c  10 continuec  20 continuec  30 continuec  40 continuec this segment is used for mpi computers      jkblok = max0(jblok,kblok)      kxym = min0(kxb,kyb)      mtr = kyb/kxym      ntr = kxb/kxym      mntr = max0(mtr,ntr)      do 70 l = 1, jkblok      do 60 i = 1, kxym      ir0 = iand(kxym-1,ieor(l+ks,i-1)) + 1      is0 = ir0      do 50 ii = 1, mntrc post receive      if ((kstrt.le.nx).and.(ii.le.mtr)) then         ir = ir0 + kxym*(ii - 1)         call MPI_IRECV(t(1,1,l),kxp*kyp,mcplx,ir-1,ir+kxym+1,lgrp,msid,     1ierr)      endifc send data      if ((kstrt.le.ny).and.(ii.le.ntr)) then         is = is0 + kxym*(ii - 1)         joff = kxp*(is - 1)         do 20 k = 1, kyp         do 10 j = 1, kxp         s(j,k,l) = f(j+joff,k,l)   10    continue   20    continue         call MPI_SEND(s(1,1,l),kxp*kyp,mcplx,is-1,l+ks+kxym+2,lgrp,ierr     1)      endifc receive data      if ((kstrt.le.nx).and.(ii.le.mtr)) then         koff = kyp*(ir - 1)         call MPI_WAIT(msid,istatus,ierr)         do 40 k = 1, kyp         do 30 j = 1, kxp         g(k+koff,j,l) = t(j,k,l)   30    continue   40    continue      endif   50 continue   60 continue   70 continue      return      endc-----------------------------------------------------------------------      subroutine P2TPOSE(f,g,s,t,nx,ny,kstrt,nxv,nyv,kxp,kyp,kxpd,kypd,j     1blok,kblok)c this subroutine performs a transpose of a matrix f, distributed in y,c to a matrix g, distributed in x, that is,c g(1:2,k+kyp*(m-1),j,l) = f(1:2,j+kxp*(l-1),k,m), wherec 1 <= j <= kxp, 1 <= k <= kyp, 1 <= l <= nx/kxp, 1 <= m <= ny/kypc and where indices l and m can be distributed across processors.c this subroutine sends and receives one message at a time, eitherc synchronously or asynchronously. it uses a minimum of system resourcesc f = complex input arrayc g = complex output arrayc s, t = complex scratch arraysc nx/ny = number of points in x/yc kstrt = starting data block numberc nxv/nyv = first dimension of f/gc kypd/kxpd = second dimension of f/gc kxp/kyp = number of data values per block in x/yc jblok/kblok = number of data blocks in x/y      implicit none      integer nx, ny, kstrt, nxv, nyv, kxp, kyp, kxpd, kypd      integer jblok, kblok      complex f, g, s, t      dimension f(2,nxv,kypd,kblok), g(2,nyv,kxpd,jblok)      dimension s(2,kxp,kyp,kblok), t(2,kxp,kyp,jblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=10)c lgrp = current communicatorc mcplx = default datatype for complex      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer ks, kxb, kyb      integer jkblok, kxym, mtr, ntr, mntr      integer l, i, joff, koff, k, j      integer ir0, is0, ii, ir, is, ierr, msid, istatus      dimension istatus(lstat)      ks = kstrt - 2      kxb = nx/kxp      kyb = ny/kypc this segment is used for shared memory computersc     if (kstrt.gt.nx) returnc     do 40 l = 1, jblokc     joff = kxp*(l + ks)c     do 30 i = 1, kybc     koff = kyp*(i - 1)c     do 20 k = 1, kypc     do 10 j = 1, kxpc     g(1,k+koff,j,l) = f(1,j+joff,k,i)c     g(2,k+koff,j,l) = f(2,j+joff,k,i)c  10 continuec  20 continuec  30 continuec  40 continuec this segment is used for mpi computers      jkblok = max0(jblok,kblok)      kxym = min0(kxb,kyb)      mtr = kyb/kxym      ntr = kxb/kxym      mntr = max0(mtr,ntr)      do 70 l = 1, jkblok      do 60 i = 1, kxym      ir0 = iand(kxym-1,ieor(l+ks,i-1)) + 1      is0 = ir0      do 50 ii = 1, mntrc post receive      if ((kstrt.le.nx).and.(ii.le.mtr)) then         ir = ir0 + kxym*(ii - 1)         call MPI_IRECV(t(1,1,1,l),2*kxp*kyp,mcplx,ir-1,ir+kxym+1,lgrp,m     1sid,ierr)      endifc send data      if ((kstrt.le.ny).and.(ii.le.ntr)) then         is = is0 + kxym*(ii - 1)         joff = kxp*(is - 1)         do 20 k = 1, kyp         do 10 j = 1, kxp         s(1,j,k,l) = f(1,j+joff,k,l)         s(2,j,k,l) = f(2,j+joff,k,l)   10    continue   20    continue         call MPI_SEND(s(1,1,1,l),2*kxp*kyp,mcplx,is-1,l+ks+kxym+2,lgrp,     1ierr)      endifc receive data      if ((kstrt.le.nx).and.(ii.le.mtr)) then         koff = kyp*(ir - 1)         call MPI_WAIT(msid,istatus,ierr)         do 40 k = 1, kyp         do 30 j = 1, kxp         g(1,k+koff,j,l) = t(1,j,k,l)         g(2,k+koff,j,l) = t(2,j,k,l)   30    continue   40    continue      endif   50 continue   60 continue   70 continue      return      endc-----------------------------------------------------------------------      subroutine PFMOVE2(f,g,noff,nyp,noffs,nyps,noffd,nypd,jsr,jsl,isig     1n,kyp,kstrt,nvp,nxv,nypmx,nblok,idps,mter,ierr)c this subroutine moves fields into appropriate spatial regions,c between non-uniform and uniform partitionsc f(j,k,l) = real data for grid j,k in field partition l.c the grid is non-uniform and includes extra guard cells.c g(j,k,l) = scratch data for grid j,k in field partition l.c noff(l) = lowermost global gridpoint in field partition lc nyp(l) = number of primary gridpoints in field partition lc noffs(l)/nyps(l) = source or scratch arrays for field partition lc noffd(l)/nypd(l) = destination or scratch arrays for field partition lc jsl(idps,l) = number of particles going down in field partition lc jsr(idps,l) = number of particles going up in field partition lc isign = -1, move from non-uniform (noff/nyp) to uniform (kyp) fieldsc isign = 1, move from uniform (kyp) to non-uniform (noff/nyp) fieldsc if isign = 0, the noffs/nyps contains the source partition, noffd/nypdc    contains the destination partition, and noff/nyp, kyp are not used.c    the source partition noffs/nyps is modified.c kyp = number of complex grids in each uniform field partition.c kstrt = starting data block numberc nvp = number of real or virtual processorsc nxv = first dimension of f, must be >= nxc nypmx = maximum size of field partition, must be >= kyp+1c nblok = number of field partitions.c idps = number of partition boundariesc mter = number of shifts requiredc if mter = 0, then number of shifts is determined and returnedc ierr = (0,1) = (no,yes) error condition exists      implicit none      real f, g      integer noff, nyp, noffs, nyps, noffd, nypd, jsr, jsl      integer isign, kyp, kstrt, nvp, nxv, nypmx, nblok, idps, mter      integer ierr      dimension f(nxv,nypmx,nblok), g(nxv,nypmx,nblok)      dimension noff(nblok), nyp(nblok)      dimension noffs(nblok), nyps(nblok), noffd(nblok), nypd(nblok)      dimension jsl(idps,nblok), jsr(idps,nblok)c common block for parallel processing      integer nproc, lgrp, lstat, mreal, mint, mcplx, mdouble, lworldc lstat = length of status array      parameter(lstat=10)c lgrp = current communicatorc mint = default datatype for integersc mreal = default datatype for reals      common /PPARMS/ nproc, lgrp, mreal, mint, mcplx, mdouble, lworldc local data      integer j, k, l      integer nbsize, ks, iter, npr, nps, nter, koff, kl, kr, kk, nypmn      integer msid, istatus      integer ibflg, iwork      dimension istatus(lstat)      dimension ibflg(2), iwork(2)c exit if certain flags are set      if (mter.lt.0) return      ks = kstrt - 2      nbsize = nxv*nypmx      nypmn = nypmx      iter = 2      ierr = 0c move from non-uniform to uniform fields      if (isign.lt.0) thenc copy non-uniform partition parameters         do 10 l = 1, nblok         noffs(l) = noff(l)         nyps(l) = nyp(l)         koff = kyp*(l + ks)         noffd(l) = koff         nypd(l) = kypc extend partition to include ny+1 grid         if ((l+ks).eq.(nvp-1)) then            nyps(l) = nyps(l) + 1            nypd(l) = nypd(l) + 1         endif   10    continuec move from uniform to non-uniform fields      else if (isign.gt.0) thenc set uniform partition parameters         do 20 l = 1, nblok         koff = kyp*(l + ks)         noffs(l) = koff         nyps(l) = kyp         noffd(l) = noff(l)         nypd(l) = nyp(l)c extend partition to include ny+1 grid         if ((l+ks).eq.(nvp-1)) then            nyps(l) = nyps(l) + 1            nypd(l) = nypd(l) + 1         endif   20    continue      endifc determine number of outgoing grids   30 do 50 l = 1, nblok      kl = noffd(l)      kr = kl + nypd(l)      jsl(1,l) = 0      jsr(1,l) = 0      do 40 k = 1, nyps(l)      kk = k + noffs(l)c fields going up      if (kk.gt.kr) then         jsr(1,l) = jsr(1,l) + 1c fields going down      else if (kk.le.kl) then         jsl(1,l) = jsl(1,l) + 1      endif   40 continue   50 continuec copy fields      iter = iter + 2      npr = 0      nter = 0c get fields from below      do 80 l = 1, nblok      kr = l + ks + 2      kl = l + ks      jsl(2,l) = 0      jsr(2,l) = 0c this segment is used for shared memory computersc     if (noffs(l).gt.noffd(l)) then     c        jsl(2,l) = jsr(1,kl)c        do 70 k = 1, jsl(2,l)c        do 60 j = 1, nxvc        g(j,k,l) = f(j,k+nyps(kl)-jsr(1,kl),kl)c  60    continuec  70    continuec     endifc this segment is used for mpi computersc post receive from left      if (noffs(l).gt.noffd(l)) then               call MPI_IRECV(g,nbsize,mreal,kl-1,iter-1,lgrp,msid,ierr)      endifc send fields to right      if (jsr(1,l).gt.0) then         call MPI_SEND(f(1,nyps(l)-jsr(1,l)+1,l),nxv*jsr(1,l),mreal,kr-1     1,iter-1,lgrp,ierr)      endifc wait for fields to arrive      if (noffs(l).gt.noffd(l)) then          call MPI_WAIT(msid,istatus,ierr)         call MPI_GET_COUNT(istatus,mreal,nps,ierr)         jsl(2,l) = nps/nxv      endif   80 continuec adjust field      do 150 l = 1, nblokc adjust field size      nyps(l) = nyps(l) - jsr(1,l)c do not allow move to overflow field array      jsr(1,l) = max0((nyps(l)+jsl(2,l)-nypmn),0)      nyps(l) = nyps(l) - jsr(1,l)      if (jsr(1,l).gt.0) then         npr = max0(npr,jsr(1,l))c save whatever is possible into end of g         kk = min0(jsr(1,l),nypmn-jsl(2,l))         do 100 k = 1, kk         do  90 j = 1, nxv         g(j,nypmn-kk+k,l) = f(j,nyps(l)+k,l)   90    continue  100    continue      endifc shift data which is staying, if necessary      if ((nyps(l).gt.0).and.(jsl(2,l).gt.0)) then         do 120 k = 1, nyps(l)         kk = nyps(l) - k + 1         do 110 j = 1, nxv         f(j,kk+jsl(2,l),l) = f(j,kk,l)  110    continue  120    continue      endifc insert data coming from left      do 140 k = 1, jsl(2,l)      do 130 j = 1, nxv      f(j,k,l) = g(j,k,l)  130 continue  140 continuec adjust field size and offset      nyps(l) = nyps(l) + jsl(2,l)      noffs(l) = noffs(l) - jsl(2,l)  150 continuec get fields from above      do 180 l = 1, nblok      kr = l + ks + 2      kl = l + ksc this segment is used for shared memory computersc     if ((noffs(l)+nyps(l)).lt.(noffd(l)+nypd(l))) then c        jsr(2,l) = jsl(1,kr)c        do 170 k = 1, jsr(2,l)c        do 160 j = 1, nxvc        g(j,k,l) =  f(j,k,kr)c 160    continuec 170    continuec     endifc this segment is used for mpi computersc post receive from right      if ((noffs(l)+nyps(l)).lt.(noffd(l)+nypd(l))) then              call MPI_IRECV(g,nbsize,mreal,kr-1,iter,lgrp,msid,ierr)      endifc send fields to left      if (jsl(1,l).gt.0) then         call MPI_SEND(f(1,1,l),nxv*jsl(1,l),mreal,kl-1,iter,lgrp,ierr)      endifc wait for fields to arrive      if ((noffs(l)+nyps(l)).lt.(noffd(l)+nypd(l))) then           call MPI_WAIT(msid,istatus,ierr)         call MPI_GET_COUNT(istatus,mreal,nps,ierr)         jsr(2,l) = nps/nxv      endif  180 continuec adjust field      do 240 l = 1, nblokc adjust field size      nyps(l) = nyps(l) - jsl(1,l)      noffs(l) = noffs(l) + jsl(1,l)c shift data which is staying, if necessary      if ((nyps(l).gt.0).and.(jsl(1,l).gt.0)) then         do 200 k = 1, nyps(l)         do 190 j = 1, nxv         f(j,k,l) = f(j,k+jsl(1,l),l)  190    continue  200    continue      endifc do not allow move to overflow field array      jsl(1,l) = max0((nyps(l)+jsr(2,l)-nypmn),0)      if (jsl(1,l).gt.0) then         npr = max0(npr,jsl(1,l))         jsr(2,l) = jsr(2,l) - jsl(1,l)c do not process if prior error      else if (jsr(1,l).gt.0) then         go to 230      endifc insert data coming from right      do 220 k = 1, jsr(2,l)      do 210 j = 1, nxv      f(j,k+nyps(l),l) = g(j,k,l)  210 continue  220 continuec adjust field size and offset      nyps(l) = nyps(l) + jsr(2,l)c check if new partition is uniform  230 nter = nter + abs(nyps(l)-nypd(l)) + abs(noffs(l)-noffd(l))  240 continuec calculate number of iterations      nps = iter/2 - 1      if (nps.le.mter) thenc process errors         if (npr.ne.0) then            ierr = npr            write (2,*) 'local field overflow error, ierr = ', ierr            go to 250         endif         if (nps.lt.mter) go to 30         go to 250      endifc process errors      ibflg(1) = npr      ibflg(2) = nter      call PIMAX(ibflg,iwork,2,1)c field overflow error      if (ibflg(1).ne.0) then         ierr = ibflg(1)         write (2,*) 'global field overflow error, ierr = ', ierr         go to 250      endifc check if any fields have to be passed further      if (ibflg(2).gt.0) then         write (2,*) 'Info: fields being passed further = ', ibflg(2)         go to 30      endif      mter = npsc restore partition to normal  250 do 260 l = 1, nblok      if ((l+ks).eq.(nvp-1)) then         nyps(l) = nyps(l) - 1         nypd(l) = nypd(l) - 1      endif  260 continue      return      endc-----------------------------------------------------------------------c 2d parallel PIC library for initializationc written by viktor k. decyk, uclac copyright 1995, regents of the university of californiac update: may 9, 2005c-----------------------------------------------------------------------      subroutine PFDISTR2(part,nps,fnx,argx1,argx2,argx3,fny,argy1,argy2     1,argy3,npx,npy,nx,ny,idimp,npmax,nblok,kstrt,nvp,ipbc,ierr)c for 2d code, this subroutine calculates initial particle co-ordinatesc with general density profile n(x,y) = n(x)*n(y), c where density in x is given by n(x) = fnx(x,argx1,argx2,argx3,0)c and integral of the density is given by = fnx(x,argx1,argx2,argx3,1)c and where density in y is given by n(y) = fny(y,argy1,argy2,argy3,0)c and integral of the density is given by = fny(y,argy1,argy2,argy3,1)c for distributed data.c particles are not necessarily in the correct processor.c part(1,n,l) = position x of particle n in partition lc part(2,n,l) = position y of particle n in partition lc nps(l) = starting address of particles in partition lc fnx/fny = density and density integral function in x/y directionc argx1,argx2,argx3 = arguments to fnxc argy1,argy2,argy3 = arguments to fnyc npx/npy = initial number of particles distributed in x/y directionc nx/ny = system length in x/y directionc idimp = size of phase space = 4 or 5c npmax = maximum number of particles in each partitionc nblok = number of particle partitionsc kstrt = starting data block numberc nvp = number of real or virtual processorsc ipbc = particle boundary condition = (0,1,2,3) =c (none,2d periodic,2d reflecting,mixed reflecting/periodic)c ierr = (0,1) = (no,yes) error condition existsc with spatial decomposition      implicit none      integer npx, npy, nx, ny, idimp, npmax, nblok, kstrt, nvp, ipbc      integer ierr, nps      real argx1, argx2, argx3, argy1, argy2, argy3      real part      dimension part(idimp,npmax,nblok)      dimension nps(nblok)      real fnx, fny      external fnx, fnyc local data      integer ks, nppv, npxy, kc, jc, i, j, k, l, n, nn, koff, noff      integer imax, iwork      real edgelx, edgely, anx, any, bnx, bny, xt, yt, xt0, yt0, x0, y0      real xn, yn, eps, big, f, fp      ierr = 0c particle distribution constants      ks = kstrt - 2      nppv = min((npx*npy)/nvp,npmax)      npxy = nppv*nvpc eps = convergence criterion      imax = 20      eps = 0.0001      big = 0.5c check for errors      if (npxy.ne.(npx*npy)) ierr = 1      call PISUM(ierr,iwork,1,1)      if (ierr.gt.0) then         ierr = npxy - npx*npy         write (2,*) 'particle distribution truncated, np = ', npxy         return      endifc set boundary values      edgelx = 0.      edgely = 0.      if (ipbc.eq.2) then         edgelx = 1.         edgely = 1.      else if (ipbc.eq.3) then         edgelx = 1.         edgely = 0.      endifc find normalization for function      anx = float(nx) - edgelx      any = float(ny) - edgely      x0 = fnx(edgelx,argx1,argx2,argx3,1)      y0 = fny(edgely,argy1,argy2,argy3,1)      bnx = float(npx)/(fnx(anx,argx1,argx2,argx3,1) - x0)      bny = float(npy)/(fny(any,argy1,argy2,argy3,1) - y0)      x0 = bnx*x0 - .5      y0 = bny*y0 - .5c uniform density profile      do 90 l = 1, nblok      koff = nppv*(l + ks)      noff = nps(l) - 1c integrate to find starting point in y      kc = koff/npx      yt0 = edgely      yt = yt0 + 0.5/(bny*fny(yt0,argy1,argy2,argy3,0))      do 20 k = 1, kc      yn = float(k) + y0c guess next value for yt      if (k.gt.1) yt = yt + 1.0/(bny*fny(yt,argy1,argy2,argy3,0))      yt = max(edgely,min(yt,any))      i = 0   10 f = bny*fny(yt,argy1,argy2,argy3,1) - ync find improved value for yt      if (abs(f).ge.eps) thenc newton's method         if (abs(f).lt.big) then            fp = bny*fny(yt,argy1,argy2,argy3,0)            yt0 = yt            yt = yt - f/fp            yt = max(edgely,min(yt,any))c bisection method         else if (f.gt.0.) then            fp = .5*(yt - yt0)            yt = yt0 + fp         else            fp = yt - yt0c           yt0 = yt            yt = yt + fp         endif         i = i + 1         if (i.lt.imax) go to 10         write (2,*) 'newton iteration max exceeded, yt = ', yt         ierr = ierr + 1      endif      yt0 = yt   20 continuec quit if error      if (ierr.ne.0) returnc integrate to find starting point in x      jc = koff - npx*kc      xt0 = edgelx      xt = xt0 + 0.5/(bnx*fnx(xt0,argx1,argx2,argx3,0))      do 40 j = 1, jc      xn = float(j) + x0c guess next value for xt      if (j.gt.1) xt = xt + 1.0/(bnx*fnx(xt,argx1,argx2,argx3,0))      xt = max(edgelx,min(xt,anx))      i = 0   30 f = bnx*fnx(xt,argx1,argx2,argx3,1) - xnc find improved value for xt      if (abs(f).ge.eps) thenc newton's method         if (abs(f).lt.big) then            fp = bnx*fnx(xt,argx1,argx2,argx3,0)            xt0 = xt            xt = xt - f/fp            xt = max(edgelx,min(xt,anx))c bisection method         else if (f.gt.0.) then            fp = .5*(xt - xt0)            xt = xt0 + fp         else            fp = xt - xt0c           xt0 = xt            xt = xt + fp         endif         i = i + 1         if (i.lt.imax) go to 30         write (2,*) 'newton iteration max exceeded, xt = ', xt         ierr = ierr + 1      endif      xt0 = xt   40 continuec quit if error      if (ierr.ne.0) returnc density profile in x      kc = kc + 1      do 60 n = 1, min(npx,nppv)c j, k = used to determine spatial location of this particle      nn = n + koff      k = (nn - 1)/npx + 1      j = nn - npx*(k - 1)      xn = float(j) + x0c guess next value for xt      if (j.eq.1) then         xt0 = edgelx         xt = xt0 + 0.5/(bnx*fnx(xt0,argx1,argx2,argx3,0))      else         xt = xt + 1.0/(bnx*fnx(xt,argx1,argx2,argx3,0))      endif      xt = max(edgelx,min(xt,anx))      i = 0   50 f = bnx*fnx(xt,argx1,argx2,argx3,1) - xnc find improved value for xt      if (abs(f).ge.eps) thenc newton's method         if (abs(f).lt.big) then            fp = bnx*fnx(xt,argx1,argx2,argx3,0)            xt0 = xt            xt = xt - f/fp            xt = max(edgelx,min(xt,anx))c bisection method         else if (f.gt.0.) then            fp = .5*(xt - xt0)            xt = xt0 + fp         else            fp = xt - xt0c           xt0 = xt            xt = xt + fp         endif         i = i + 1         if (i.lt.imax) go to 50         write (2,*) 'newton iteration max exceeded, xt = ', xt         ierr = ierr + 1      endif      part(1,n+noff,l) = xt      xt0 = xt   60 continuec quit if error      if (ierr.ne.0) returnc density profile in y      do 80 n = 1, nppvc j, k = used to determine spatial location of this particle      nn = n + koff      k = (nn - 1)/npx + 1      j = nn - npx*(k - 1)      nn = n - ((n - 1)/npx)*npx      if (k.eq.kc) then         yn = float(k) + y0c guess next value for yt         if (k.gt.1) yt = yt + 1.0/(bny*fny(yt,argy1,argy2,argy3,0))         yt = max(edgely,min(yt,any))         i = 0   70    f = bny*fny(yt,argy1,argy2,argy3,1) - ync find improved value for yt         if (abs(f).ge.eps) thenc newton's method            if (abs(f).lt.big) then               fp = bny*fny(yt,argy1,argy2,argy3,0)               yt0 = yt               yt = yt - f/fp               yt = max(edgely,min(yt,any))c bisection method            else if (f.gt.0.) then               fp = .5*(yt - yt0)               yt = yt0 + fp            else               fp = yt - yt0c              yt0 = yt               yt = yt + fp            endif            i = i + 1            if (i.lt.imax) go to 70            write (2,*) 'newton iteration max exceeded, yt = ', yt            ierr = ierr + 1         endif         kc = kc + 1         yt0 = yt      endifc store co-ordinates      part(1,n+noff,l) = part(1,nn+noff,l)      part(2,n+noff,l) = yt   80 continue   90 continue      return      endc-----------------------------------------------------------------------      subroutine PRDISTR2(part,nps,fnx,argx1,argx2,argx3,fny,argy1,argy2     1,argy3,npx,npy,nx,ny,idimp,npmax,nblok,kstrt,nvp,ipbc)c for 2d code, this subroutine randomizes initial particle co-ordinatesc which have been previously calculated using a general density profilec n(x,y) = n(x)*n(y), c where density in x is given by n(x) = fnx(x,argx1,argx2,argx3,0)c and integral of the density is given by = fnx(x,argx1,argx2,argx3,1)c and where density in y is given by n(y) = fny(y,argy1,argy2,argy3,0)c and integral of the density is given by = fny(y,argy1,argy2,argy3,1)c for distributed data.c particles are not necessarily in the correct processor.c part(1,n,l) = position x of particle n in partition lc part(2,n,l) = position y of particle n in partition lc nps(l) = starting address of particles in partition lc fnx/fny = density and density integral function in x/y directionc argx1,argx2,argx3 = arguments to fnxc argy1,argy2,argy3 = arguments to fnyc npx/npy = initial number of particles distributed in x/y directionc nx/ny = system length in x/y directionc idimp = size of phase space = 4 or 5c npmax = maximum number of particles in each partitionc nblok = number of particle partitionsc kstrt = starting data block numberc nvp = number of real or virtual processorsc ipbc = particle boundary condition = (0,1,2,3) =c (none,2d periodic,2d reflecting,mixed reflecting/periodic)c with spatial decomposition      implicit none      integer npx, npy, nx, ny, idimp, npmax, nblok, kstrt, nvp, ipbc      integer nps      real argx1, argx2, argx3, argy1, argy2, argy3      real part      dimension part(idimp,npmax,nblok)      dimension nps(nblok)      real fnx, fny      external fnx, fnyc local data      integer ks, nppv, kc, j, k, l, n, nn, koff, noff      real edgelx, edgely, anx, any, bnx, bny, xt, yt, xt0, yt0, x0, y0      real xn, yn      double precision randumc particle distribution constants      ks = kstrt - 2      nppv = min((npx*npy)/nvp,npmax)c set boundary values      edgelx = 0.      edgely = 0.      if (ipbc.eq.2) then         edgelx = 1.         edgely = 1.      else if (ipbc.eq.3) then         edgelx = 1.         edgely = 0.      endifc find normalization for function      anx = float(nx) - edgelx      any = float(ny) - edgely      x0 = fnx(edgelx,argx1,argx2,argx3,1)      y0 = fny(edgely,argy1,argy2,argy3,1)      bnx = float(npx)/(fnx(anx,argx1,argx2,argx3,1) - x0)      bny = float(npy)/(fny(any,argy1,argy2,argy3,1) - y0)c randomize co-ordinates      do 30 k = 1, npy      kc = npx*(k - 1)      do 20 j = 1, npx      nn = j + kc      xn = randum()      yn = randum()      do 10 l = 1, nblok      koff = nppv*(l + ks)      n = nn - koff      if ((n.gt.0).and.(n.le.nppv)) then         noff = nps(l) - 1         xt = part(1,n+noff,l)         xt0 = 1.0/(bnx*fnx(xt,argx1,argx2,argx3,0))         xn = xt + xt0*(xn - 0.5)         xn = max(edgelx,min(xn,anx))         part(1,n+noff,l) = xn         yt = part(2,n+noff,l)         yt0 = 1.0/(bny*fny(yt,argy1,argy2,argy3,0))         yn = yt + yt0*(yn - 0.5)         yn = max(edgely,min(yn,any))         part(2,n+noff,l) = yn      endif   10 continue   20 continue   30 continue      return      endc-----------------------------------------------------------------------      subroutine PVDISTR2(part,npp,nps,vtx,vty,vdx,vdy,npx,npy,idimp,npm     1ax,nblok,kstrt,nvp,ierr)c for 2d code, this subroutine calculates initial particle velocitiesc with maxwellian velocity with drift for distributed data.c part(3,n,l) = velocity vx of particle n in partition lc part(4,n,l) = velocity vy of particle n in partition lc npp(l) = number of particles in partition lc nps(l) = starting address of particles in partition lc vtx/vty = thermal velocity of electrons in x/y directionc vdx/vdy = drift velocity of beam electrons in x/y directionc npx/npy = initial number of particles distributed in x/y directionc idimp = size of phase space = 4c npmax = maximum number of particles in each partitionc nblok = number of particle partitionsc kstrt = starting data block numberc nvp = number of real or virtual processorsc ierr = (0,1) = (no,yes) error condition existsc ranorm = gaussian random number with zero mean and unit variancec with spatial decomposition      implicit none      integer npx, npy, idimp, npmax, nblok, kstrt, nvp, ierr      real vtx, vty, vdx, vdy      integer npp, nps      real part      dimension part(idimp,npmax,nblok)      dimension npp(nblok), nps(nblok)c local data      integer ks, nppv, npxy, i, j, k, l, joff, imin, npt, iwork      real vxt, vyt, at1      double precision ranorm      double precision dsum1, dsum2      real sum2, work2      dimension sum2(2), work2(2)      ierr = 0c particle distribution constants      ks = kstrt - 2      nppv = min((npx*npy)/nvp,npmax)      npxy = nppv*nvpc maxwellian velocity distribution      do 30 k = 1, npy      joff = npx*(k - 1)      do 20 j = 1, npx      i = j + joffc maxwellian velocity distribution      vxt = vtx*ranorm()      vyt = vty*ranorm()      do 10 l = 1, nblok      imin = nppv*(l + ks) + 1      if ((i.ge.imin).and.(i.lt.(imin+nppv))) then         npt = npp(l) + 1         part(3,npt,l) = vxt         part(4,npt,l) = vyt         npp(l) = npt      endif   10 continue   20 continue   30 continue      npxy = 0c add correct drift      sum2(1) = 0.      sum2(2) = 0.      do 50 l = 1, nblok      dsum1 = 0.0d0      dsum2 = 0.0d0      do 40 j = nps(l), npp(l)      npxy = npxy + 1      dsum1 = dsum1 + part(3,j,l)      dsum2 = dsum2 + part(4,j,l)   40 continue      sum2(1) = sum2(1) + dsum1      sum2(2) = sum2(2) + dsum2   50 continue      call PISUM(npxy,iwork,1,1)      call PSUM(sum2,work2,2,1)      at1 = 1./float(npxy)      sum2(1) = at1*sum2(1) - vdx      sum2(2) = at1*sum2(2) - vdy      do 70 l = 1, nblok      do 60 j = nps(l), npp(l)      part(3,j,l) = part(3,j,l) - sum2(1)      part(4,j,l) = part(4,j,l) - sum2(2)   60 continue   70 continuec process errors      if (npxy.ne.(npx*npy)) then         ierr = npxy - npx*npy         write (2,*) 'velocity distribution truncated, np = ', npxy      endif      return      endc-----------------------------------------------------------------------      subroutine FEDGES2(edges,noff,nyp,fny,arg1,arg2,arg3,ny,nypmin,nyp     1max,kstrt,nvp,nblok,idps,ipbc)c this subroutines finds new partitions boundaries (edges,noff,nyp)c from density integral given by = fny(y,arg1,arg2,arg3,1)c edges(1,l) = lower boundary of particle partition lc edges(2,l) = upper boundary of particle partition lc noff(l) = lowermost global gridpoint in particle partition lc nyp(l) = number of primary gridpoints in particle partition lc fny = density and density integral functionc arg1,arg2,arg3 = arguments to fnyc nypmin/nypmax = minimum/maximum value of nyp in new partitionc kstrt = starting data block numberc nvp = number of real or virtual processorsc nblok = number of field partitions.c idps = number of partition boundariesc ipbc = particle boundary condition = (0,1,2,3) =c (none,2d periodic,2d reflecting,mixed reflecting/periodic)      implicit none      real edges      real arg1, arg2, arg3      integer noff, nyp      integer ny, nypmin, nypmax, kstrt, nvp, nblok, idps, ipbc      dimension edges(idps,nblok)      dimension noff(nblok), nyp(nblok)      real fny      external fnyc local data      integer ks, kl, kr, l      real edgely, any1, any, y0, y1, anpav, anpl, anpr, sum1, at1, at2      integer ibflg, iwork      dimension ibflg(2), iwork(2)c particle distribution constants      ks = kstrt - 2c set boundary values      edgely = 0.      if (ipbc.eq.2) then         edgely = 1.      else if (ipbc.eq.3) then         edgely = 0.      endifc find normalization for function      any = real(ny)      any1 = any - edgely      y0 = fny(edgely,arg1,arg2,arg3,1)c anpav = desired number of particles per processor      anpav = (fny(any1,arg1,arg2,arg3,1) - y0)/real(nvp)c search for boundaries      do 30 l = 1, nblok      kl = l + ks      anpl = real(kl)*anpav      anpr = real(kl+1)*anpav      y1 = edgely      sum1 = 0.c first find left boundary   10 at1 = sum1      sum1 = fny(y1,arg1,arg2,arg3,1) - y0      y1 = y1 + 1.0      if ((sum1.lt.anpl).and.(y1.le.any)) go to 10       if (sum1.gt.at1) then         at2 = (y1 - 2.0) + (anpl - at1)/(sum1 - at1)      else         at2 = y1 - 1.0      endif      edges(1,l) = at2c set leftmost edge to zero      if (kl.eq.0) edges(1,l) = 0.c then find right boundary   20 at1 = sum1      sum1 = fny(y1,arg1,arg2,arg3,1) - y0      y1 = y1 + 1.0      if ((sum1.lt.anpr).and.(y1.le.any)) go to 20      at2 = (y1 - 2.0) + (anpr - at1)/(sum1 - at1)      edges(2,l) = at2c set rightmost edge to ny      if ((kl+1).eq.nvp) edges(2,l) = any   30 continuec calculate number of grids and offsets in new partitions      do 40 l = 1, nblok      kl = edges(1,l) + .5      noff(l) = kl      kr = edges(2,l) + .5      nyp(l) = kr - kl      edges(1,l) = real(kl)      edges(2,l) = real(kr)   40 continuec find minimum and maximum partition size      nypmin = nyp(1)      nypmax = nyp(1)      do 50 l = 1, nblok      nypmin = min0(nypmin,nyp(l))      nypmax = max0(nypmax,nyp(l))   50 continue      ibflg(1) = -nypmin      ibflg(2) = nypmax      call PIMAX(ibflg,iwork,2,1)      nypmin = -ibflg(1)      nypmax = ibflg(2)      return      endc-----------------------------------------------------------------------      function FLDISTR1(x,anlx,anxi,shift,intg)c this function calculates either a density function or its integralc for a linear density profile.  Used in initializing particlec coordinates.  The three parameters are redundant, and one can set onec of them arbitrarily.  A convenient choice is to set  anxi = 1/Lx,c anlx = NH - NL, shift = (1 - NL)/(NH - NL), where NL is the densityc at the left, and NH at the right compared to the average densityc if intg = 0, n(x) = 1. + anlx*(x*anxi - shift)c if intg = 1, n(x) = x + .5*anlx*x*(x*anxi - 2.*shift)      implicit none      integer intg      real x, anlx, anxi, shiftc local data      real FLDISTR1, f      if (intg.eq.0) then         f = 1.0 + anlx*(x*anxi - shift)      else if (intg.eq.1) then         if (anxi.eq.0.) then            f = x         else            f = x + .5*anlx*x*(x*anxi - 2.*shift)         endif      else         f = -1.0      endif      if (f.lt.0.) write (2,*) 'FLDISTR1 Error: f = ', f      FLDISTR1 = f      return      endc-----------------------------------------------------------------------      function FSDISTR1(x,ans,dkx,phase,intg)c this function calculates either a density function or its integralc for a sinusoidal density profile.  Used in initializing particlec coordinates.c if intg = 0, n(x) = 1.0 + ans*sin(dkx*x - phase)c if intg = 1, n(x) = x - (ans/dkx)*(cos(dkx*x - phase) - cos(phase))      implicit none      integer intg      real x, ans, dkx, phasec local data      real FSDISTR1, f      if (intg.eq.0) then         f = 1.0 + ans*sin(dkx*x - phase)      else if (intg.eq.1) then         if (dkx.eq.0.) then            f = x - ans*sin(phase)*x         else            f = x - (ans/dkx)*(cos(dkx*x - phase) - cos(phase))         endif      else         f = -1.0      endif      if (f.lt.0.) write (2,*) 'FSDISTR1 Error: f = ', f      FSDISTR1 = f      return      endc-----------------------------------------------------------------------      function FGDISTR1(x,ang,wi,x0,intg)c this function calculates either a density function or its integralc for a gaussian density profile.  Used in initializing particlec coordinates.c if intg = 0, n(x) = 1.0 + ang*exp(-((x-x0)*wi)**2/2.)c if intg = 1, n(x) = x + (ang*sqrt(pi/2)/wi)*c                         (erf((x-x0)*wi/sqrt(2)) + erf(x0*wi/sqrt(2)))      implicit none      integer intg      real x, ang, x0, wic local data      real FGDISTR1, f, sqrt2i, sqtpih, aw, t, erfn      external erfn      data sqrt2i, sqtpih /0.7071067811865476,1.253314137397325/      save sqrt2i, sqtpih      aw = wi*sqrt2i      t = (x - x0)*aw      if (intg.eq.0) then         if (abs(t).lt.8.) then            f = 1.0 + ang*exp(-t**2)         else            f = 1.0         endif      else if (intg.eq.1) then         if (wi.eq.0.) then            f = (1.0 + ang)*x         else            f = x + (ang*sqtpih/wi)*(erfn(t) + erfn(x0*aw))         endif      else         f = -1.0      endif      if (f.lt.0.) write (2,*) 'FGDISTR1 Error: f = ', f      FGDISTR1 = f      return      endc-----------------------------------------------------------------------      function FHDISTR1(x,anh,wi,x0,intg)c this function calculates either a density function or its integralc for a hyperbolic secant squared density profile.  Used in initializingc particle coordinates.c if intg = 0, n(x) = 1.0 + anh*sech((x-x0)*wi)**2c if intg = 1, n(x) = x + (anh/wi)*(tanh((x-x0)*wi) + tanh(x0*wi))      implicit none      integer intg      real x, anh, x0, wic local data      real FHDISTR1, f, g, t, u      t = (x - x0)*wi      if (intg.eq.0) then         if (abs(t).lt.32.) then            u = exp(-abs(t))            f = 1.0 + anh*(2.*u/(1.0 + u*u))**2         else            f = 1.0         endif      else if (intg.eq.1) then         if (wi.eq.0.) then            f = (1.0 + anh)*x         else            if (abs(t).lt.32.) then               u = exp(-abs(t))**2               f = (1.0 - u)/(1.0 + u)            else               f = 1.0            endif            if (t.lt.0.) f = -f            t = x0*wi            if (abs(t).lt.32.) then               u = exp(-abs(t))**2               g = (1.0 - u)/(1.0 + u)            else               g = 1.0            endif            if (t.lt.0.) g = -g            f = x + (anh/wi)*(f + g)         endif      else         f = -1.0      endif      if (f.lt.0.) write (2,*) 'FHDISTR1 Error: f = ', f      FHDISTR1 = f      return      endc-----------------------------------------------------------------------      function ranorm()c this program calculates a random number y from a gaussian distributionc with zero mean and unit variance, according to the method ofc mueller and box:c    y(k) = (-2*ln(x(k)))**1/2*sin(2*pi*x(k+1))c    y(k+1) = (-2*ln(x(k)))**1/2*cos(2*pi*x(k+1)),c where x is a random number uniformly distributed on (0,1).c written for the ibm by viktor k. decyk, ucla      integer r1,r2,r4,r5      double precision ranorm,h1l,h1u,h2l,r0,r3,asc,bsc,temp      save iflg,r1,r2,r4,r5,h1l,h1u,h2l,r0      data r1,r2,r4,r5 /885098780,1824280461,1396483093,55318673/      data h1l,h1u,h2l /65531.0d0,32767.0d0,65525.0d0/      data iflg,r0 /0,0.0d0/      if (iflg.eq.0) go to 10      ranorm = r0      r0 = 0.0d0      iflg = 0      return   10 isc = 65536      asc = dble(isc)      bsc = asc*asc      i1 = r1 - (r1/isc)*isc      r3 = h1l*dble(r1) + asc*h1u*dble(i1)      i1 = r3/bsc      r3 = r3 - dble(i1)*bsc      bsc = 0.5d0*bsc      i1 = r2/isc      isc = r2 - i1*isc      r0 = h1l*dble(r2) + asc*h1u*dble(isc)      asc = 1.0d0/bsc      isc = r0*asc      r2 = r0 - dble(isc)*bsc      r3 = r3 + (dble(isc) + 2.0d0*h1u*dble(i1))      isc = r3*asc      r1 = r3 - dble(isc)*bsc      temp = dsqrt(-2.0d0*dlog((dble(r1) + dble(r2)*asc)*asc))      isc = 65536      asc = dble(isc)      bsc = asc*asc      i1 = r4 - (r4/isc)*isc      r3 = h2l*dble(r4) + asc*h1u*dble(i1)      i1 = r3/bsc      r3 = r3 - dble(i1)*bsc      bsc = 0.5d0*bsc      i1 = r5/isc      isc = r5 - i1*isc      r0 = h2l*dble(r5) + asc*h1u*dble(isc)      asc = 1.0d0/bsc      isc = r0*asc      r5 = r0 - dble(isc)*bsc      r3 = r3 + (dble(isc) + 2.0d0*h1u*dble(i1))      isc = r3*asc      r4 = r3 - dble(isc)*bsc      r0 = 6.28318530717959d0*((dble(r4) + dble(r5)*asc)*asc)      ranorm = temp*dsin(r0)      r0 = temp*dcos(r0)      iflg = 1      return      endc-----------------------------------------------------------------------      function randum()c this is a version of the random number generator dprandom due toc c. bingham and the yale computer center, producing numbersc in the interval (0,1).  written for the sun by viktor k. decyk, ucla      integer r1,r2      double precision randum,h1l,h1u,r0,r3,asc,bsc      save r1,r2,h1l,h1u      data r1,r2 /1271199957,1013501921/      data h1l,h1u /65533.0d0,32767.0d0/      isc = 65536      asc = dble(isc)      bsc = asc*asc      i1 = r1 - (r1/isc)*isc      r3 = h1l*dble(r1) + asc*h1u*dble(i1)      i1 = r3/bsc      r3 = r3 - dble(i1)*bsc      bsc = 0.5d0*bsc      i1 = r2/isc      isc = r2 - i1*isc      r0 = h1l*dble(r2) + asc*h1u*dble(isc)      asc = 1.0d0/bsc      isc = r0*asc      r2 = r0 - dble(isc)*bsc      r3 = r3 + (dble(isc) + 2.0d0*h1u*dble(i1))      isc = r3*asc      r1 = r3 - dble(isc)*bsc      randum = (dble(r1) + dble(r2)*asc)*asc      return      endc-----------------------------------------------------------------------      function erfn(x)c this function calculates the real error function, according to thec formulae given in Abramowitz and Stegun, Handbook of Mathematicalc Functions, p. 299.  Error is < 1.5 x 10-7.      implicit none      real xc local data      real erfn, p, a1, a2, a3, a4, a5, t, f      data p, a1, a2 /0.3275911,0.254829592,-0.284496736/      data a3, a4, a5 /1.421413741,-1.453152027,1.061405429/      save p, a1, a2, a3, a4, a5      f = abs(x)      t = 1.0/(1.0 + p*f)      if (f.le.8.) then         erfn = 1.0 - t*(a1 + t*(a2 + t*(a3 + t*(a4 + t*a5))))*exp(-x*x)      else         erfn = 1.0      endif      if (x.lt.0.) erfn = -erfn      return      endc-----------------------------------------------------------------------      function e1ln(x)c this function calculates the sum of the exponential integral and thec natural logarithm, according to the formulae given in Abramowitz andc Stegun, Handbook of Mathematical Functions, p. 231.c Error is < 2.0 x 10-7.      implicit none      real xc local data      real e1ln, a0, a1, a2, a3, a4, a5, b1, b2, b3, b4, c1, c2, c3, c4      data a0, a1, a2 /-0.57721566,0.99999193,-0.24991055/      data a3, a4, a5 /0.05519968,-0.00976004,0.00107857/      data b1, b2, b3 /8.5733287401,18.0590169730,8.6347608925/      data c1, c2, c3 /9.5733223454,25.6329561486,21.0996530827/      data b4, c4 /0.2677737343,3.9584969228/      save       if (x.le.1.0) then         e1ln = a0 + x*(a1 + x*(a2 + x*(a3 + x*(a4 + x*a5))))      else if (x.lt.50.0) then         e1ln = alog(x) + (exp(-x)/x)*((b4 + x*(b3 + x*(b2 + x*(b1 + x))     1))/(c4 + x*(c3 + x*(c2 + x*(c1 + x)))))      else         e1ln = alog(x)      endif      return      endc-----------------------------------------------------------------------c 2d parallel PIC library for pushing particles and depositing chargec written by viktor k. decyk, uclac copyright 1995, regents of the university of californiac update: may 9, 2005c-----------------------------------------------------------------------      subroutine PGPOST2L(part,q,npp,noff,qm,idimp,npmax,nblok,nxv,nypmx     1)c for 2d code, this subroutine calculates particle charge densityc using first-order linear interpolation, periodic boundariesc and distributed data.c scalar version using guard cells, for distributed datac 17 flops/particle, 6 loads, 4 storesc input: all, output: qc charge density is approximated by values at the nearest grid pointsc q(n,m)=qm*(1.-dx)*(1.-dy)c q(n+1,m)=qm*dx*(1.-dy)c q(n,m+1)=qm*(1.-dx)*dyc q(n+1,m+1)=qm*dx*dyc where n,m = leftmost grid points and dx = x-n, dy = y-mc part(1,n,l) = position x of particle n in partition lc part(2,n,l) = position y of particle n in partition lc q(j,k,l) = charge density at grid point (j,kk),c where kk = k + noff(l) - 1c npp(l) = number of particles in partition lc noff(l) = lowermost global gridpoint in particle partition l.c qm = charge on particle, in units of ec idimp = size of phase space = 4c npmax = maximum number of particles in each partitionc nblok = number of particle partitions.c nxv = first dimension of charge array, must be >= nx+1c nypmx = maximum size of particle partition, including guard cells.      dimension part(idimp,npmax,nblok), q(nxv,nypmx,nblok)      dimension npp(nblok), noff(nblok)      do 20 l = 1, nblok      mnoff = noff(l) - 1      do 10 j = 1, npp(l)c find interpolation weights      nn = part(1,j,l)      mm = part(2,j,l)      dxp = qm*(part(1,j,l) - float(nn))      dyp = part(2,j,l) - float(mm)      nn = nn + 1      mm = mm - mnoff      amx = qm - dxp      mp = mm + 1      amy = 1. - dyp      np = nn + 1c deposit charge      q(np,mp,l) = q(np,mp,l) + dxp*dyp      q(nn,mp,l) = q(nn,mp,l) + amx*dyp      q(np,mm,l) = q(np,mm,l) + dxp*amy      q(nn,mm,l) = q(nn,mm,l) + amx*amy   10 continue   20 continue      return      endc-----------------------------------------------------------------------      subroutine PGSPOST2L(part,q,npp,noff,qm,idimp,npmax,nblok,nxv,nxyp     1)c for 2d code, this subroutine calculates particle charge densityc using first-order linear interpolation, periodic boundariesc and distributed data.c scalar version using guard cells, integer conversion precalculation,c and 1d addressing, for distributed datac cases 9-10 in v.k.decyk et al, computers in physics 10, 290 (1996).c 17 flops/particle, 6 loads, 4 storesc input: all, output: qc charge density is approximated by values at the nearest grid pointsc q(n,m)=qm*(1.-dx)*(1.-dy)c q(n+1,m)=qm*dx*(1.-dy)c q(n,m+1)=qm*(1.-dx)*dyc q(n+1,m+1)=qm*dx*dyc where n,m = leftmost grid points and dx = x-n, dy = y-mc part(1,n,l) = position x of particle n in partition lc part(2,n,l) = position y of particle n in partition lc q(j,k,l) = charge density at grid point (j,kk),c where kk = k + noff(l) - 1c npp(l) = number of particles in partition lc noff(l) = lowermost global gridpoint in particle partition l.c qm = charge on particle, in units of ec idimp = size of phase space = 4c npmax = maximum number of particles in each partitionc nblok = number of particle partitions.c nxv = first dimension of charge array, must be >= nx+1c nxyp = actual first dimension of charge array, must be >= nxv*nypmx      dimension part(idimp,npmax,nblok), q(nxyp,nblok)      dimension npp(nblok), noff(nblok)      do 20 l = 1, nblok      if (npp(l).lt.1) go to 20      mnoff = noff(l)c begin first particle      nnn = part(1,1,l)      mmn = part(2,1,l)      dxn = part(1,1,l) - float(nnn)      dyn = part(2,1,l) - float(mmn)      mmn = mmn - mnoff      do 10 j = 2, npp(l)c find interpolation weights      nn = nnn + 1      mm = nxv*mmn      nnn = part(1,j,l)      mmn = part(2,j,l)      dxp = qm*dxn      dyp = dyn      dxn = part(1,j,l) - float(nnn)      dyn = part(2,j,l) - float(mmn)      mm = mm + nn      amx = qm - dxp      mp = mm + nxv      amy = 1. - dyp      mmn = mmn - mnoffc deposit charge      dx1 = q(mp+1,l) + dxp*dyp      dyp = q(mp,l) + amx*dyp      dxp = q(mm+1,l) + dxp*amy      amy = q(mm,l) + amx*amy      q(mp+1,l) = dx1      q(mp,l) = dyp      q(mm+1,l) = dxp      q(mm,l) = amy   10 continuec deposit charge for last particle      nn = nnn + 1      mm = nxv*mmn      dxp = qm*dxn      mm = mm + nn      amx = qm - dxp      mp = mm + nxv      amy = 1. - dync deposit charge      q(mp+1,l) = q(mp+1,l) + dxp*dyn      q(mp,l) = q(mp,l) + amx*dyn      q(mm+1,l) = q(mm+1,l) + dxp*amy      q(mm,l) = q(mm,l) + amx*amy   20 continue      return      endc-----------------------------------------------------------------------      subroutine PGSOST2XL(part,q,npp,noff,nn,amxy,qm,idimp,npmax,nblok,     1nxv,nxvyp,npd,ifour)c for 2d code, this subroutine calculates particle charge densityc using first-order linear interpolation, periodic boundaries,c with short vectors over independent weights, and distributed data,c as in j. schwartzmeier and t. hewitt, proc. 12th conf. on numericalc simulation of plasmas, san francisco, ca, 1987.c vectorized distributed version with guard cells and 1d addressingc 17 flops/particle, 14 loads, 12 storesc input: all, output: qc charge density is approximated by values at the nearest grid pointsc q(n,m)=qm*(1.-dx)*(1.-dy)c q(n+1,m)=qm*dx*(1.-dy)c q(n,m+1)=qm*(1.-dx)*dyc q(n+1,m+1)=qm*dx*dyc where n,m = leftmost grid points and dx = x-n, dy = y-mc part(1,n,l) = position x of particle n in partition lc part(2,n,l) = position y of particle n in partition lc q(j,k,l) = charge density at grid point (j,kk),c where kk = k + noff(l) - 1c npp(l) = number of particles in partition lc noff(l) = lowermost global gridpoint in particle partition l.c nn = scratch address array for vectorized charge depositionc amxy = scratch weight array for vectorized charge depositionc qm = charge on particle, in units of ec idimp = size of phase space = 4c npmax = maximum number of particles in each partitionc nblok = number of particle partitions.c nxv = first virtual dimension of charge array, must be >= nx+1c nxvyp = nxv*nypmx, first actual dimension of charge arrayc npd = size of scratch buffers for vectorized charge depositionc ifour = number of independent weights      dimension part(idimp,npmax,nblok), q(nxvyp,nblok)      dimension npp(nblok), noff(nblok)      dimension nn(ifour,npd,nblok), amxy(ifour,npd,nblok)c parallel loop      do 50 l = 1, nblok      mnoff = noff(l)      npb = npd      if (npp(l).gt.npd) then         ipp = float(npp(l) - 1)/float(npd) + 1.      else         ipp = 1      endifc outer loop over blocks of particles      do 40 j = 1, ipp      jb = (j - 1)*npd      if (j.ge.ipp) npb = npp(l) - (ipp - 1)*npd      do 10 i = 1, npbc find interpolation weights      n = part(1,i+jb,l)      m = part(2,i+jb,l)      dxp = qm*(part(1,i+jb,l) - float(n))      dyp = part(2,i+jb,l) - float(m)      n = n + 1      mm = nxv*(m - mnoff)      amx = qm - dxp      mm = mm + n      amy = 1. - dyp      mp = mm + nxv      nn(4,i,l) = mm      nn(3,i,l) = mm + 1      nn(2,i,l) = mp      nn(1,i,l) = mp + 1      amxy(1,i,l) = dxp*dyp      amxy(2,i,l) = amx*dyp      amxy(3,i,l) = dxp*amy      amxy(4,i,l) = amx*amy   10 continuec deposit charge      do 30 i = 1, npbcdir$ ivdep      do 20 k = 1, 4      q(nn(k,i,l),l) = q(nn(k,i,l),l) + amxy(k,i,l)   20 continue   30 continue   40 continue   50 continue      return      endc-----------------------------------------------------------------------      subroutine PGPUSH2L(part,fxy,npp,noff,qbm,dt,ek,nx,ny,idimp,npmax,     1nblok,nxv,nypmx,ipbc)c for 2d code, this subroutine updates particle co-ordinates andc velocities using leap-frog scheme in time and first-order linearc interpolation in space, with various boundary conditions,c for distributed data.c scalar version using guard cells, for distributed datac 42 flops/particle, 12 loads, 4 storesc input: all, output: part, ekc equations used are:c vx(t+dt/2) = vx(t-dt/2) + (q/m)*fx(x(t),y(t))*dt,c vy(t+dt/2) = vy(t-dt/2) + (q/m)*fy(x(t),y(t))*dt,c where q/m is charge/mass, andc x(t+dt) = x(t) + vx(t+dt/2)*dt, y(t+dt) = y(t) + vy(t+dt/2)*dtc fx(x(t),y(t)) and fy(x(t),y(t)) are approximated by interpolation fromc the nearest grid points:c fx(x,y) = (1-dy)*((1-dx)*fx(n,m)+dx*fx(n+1,m)) + dy*((1-dx)*fx(n,m+1)c    + dx*fx(n+1,m+1))c fy(x,y) = (1-dy)*((1-dx)*fy(n,m)+dx*fy(n+1,m)) + dy*((1-dx)*fy(n,m+1)c    + dx*fy(n+1,m+1))c where n,m = leftmost grid points and dx = x-n, dy = y-mc part(1,n,l) = position x of particle n in partition lc part(2,n,l) = position y of particle n in partition lc part(3,n,l) = velocity vx of particle n in partition lc part(4,n,l) = velocity vy of particle n in partition lc fxy(1,j,k,l) = x component of force/charge at grid (j,kk)c fxy(2,j,k,l) = y component of force/charge at grid (j,kk)c in other words, fxy are the convolutions of the electric fieldc over the particle shape, where kk = k + noff(l) - 1c npp(l) = number of particles in partition lc noff(l) = lowermost global gridpoint in particle partition l.c qbm = particle charge/massc dt = time interval between successive calculationsc kinetic energy/mass at time t is also calculated, usingc ek = .125*sum((vx(t+dt/2)+vx(t-dt/2))**2+(vy(t+dt/2)+vy(t-dt/2))**2)c nx/ny = system length in x/y directionc idimp = size of phase space = 4c npmax = maximum number of particles in each partitionc nblok = number of particle partitions.c nxv = first dimension of field array, must be >= nx+1c nypmx = maximum size of particle partition, including guard cells.c ipbc = particle boundary condition = (0,1,2,3) =c (none,2d periodic,2d reflecting,mixed reflecting/periodic)      double precision sum1      dimension part(idimp,npmax,nblok)      dimension fxy(2,nxv,nypmx,nblok)      dimension npp(nblok), noff(nblok)      qtm = qbm*dt      sum1 = 0.0d0c set boundary values      if (ipbc.eq.1) then         edgelx = 0.         edgerx = float(nx)      else if (ipbc.eq.2) then         edgelx = 1.         edgely = 1.         edgerx = float(nx-1)         edgery = float(ny-1)      else if (ipbc.eq.3) then         edgelx = 1.         edgerx = float(nx-1)      endif      do 20 l = 1, nblok      mnoff = noff(l) - 1      do 10 j = 1, npp(l)c find interpolation weights      nn = part(1,j,l)      mm = part(2,j,l)      dxp = part(1,j,l) - float(nn)      dyp = part(2,j,l) - float(mm)      nn = nn + 1      mm = mm - mnoff      amx = 1. - dxp      mp = mm + 1      amy = 1. - dyp      np = nn + 1c find acceleration      dx = dyp*(dxp*fxy(1,np,mp,l) + amx*fxy(1,nn,mp,l)) + amy*(dxp*fxy(     11,np,mm,l) + amx*fxy(1,nn,mm,l))      dy = dyp*(dxp*fxy(2,np,mp,l) + amx*fxy(2,nn,mp,l)) + amy*(dxp*fxy(     12,np,mm,l) + amx*fxy(2,nn,mm,l))c new velocity      dx = part(3,j,l) + qtm*dx      dy = part(4,j,l) + qtm*dyc average kinetic energy      sum1 = sum1 + (dx + part(3,j,l))**2 + (dy + part(4,j,l))**2      part(3,j,l) = dx      part(4,j,l) = dyc new position      dx = part(1,j,l) + dx*dt      dy = part(2,j,l) + dy*dtc periodic boundary conditions      if (ipbc.eq.1) then         if (dx.lt.edgelx) dx = dx + edgerx         if (dx.ge.edgerx) dx = dx - edgerxc reflecting boundary conditions      else if (ipbc.eq.2) then         if ((dx.lt.edgelx).or.(dx.ge.edgerx)) then            dx = part(1,j,l)            part(3,j,l) = -part(3,j,l)         endif         if ((dy.lt.edgely).or.(dy.ge.edgery)) then            dy = part(2,j,l)            part(4,j,l) = -part(4,j,l)         endifc mixed reflecting/periodic boundary conditions      else if (ipbc.eq.3) then         if ((dx.lt.edgelx).or.(dx.ge.edgerx)) then            dx = part(1,j,l)            part(3,j,l) = -part(3,j,l)         endif      endifc set new position      part(1,j,l) = dx      part(2,j,l) = dy   10 continue   20 continuec normalize kinetic energy      ek = ek + .125*sum1      return      endc-----------------------------------------------------------------------      subroutine PGSPUSH2L(part,fxy,npp,noff,qbm,dt,ek,nx,ny,idimp,npmax     1,nblok,nxv,nxyp,ipbc)c for 2d code, this subroutine updates particle co-ordinates andc velocities using leap-frog scheme in time and first-order linearc interpolation in space, with various boundary conditions,c for distributed data.c scalar version using guard cells, integer conversion precalculation,c and 1d addressing, for distributed datac cases 9-10 in v.k.decyk et al, computers in physics 10, 290 (1996)c 42 flops/particle, 12 loads, 4 storesc input: all, output: part, ekc equations used are:c vx(t+dt/2) = vx(t-dt/2) + (q/m)*fx(x(t),y(t))*dt,c vy(t+dt/2) = vy(t-dt/2) + (q/m)*fy(x(t),y(t))*dt,c where q/m is charge/mass, andc x(t+dt) = x(t) + vx(t+dt/2)*dt, y(t+dt) = y(t) + vy(t+dt/2)*dtc fx(x(t),y(t)) and fy(x(t),y(t)) are approximated by interpolation fromc the nearest grid points:c fx(x,y) = (1-dy)*((1-dx)*fx(n,m)+dx*fx(n+1,m)) + dy*((1-dx)*fx(n,m+1)c    + dx*fx(n+1,m+1))c fy(x,y) = (1-dy)*((1-dx)*fy(n,m)+dx*fy(n+1,m)) + dy*((1-dx)*fy(n,m+1)c    + dx*fy(n+1,m+1))c where n,m = leftmost grid points and dx = x-n, dy = y-mc part(1,n,l) = position x of particle n in partition lc part(2,n,l) = position y of particle n in partition lc part(3,n,l) = velocity vx of particle n in partition lc part(4,n,l) = velocity vy of particle n in partition lc fxy(1,j,k,l) = x component of force/charge at grid (j,kk)c fxy(2,j,k,l) = y component of force/charge at grid (j,kk)c in other words, fxy are the convolutions of the electric fieldc over the particle shape, where kk = k + noff(l) - 1c npp(l) = number of particles in partition lc noff(l) = lowermost global gridpoint in particle partition l.c qbm = particle charge/massc dt = time interval between successive calculationsc kinetic energy/mass at time t is also calculated, usingc ek = .125*sum((vx(t+dt/2)+vx(t-dt/2))**2+(vy(t+dt/2)+vy(t-dt/2))**2)c nx/ny = system length in x/y directionc idimp = size of phase space = 4c npmax = maximum number of particles in each partitionc nblok = number of particle partitions.c nxv = second virtual dimension of field array, must be >= nx+1c nxyp = second actual dimension of field array, must be >= nxv*nypmxc ipbc = particle boundary condition = (0,1,2,3) =c (none,2d periodic,2d reflecting,mixed reflecting/periodic)      double precision sum1      dimension part(idimp,npmax,nblok)      dimension fxy(2,nxyp,nblok)      dimension npp(nblok), noff(nblok)      qtm = qbm*dt      sum1 = 0.0d0c set boundary values      if (ipbc.eq.1) then         edgelx = 0.         edgerx = float(nx)      else if (ipbc.eq.2) then         edgelx = 1.         edgely = 1.         edgerx = float(nx-1)         edgery = float(ny-1)      else if (ipbc.eq.3) then         edgelx = 1.         edgerx = float(nx-1)      endif      do 20 l = 1, nblok      if (npp(l).lt.1) go to 20      mnoff = noff(l)c begin first particle      nnn = part(1,1,l)      mmn = part(2,1,l)      dxn = part(1,1,l) - float(nnn)      dyn = part(2,1,l) - float(mmn)      mmn = mmn - mnoff      nop1 = npp(l) - 1      do 10 j = 1, nop1c find interpolation weights      nn = nnn + 1      mm = nxv*mmn      nnn = part(1,j+1,l)      mmn = part(2,j+1,l)      dxp = dxn      dyp = dyn      dxn = part(1,j+1,l) - float(nnn)      dyn = part(2,j+1,l) - float(mmn)      mm = mm + nn      amx = 1. - dxp      mp = mm + nxv      amy = 1. - dyp      mmn = mmn - mnoffc find acceleration      dx = dyp*(dxp*fxy(1,mp+1,l) + amx*fxy(1,mp,l)) + amy*(dxp*fxy(1,mm     1+1,l) + amx*fxy(1,mm,l))      dy = dyp*(dxp*fxy(2,mp+1,l) + amx*fxy(2,mp,l)) + amy*(dxp*fxy(2,mm     1+1,l) + amx*fxy(2,mm,l))c new velocity      dx = part(3,j,l) + qtm*dx      dy = part(4,j,l) + qtm*dyc average kinetic energy      sum1 = sum1 + (dx + part(3,j,l))**2 + (dy + part(4,j,l))**2      part(3,j,l) = dx      part(4,j,l) = dyc new position      dx = part(1,j,l) + dx*dt      dy = part(2,j,l) + dy*dtc periodic boundary conditions      if (ipbc.eq.1) then         if (dx.lt.edgelx) dx = dx + edgerx         if (dx.ge.edgerx) dx = dx - edgerxc reflecting boundary conditions      else if (ipbc.eq.2) then         if ((dx.lt.edgelx).or.(dx.ge.edgerx)) then            dx = part(1,j,l)            part(3,j,l) = -part(3,j,l)         endif         if ((dy.lt.edgely).or.(dy.ge.edgery)) then            dy = part(2,j,l)            part(4,j,l) = -part(4,j,l)         endifc mixed reflecting/periodic boundary conditions      else if (ipbc.eq.3) then         if ((dx.lt.edgelx).or.(dx.ge.edgerx)) then            dx = part(1,j,l)            part(3,j,l) = -part(3,j,l)         endif      endifc set new position      part(1,j,l) = dx      part(2,j,l) = dy   10 continue      nop = npp(l)c push last particle      nn = nnn + 1      mm = nxv*mmn      mm = mm + nn      amx = 1. - dxn      mp = mm + nxv      amy = 1. - dync find acceleration      dx = dyn*(dxn*fxy(1,mp+1,l) + amx*fxy(1,mp,l)) + amy*(dxn*fxy(1,mm     1+1,l) + amx*fxy(1,mm,l))      dy = dyn*(dxn*fxy(2,mp+1,l) + amx*fxy(2,mp,l)) + amy*(dxn*fxy(2,mm     1+1,l) + amx*fxy(2,mm,l))c new velocity      dx = part(3,nop,l) + qtm*dx      dy = part(4,nop,l) + qtm*dyc average kinetic energy      sum1 = sum1 + (dx + part(3,nop,l))**2 + (dy + part(4,nop,l))**2      part(3,nop,l) = dx      part(4,nop,l) = dyc new position      dx = part(1,nop,l) + dx*dt      dy = part(2,nop,l) + dy*dtc periodic boundary conditions      if (ipbc.eq.1) then         if (dx.lt.edgelx) dx = dx + edgerx         if (dx.ge.edgerx) dx = dx - edgerxc reflecting boundary conditions      else if (ipbc.eq.2) then         if ((dx.lt.edgelx).or.(dx.ge.edgerx)) then            dx = part(1,nop,l)            part(3,nop,l) = -part(3,nop,l)         endif         if ((dy.lt.edgely).or.(dy.ge.edgery)) then            dy = part(2,nop,l)            part(4,nop,l) = -part(4,nop,l)         endifc mixed reflecting/periodic boundary conditions      else if (ipbc.eq.3) then         if ((dx.lt.edgelx).or.(dx.ge.edgerx)) then            dx = part(1,nop,l)            part(3,nop,l) = -part(3,nop,l)         endif      endifc set new position      part(1,nop,l) = dx      part(2,nop,l) = dy   20 continuec normalize kinetic energy      ek = ek + .125*sum1      return      endc-----------------------------------------------------------------------      subroutine PSORTP2YL(part,pt,ip,npic,npp,noff,nyp,idimp,npmax,nblo     1k,nypm1)c this subroutine sorts particles by y gridc linear interpolation, spatial decomposition in y directionc part = particle arrayc part(2,n,m) = position y of particle n in partition mc pt = scratch array for reordering particlesc ip = index array for reordering particlesc npic = address offset for reordering particlesc npp(m) = number of particles in partition mc noff(m) = backmost global gridpoint in particle partition mc nyp(m) = number of primary gridpoints in particle partition mc idimp = size of phase spacec npmax = maximum number of particles in each partitionc nblok = number of particle partitions.c nypm1 = maximum size of particle partition plus one      dimension part(idimp,npmax,nblok), pt(npmax,nblok)      dimension ip(npmax,nblok), npic(nypm1,nblok)      dimension npp(nblok), noff(nblok), nyp(nblok)      do 80 l = 1, nblok      mnoff = noff(l) - 1      nyp1 = nyp(l) + 1c clear counter array      do 10 k = 1, nyp1      npic(k,l) = 0   10 continuec find how many particles in each grid      do 20 j = 1, npp(l)      m = part(2,j,l)      m = m - mnoff      npic(m,l) = npic(m,l) + 1      ip(j,l) = m   20 continuec find address offset      isum = 0      do 30 k = 1, nyp1      ist = npic(k,l)      npic(k,l) = isum      isum = isum + ist   30 continuec find addresses of particles at each grid      do 40 j = 1, npp(l)      m = ip(j,l)      npic(m,l) = npic(m,l) + 1      ip(j,l) = npic(m,l)   40 continuec reorder particles by copying each component to temporary      do 70 i = 1, idimp      do 50 j = 1, npp(l)      pt(ip(j,l),l) = part(i,j,l)   50 continue      do 60 j = 1, npp(l)      part(i,j,l) = pt(j,l)   60 continue   70 continue   80 continue      return      endc-----------------------------------------------------------------------      subroutine PDSORTP2YL(parta,partb,npic,npp,noff,nyp,idimp,npmax,nb     1lok,nypm1)c this subroutine sorts particles by y gridc linear interpolation, spatial decomposition in y directionc parta/partb = input/outpu particle arrayc part(2,n,m) = position y of particle n in partition mc npic = address offset for reordering particlesc npp(m) = number of particles in partition mc noff(m) = backmost global gridpoint in particle partition mc nyp(m) = number of primary gridpoints in particle partition mc idimp = size of phase spacec npmax = maximum number of particles in each partitionc nblok = number of particle partitions.c nypm1 = maximum size of particle partition plus one      implicit none      integer idimp, npmax, nblok, nypm1      integer npic, npp, noff, nyp      real parta, partb      dimension parta(idimp,npmax,nblok), partb(idimp,npmax,nblok)      dimension npic(nypm1,nblok)      dimension npp(nblok), noff(nblok), nyp(nblok)c local data      integer i, j, k, l, m, mnoff, nyp1, isum, ist, ip      do 60 l = 1, nblok      mnoff = noff(l) - 1      nyp1 = nyp(l) + 1c clear counter array      do 10 k = 1, nyp1      npic(k,l) = 0   10 continuec find how many particles in each grid      do 20 j = 1, npp(l)      m = parta(2,j,l)      m = m - mnoff      npic(m,l) = npic(m,l) + 1   20 continuec find address offset      isum = 0      do 30 k = 1, nyp1      ist = npic(k,l)      npic(k,l) = isum      isum = isum + ist   30 continuec find addresses of particles at each grid and reorder particles      do 50 j = 1, npp(l)      m = parta(2,j,l)      m = m - mnoff      ip = npic(m,l) + 1      do 40 i = 1, idimp      partb(i,ip,l) = parta(i,j,l)   40 continue      npic(m,l) = ip   50 continue   60 continue      return      endc-----------------------------------------------------------------------      subroutine PCOUNT2YL(part,isign,npic,npp,noff,nyp,idimp,npmax,nblo     1k,nypm1)c this subroutine counts particles by y grid, accumulating into npicc npic array is initialized to zero, unless isign = 0c part = particle arrayc isign = (0,1) = (no,yes) initialize npic array to zeroc part(2,j,l) = position y of particle j in partition lc npic = number of particles per gridc npp(l) = number of particles in partition lc noff(l) = backmost global gridpoint in particle partition lc nyp(l) = number of primary gridpoints in particle partition lc idimp = size of phase spacec npmax = maximum number of particles in each partitionc nblok = number of particle partitions.c nypm1 = maximum size of particle partition plus one      implicit none      real part      integer npic, npp, noff, nyp      integer isign, idimp, npmax, nblok, nypm1      dimension part(idimp,npmax,nblok)      dimension npic(nypm1,nblok), npp(nblok), noff(nblok), nyp(nblok)      integer j, l, m, mnoff, nyp1      do 30 l = 1, nblok      mnoff = noff(l) - 1      nyp1 = nyp(l) + 1      if (isign.ne.0) then         do 10 j = 1, nyp1         npic(j,l) = 0   10    continue      endifc find how many particles in each grid      do 20 j = 1, npp(l)      m = part(2,j,l)      m = m - mnoff      npic(m,l) = npic(m,l) + 1   20 continue   30 continue      return      endc-----------------------------------------------------------------------c 2d parallel PIC library for pushing relativistic particles withc magnetic field and depositing currentc written by viktor k. decyk, uclac copyright 1999, regents of the university of californiac update: may 26, 2003c-----------------------------------------------------------------------      subroutine PGRPUSH2L(part,fxy,npp,noff,qbm,dt,ci,ek,nx,ny,idimp,np     1max,nblok,nxv,nypmx,ipbc)c for 2d code, this subroutine updates particle co-ordinates andc velocities using leap-frog scheme in time and first-order linearc interpolation in space, for relativistic particlesc with various boundary conditions.c scalar version using guard cells, for distributed datac 50 flops/particle, 2 divides, 2 sqrts, 12 loads, 4 storesc input: all, output: part, ekc equations used are:c px(t+dt/2) = px(t-dt/2) + (q/m)*fx(x(t),y(t))*dt,c py(t+dt/2) = py(t-dt/2) + (q/m)*fy(x(t),y(t))*dt,c where q/m is charge/mass, andc x(t+dt) = x(t) + px(t+dt/2)*dtgc y(t+dt) = y(t) + py(t+dt/2)*dtg, wherec dtg = dtc/sqrt(1.+(px(t+dt/2)*px(t+dt/2)+py(t+dt/2)*py(t+dt/2))*ci*ci)c fx(x(t),y(t)) and fy(x(t),y(t)) are approximated by interpolation fromc the nearest grid points:c fx(x,y) = (1-dy)*((1-dx)*fx(n,m)+dx*fx(n+1,m)) + dy*((1-dx)*fx(n,m+1)c    + dx*fx(n+1,m+1))c fy(x,y) = (1-dy)*((1-dx)*fy(n,m)+dx*fy(n+1,m)) + dy*((1-dx)*fy(n,m+1)c    + dx*fy(n+1,m+1))c where n,m = leftmost grid points and dx = x-n, dy = y-mc part(1,n,l) = position x of particle n in partition lc part(2,n,l) = position y of particle n in partition lc part(3,n,l) = momentum px of particle n in partition lc part(4,n,l) = momentum py of particle n in partition lc fxy(1,j,k,l) = x component of force/charge at grid (j,kk)c fxy(2,j,k,l) = y component of force/charge at grid (j,kk)c in other words, fxy are the convolutions of the electric fieldc over the particle shape, where kk = k + noff(l) - 1c npp(l) = number of particles in partition lc noff(l) = lowermost global gridpoint in particle partition l.c qbm = particle charge/massc dt = time interval between successive calculationsc ci = reciprical of velocity of lightc kinetic energy/mass at time t is also calculated, usingc ek = sum((px(t-dt/2) + .5*(q/m)*fx(x(t),y(t))*dt)**2 +c      (py(t-dt/2) + .5*(q/m)*fy(x(t),y(t))*dt)**2)/(1. + gamma)c where gamma = sqrt(1.+(px(t)*px(t)+py(t)*py(t))*ci*ci)c nx/ny = system length in x/y directionc idimp = size of phase space = 4c npmax = maximum number of particles in each partitionc nblok = number of particle partitions.c nxv = first dimension of field array, must be >= nx+1c nypmx = maximum size of particle partition, including guard cells.c ipbc = particle boundary condition = (0,1,2,3) =c (none,2d periodic,2d reflecting,mixed reflecting/periodic)      double precision sum1      dimension part(idimp,npmax,nblok)      dimension fxy(2,nxv,nypmx,nblok)      dimension npp(nblok), noff(nblok)      qtmh = .5*qbm*dt      ci2 = ci*ci      sum1 = 0.0d0c set boundary values      if (ipbc.eq.1) then         edgelx = 0.         edgerx = float(nx)      else if (ipbc.eq.2) then         edgelx = 1.         edgely = 1.         edgerx = float(nx-1)         edgery = float(ny-1)      else if (ipbc.eq.3) then         edgelx = 1.         edgerx = float(nx-1)      endif      do 20 l = 1, nblok      mnoff = noff(l) - 1      do 10 j = 1, npp(l)c find interpolation weights      nn = part(1,j,l)      mm = part(2,j,l)      dxp = part(1,j,l) - float(nn)      dyp = part(2,j,l) - float(mm)      nn = nn + 1      mm = mm - mnoff      amx = 1. - dxp      mp = mm + 1      amy = 1. - dyp      np = nn + 1c find acceleration      dx = dyp*(dxp*fxy(1,np,mp,l) + amx*fxy(1,nn,mp,l)) + amy*(dxp*fxy(     11,np,mm,l) + amx*fxy(1,nn,mm,l))      dy = dyp*(dxp*fxy(2,np,mp,l) + amx*fxy(2,nn,mp,l)) + amy*(dxp*fxy(     12,np,mm,l) + amx*fxy(2,nn,mm,l))c calculate half impulse      dx = qtmh*dx      dy = qtmh*dyc half acceleration      acx = part(3,j,l) + dx      acy = part(4,j,l) + dyc time-centered kinetic energy      p2 = acx*acx + acy*acy      sum1 = sum1 + p2/(1.0 + sqrt(1.0 + p2*ci2))c new velocity      dx = acx + dx      dy = acy + dy      part(3,j,l) = dx      part(4,j,l) = dyc update inverse gamma      p2 = dx*dx + dy*dy      dtg = dt/sqrt(1.0 + p2*ci2)c new position      dx = part(1,j,l) + dx*dtg      dy = part(2,j,l) + dy*dtgc periodic boundary conditions      if (ipbc.eq.1) then         if (dx.lt.edgelx) dx = dx + edgerx         if (dx.ge.edgerx) dx = dx - edgerxc reflecting boundary conditions      else if (ipbc.eq.2) then         if ((dx.lt.edgelx).or.(dx.ge.edgerx)) then            dx = part(1,j,l)            part(3,j,l) = -part(3,j,l)         endif         if ((dy.lt.edgely).or.(dy.ge.edgery)) then            dy = part(2,j,l)            part(4,j,l) = -part(4,j,l)         endifc mixed reflecting/periodic boundary conditions      else if (ipbc.eq.3) then         if ((dx.lt.edgelx).or.(dx.ge.edgerx)) then            dx = part(1,j,l)            part(3,j,l) = -part(3,j,l)         endif      endifc set new position      part(1,j,l) = dx      part(2,j,l) = dy   10 continue   20 continuec normalize kinetic energy      ek = ek + sum1      return      endc-----------------------------------------------------------------------      subroutine PGSRPUSH2L(part,fxy,npp,noff,qbm,dt,ci,ek,nx,ny,idimp,n     1pmax,nblok,nxv,nxyp,ipbc)c for 2d code, this subroutine updates particle co-ordinates andc velocities using leap-frog scheme in time and first-order linearc interpolation in space, for relativistic particlesc with various boundary conditions.c scalar version using guard cells, integer conversion precalculation,c and 1d addressing, for distributed datac cases 9-10 in v.k.decyk et al, computers in physics 10, 290 (1996)c 50 flops/particle, 2 divides, 2 sqrts, 12 loads, 4 storesc input: all, output: part, ekc equations used are:c px(t+dt/2) = px(t-dt/2) + (q/m)*fx(x(t),y(t))*dt,c py(t+dt/2) = py(t-dt/2) + (q/m)*fy(x(t),y(t))*dt,c where q/m is charge/mass, andc x(t+dt) = x(t) + px(t+dt/2)*dtgc y(t+dt) = y(t) + py(t+dt/2)*dtg, wherec dtg = dtc/sqrt(1.+(px(t+dt/2)*px(t+dt/2)+py(t+dt/2)*py(t+dt/2))*ci*ci)c fx(x(t),y(t)) and fy(x(t),y(t)) are approximated by interpolation fromc the nearest grid points:c fx(x,y) = (1-dy)*((1-dx)*fx(n,m)+dx*fx(n+1,m)) + dy*((1-dx)*fx(n,m+1)c    + dx*fx(n+1,m+1))c fy(x,y) = (1-dy)*((1-dx)*fy(n,m)+dx*fy(n+1,m)) + dy*((1-dx)*fy(n,m+1)c    + dx*fy(n+1,m+1))c where n,m = leftmost grid points and dx = x-n, dy = y-mc part(1,n,l) = position x of particle n in partition lc part(2,n,l) = position y of particle n in partition lc part(3,n,l) = momentum px of particle n in partition lc part(4,n,l) = momentum py of particle n in partition lc fxy(1,j,k,l) = x component of force/charge at grid (j,kk)c fxy(2,j,k,l) = y component of force/charge at grid (j,kk)c in other words, fxy are the convolutions of the electric fieldc over the particle shape, where kk = k + noff(l) - 1c npp(l) = number of particles in partition lc noff(l) = lowermost global gridpoint in particle partition l.c qbm = particle charge/massc dt = time interval between successive calculationsc ci = reciprical of velocity of lightc kinetic energy/mass at time t is also calculated, usingc ek = sum((px(t-dt/2) + .5*(q/m)*fx(x(t),y(t))*dt)**2 +c      (py(t-dt/2) + .5*(q/m)*fy(x(t),y(t))*dt)**2)/(1. + gamma)c where gamma = sqrt(1.+(px(t)*px(t)+py(t)*py(t))*ci*ci)c nx/ny = system length in x/y directionc idimp = size of phase space = 4c npmax = maximum number of particles in each partitionc nblok = number of particle partitions.c nxv = second virtual dimension of field array, must be >= nx+1c nxyp = second actual dimension of field array, must be >= nxv*nypmxc ipbc = particle boundary condition = (0,1,2,3) =c (none,2d periodic,2d reflecting,mixed reflecting/periodic)      double precision sum1      dimension part(idimp,npmax,nblok)      dimension fxy(2,nxyp,nblok)      dimension npp(nblok), noff(nblok)      qtmh = .5*qbm*dt      ci2 = ci*ci      sum1 = 0.0d0c set boundary values      if (ipbc.eq.1) then         edgelx = 0.         edgerx = float(nx)      else if (ipbc.eq.2) then         edgelx = 1.         edgely = 1.         edgerx = float(nx-1)         edgery = float(ny-1)      else if (ipbc.eq.3) then         edgelx = 1.         edgerx = float(nx-1)      endif      do 20 l = 1, nblok      if (npp(l).lt.1) go to 20      mnoff = noff(l)c begin first particle      nnn = part(1,1,l)      mmn = part(2,1,l)      dxn = part(1,1,l) - float(nnn)      dyn = part(2,1,l) - float(mmn)      mmn = mmn - mnoff      nop1 = npp(l) - 1      do 10 j = 1, nop1c find interpolation weights      nn = nnn + 1      mm = nxv*mmn      nnn = part(1,j+1,l)      mmn = part(2,j+1,l)      dxp = dxn      dyp = dyn      dxn = part(1,j+1,l) - float(nnn)      dyn = part(2,j+1,l) - float(mmn)      mm = mm + nn      amx = 1. - dxp      mp = mm + nxv      amy = 1. - dyp      mmn = mmn - mnoffc find acceleration      dx = dyp*(dxp*fxy(1,mp+1,l) + amx*fxy(1,mp,l)) + amy*(dxp*fxy(1,mm     1+1,l) + amx*fxy(1,mm,l))      dy = dyp*(dxp*fxy(2,mp+1,l) + amx*fxy(2,mp,l)) + amy*(dxp*fxy(2,mm     1+1,l) + amx*fxy(2,mm,l))c calculate half impulse      dx = qtmh*dx      dy = qtmh*dyc half acceleration      acx = part(3,j,l) + dx      acy = part(4,j,l) + dyc time-centered kinetic energy      p2 = acx*acx + acy*acy      sum1 = sum1 + p2/(1.0 + sqrt(1.0 + p2*ci2))c new velocity      dx = acx + dx      dy = acy + dy      part(3,j,l) = dx      part(4,j,l) = dyc update inverse gamma      p2 = dx*dx + dy*dy      dtg = dt/sqrt(1.0 + p2*ci2)c new position      dx = part(1,j,l) + dx*dtg      dy = part(2,j,l) + dy*dtgc periodic boundary conditions      if (ipbc.eq.1) then         if (dx.lt.edgelx) dx = dx + edgerx         if (dx.ge.edgerx) dx = dx - edgerxc reflecting boundary conditions      else if (ipbc.eq.2) then         if ((dx.lt.edgelx).or.(dx.ge.edgerx)) then            dx = part(1,j,l)            part(3,j,l) = -part(3,j,l)         endif         if ((dy.lt.edgely).or.(dy.ge.edgery)) then            dy = part(2,j,l)            part(4,j,l) = -part(4,j,l)         endifc mixed reflecting/periodic boundary conditions      else if (ipbc.eq.3) then         if ((dx.lt.edgelx).or.(dx.ge.edgerx)) then            dx = part(1,j,l)            part(3,j,l) = -part(3,j,l)         endif      endifc set new position      part(1,j,l) = dx      part(2,j,l) = dy   10 continue      nop = npp(l)c push last particle      nn = nnn + 1      mm = nxv*mmn      mm = mm + nn      amx = 1. - dxn      mp = mm + nxv      amy = 1. - dync find acceleration      dx = dyn*(dxn*fxy(1,mp+1,l) + amx*fxy(1,mp,l)) + amy*(dxn*fxy(1,mm     1+1,l) + amx*fxy(1,mm,l))      dy = dyn*(dxn*fxy(2,mp+1,l) + amx*fxy(2,mp,l)) + amy*(dxn*fxy(2,mm     1+1,l) + amx*fxy(2,mm,l))c calculate half impulse      dx = qtmh*dx      dy = qtmh*dyc half acceleration      acx = part(3,nop,l) + dx      acy = part(4,nop,l) + dyc time-centered kinetic energy      p2 = acx*acx + acy*acy      sum1 = sum1 + p2/(1.0 + sqrt(1.0 + p2*ci2))c new velocity      dx = acx + dx      dy = acy + dy      part(3,nop,l) = dx      part(4,nop,l) = dyc update inverse gamma      p2 = dx*dx + dy*dy      dtg = dt/sqrt(1.0 + p2*ci2)c new position      dx = part(1,nop,l) + dx*dtg      dy = part(2,nop,l) + dy*dtgc periodic boundary conditions      if (ipbc.eq.1) then         if (dx.lt.edgelx) dx = dx + edgerx         if (dx.ge.edgerx) dx = dx - edgerxc reflecting boundary conditions      else if (ipbc.eq.2) then         if ((dx.lt.edgelx).or.(dx.ge.edgerx)) then            dx = part(1,nop,l)            part(3,nop,l) = -part(3,nop,l)         endif         if ((dy.lt.edgely).or.(dy.ge.edgery)) then            dy = part(2,nop,l)            part(4,nop,l) = -part(4,nop,l)         endifc mixed reflecting/periodic boundary conditions      else if (ipbc.eq.3) then         if ((dx.lt.edgelx).or.(dx.ge.edgerx)) then            dx = part(1,nop,l)            part(3,nop,l) = -part(3,nop,l)         endif      endifc set new position      part(1,nop,l) = dx      part(2,nop,l) = dy   20 continuec normalize kinetic energy      ek = ek + sum1      return      endc-----------------------------------------------------------------------c 2d parallel PIC library for fast fourier transformsc written by viktor k. decyk, uclac copyright 1995, regents of the university of californiac update: february 3, 2006c-----------------------------------------------------------------------      subroutine WPFFT2RINIT(mixup,sct,indx,indy,nxhyd,nxyhd)c this subroutine calculates tables needed by a two dimensionalc real to complex fast fourier transform and its inverse.c input: indx, indy, nxhyd, nxyhdc output: mixup, sctc mixup = array of bit reversed addressesc sct = sine/cosine tablec indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc nxhyd = maximum of (nx/2,ny)c nxyhd = one half of maximum of (nx,ny)c written by viktor k. decyk, ucla      implicit none      integer indx, indy, nxhyd, nxyhd      integer mixup      complex sct      dimension mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, ny, nxy, nxhy, nxyh      integer j, k, lb, ll, jb, it      real dnxy, arg      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      ny = 2**indy      nxy = max0(nx,ny)      nxhy = 2**indx1yc bit-reverse index table: mixup(j) = 1 + reversed bits of (j - 1)      do 20 j = 1, nxhy      lb = j - 1      ll = 0      do 10 k = 1, indx1y      jb = lb/2      it = lb - 2*jb      lb = jb      ll = 2*ll + it   10 continue      mixup(j) = ll + 1   20 continuec sine/cosine table for the angles 2*n*pi/nxy      nxyh = nxy/2      dnxy = 6.28318530717959/float(nxy)      do 30 j = 1, nxyh      arg = dnxy*float(j - 1)      sct(j) = cmplx(cos(arg),-sin(arg))   30 continue      return      endc-----------------------------------------------------------------------      subroutine WPFFT2R(f,g,bs,br,isign,ntpose,mixup,sct,ttp,indx,indy,     1kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)c wrapper function for parallel real to complex fft      implicit none      integer isign, ntpose, indx, indy, kstrt, nxvh, nyv, kxp, kyp      integer kypd, jblok, kblok, nxhyd, nxyhd, mixup      real ttp      complex f, g, bs, br, sct      dimension f(nxvh,kypd,kblok), g(nyv,kxp,jblok)      dimension bs(kxp,kyp,kblok), br(kxp,kyp,jblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer nxh, ny, kxpi, kypi      real tf      double precision dtime      data kxpi, kypi /1,1/c calculate range of indices      nxh = 2**(indx - 1)      ny = 2**indyc inverse fourier transform      if (isign.lt.0) thenc perform x fft         call PFFT2RXX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kyp,nxvh,k     1ypd,kblok,nxhyd,nxyhd)c transpose f array to g         call PWTIMERA(-1,ttp,dtime)         call PTPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kypd,jb     1lok,kblok)         call PWTIMERA(1,ttp,dtime)c perform y fft         call PFFT2RXY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxp,nyv,kx     1p,jblok,nxhyd,nxyhd)c transpose g array to f         if (ntpose.eq.0) then            call PWTIMERA(-1,tf,dtime)            call PTPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kxp     1,kblok,jblok)            call PWTIMERA(1,tf,dtime)         endifc forward fourier transform      else if (isign.gt.0) thenc transpose f array to g         if (ntpose.eq.0) then            call PWTIMERA(-1,tf,dtime)            call PTPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kypd     1,jblok,kblok)            call PWTIMERA(1,tf,dtime)         endifc perform y fft         call PFFT2RXY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxp,nyv,kx     1p,jblok,nxhyd,nxyhd)c transpose g array to f         call PWTIMERA(-1,ttp,dtime)         call PTPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kxp,kb     1lok,jblok)         call PWTIMERA(1,ttp,dtime)c perform x fft         call PFFT2RXX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kyp,nxvh,k     1ypd,kblok,nxhyd,nxyhd)      endif      if (ntpose.eq.0) ttp = ttp + tf      return      endc-----------------------------------------------------------------------      subroutine WPFFT2R2(f,g,bs,br,isign,ntpose,mixup,sct,ttp,indx,indy     1,kstrt,nxvh,nyv,kxp,kyp,kypd,jblok,kblok,nxhyd,nxyhd)c wrapper function for parallel real to complex fft      implicit none      integer isign, ntpose, indx, indy, kstrt, nxvh, nyv, kxp, kyp      integer kypd, jblok, kblok, nxhyd, nxyhd, mixup      real ttp      complex f, g, bs, br, sct      dimension f(2,nxvh,kypd,kblok), g(2,nyv,kxp,jblok)      dimension bs(2,kxp,kyp,kblok), br(2,kxp,kyp,jblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer nxh, ny, kxpi, kypi      real tf      double precision dtime      data kxpi, kypi /1,1/c calculate range of indices      nxh = 2**(indx - 1)      ny = 2**indyc inverse fourier transform      if (isign.lt.0) thenc perform x fft         call PFFT2R2XX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kyp,nxvh,     1kypd,kblok,nxhyd,nxyhd)c transpose f array to g         call PWTIMERA(-1,ttp,dtime)         call P2TPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kypd,j     1blok,kblok)         call PWTIMERA(1,ttp,dtime)c perform y fft         call PFFT2R2XY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxp,nyv,k     1xp,jblok,nxhyd,nxyhd)c transpose g array to f         if (ntpose.eq.0) then            call PWTIMERA(-1,tf,dtime)            call P2TPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kx     1p,kblok,jblok)            call PWTIMERA(1,tf,dtime)         endifc forward fourier transform      else if (isign.gt.0) thenc transpose f array to g         if (ntpose.eq.0) then            call PWTIMERA(-1,tf,dtime)            call P2TPOSE(f,g,bs,br,nxh,ny,kstrt,nxvh,nyv,kxp,kyp,kxp,kyp     1d,jblok,kblok)            call PWTIMERA(1,tf,dtime)         endifc perform y fft         call PFFT2R2XY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxp,nyv,k     1xp,jblok,nxhyd,nxyhd)c transpose g array to f         call PWTIMERA(-1,ttp,dtime)         call P2TPOSE(g,f,br,bs,ny,nxh,kstrt,nyv,nxvh,kyp,kxp,kypd,kxp,k     1blok,jblok)         call PWTIMERA(1,ttp,dtime)c perform x fft         call PFFT2R2XX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kyp,nxvh,     1kypd,kblok,nxhyd,nxyhd)      endif      if (ntpose.eq.0) ttp = ttp + tf      return      endc-----------------------------------------------------------------------      subroutine PFFT2RXX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kypp,nx     1vh,kypd,kblok,nxhyd,nxyhd)c this subroutine performs the x part of a two dimensional real toc complex fast fourier transform and its inverse, for a subset of y,c using complex arithmetic, for data which is distributed in blocksc for isign = (-1,1), input: all, output: fc for isign = -1, approximate flop count: N*(5*log2(N) + 10)/nvpc for isign = 1,  approximate flop count: N*(5*log2(N) + 8)/nvpc where N = (nx/2)*ny, and nvp = number of procsc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, an inverse fourier transform is performedc f(n,m,i) = (1/nx*ny)*sum(f(j,k,i)*exp(-sqrt(-1)*2pi*n*j/nx)c if isign = 1, a forward fourier transform is performedc f(j,k,i) = sum(f(n,m,i)*exp(sqrt(-1)*2pi*n*j/nx)*c kstrt = starting data block numberc kypi = initial y index usedc kypp = number of y indices usedc nxvh = first dimension of fc kypd = second dimension of fc kblok = number of data blocks in yc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxhyd = maximum of (nx/2,ny)c nxyhd = one half of maximum of (nx,ny)c the real data is stored in a complex array of length nx/2, nyc with the odd/even x points stored in the real/imaginary parts.c in complex notation, fourier coefficients are stored as follows:c f(j,k,i) = mode j-1,kk-1, where kk = k + kyp*(i - 1)c 1 <= j <= nx/2 and 1 <= kk <= ny, except forc f(1,k,i) = mode nx/2,kk-1, where ny/2+2 <= kk <= ny, andc imaginary part of f(1,1,1) = real part of mode nx/2,0 andc imaginary part of f(1,1,(ny/2)/kyp+1) = real part of mode nx/2,ny/2c written by viktor k. decyk, uclac parallel, RISC optimized version      implicit none      integer isign, mixup, indx, indy, kstrt, nxvh, kypi, kypp      integer kypd, kblok, nxhyd, nxyhd      complex f, sct      dimension f(nxvh,kypd,kblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, nxh, nxhh, nxh2, ny      integer nxy, nxhy, ks, kypt, j, k, nrx      integer l, i, m, ns, ns2, km, kmr, k1, k2, j1, j2      real ani      complex s, t, t1      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nxh2 = nxh + 2      ny = 2**indy      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      kypt = kypi + kypp - 1      if (kstrt.gt.ny) return      if (isign.gt.0) go to 130c inverse fourier transform      ani = 1./float(2*nx*ny)      nrx = nxhy/nxh      do 30 l = 1, kblokc bit-reverse array elements in x      do 20 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 20      do 10 k = kypi, kypt      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = t   10 continue   20 continue   30 continuec first transform in x      nrx = nxy/nxh      do 80 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 70 l = 1, kblok      do 60 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 50 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 40 i = kypi, kypt      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t   40 continue   50 continue   60 continue   70 continue   80 continuec unscramble coefficients and normalize      kmr = nxy/nx      do 120 l = 1, kblok      do 100 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),-real(sct(1+kmr*(j-1))))      do 90 k = kypi, kypt      t = conjg(f(nxh2-j,k,l))      s = f(j,k,l) + t      t = (f(j,k,l) - t)*t1      f(j,k,l) = ani*(s + t)      f(nxh2-j,k,l) = ani*conjg(s - t)   90 continue  100 continue      do 110 k = kypi, kypt      f(nxhh+1,k,l) = 2.*ani*conjg(f(nxhh+1,k,l))      f(1,k,l) = 2.*ani*cmplx(real(f(1,k,l)) + aimag(f(1,k,l)),real(f(1,     1k,l)) - aimag(f(1,k,l)))  110 continue  120 continue      returnc forward fourier transform  130 kmr = nxy/nx      do 190 l = 1, kblokc scramble coefficients      do 150 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),real(sct(1+kmr*(j-1))))      do 140 k = kypi, kypt      t = conjg(f(nxh2-j,k,l))      s = f(j,k,l) + t      t = (f(j,k,l) - t)*t1      f(j,k,l) = s + t      f(nxh2-j,k,l) = conjg(s - t)  140 continue  150 continue      do 160 k = kypi, kypt      f(nxhh+1,k,l) = 2.*conjg(f(nxhh+1,k,l))      f(1,k,l) = cmplx(real(f(1,k,l)) + aimag(f(1,k,l)),real(f(1,k,l)) -     1 aimag(f(1,k,l)))  160 continue      nrx = nxhy/nxhc bit-reverse array elements in x      do 180 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 180      do 170 k = kypi, kypt      t = f(j1,k,l)      f(j1,k,l) = f(j,k,l)      f(j,k,l) = t  170 continue  180 continue  190 continuec then transform in x      nrx = nxy/nxh      do 240 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 230 l = 1, kblok      do 220 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 210 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 200 i = kypi, kypt      t = s*f(j2,i,l)      f(j2,i,l) = f(j1,i,l) - t      f(j1,i,l) = f(j1,i,l) + t  200 continue  210 continue  220 continue  230 continue  240 continue      return      endc-----------------------------------------------------------------------      subroutine PFFT2RXY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxpp,ny     1v,kxp,jblok,nxhyd,nxyhd)c this subroutine performs the y part of a two dimensional real toc complex fast fourier transform and its inverse, for a subset of x,c using complex arithmetic, for data which is distributed in blocksc for isign = (-1,1), input: all, output: f, gc for isign = -1, approximate flop count: N*(5*log2(N) + 10)/nvpc for isign = 1,  approximate flop count: N*(5*log2(N) + 8)/nvpc where N = (nx/2)*ny, and nvp = number of procsc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, an inverse fourier transform is performedc g(m,n,i) = sum(g(k,j,i)*exp(-sqrt(-1)*2pi*m*k/ny))c if isign = 1, a forward fourier transform is performedc g(k,j,i) = sum(g(m,n,i)*exp(sqrt(-1)*2pi*m*k/ny))c kstrt = starting data block numberc kxpi = initial x index usedc kxpp = number of   indices usedc nyv = first dimension of gc kxp = number of data values per block in xc jblok = number of data blocks in xc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxhyd = maximum of (nx/2,ny)c nxyhd = one half of maximum of (nx,ny)c the real data is stored in a complex array of length nx/2, nyc with the odd/even x points stored in the real/imaginary parts.c in complex notation, fourier coefficients are stored as follows:c g(k,j,i) = mode jj-1,k-1, where jj = j + kxp*(i - 1)c 1 <= jj <= nx/2 and 1 <= k <= ny, except forc g(k,1,1) = mode nx/2,k-1, where ny/2+2 <= k <= ny, andc imaginary part of g(1,1,1) = real part of mode nx/2,0 andc imaginary part of g(ny/2+1,1,1) = real part of mode nx/2,ny/2c written by viktor k. decyk, uclac parallel, RISC optimized version      implicit none      integer isign, mixup, indx, indy, kstrt, kxpi, kxpp, nyv      integer kxp, jblok, nxhyd, nxyhd      complex g, sct      dimension g(nyv,kxp,jblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, nxh, ny, nyh, ny2      integer nxy, nxhy, ks, kxpt, j, k, nry      integer l, i, m, ns, ns2, km, kmr, k1, k2, j1, j2      complex s, t      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      ny = 2**indy      nyh = ny/2      ny2 = ny + 2      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      kxpt = kxpi + kxpp - 1      if (kstrt.gt.nxh) return      if (isign.gt.0) go to 110c inverse fourier transform      nry = nxhy/ny      do 30 l = 1, jblokc bit-reverse array elements in y      do 20 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 20      do 10 j = kxpi, kxpt      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = t   10 continue   20 continue   30 continuec then transform in y      nry = nxy/ny      do 80 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 70 l = 1, jblok      do 60 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 50 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 40 i = kxpi, kxpt      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t   40 continue   50 continue   60 continue   70 continue   80 continuec unscramble modes kx = 0, nx/2      do 100 l = 1, jblok      if ((l+ks).gt.0) go to 100      do 90 k = 2, nyh      if (kxpi.eq.1) then         s = g(ny2-k,1,l)         g(ny2-k,1,l) = .5*cmplx(aimag(g(k,1,l) + s),real(g(k,1,l) - s))         g(k,1,l) = .5*cmplx(real(g(k,1,l) + s),aimag(g(k,1,l) - s))      endif   90 continue  100 continue      returnc forward fourier transformc scramble modes kx = 0, nx/2  110 nry = nxhy/ny      do 160 l = 1, jblok      if ((l+ks).gt.0) go to 130      do 120 k = 2, nyh      if (kxpi.eq.1) then         s = cmplx(aimag(g(ny2-k,1,l)),real(g(ny2-k,1,l)))         g(ny2-k,1,l) = conjg(g(k,1,l) - s)         g(k,1,l) = g(k,1,l) + s      endif  120 continuec bit-reverse array elements in y  130 do 150 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 150      do 140 j = kxpi, kxpt      t = g(k1,j,l)      g(k1,j,l) = g(k,j,l)      g(k,j,l) = t  140 continue  150 continue  160 continuec first transform in y      nry = nxy/ny      do 210 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 200 l = 1, jblok      do 190 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 180 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 170 i = kxpi, kxpt      t = s*g(j2,i,l)      g(j2,i,l) = g(j1,i,l) - t      g(j1,i,l) = g(j1,i,l) + t  170 continue  180 continue  190 continue  200 continue  210 continue      return      endc-----------------------------------------------------------------------      subroutine PFFT2R2XX(f,isign,mixup,sct,indx,indy,kstrt,kypi,kypp,n     1xvh,kypd,kblok,nxhyd,nxyhd)c this subroutine performs the x part of 2 two dimensional real toc complex fast fourier transforms and their inverses, for a subset of y,c using complex arithmetic, for data which is distributed in blocksc for isign = (-1,1), input: all, output: fc for isign = -1, approximate flop count: N*(5*log2(N) + 10)/nvpc for isign = 1,  approximate flop count: N*(5*log2(N) + 8)/nvpc where N = (nx/2)*ny, and nvp = number of procsc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, an inverse fourier transform is performedc f(n,m,i) = (1/nx*ny)*sum(f(j,k,i)*exp(-sqrt(-1)*2pi*n*j/nx)c if isign = 1, a forward fourier transform is performedc f(j,k,i) = sum(f(n,m,i)*exp(sqrt(-1)*2pi*n*j/nx)*c kstrt = starting data block numberc kypi = initial y index usedc kypp = number of y indices usedc nxvh = first dimension of fc kypd = second dimension of fc kblok = number of data blocks in yc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxhyd = maximum of (nx/2,ny)c nxyhd = one half of maximum of (nx,ny)c the real data is stored in a complex array of length nx/2, nyc with the odd/even x points stored in the real/imaginary parts.c in complex notation, fourier coefficients are stored as follows:c f(j,k,i) = mode j-1,kk-1, where kk = k + kyp*(i - 1)c 1 <= j <= nx/2 and 1 <= kk <= ny, except forc f(1,k,i) = mode nx/2,kk-1, where ny/2+2 <= kk <= ny, andc imaginary part of f(1,1,1) = real part of mode nx/2,0 andc imaginary part of f(1,1,(ny/2)/kyp+1) = real part of mode nx/2,ny/2c written by viktor k. decyk, uclac parallel, RISC optimized version      implicit none      integer isign, mixup, indx, indy, kstrt, nxvh, kypi, kypp      integer kypd, kblok, nxhyd, nxyhd      complex f, sct      dimension f(2,nxvh,kypd,kblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, nxh, nxhh, nxh2, ny      integer nxy, nxhy, ks, kypt, j, k, nrx      integer l, i, m, ns, ns2, km, kmr, k1, k2, j1, j2, jj      real ani, at1      complex s, t, t1, t2      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      nxhh = nx/4      nxh2 = nxh + 2      ny = 2**indy      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      kypt = kypi + kypp - 1      if (kstrt.gt.ny) return      if (isign.gt.0) go to 180c inverse fourier transform      ani = 1./float(2*nx*ny)c swap complex components      do 30 l = 1, kblok      do 20 k = kypi, kypt      do 10 j = 1, nxh      at1 = aimag(f(1,j,k,l))      f(1,j,k,l) = cmplx(real(f(1,j,k,l)),real(f(2,j,k,l)))      f(2,j,k,l) = cmplx(at1,aimag(f(2,j,k,l)))   10 continue   20 continue   30 continue      nrx = nxhy/nxh      do 60 l = 1, kblokc bit-reverse array elements in x      do 50 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 50      do 40 k = kypi, kypt      t1 = f(1,j1,k,l)      t2 = f(2,j1,k,l)      f(1,j1,k,l) = f(1,j,k,l)      f(2,j1,k,l) = f(2,j,k,l)      f(1,j,k,l) = t1      f(2,j,k,l) = t2   40 continue   50 continue   60 continuec first transform in x      nrx = nxy/nxh      do 110 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 100 l = 1, kblok      do 90 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 80 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 70 i = kypi, kypt      t1 = s*f(1,j2,i,l)      t2 = s*f(2,j2,i,l)      f(1,j2,i,l) = f(1,j1,i,l) - t1      f(2,j2,i,l) = f(2,j1,i,l) - t2      f(1,j1,i,l) = f(1,j1,i,l) + t1      f(2,j1,i,l) = f(2,j1,i,l) + t2   70 continue   80 continue   90 continue  100 continue  110 continuec unscramble coefficients and normalize      kmr = nxy/nx      do 170 l = 1, kblok      do 140 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),-real(sct(1+kmr*(j-1))))      do 130 k = kypi, kypt      do 120 jj = 1, 2      t = conjg(f(jj,nxh2-j,k,l))      s = f(jj,j,k,l) + t      t = (f(jj,j,k,l) - t)*t1      f(jj,j,k,l) = ani*(s + t)      f(jj,nxh2-j,k,l) = ani*conjg(s - t)  120 continue  130 continue  140 continue      do 160 k = kypi, kypt      do 150 jj = 1, 2      f(jj,nxhh+1,k,l) = 2.*ani*conjg(f(jj,nxhh+1,k,l))      f(jj,1,k,l) = 2.*ani*cmplx(real(f(jj,1,k,l)) + aimag(f(jj,1,k,l)),     1real(f(jj,1,k,l)) - aimag(f(jj,1,k,l)))  150 continue  160 continue  170 continue      returnc forward fourier transform  180 kmr = nxy/nx      do 260 l = 1, kblokc scramble coefficients      do 210 j = 2, nxhh      t1 = cmplx(aimag(sct(1+kmr*(j-1))),real(sct(1+kmr*(j-1))))      do 200 k = kypi, kypt      do 190 jj = 1, 2      t = conjg(f(jj,nxh2-j,k,l))      s = f(jj,j,k,l) + t      t = (f(jj,j,k,l) - t)*t1      f(jj,j,k,l) = s + t      f(jj,nxh2-j,k,l) = conjg(s - t)  190 continue  200 continue  210 continue      do 230 k = kypi, kypt      do 220 jj = 1, 2      f(jj,nxhh+1,k,l) = 2.*conjg(f(jj,nxhh+1,k,l))      f(jj,1,k,l) = cmplx(real(f(jj,1,k,l)) + aimag(f(jj,1,k,l)),real(f(     1jj,1,k,l)) - aimag(f(jj,1,k,l)))  220 continue  230 continue      nrx = nxhy/nxhc bit-reverse array elements in x      do 250 j = 1, nxh      j1 = (mixup(j) - 1)/nrx + 1      if (j.ge.j1) go to 250      do 240 k = kypi, kypt      t1 = f(1,j1,k,l)      t2 = f(2,j1,k,l)      f(1,j1,k,l) = f(1,j,k,l)      f(2,j1,k,l) = f(2,j,k,l)      f(1,j,k,l) = t1      f(2,j,k,l) = t2  240 continue  250 continue  260 continuec then transform in x      nrx = nxy/nxh      do 310 m = 1, indx1      ns = 2**(m - 1)      ns2 = ns + ns      km = nxhh/ns      kmr = km*nrx      do 300 l = 1, kblok      do 290 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 280 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 270 i = kypi, kypt      t1 = s*f(1,j2,i,l)      t2 = s*f(2,j2,i,l)      f(1,j2,i,l) = f(1,j1,i,l) - t1      f(2,j2,i,l) = f(2,j1,i,l) - t2      f(1,j1,i,l) = f(1,j1,i,l) + t1      f(2,j1,i,l) = f(2,j1,i,l) + t2  270 continue  280 continue  290 continue  300 continue  310 continuec swap complex components      do 340 l = 1, kblok      do 330 k = kypi, kypt      do 320 j = 1, nxh      at1 = aimag(f(1,j,k,l))      f(1,j,k,l) = cmplx(real(f(1,j,k,l)),real(f(2,j,k,l)))      f(2,j,k,l) = cmplx(at1,aimag(f(2,j,k,l)))  320 continue  330 continue  340 continue      return      endc-----------------------------------------------------------------------      subroutine PFFT2R2XY(g,isign,mixup,sct,indx,indy,kstrt,kxpi,kxpp,n     1yv,kxp,jblok,nxhyd,nxyhd)c this subroutine performs the y part of 2 two dimensional real toc complex fast fourier transforms and their inverses, for a subset of x,c using complex arithmetic, for data which is distributed in blocksc for isign = (-1,1), input: all, output: f, gc for isign = -1, approximate flop count: N*(5*log2(N) + 10)/nvpc for isign = 1,  approximate flop count: N*(5*log2(N) + 8)/nvpc where N = (nx/2)*ny, and nvp = number of procsc indx/indy = exponent which determines length in x/y direction,c where nx=2**indx, ny=2**indyc if isign = -1, an inverse fourier transform is performedc g(m,n,i) = sum(g(k,j,i)*exp(-sqrt(-1)*2pi*m*k/ny))c if isign = 1, a forward fourier transform is performedc g(k,j,i) = sum(g(m,n,i)*exp(sqrt(-1)*2pi*m*k/ny))c kstrt = starting data block numberc kxpi = initial x index usedc kxpp = number of   indices usedc nyv = first dimension of gc kxp = number of data values per block in xc jblok = number of data blocks in xc mixup = array of bit reversed addressesc sct = sine/cosine tablec nxhyd = maximum of (nx/2,ny)c nxyhd = one half of maximum of (nx,ny)c the real data is stored in a complex array of length nx/2, nyc with the odd/even x points stored in the real/imaginary parts.c in complex notation, fourier coefficients are stored as follows:c g(k,j,i) = mode jj-1,k-1, where jj = j + kxp*(i - 1)c 1 <= jj <= nx/2 and 1 <= k <= ny, except forc g(k,1,1) = mode nx/2,k-1, where ny/2+2 <= k <= ny, andc imaginary part of g(1,1,1) = real part of mode nx/2,0 andc imaginary part of g(ny/2+1,1,1) = real part of mode nx/2,ny/2c written by viktor k. decyk, uclac parallel, RISC optimized version      implicit none      integer isign, mixup, indx, indy, kstrt, kxpi, kxpp, nyv      integer kxp, jblok, nxhyd, nxyhd      complex g, sct      dimension g(2,nyv,kxp,jblok)      dimension mixup(nxhyd), sct(nxyhd)c local data      integer indx1, indx1y, nx, nxh, ny, nyh, ny2      integer nxy, nxhy, ks, kxpt, j, k, nry      integer l, i, m, ns, ns2, km, kmr, k1, k2, j1, j2, jj      complex s, t1, t2      indx1 = indx - 1      indx1y = max0(indx1,indy)      nx = 2**indx      nxh = nx/2      ny = 2**indy      nyh = ny/2      ny2 = ny + 2      nxy = max0(nx,ny)      nxhy = 2**indx1y      ks = kstrt - 2      kxpt = kxpi + kxpp - 1      if (kstrt.gt.nxh) return      if (isign.gt.0) go to 120c inverse fourier transform      nry = nxhy/ny      do 30 l = 1, jblokc bit-reverse array elements in y      do 20 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 20      do 10 j = kxpi, kxpt      t1 = g(1,k1,j,l)      t2 = g(2,k1,j,l)      g(1,k1,j,l) = g(1,k,j,l)      g(2,k1,j,l) = g(2,k,j,l)      g(1,k,j,l) = t1      g(2,k,j,l) = t2   10 continue   20 continue   30 continuec then transform in y      nry = nxy/ny      do 80 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 70 l = 1, jblok      do 60 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 50 j = 1, ns      j1 = j + k1      j2 = j + k2      s = sct(1+kmr*(j-1))      do 40 i = kxpi, kxpt      t1 = s*g(1,j2,i,l)      t2 = s*g(2,j2,i,l)      g(1,j2,i,l) = g(1,j1,i,l) - t1      g(2,j2,i,l) = g(2,j1,i,l) - t2      g(1,j1,i,l) = g(1,j1,i,l) + t1      g(2,j1,i,l) = g(2,j1,i,l) + t2   40 continue   50 continue   60 continue   70 continue   80 continuec unscramble modes kx = 0, nx/2      do 110 l = 1, jblok      if ((l+ks).gt.0) go to 110      do 100 k = 2, nyh      if (kxpi.eq.1) then         do 90 jj = 1, 2         s = g(jj,ny2-k,1,l)         g(jj,ny2-k,1,l) = .5*cmplx(aimag(g(jj,k,1,l) + s),real(g(jj,k,1     1,l)- s))         g(jj,k,1,l) = .5*cmplx(real(g(jj,k,1,l) + s),aimag(g(jj,k,1,l)      1- s))   90    continue      endif  100 continue  110 continue      returnc forward fourier transformc scramble modes kx = 0, nx/2  120 nry = nxhy/ny      do 180 l = 1, jblok      if ((l+ks).gt.0) go to 150      do 140 k = 2, nyh      if (kxpi.eq.1) then         do 130 jj = 1, 2         s = cmplx(aimag(g(jj,ny2-k,1,l)),real(g(jj,ny2-k,1,l)))         g(jj,ny2-k,1,l) = conjg(g(jj,k,1,l) - s)         g(jj,k,1,l) = g(jj,k,1,l) + s  130    continue      endif  140 continuec bit-reverse array elements in y  150 do 170 k = 1, ny      k1 = (mixup(k) - 1)/nry + 1      if (k.ge.k1) go to 170      do 160 j = kxpi, kxpt      t1 = g(1,k1,j,l)      t2 = g(2,k1,j,l)      g(1,k1,j,l) = g(1,k,j,l)      g(2,k1,j,l) = g(2,k,j,l)      g(1,k,j,l) = t1      g(2,k,j,l) = t2  160 continue  170 continue  180 continuec first transform in y      nry = nxy/ny      do 230 m = 1, indy      ns = 2**(m - 1)      ns2 = ns + ns      km = nyh/ns      kmr = km*nry      do 220 l = 1, jblok      do 210 k = 1, km      k1 = ns2*(k - 1)      k2 = k1 + ns      do 200 j = 1, ns      j1 = j + k1      j2 = j + k2      s = conjg(sct(1+kmr*(j-1)))      do 190 i = kxpi, kxpt      t1 = s*g(1,j2,i,l)      t2 = s*g(2,j2,i,l)      g(1,j2,i,l) = g(1,j1,i,l) - t1      g(2,j2,i,l) = g(2,j1,i,l) - t2      g(1,j1,i,l) = g(1,j1,i,l) + t1      g(2,j1,i,l) = g(2,j1,i,l) + t2  190 continue  200 continue  210 continue  220 continue  230 continue      return      endc-----------------------------------------------------------------------c 2d parallel PIC library for solving field equations with dirichletc boundary conditionsc written by viktor k. decyk, uclac copyright 1995, regents of the university of californiac update: february 25, 2006c-----------------------------------------------------------------------      subroutine PLCGUARD2X(fxy,nyp,nx,nxe,nypmx,nblok)c this subroutine replicates field so as to disablec quadratic interpolation within a half a cell of the edges,c and reduce it to linear interpolation in the x directionc for distributed data      implicit none      real fxy      integer nyp, nx, nxe, nypmx, nblok      dimension fxy(2,nxe,nypmx,nblok), nyp(nblok)c local data      integer k, l, nyp3      do 20 l = 1, nblok      nyp3 = nyp(l) + 3      do 10 k = 1, nyp3      fxy(1,1,k,l) = 2.*fxy(1,2,k,l) - fxy(1,3,k,l)      fxy(2,1,k,l) = 2.*fxy(2,2,k,l) - fxy(2,3,k,l)      fxy(1,nx+3,k,l) = 2.*fxy(1,nx+2,k,l) - fxy(1,nx+1,k,l)      fxy(2,nx+3,k,l) = 2.*fxy(2,nx+2,k,l) - fxy(2,nx+1,k,l)   10 continue   20 continue      return      endc-----------------------------------------------------------------------      subroutine PLDGUARD2X(q,nyp,nx,nxe,nypmx,nblok)c this subroutine replicates scalar field so as to disablec quadratic interpolation within a half a cell of the edges,c and reduce it to linear interpolation in the x directionc for distributed data      implicit none      real q      integer nyp, nx, nxe, nypmx, nblok      dimension q(nxe,nypmx,nblok), nyp(nblok)c local data      integer k, l, nyp3      do 20 l = 1, nblok      nyp3 = nyp(l) + 3      do 10 k = 1, nyp3      q(1,k,l) = 2.*q(2,k,l) - q(3,k,l)      q(nx+3,k,l) = 2.*q(nx+2,k,l) - q(nx+1,k,l)   10 continue   20 continue      return      endc-----------------------------------------------------------------------      subroutine PLAGUARD2X(q,nyp,nx,nxe,nypmx,nblok)c this subroutine adds adds up guard cells so as to disablec quadratic interpolation within a half a cell of the edges,c and reduce it to linear interpolation in the x directionc for distributed scalar data      implicit none      real q      integer nyp, nx, nxe, nypmx, nblok      dimension q(nxe,nypmx,nblok), nyp(nblok)c local data      integer k, l, nyp3c add up guard cells      do 20 l = 1, nblok      nyp3 = nyp(l) + 3      do 10 k = 1, nyp3      q(2,k,l) = q(2,k,l) + 2.*q(1,k,l)      q(3,k,l) = q(3,k,l) - q(1,k,l)      q(nx+1,k,l) = q(nx+1,k,l) - q(nx+3,k,l)      q(nx+2,k,l) = q(nx+2,k,l) + 2.*q(nx+3,k,l)      q(1,k,l) = 0.      q(nx+3,k,l) = 0.   10 continue   20 continue      return      endc-----------------------------------------------------------------------c 2d parallel PIC library for solving field equations with open (vacuum)c boundary conditionsc written by viktor k. decyk, uclac copyright 1991, regents of the university of californiac update: march 15, 2006c-----------------------------------------------------------------------      subroutine PFORMC2(ffg,f,ft,bs,br,fpotc,mixup2,sct2,affp,ar,indx1,     1indy1,kstrt,nxv,ny2d,kxp2,kyp2,j2blok,k2blok,kxp2d,ny1d,nxhy2,nxyh     22)c this subroutine calculates the form factor array ffg needed by fieldc solvers with open (vacuum) boundary conditions using hockney's method.c the four green's functions calculated are:c g(kx,ky) = affp*inverse FFT of potrc s(kx,ky) = inverse FFT of the density of a finite-sized particlec gx(kx,ky) = affp*s(kx,ky)*inverse FFT of (x/r)*Erc gy(kx,ky) = affp*s(kx,ky)*inverse FFT of (y/r)*Erc where the fields due to the finite-sized particles are given by fpotcc input: fpotc,mixup2,sct2,affp,ar,indx1,indy1,kstrt,nxv,ny2d,kxp2,kyp2,c        j2blok,k2blok,kxp2d,ny1d,nxhy2,nxyh2)c output: ffg, fc ffg(1,k,j,l) = potential green's function gc ffg(2,k,j,l) = finite-size particle shape factor sc ffg(3,k,j,l) = x component of electric field green's function gxc ffg(4,k,j,l) = y component of electric field green's function gyc on processor 0, ffg(i,k,kxp2+1,l) = ffg(i,k,NX+1,l)c on other processors, ffg(i,k,kxp2+1,l) = ffg(i,k,1,l) on processor 0c f, ft = scratch arrays used by FFTc fpotc = a function which calculates green's functionc mixup2/sct2 = bit-reverse and sine-cosine table used by FFTc affp = normalization constant = nx*ny/np, where np=number of particlesc ar = half-width of particle in r directionc indx1/indy1 = exponent which determines FFT length in x/y direction,c where 2*nx=2**indx1, 2*ny=2**indy1c kstrt = starting data block numberc nxv = half of first dimension of field arrays, must be >= nxc ny2d = second dimension of field arrays, must be >= 2*nyc kxp2/kyp2 = number of data values per block in x/yc j2blok/k2blok = number of data blocks in x/yc kxp2d = third dimension of ffg arrays, must be >= nx+1c ny1d = second dimension of field arrays, must be >= ny+1c nxhy2 = maximum of (nx,2*ny)c nxyh2 = maximum of (nx,ny)      implicit none      real ffg, f      complex ft, bs, br      integer mixup2      complex sct2      real affp, ar      integer indx1, indy1, kstrt, kxp2d, ny1d, nxv, ny2d, kxp2, kyp2      integer j2blok, k2blok, nxhy2, nxyh2      dimension ffg(4,ny1d,kxp2d,j2blok)      dimension f(2*nxv,kyp2,k2blok), ft(ny2d,kxp2,j2blok)      dimension bs(kxp2,kyp2,k2blok), br(kxp2,kyp2,j2blok)      dimension mixup2(nxhy2), sct2(nxyh2)      real fpotc      external fpotcc local data      integer ntpose, nx, ny, ny1, nx2, ny2, isign, j, k, l, j1, k1, ks      integer joff, koff, ifun      real an, ari, at1, x, y, r, ttp      real POTC2      external POTC2      data ntpose /1/      nx2 = 2**(indx1)      ny2 = 2**(indy1)      nx = nx2/2      ny = ny2/2      ny1 = ny + 1      ks = kstrt - 2      ari = 0.0      if (ar.gt.0.) ari = 1.0/ar      an = float(nx2*ny2)c calculate potential green's function      ifun = 1      if (kstrt.gt.ny2) go to 40      do 30 l = 1, k2blok      koff = kyp2*(l + ks) - 1      do 20 k = 1, kyp2      k1 = k + koff      if (k1.gt.ny) k1 = k1 - ny2      at1 = float(k1)**2      do 10 j = 1, nx2      j1 = j - 1      if (j1.gt.nx) j1 = j1 - nx2      r = sqrt(at1 + float(j1)**2)      f(j,k,l) = fpotc(r,affp,ari,1)   10 continue   20 continue   30 continue      isign = -1      call WPFFT2R(f,ft,bs,br,isign,ntpose,mixup2,sct2,ttp,indx1,indy1,k     1strt,nxv,ny2d,kxp2,kyp2,kyp2,j2blok,k2blok,nxhy2,nxyh2)   40 if (kstrt.gt.nx) go to 100      do 90 l = 1, j2blok      do 60 j = 1, kxp2      do 50 k = 1, ny1      ffg(ifun,k,j,l) = an*real(ft(k,j,l))   50 continue   60 continue      if ((l+ks).eq.0) then         do 70 k = 2, ny         k1 = ny2 + 2 - k         ffg(ifun,k,kxp2+1,l) = an*real(ft(k1,1,l))   70    continue         ffg(ifun,1,kxp2+1,l) = an*aimag(ft(1,1,l))         ffg(ifun,ny1,kxp2+1,l) = an*aimag(ft(ny1,1,l))      else         do 80 k = 1, ny1         ffg(ifun,k,kxp2+1,l) = 0.0   80    continue      endif   90 continuec calculate particle smoothing function  100 ifun = ifun + 1      if (kstrt.gt.ny2) go to 140      do 130 l = 1, k2blok      koff = kyp2*(l + ks) - 1      do 120 k = 1, kyp2      k1 = k + koff      if (k1.gt.ny) k1 = k1 - ny2      at1 = float(k1)**2      do 110 j = 1, nx2      j1 = j - 1      if (j1.gt.nx) j1 = j1 - nx2      r = sqrt(at1 + float(j1)**2)      f(j,k,l) = POTC2(r,affp,ari,2)  110 continue  120 continue  130 continue      isign = -1      call WPFFT2R(f,ft,bs,br,isign,ntpose,mixup2,sct2,ttp,indx1,indy1,k     1strt,nxv,ny2d,kxp2,kyp2,kyp2,j2blok,k2blok,nxhy2,nxyh2)  140 if (kstrt.gt.nx) go to 200      do 190 l = 1, j2blok      do 160 j = 1, kxp2      do 150 k = 1, ny1      ffg(ifun,k,j,l) = an*real(ft(k,j,l))  150 continue  160 continue      if ((l+ks).eq.0) then         do 170 k = 2, ny         k1 = ny2 + 2 - k         ffg(ifun,k,kxp2+1,l) = an*real(ft(k1,1,l))  170    continue         ffg(ifun,1,kxp2+1,l) = an*aimag(ft(1,1,l))         ffg(ifun,ny1,kxp2+1,l) = an*aimag(ft(ny1,1,l))      else         do 180 k = 1, ny1         ffg(ifun,k,kxp2+1,l) = 0.0  180    continue      endif  190 continuec calculate green's function for x component of electric field  200 ifun = ifun + 1      if (kstrt.gt.ny2) go to 240      do 230 l = 1, k2blok      koff = kyp2*(l + ks) - 1      do 220 k = 1, kyp2      k1 = k + koff      if (k1.gt.ny) k1 = k1 - ny2      at1 = float(k1)**2      do 210 j = 1, nx2      j1 = j - 1      if (j1.gt.nx) j1 = j1 - nx2      x = float(j1)      r = sqrt(at1 + x*x)      f(j,k,l) = fpotc(r,affp,ari,3)      if (r.gt.0.) f(j,k,l) = f(j,k,l)*(x/r)  210 continue  220 continue  230 continue      isign = -1      call WPFFT2R(f,ft,bs,br,isign,ntpose,mixup2,sct2,ttp,indx1,indy1,k     1strt,nxv,ny2d,kxp2,kyp2,kyp2,j2blok,k2blok,nxhy2,nxyh2)  240 if (kstrt.gt.nx) go to 300      do 290 l = 1, j2blok      joff = kxp2*(l + ks) - 1      do 260 j = 1, kxp2      if ((j+joff).gt.0) then         do 250 k = 1, ny1         ffg(ifun,k,j,l) = an*aimag(ft(k,j,l))  250    continue      endif  260 continue      if ((l+ks).eq.0) then         do 270 k = 2, ny         k1 = ny2 + 2 - k         ffg(ifun,k,1,l) = an*real(ft(k,1,l))         ffg(ifun,k,kxp2+1,l) = an*real(ft(k1,1,l))  270    continue         ffg(ifun,1,1,l) = an*real(ft(1,1,l))         ffg(ifun,1,kxp2+1,l) = an*aimag(ft(1,1,l))         ffg(ifun,ny1,1,l) = an*real(ft(ny1,1,l))         ffg(ifun,ny1,kxp2+1,l) = an*aimag(ft(ny1,1,l))      else         do 280 k = 1, ny1         ffg(ifun,k,kxp2+1,l) = 0.0  280    continue      endif  290 continuec calculate green's function for y component of electric field  300 ifun = ifun + 1      if (kstrt.gt.ny2) go to 340      do 330 l = 1, k2blok      koff = kyp2*(l + ks) - 1      do 320 k = 1, kyp2      k1 = k + koff      if (k1.gt.ny) k1 = k1 - ny2      y = float(k1)      at1 = y*y      do 310 j = 1, nx2      j1 = j - 1      if (j1.gt.nx) j1 = j1 - nx2      r = sqrt(at1 + float(j1)**2)      f(j,k,l) = fpotc(r,affp,ari,3)      if (r.gt.0.) f(j,k,l) = f(j,k,l)*(y/r)  310 continue  320 continue  330 continue      isign = -1      call WPFFT2R(f,ft,bs,br,isign,ntpose,mixup2,sct2,ttp,indx1,indy1,k     1strt,nxv,ny2d,kxp2,kyp2,kyp2,j2blok,k2blok,nxhy2,nxyh2)  340 if (kstrt.gt.nx) go to 400      do 390 l = 1, j2blok      joff = kxp2*(l + ks) - 1      do 360 j = 1, kxp2      if ((j+joff).gt.0) then         do 350 k = 2, ny         ffg(ifun,k,j,l) = an*aimag(ft(k,j,l))  350    continue         ffg(ifun,1,j,l) = an*real(ft(1,j,l))         ffg(ifun,ny1,j,l) = an*real(ft(ny1,j,l))      endif  360 continue      if ((l+ks).eq.0) then         do 370 k = 2, ny         k1 = ny2 + 2 - k         ffg(ifun,k,1,l) = an*aimag(ft(k,1,l))         ffg(ifun,k,kxp2+1,l) = an*aimag(ft(k1,1,l))  370    continue         ffg(ifun,1,1,l) = an*real(ft(1,1,l))         ffg(ifun,1,kxp2+1,l) = an*aimag(ft(1,1,l))         ffg(ifun,ny1,1,l) = an*real(ft(ny1,1,l))         ffg(ifun,ny1,kxp2+1,l) = an*aimag(ft(ny1,1,l))      else         do 380 k = 1, ny1         ffg(ifun,k,kxp2+1,l) = 0.0  380    continue      endif  390 continuec copy ffg(i,k,1,l) on node 0 to ffg(i,k,kxp2+1,l) on other nodes  400 do 410 l = 1, j2blok      call P0COPY(ffg(1,1,1,l),ffg(1,1,kxp2+1,l),4*ny1d)  410 continue      return      endc-----------------------------------------------------------------------      subroutine PPOISC2(q,fx,fy,isign,ffg,we,nx,ny,kstrt,ny2d,kxp2,j2bl     1ok,ny1d,kxp2d)c this subroutine solves 2d poisson's equation in fourier space forc force/charge (or convolution of electric field over particle shape)c or for potential, or provides a smoothing function, with open (vacuum)c boundary conditions using hockney's method, for distributed data.c fourier coefficients are constructed so that a real to complex fftc will perform the appropriate convolutionc for isign = -1, c input: q,ffg,isign,nx,ny,kstrt,ny2d,kxp2,j2blok,ny1d,kxp2dc output: fx,fy,wec approximate flop count is: 44*nx*ny + 36*(nx + ny)c for isign = 1,c input: q,ffg,isign,nx,ny,kstrt,ny2d,kxp2,j2blok,ny1d,kxp2dc output: fx,wec approximate flop count is: 22*nx*ny + 24(nx + ny)c for isign = 2,c input: q,ffg,isign,nx,ny,kstrt,ny2d,kxp2,j2blok,ny1d,kxp2dc output: fyc approximate flop count is: 4*nx*ny + 2*(nx + ny)c if isign < 0, force/charge is calculated using the equations:c fx(kx,ky) = gx(kx,ky)*s(kx,ky)*q(kx,ky),c fy(kx,ky) = gy(kx,ky)*s(kx,ky)*q(kx,ky),c where kx = pi*j/nx, ky = pi*k/ny, and j,k = fourier mode numbers,c gx(kx,ky) = s(kx,ky)*inverse FFT of (x/r)*Erc gy(kx,ky) = s(kx,ky)*inverse FFT of (y/r)*Erc where Er is the electric field of a single finite-sized particlec s(kx,ky) = inverse FFT of the density of a finite-sized particlec if isign = 1, potential is calculated using the equation:c fx(kx,ky) = g(kx,ky)*q(kx,ky)c where g(kx,ky) = affp*inverse FFT of potrc where potr is the potential of a single finite-sized particlec if isign = 2, smoothing is calculated using the equation:c fy(kx,ky) = q(kx,ky)*s(kx,ky)c q(k,j,l) = complex charge density for fourier mode (jj-1,k-1)c fx(k,j,l) = x component of complex force/charge,c fy(k,j,l) = y component of complex force/charge,c ffg(1,k,j,l) = potential green's function gc ffg(2,k,j,l) = finite-size particle shape factor sc ffg(3,k,j,l) = x component of electric field green's function gxc ffg(4,k,j,l) = y component of electric field green's function gyc all for fourier mode (jj-1,k-1), where jj = j + kxp2*(l - 1)c the ffg array is calculated by the subroutine PFORMC2c nx/ny = system length in x/y directionc kstrt = starting data block numberc ny2d = first dimension of field arrays, must be >= 2*nyc kxp2 = number of data values per blockc j2blok = number of data blocksc electric field energy is also calculated and returned in wec ny1d = second dimension of ffg array, must be >= ny+1c kxp2d = third dimension of ffg array, must be >= kxp2+1      implicit none      real ffg      complex q, fx, fy      integer isign, nx, ny, kstrt, ny2d, kxp2, j2blok, ny1d, kxp2d      real we      dimension q(ny2d,kxp2,j2blok)      dimension fx(ny2d,kxp2,j2blok), fy(ny2d,kxp2,j2blok)      dimension ffg(4,ny1d,kxp2d,j2blok)c local data      double precision wp      integer j, k, l, k1, ny22, ks, kx1, joff, ny1      real at1, at2, at3, at4      complex zt1, zt2      if (isign.eq.0) return      ny1 = ny + 1      ny22 = ny + ny + 2      ks = kstrt - 2      kx1 = 1      if (isign.gt.0) go to 70c calculate force/charge and sum field energy      wp = 0.0d0      if (kstrt.gt.nx) go to 60      do 50 l = 1, j2blok      if ((l+ks).gt.0) kx1 = kxp2 + 1c mode numbers kx > 0 and 0 < ky < ny      joff = kxp2*(l + ks) - 1      at3 = -1.0      do 20 j = 1, kxp2      at3 = -at3      if ((j+joff).gt.0) then         at2 = ffg(4,1,j,l)         do 10 k = 2, ny         k1 = ny22 - k         at1 = at3*ffg(3,k,kx1,l)         at2 = -at2         zt1 = cmplx(at1,ffg(3,k,j,l))         zt2 = cmplx(at2,ffg(4,k,j,l))         fx(k,j,l) = zt1*q(k,j,l)         fx(k1,j,l) = zt1*q(k1,j,l)         fy(k,j,l) = zt2*q(k,j,l)         fy(k1,j,l) = conjg(zt2)*q(k1,j,l)         wp = wp + ffg(1,k,j,l)*(q(k,j,l)*conjg(q(k,j,l)) + q(k1,j,l)*co     1njg(q(k1,j,l)))   10    continuec mode number ky = 0         at1 = at3*ffg(3,1,kx1,l)         zt1 = cmplx(at1,ffg(3,1,j,l))         fx(1,j,l) = zt1*q(1,j,l)         fy(1,j,l) = ffg(4,1,j,l)*q(1,j,l)         wp = wp + ffg(1,1,j,l)*(q(1,j,l)*conjg(q(1,j,l)))c mode number ky = ny         at1 = at3*ffg(3,ny1,kx1,l)         zt1 = cmplx(at1,ffg(3,ny1,j,l))         fx(ny1,j,l) = zt1*q(ny1,j,l)         fy(ny1,j,l) = ffg(4,ny1,j,l)*q(ny1,j,l)         wp = wp + ffg(1,ny1,j,l)*(q(ny1,j,l)*conjg(q(ny1,j,l)))      endif   20 continuec mode number kx = 0      if ((l+ks).eq.0) thenc mode number kx = 0         at3 = ffg(4,1,1,l)         do 30 k = 2, ny         at3 = -at3         zt1 = cmplx(at3,ffg(4,k,1,l))         fx(k,1,l) = ffg(3,k,1,l)*q(k,1,l)         fy(k,1,l) = zt1*q(k,1,l)         wp = wp + ffg(1,k,1,l)*(q(k,1,l)*conjg(q(k,1,l)))   30    continuec mode number kx = nx/2         at3 = ffg(4,1,kxp2+1,l)         do 40 k = 2, ny         k1 = ny22 - k         at3 = -at3         zt1 = cmplx(at3,ffg(4,k,kxp2+1,l))         fx(k1,1,l) = ffg(3,k,kxp2+1,l)*q(k1,1,l)         fy(k1,1,l) = zt1*q(k1,1,l)         wp = wp + ffg(1,k,kxp2+1,l)*(q(k1,1,l)*conjg(q(k1,1,l)))   40    continuec mode numbers ky = 0, kx = 0, nx/2         fx(1,1,l) = cmplx(ffg(3,1,1,l)*real(q(1,1,l)),ffg(3,1,kxp2+1,l)     1*aimag(q(1,1,l)))         fy(1,1,l) = cmplx(ffg(4,1,1,l)*real(q(1,1,l)),ffg(4,1,kxp2+1,l)     1*aimag(q(1,1,l)))         wp = wp + .5*(ffg(1,1,1,l)*real(q(1,1,l))**2 + ffg(1,1,kxp2+1,l     1)*aimag(q(1,1,l))**2)c mode numbers ky = ny/2, kx = 0, nx/2         fx(ny1,1,l) = cmplx(ffg(3,ny1,1,l)*real(q(ny1,1,l)),ffg(3,ny1,k     1xp2+1,l)*aimag(q(ny1,1,l)))         fy(ny1,1,l) = cmplx(ffg(4,ny1,1,l)*real(q(ny1,1,l)),ffg(4,ny1,k     1xp2+1,l)*aimag(q(ny1,1,l)))         wp = wp + .5*(ffg(1,ny1,1,l)*real(q(ny1,1,l))**2 + ffg(1,ny1,kx     1p2+1,l)*aimag(q(ny1,1,l))**2)      endif   50 continue   60 continue      we = 4.0*float(nx*ny)*wp      returnc calculate potential and sum field energy   70 if (isign.gt.1) go to 140      wp = 0.0d0      if (kstrt.gt.nx) go to 130      do 120 l = 1, j2blokc mode numbers kx > 0 and 0 < ky < ny      joff = kxp2*(l + ks) - 1      do 90 j = 1, kxp2      if ((j+joff).gt.0) then         do 80 k = 2, ny         k1 = ny22 - k         at2 = ffg(1,k,j,l)         at1 = at2*ffg(2,k,j,l)c        at1 = at2         fx(k,j,l) = at2*q(k,j,l)         fx(k1,j,l) = at2*q(k1,j,l)         wp = wp + at1*(q(k,j,l)*conjg(q(k,j,l)) + q(k1,j,l)*conjg(q(k1,     1j,l)))   80    continuec mode number ky = 0         at2 = ffg(1,1,j,l)         at1 = at2*ffg(2,1,j,l)c        at1 = at2         fx(1,j,l) = at2*q(1,j,l)         wp = wp + at1*(q(1,j,l)*conjg(q(1,j,l)))c mode number ky = ny         at2 = ffg(1,ny1,j,l)         at1 = at2*ffg(2,ny1,j,l)c        at1 = at2         fx(ny1,j,l) = at2*q(ny1,j,l)         wp = wp + at1*(q(ny1,j,l)*conjg(q(ny1,j,l)))      endif   90 continuec mode number kx = 0      if ((l+ks).eq.0) thenc mode number kx = 0         do 100 k = 2, ny         at2 = ffg(1,k,1,l)         at1 = at2*ffg(2,k,1,l)c        at1 = at2         fx(k,1,l) = at2*q(k,1,l)         wp = wp + at1*(q(k,1,l)*conjg(q(k,1,l)))  100    continuec mode number kx = nx/2         do 110 k = 2, ny         k1 = ny22 - k         at2 = ffg(1,k,kxp2+1,l)         at1 = at2*ffg(2,k,kxp2+1,l)c        at1 = at2         fx(k1,1,l) = at2*q(k1,1,l)         wp = wp + at1*(q(k1,1,l)*conjg(q(k1,1,l)))  110    continuec mode numbers ky = 0, kx = 0, nx/2         at2 = ffg(1,1,1,l)         at1 = at2*ffg(2,1,1,l)c        at1 = at2         at4 = ffg(1,1,kxp2+1,l)         at3 = at4*ffg(2,1,kxp2+1,l)c        at3 = at4         fx(1,1,l) = cmplx(at2*real(q(1,1,l)),at4*aimag(q(1,1,l)))         wp = wp + .5*(at1*real(q(1,1,l))**2 + at3*aimag(q(1,1,l))**2)c mode numbers ky = ny/2, kx = 0, nx/2         at2 = ffg(1,ny1,1,l)         at1 = at2*ffg(2,ny1,1,l)c        at1 = at2         at4 = ffg(1,ny1,kxp2+1,l)         at3 = at4*ffg(2,ny1,kxp2+1,l)c        at3 = at4         fx(ny1,1,l) = cmplx(at2*real(q(ny1,1,l)),at4*aimag(q(ny1,1,l)))         wp = wp + .5*(at1*real(q(ny1,1,l))**2 + at3*aimag(q(ny1,1,l))**     12)      endif  120 continue  130 continue      we = 4.0*float(nx*ny)*wp      returnc calculate smoothing  140 if (kstrt.gt.nx) go to 200      do 190 l = 1, j2blokc mode numbers kx > 0 and 0 < ky < ny      joff = kxp2*(l + ks) - 1      do 160 j = 1, kxp2      if ((j+joff).gt.0) then         do 150 k = 2, ny         k1 = ny22 - k         at1 = ffg(2,k,j,l)         fy(k,j,l) = at1*q(k,j,l)         fy(k1,j,l) = at1*q(k1,j,l)  150    continuec mode number ky = 0         fy(1,j,l) = ffg(2,1,j,l)*q(1,j,l)c mode number ky = ny         fy(ny1,j,l) = ffg(2,ny1,j,l)*q(ny1,j,l)      endif  160 continuec mode number kx = 0      if ((l+ks).eq.0) thenc mode number kx = 0         do 170 k = 2, ny         fy(k,1,l) = ffg(2,k,1,l)*q(k,1,l)  170    continuec mode number kx = nx/2         do 180 k = 2, ny         k1 = ny22 - k         fy(k1,1,l) = ffg(2,k,kxp2+1,l)*q(k1,1,l)  180    continuec mode numbers ky = 0, kx = 0, nx/2         at1 = ffg(2,1,1,l)         at3 = ffg(2,1,kxp2+1,l)         fy(1,1,l) = cmplx(at1*real(q(1,1,l)),at3*aimag(q(1,1,l)))c mode numbers ky = ny/2, kx = 0, nx/2         at1 = ffg(2,ny1,1,l)         at3 = ffg(2,ny1,kxp2+1,l)         fy(ny1,1,l) = cmplx(at1*real(q(ny1,1,l)),at3*aimag(q(ny1,1,l)))      endif  190 continue  200 continue      return      endc-----------------------------------------------------------------------      subroutine PPOISC22(q,fxy,ffg,we,nx,ny,kstrt,ny2d,kxp2,j2blok,ny1d     1,kxp2d)c this subroutine solves 2d poisson's equation in fourier space forc force/charge (or convolution of electric field over particle shape)c with open (vacuum) boundary conditions using hockney's method,c for distributed data.c fourier coefficients are constructed so that a real to complex fftc will perform the appropriate convolutionc input: q,ffg,nx,ny,kstrt,ny2d,kxp2,j2blok,ny1d,kxp2dc output: fxy,wec approximate flop count is: 44*nx*ny + 36*(nx + ny)c force/charge is calculated using the equations:c fx(kx,ky) = gx(kx,ky)*s(kx,ky)*q(kx,ky),c fy(kx,ky) = gy(kx,ky)*s(kx,ky)*q(kx,ky),c where kx = pi*j/nx, ky = pi*k/ny, and j,k = fourier mode numbers,c gx(kx,ky) = s(kx,ky)*inverse FFT of (x/r)*Erc gy(kx,ky) = s(kx,ky)*inverse FFT of (y/r)*Erc where Er is the electric field of a single finite-sized particlec s(kx,ky) = inverse FFT of the density of a finite-sized particlec q(k,j,l) = complex charge density for fourier mode (jj-1,k-1)c fxy(1,k,j,l) = x component of complex force/charge,c fxy(2,k,j,l) = y component of complex force/charge,c ffg(1,k,j,l) = potential green's function gc ffg(2,k,j,l) = finite-size particle shape factor sc ffg(3,k,j,l) = x component of electric field green's function gxc ffg(4,k,j,l) = y component of electric field green's function gyc all for fourier mode (jj-1,k-1), where jj = j + kxp2*(l - 1)c the ffg array is calculated by the subroutine PFORMC2c nx/ny = system length in x/y directionc kstrt = starting data block numberc ny2d = first dimension of field arrays, must be >= 2*nyc kxp2 = number of data values per blockc j2blok = number of data blocksc electric field energy is also calculated and returned in wec ny1d = second dimension of ffg array, must be >= ny+1c kxp2d = third dimension of ffg array, must be >= kxp2+1      implicit none      real ffg      complex q, fxy      integer nx, ny, kstrt, ny2d, kxp2, j2blok, ny1d, kxp2d      real we      dimension q(ny2d,kxp2,j2blok), fxy(2,ny2d,kxp2,j2blok)      dimension ffg(4,ny1d,kxp2d,j2blok)c local data      double precision wp      integer j, k, l, k1, ny22, ks, kx1, joff, ny1      real at1, at2, at3      complex zt1, zt2      ny1 = ny + 1      ny22 = ny + ny + 2      ks = kstrt - 2      kx1 = 1c calculate force/charge and sum field energy      wp = 0.0d0      if (kstrt.gt.nx) go to 60      do 50 l = 1, j2blok      if ((l+ks).gt.0) kx1 = kxp2 + 1c mode numbers kx > 0 and 0 < ky < ny      joff = kxp2*(l + ks) - 1      at3 = -1.0      do 20 j = 1, kxp2      at3 = -at3      if ((j+joff).gt.0) then         at2 = ffg(4,1,j,l)         do 10 k = 2, ny         k1 = ny22 - k         at1 = at3*ffg(3,k,kx1,l)         at2 = -at2         zt1 = cmplx(at1,ffg(3,k,j,l))         zt2 = cmplx(at2,ffg(4,k,j,l))         fxy(1,k,j,l) = zt1*q(k,j,l)         fxy(1,k1,j,l) = zt1*q(k1,j,l)         fxy(2,k,j,l) = zt2*q(k,j,l)         fxy(2,k1,j,l) = conjg(zt2)*q(k1,j,l)         wp = wp + ffg(1,k,j,l)*(q(k,j,l)*conjg(q(k,j,l)) + q(k1,j,l)*co     1njg(q(k1,j,l)))   10    continuec mode number ky = 0         at1 = at3*ffg(3,1,kx1,l)         zt1 = cmplx(at1,ffg(3,1,j,l))         fxy(1,1,j,l) = zt1*q(1,j,l)         fxy(2,1,j,l) = ffg(4,1,j,l)*q(1,j,l)         wp = wp + ffg(1,1,j,l)*(q(1,j,l)*conjg(q(1,j,l)))c mode number ky = ny         at1 = at3*ffg(3,ny1,kx1,l)         zt1 = cmplx(at1,ffg(3,ny1,j,l))         fxy(1,ny1,j,l) = zt1*q(ny1,j,l)         fxy(2,ny1,j,l) = ffg(4,ny1,j,l)*q(ny1,j,l)         wp = wp + ffg(1,ny1,j,l)*(q(ny1,j,l)*conjg(q(ny1,j,l)))      endif   20 continuec mode number kx = 0      if ((l+ks).eq.0) thenc mode number kx = 0         at3 = ffg(4,1,1,l)         do 30 k = 2, ny         at3 = -at3         zt1 = cmplx(at3,ffg(4,k,1,l))         fxy(1,k,1,l) = ffg(3,k,1,l)*q(k,1,l)         fxy(2,k,1,l) = zt1*q(k,1,l)         wp = wp + ffg(1,k,1,l)*(q(k,1,l)*conjg(q(k,1,l)))   30    continuec mode number kx = nx/2         at3 = ffg(4,1,kxp2+1,l)         do 40 k = 2, ny         k1 = ny22 - k         at3 = -at3         zt1 = cmplx(at3,ffg(4,k,kxp2+1,l))         fxy(1,k1,1,l) = ffg(3,k,kxp2+1,l)*q(k1,1,l)         fxy(2,k1,1,l) = zt1*q(k1,1,l)         wp = wp + ffg(1,k,kxp2+1,l)*(q(k1,1,l)*conjg(q(k1,1,l)))   40    continuec mode numbers ky = 0, kx = 0, nx/2-         fxy(1,1,1,l) = cmplx(ffg(3,1,1,l)*real(q(1,1,l)),ffg(3,1,kxp2+1     1,l)*aimag(q(1,1,l)))         fxy(2,1,1,l) = cmplx(ffg(4,1,1,l)*real(q(1,1,l)),ffg(4,1,kxp2+1     1,l)*aimag(q(1,1,l)))         wp = wp + .5*(ffg(1,1,1,l)*real(q(1,1,l))**2 + ffg(1,1,kxp2+1,l     1)*aimag(q(1,1,l))**2)c mode numbers ky = ny/2, kx = 0, nx/2         fxy(1,ny1,1,l) = cmplx(ffg(3,ny1,1,l)*real(q(ny1,1,l)),ffg(3,ny     11,kxp2+1,l)*aimag(q(ny1,1,l)))         fxy(2,ny1,1,l) = cmplx(ffg(4,ny1,1,l)*real(q(ny1,1,l)),ffg(4,ny     11,kxp2+1,l)*aimag(q(ny1,1,l)))         wp = wp + .5*(ffg(1,ny1,1,l)*real(q(ny1,1,l))**2 + ffg(1,ny1,kx     1p2+1,l)*aimag(q(ny1,1,l))**2)      endif   50 continue   60 continue      we = 4.0*float(nx*ny)*wp      return      endc-----------------------------------------------------------------------      function POTC3(r,affp,ari,ifun)c this function calculates the fields for finite-size gaussian particlesc in 3D:c if ifun = 1, calculate potential functionc POTC3 = (affp/(4*pi))*erfn(r/(ar*sqrt(2.)))/r, for r > 0.c POTC3 = (affp/(4*pi))*sqrt(2./3.14159265358979)/ar, for r = 0.c if ifun = 2, calculate particle shape functionc POTC3 = exp(-(r/(sqrt(2.)*ar))**2)/(sqrt(2.*pi)*ar)**3, for r > 0.c POTC3 = 1./(sqrt(2.*pi)*ar)**3, for r = 0.c if ifun = 3, calculate radial electric fieldc POTC3 = (affp/(4*pi))*(1/r)*(erf(r/(sqrt(2.)*ar))/r -c exp(-(r/(sqrt(2.)*ar))**2)*sqrt(2./3.14159265358979)/ar, for r > 0.c POTC3 = 0.0, for r = 0.c where erfn is the error functionc and where the finite-size particle density is given by:c rho(r) = exp(-(r/sqrt(2)*ar)**2)/(sqrt(2*pi)*ar)**3c affp = 4*pi*e**2/(me*(omega0**2)*delta**3) = 1/(n0*delta**3)c where n0*delta**3 = number density per gridc r = radial coordinatec affp = normalization constantc ari = 1/ar = inverse of particle size functionc (ari = 0., means use point particle result)c ifun = (1,2,3) = calculate (potential,shape,electric field)      implicit none      real r, affp, ari      integer ifunc local datac pi4i = 1/4*pi, sqt2i = 1./sqrt(2.), sqt2pi = sqrt(2./pi)      real pi4i, sqt2i, sqt2pi      parameter(pi4i=0.5/6.28318530717959)      parameter(sqt2i=0.707106781186548,sqt2pi=0.797884560802865)      real POTC3, erfn      external erfn      real anorm, at1, ri      anorm = affp*pi4ic calculate potential function      if (ifun.eq.1) thenc finite-size particles         if (ari.gt.0.) then            if (r.eq.0.) then               POTC3 = anorm*sqt2pi*ari            else               POTC3 = anorm*erfn(r*sqt2i*ari)/r            endifc point particles         else            if (r.eq.0.) then               POTC3 = 0.0            else               POTC3 = anorm/r            endif         endifc calculate particle shape function      else if (ifun.eq.2) then         anorm = affp*(.5*sqt2pi*ari)**3c finite-size particles         if (ari.gt.0.) then            if (r.eq.0.) then               POTC3 = anorm            else               at1 = amin1(r*sqt2i*ari,8.0)               POTC3 = anorm*exp(-(at1*at1))            endifc point particles         else            if (r.eq.0.) then               POTC3 = affp            else               POTC3 = 0.0            endif         endifc calculate radial electric field      else if (ifun.eq.3) thenc finite-size particles         if (ari.gt.0.) then            if (r.eq.0.) then               POTC3 = 0.0            else               ri = 1.0/r               at1 = amin1(r*sqt2i*ari,8.0)               POTC3 = anorm*ri*(erfn(at1)*ri - sqt2pi*ari*exp(-(at1*at1     1)))            endifc point particles         else            if (r.eq.0.) then               POTC3 = 0.0            else               POTC3 = anorm/(r*r)            endif         endif      endif      return      endc-----------------------------------------------------------------------      function POTC2(r,affp,ari,ifun)c this function calculates the fields for finite-size gaussian particlesc in 2D:c if ifun = 1, calculate potential functionc POTC2 = -(affp/(4*pi))*(e1(r**2/(2*ar**2)) + ln(r**2)), for r > 0.c POTC2 = -(affp/(4*pi))*(ln(2) - gamma + 2*ln(ar), for r = 0.c if ifun = 2, calculate particle shape functionc POTC2 = exp(-(r/(sqrt(2.)*ar))**2)/(sqrt(2.*pi)*ar)**2, for r > 0.c POTC2 = 1./(sqrt(2.*pi)*ar)**2, for r = 0.c if ifun = 3, calculate radial electric fieldc POTC2 = 2*(1 - exp(-(r/(sqrt(2.)*ar))**2)/r, for r > 0.c POTC2 = 0.0, for r = 0.c where e1 is the exponential integralc and where the finite-size particle density is given by:c rho(r) = exp(-(r/sqrt(2)*ar)**2)/(2*pi*ar**2), qm = q/ec affp = 4*pi*e**2/(me*(omega0**2)*delta**2) = 1/(n0*delta**2)c where n0*delta**2 = number density per gridc r = radial coordinatec affp = normalization constantc ari = 1/ar = inverse of particle size functionc (ari = 0., means use point particle result)c ifun = 1 = calculate (potential)      implicit none      real r, affp, ari      integer ifunc local datac pi4i = 1/4*pi, sqt2i = 1./sqrt(2.), sqt2pi = sqrt(2./pi)      real pi4i, sqt2i, sqt2pi      parameter(pi4i=0.5/6.28318530717959)      parameter(sqt2i=0.707106781186548,sqt2pi=0.797884560802865)      real POTC2, e1ln      external e1ln      real anorm, at1c calculate potential function      if (ifun.eq.1) then         anorm = -affp*pi4ic finite-size particles         if (ari.gt.0.) then            POTC2 = anorm*(e1ln((r*sqt2i*ari)**2) - 2.0*alog(sqt2i*ari))c point particles         else            if (r.eq.0.) then               POTC2 = 0.0            else               POTC2 = 2.0*anorm*alog(r)            endif         endifc calculate particle shape function      else if (ifun.eq.2) then         anorm = affp*(.5*sqt2pi*ari)**2c finite-size particles         if (ari.gt.0.) then            if (r.eq.0.) then               POTC2 = anorm            else               at1 = amin1(r*sqt2i*ari,8.0)               POTC2 = anorm*exp(-(at1*at1))            endifc point particles         else            if (r.eq.0.) then               POTC2 = affp            else               POTC2 = 0.0            endif         endifc calculate radial electric field      else if (ifun.eq.3) then         anorm = 2.*affp*pi4ic finite-size particles         if (ari.gt.0.) then            if (r.eq.0.) then               POTC2 = 0.0            else               at1 = amin1(r*sqt2i*ari,8.0)               POTC2 = anorm*(1.0 - exp(-(at1*at1)))/r            endifc point particles         else            if (r.eq.0.) then               POTC2 = 0.0            else               POTC2 = anorm/r            endif         endif      endif      return      endc-----------------------------------------------------------------------c 2d parallel PIC library for solving field equationsc written by viktor k. decyk, uclac copyright 1995, regents of the university of californiac update: february 7, 2006c-----------------------------------------------------------------------      subroutine PZGUARD2L(q,nyp,nx,nxe,nypmx,nblok)c zero out guard cells in extended periodic scalar fieldc linear interpolation, for distributed data      implicit none      real q      integer nyp, nx, nxe, nypmx, nblok      dimension q(nxe,nypmx,nblok), nyp(nblok)      integer j, k, l, nx1      nx1 = nx + 1c zero out guard cells in x      do 30 l = 1, nblokc zero out guard cells in x      do 10 k = 1, nyp(l)      q(nx+1,k,l) = 0.   10 continuec zero out guard cells in y      do 20 j = 1, nx1      q(j,nyp(l)+1,l) = 0.   20 continue   30 continue      return      end